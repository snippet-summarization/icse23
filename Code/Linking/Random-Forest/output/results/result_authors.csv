id_istance,predicted linking,correct linking
4022,"    @Override
public void finishedTrackingActivity(ResponseData responseData) {
//comment
if (responseData instanceof SessionResponseData) {
<start>logger.debug(""Finished tracking session"");<end>
attributionHandler.checkSessionResponse((SessionResponseData)responseData);
return;
}
//comment
if (responseData instanceof SdkClickResponseData) {
checkForInstallReferrerInfo((SdkClickResponseData) responseData);
attributionHandler.checkSdkClickResponse((SdkClickResponseData)responseData);
return;
}
//comment
if (responseData instanceof EventResponseData) {
launchEventResponseTasks((EventResponseData)responseData);
return;
}
}","    @Override
public void finishedTrackingActivity(ResponseData responseData) {
//comment
<start>if (responseData instanceof SessionResponseData) {
logger.debug(""Finished tracking session"");
attributionHandler.checkSessionResponse((SessionResponseData)responseData);
return;
}<end>
//comment
if (responseData instanceof SdkClickResponseData) {
checkForInstallReferrerInfo((SdkClickResponseData) responseData);
attributionHandler.checkSdkClickResponse((SdkClickResponseData)responseData);
return;
}
//comment
if (responseData instanceof EventResponseData) {
launchEventResponseTasks((EventResponseData)responseData);
return;
}
}"
4023,"    @Override
public void finishedTrackingActivity(ResponseData responseData) {
//comment
if (responseData instanceof SessionResponseData) {
logger.debug(""Finished tracking session"");
<start>attributionHandler.checkSessionResponse((SessionResponseData)responseData);
return;<end>
}
//comment
if (responseData instanceof SdkClickResponseData) {
<start>checkForInstallReferrerInfo((SdkClickResponseData) responseData);<end>
attributionHandler.checkSdkClickResponse((SdkClickResponseData)responseData);
return;
}
//comment
if (responseData instanceof EventResponseData) {
launchEventResponseTasks((EventResponseData)responseData);
<start>return;<end>
}
}","    @Override
public void finishedTrackingActivity(ResponseData responseData) {
//comment
if (responseData instanceof SessionResponseData) {
logger.debug(""Finished tracking session"");
attributionHandler.checkSessionResponse((SessionResponseData)responseData);
return;
}
//comment
<start>if (responseData instanceof SdkClickResponseData) {
checkForInstallReferrerInfo((SdkClickResponseData) responseData);
attributionHandler.checkSdkClickResponse((SdkClickResponseData)responseData);
return;
}<end>
//comment
if (responseData instanceof EventResponseData) {
launchEventResponseTasks((EventResponseData)responseData);
return;
}
}"
4024,"    @Override
public void finishedTrackingActivity(ResponseData responseData) {
//comment
if (responseData instanceof SessionResponseData) {
logger.debug(""Finished tracking session"");
attributionHandler.checkSessionResponse((SessionResponseData)responseData);
return;
}
//comment
if (responseData instanceof SdkClickResponseData) {
checkForInstallReferrerInfo((SdkClickResponseData) responseData);
attributionHandler.checkSdkClickResponse((SdkClickResponseData)responseData);
return;
}
//comment
if (responseData instanceof EventResponseData) {
<start>launchEventResponseTasks((EventResponseData)responseData);<end>
return;
}
}","    @Override
public void finishedTrackingActivity(ResponseData responseData) {
//comment
if (responseData instanceof SessionResponseData) {
logger.debug(""Finished tracking session"");
attributionHandler.checkSessionResponse((SessionResponseData)responseData);
return;
}
//comment
if (responseData instanceof SdkClickResponseData) {
checkForInstallReferrerInfo((SdkClickResponseData) responseData);
attributionHandler.checkSdkClickResponse((SdkClickResponseData)responseData);
return;
}
//comment
<start>if (responseData instanceof EventResponseData) {<end>
launchEventResponseTasks((EventResponseData)responseData);
return;
}
}"
4033,"private void checkForPreinstallI() {
if (activityState == null) return;
if (!activityState.enabled) return;
if (activityState.isGdprForgotten) return;

//comment
sendPreinstallReferrerI();

if (!adjustConfig.preinstallTrackingEnabled) return;
if (internalState.hasPreinstallBeenRead()) return;

if (deviceInfo.packageName == null || deviceInfo.packageName.isEmpty()) {
logger.debug(""Can't read preinstall payload, invalid package name"");
return;
}

SharedPreferencesManager sharedPreferencesManager = new SharedPreferencesManager(getContext());
long readStatus = sharedPreferencesManager.getPreinstallPayloadReadStatus();

if (PreinstallUtil.hasAllLocationsBeenRead(readStatus)) {
internalState.preinstallHasBeenRead = true;
return;
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES, readStatus)) {
String payloadSystemProperty = PreinstallUtil.getPayloadFromSystemProperty(
deviceInfo.packageName, logger);

if (payloadSystemProperty != null && !payloadSystemProperty.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemProperty, Constants.SYSTEM_PROPERTIES);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_REFLECTION, readStatus)) {
String payloadSystemPropertyReflection = PreinstallUtil.getPayloadFromSystemPropertyReflection(
deviceInfo.packageName, logger);

if (payloadSystemPropertyReflection != null && !payloadSystemPropertyReflection.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyReflection, Constants.SYSTEM_PROPERTIES_REFLECTION);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_REFLECTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_PATH, readStatus)) {
String payloadSystemPropertyFilePath = PreinstallUtil.getPayloadFromSystemPropertyFilePath(
deviceInfo.packageName, logger);

if (payloadSystemPropertyFilePath != null && !payloadSystemPropertyFilePath.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyFilePath, Constants.SYSTEM_PROPERTIES_PATH);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_PATH, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_PATH_REFLECTION, readStatus)) {
String payloadSystemPropertyFilePathReflection = PreinstallUtil.getPayloadFromSystemPropertyFilePathReflection(
deviceInfo.packageName, logger);

if (payloadSystemPropertyFilePathReflection != null && !payloadSystemPropertyFilePathReflection.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyFilePathReflection, Constants.SYSTEM_PROPERTIES_PATH_REFLECTION);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_PATH_REFLECTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER, readStatus)) {
String payloadContentProviderDefault = PreinstallUtil.getPayloadFromContentProviderDefault(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadContentProviderDefault != null && !payloadContentProviderDefault.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadContentProviderDefault, Constants.CONTENT_PROVIDER);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER_INTENT_ACTION, readStatus)) {
List<String> payloadListContentProviderIntentAction = PreinstallUtil.getPayloadsFromContentProviderIntentAction(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadListContentProviderIntentAction != null && !payloadListContentProviderIntentAction.isEmpty()) {
for (String payload : payloadListContentProviderIntentAction) {
sdkClickHandler.sendPreinstallPayload(payload, Constants.CONTENT_PROVIDER_INTENT_ACTION);
}
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER_INTENT_ACTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER_NO_PERMISSION, readStatus)) {
List<String> payloadListContentProviderIntentAction = PreinstallUtil.getPayloadsFromContentProviderNoPermission(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadListContentProviderIntentAction != null && !payloadListContentProviderIntentAction.isEmpty()) {
for (String payload : payloadListContentProviderIntentAction) {
sdkClickHandler.sendPreinstallPayload(payload, Constants.CONTENT_PROVIDER_NO_PERMISSION);
}
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER_NO_PERMISSION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.FILE_SYSTEM, readStatus)) {
String payloadFileSystem = PreinstallUtil.getPayloadFromFileSystem(
deviceInfo.packageName,
adjustConfig.preinstallFilePath,
logger);

if (payloadFileSystem != null && !payloadFileSystem.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadFileSystem, Constants.FILE_SYSTEM);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.FILE_SYSTEM, readStatus);
}
}

sharedPreferencesManager.setPreinstallPayloadReadStatus(readStatus);

internalState.preinstallHasBeenRead = true;
}","private void checkForPreinstallI() {
if (activityState == null) return;
if (!activityState.enabled) return;
if (activityState.isGdprForgotten) return;

//comment
sendPreinstallReferrerI();

if (!adjustConfig.preinstallTrackingEnabled) return;
if (internalState.hasPreinstallBeenRead()) return;

if (deviceInfo.packageName == null || deviceInfo.packageName.isEmpty()) {
logger.debug(""Can't read preinstall payload, invalid package name"");
return;
}

SharedPreferencesManager sharedPreferencesManager = new SharedPreferencesManager(getContext());
long readStatus = sharedPreferencesManager.getPreinstallPayloadReadStatus();

if (PreinstallUtil.hasAllLocationsBeenRead(readStatus)) {
internalState.preinstallHasBeenRead = true;
return;
}

//comment
<start>if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES, readStatus)) {
String payloadSystemProperty = PreinstallUtil.getPayloadFromSystemProperty(
deviceInfo.packageName, logger);

if (payloadSystemProperty != null && !payloadSystemProperty.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemProperty, Constants.SYSTEM_PROPERTIES);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES, readStatus);
}
}<end>

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_REFLECTION, readStatus)) {
String payloadSystemPropertyReflection = PreinstallUtil.getPayloadFromSystemPropertyReflection(
deviceInfo.packageName, logger);

if (payloadSystemPropertyReflection != null && !payloadSystemPropertyReflection.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyReflection, Constants.SYSTEM_PROPERTIES_REFLECTION);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_REFLECTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_PATH, readStatus)) {
String payloadSystemPropertyFilePath = PreinstallUtil.getPayloadFromSystemPropertyFilePath(
deviceInfo.packageName, logger);

if (payloadSystemPropertyFilePath != null && !payloadSystemPropertyFilePath.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyFilePath, Constants.SYSTEM_PROPERTIES_PATH);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_PATH, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_PATH_REFLECTION, readStatus)) {
String payloadSystemPropertyFilePathReflection = PreinstallUtil.getPayloadFromSystemPropertyFilePathReflection(
deviceInfo.packageName, logger);

if (payloadSystemPropertyFilePathReflection != null && !payloadSystemPropertyFilePathReflection.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyFilePathReflection, Constants.SYSTEM_PROPERTIES_PATH_REFLECTION);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_PATH_REFLECTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER, readStatus)) {
String payloadContentProviderDefault = PreinstallUtil.getPayloadFromContentProviderDefault(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadContentProviderDefault != null && !payloadContentProviderDefault.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadContentProviderDefault, Constants.CONTENT_PROVIDER);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER_INTENT_ACTION, readStatus)) {
List<String> payloadListContentProviderIntentAction = PreinstallUtil.getPayloadsFromContentProviderIntentAction(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadListContentProviderIntentAction != null && !payloadListContentProviderIntentAction.isEmpty()) {
for (String payload : payloadListContentProviderIntentAction) {
sdkClickHandler.sendPreinstallPayload(payload, Constants.CONTENT_PROVIDER_INTENT_ACTION);
}
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER_INTENT_ACTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER_NO_PERMISSION, readStatus)) {
List<String> payloadListContentProviderIntentAction = PreinstallUtil.getPayloadsFromContentProviderNoPermission(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadListContentProviderIntentAction != null && !payloadListContentProviderIntentAction.isEmpty()) {
for (String payload : payloadListContentProviderIntentAction) {
sdkClickHandler.sendPreinstallPayload(payload, Constants.CONTENT_PROVIDER_NO_PERMISSION);
}
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER_NO_PERMISSION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.FILE_SYSTEM, readStatus)) {
String payloadFileSystem = PreinstallUtil.getPayloadFromFileSystem(
deviceInfo.packageName,
adjustConfig.preinstallFilePath,
logger);

if (payloadFileSystem != null && !payloadFileSystem.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadFileSystem, Constants.FILE_SYSTEM);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.FILE_SYSTEM, readStatus);
}
}

sharedPreferencesManager.setPreinstallPayloadReadStatus(readStatus);

internalState.preinstallHasBeenRead = true;
}"
4034,"private void checkForPreinstallI() {
if (activityState == null) return;
if (!activityState.enabled) return;
if (activityState.isGdprForgotten) return;

//comment
sendPreinstallReferrerI();

if (!adjustConfig.preinstallTrackingEnabled) return;
if (internalState.hasPreinstallBeenRead()) return;

if (deviceInfo.packageName == null || deviceInfo.packageName.isEmpty()) {
logger.debug(""Can't read preinstall payload, invalid package name"");
return;
}

SharedPreferencesManager sharedPreferencesManager = new SharedPreferencesManager(getContext());
long readStatus = sharedPreferencesManager.getPreinstallPayloadReadStatus();

if (PreinstallUtil.hasAllLocationsBeenRead(readStatus)) {
internalState.preinstallHasBeenRead = true;
return;
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES, readStatus)) {
String payloadSystemProperty = PreinstallUtil.getPayloadFromSystemProperty(
deviceInfo.packageName, logger);

if (payloadSystemProperty != null && !payloadSystemProperty.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemProperty, Constants.SYSTEM_PROPERTIES);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_REFLECTION, readStatus)) {
<start>String payloadSystemPropertyReflection = PreinstallUtil.getPayloadFromSystemPropertyReflection(
deviceInfo.packageName, logger);<end>

if (payloadSystemPropertyReflection != null && !payloadSystemPropertyReflection.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyReflection, Constants.SYSTEM_PROPERTIES_REFLECTION);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_REFLECTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_PATH, readStatus)) {
String payloadSystemPropertyFilePath = PreinstallUtil.getPayloadFromSystemPropertyFilePath(
deviceInfo.packageName, logger);

if (payloadSystemPropertyFilePath != null && !payloadSystemPropertyFilePath.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyFilePath, Constants.SYSTEM_PROPERTIES_PATH);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_PATH, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_PATH_REFLECTION, readStatus)) {
String payloadSystemPropertyFilePathReflection = PreinstallUtil.getPayloadFromSystemPropertyFilePathReflection(
deviceInfo.packageName, logger);

if (payloadSystemPropertyFilePathReflection != null && !payloadSystemPropertyFilePathReflection.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyFilePathReflection, Constants.SYSTEM_PROPERTIES_PATH_REFLECTION);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_PATH_REFLECTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER, readStatus)) {
String payloadContentProviderDefault = PreinstallUtil.getPayloadFromContentProviderDefault(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadContentProviderDefault != null && !payloadContentProviderDefault.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadContentProviderDefault, Constants.CONTENT_PROVIDER);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER_INTENT_ACTION, readStatus)) {
List<String> payloadListContentProviderIntentAction = PreinstallUtil.getPayloadsFromContentProviderIntentAction(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadListContentProviderIntentAction != null && !payloadListContentProviderIntentAction.isEmpty()) {
for (String payload : payloadListContentProviderIntentAction) {
sdkClickHandler.sendPreinstallPayload(payload, Constants.CONTENT_PROVIDER_INTENT_ACTION);
}
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER_INTENT_ACTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER_NO_PERMISSION, readStatus)) {
List<String> payloadListContentProviderIntentAction = PreinstallUtil.getPayloadsFromContentProviderNoPermission(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadListContentProviderIntentAction != null && !payloadListContentProviderIntentAction.isEmpty()) {
for (String payload : payloadListContentProviderIntentAction) {
sdkClickHandler.sendPreinstallPayload(payload, Constants.CONTENT_PROVIDER_NO_PERMISSION);
}
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER_NO_PERMISSION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.FILE_SYSTEM, readStatus)) {
String payloadFileSystem = PreinstallUtil.getPayloadFromFileSystem(
deviceInfo.packageName,
adjustConfig.preinstallFilePath,
logger);

if (payloadFileSystem != null && !payloadFileSystem.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadFileSystem, Constants.FILE_SYSTEM);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.FILE_SYSTEM, readStatus);
}
}

sharedPreferencesManager.setPreinstallPayloadReadStatus(readStatus);

internalState.preinstallHasBeenRead = true;
}","private void checkForPreinstallI() {
if (activityState == null) return;
if (!activityState.enabled) return;
if (activityState.isGdprForgotten) return;

//comment
sendPreinstallReferrerI();

if (!adjustConfig.preinstallTrackingEnabled) return;
if (internalState.hasPreinstallBeenRead()) return;

if (deviceInfo.packageName == null || deviceInfo.packageName.isEmpty()) {
logger.debug(""Can't read preinstall payload, invalid package name"");
return;
}

SharedPreferencesManager sharedPreferencesManager = new SharedPreferencesManager(getContext());
long readStatus = sharedPreferencesManager.getPreinstallPayloadReadStatus();

if (PreinstallUtil.hasAllLocationsBeenRead(readStatus)) {
internalState.preinstallHasBeenRead = true;
return;
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES, readStatus)) {
String payloadSystemProperty = PreinstallUtil.getPayloadFromSystemProperty(
deviceInfo.packageName, logger);

if (payloadSystemProperty != null && !payloadSystemProperty.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemProperty, Constants.SYSTEM_PROPERTIES);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES, readStatus);
}
}

//comment
<start>if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_REFLECTION, readStatus)) {
String payloadSystemPropertyReflection = PreinstallUtil.getPayloadFromSystemPropertyReflection(
deviceInfo.packageName, logger);

if (payloadSystemPropertyReflection != null && !payloadSystemPropertyReflection.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyReflection, Constants.SYSTEM_PROPERTIES_REFLECTION);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_REFLECTION, readStatus);
}
}<end>

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_PATH, readStatus)) {
String payloadSystemPropertyFilePath = PreinstallUtil.getPayloadFromSystemPropertyFilePath(
deviceInfo.packageName, logger);

if (payloadSystemPropertyFilePath != null && !payloadSystemPropertyFilePath.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyFilePath, Constants.SYSTEM_PROPERTIES_PATH);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_PATH, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_PATH_REFLECTION, readStatus)) {
String payloadSystemPropertyFilePathReflection = PreinstallUtil.getPayloadFromSystemPropertyFilePathReflection(
deviceInfo.packageName, logger);

if (payloadSystemPropertyFilePathReflection != null && !payloadSystemPropertyFilePathReflection.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyFilePathReflection, Constants.SYSTEM_PROPERTIES_PATH_REFLECTION);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_PATH_REFLECTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER, readStatus)) {
String payloadContentProviderDefault = PreinstallUtil.getPayloadFromContentProviderDefault(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadContentProviderDefault != null && !payloadContentProviderDefault.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadContentProviderDefault, Constants.CONTENT_PROVIDER);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER_INTENT_ACTION, readStatus)) {
List<String> payloadListContentProviderIntentAction = PreinstallUtil.getPayloadsFromContentProviderIntentAction(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadListContentProviderIntentAction != null && !payloadListContentProviderIntentAction.isEmpty()) {
for (String payload : payloadListContentProviderIntentAction) {
sdkClickHandler.sendPreinstallPayload(payload, Constants.CONTENT_PROVIDER_INTENT_ACTION);
}
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER_INTENT_ACTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER_NO_PERMISSION, readStatus)) {
List<String> payloadListContentProviderIntentAction = PreinstallUtil.getPayloadsFromContentProviderNoPermission(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadListContentProviderIntentAction != null && !payloadListContentProviderIntentAction.isEmpty()) {
for (String payload : payloadListContentProviderIntentAction) {
sdkClickHandler.sendPreinstallPayload(payload, Constants.CONTENT_PROVIDER_NO_PERMISSION);
}
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER_NO_PERMISSION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.FILE_SYSTEM, readStatus)) {
String payloadFileSystem = PreinstallUtil.getPayloadFromFileSystem(
deviceInfo.packageName,
adjustConfig.preinstallFilePath,
logger);

if (payloadFileSystem != null && !payloadFileSystem.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadFileSystem, Constants.FILE_SYSTEM);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.FILE_SYSTEM, readStatus);
}
}

sharedPreferencesManager.setPreinstallPayloadReadStatus(readStatus);

internalState.preinstallHasBeenRead = true;
}"
4035,"private void checkForPreinstallI() {
if (activityState == null) return;
if (!activityState.enabled) return;
if (activityState.isGdprForgotten) return;

//comment
sendPreinstallReferrerI();

if (!adjustConfig.preinstallTrackingEnabled) return;
if (internalState.hasPreinstallBeenRead()) return;

if (deviceInfo.packageName == null || deviceInfo.packageName.isEmpty()) {
logger.debug(""Can't read preinstall payload, invalid package name"");
return;
}

SharedPreferencesManager sharedPreferencesManager = new SharedPreferencesManager(getContext());
long readStatus = sharedPreferencesManager.getPreinstallPayloadReadStatus();

if (PreinstallUtil.hasAllLocationsBeenRead(readStatus)) {
internalState.preinstallHasBeenRead = true;
return;
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES, readStatus)) {
String payloadSystemProperty = PreinstallUtil.getPayloadFromSystemProperty(
deviceInfo.packageName, logger);

if (payloadSystemProperty != null && !payloadSystemProperty.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemProperty, Constants.SYSTEM_PROPERTIES);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_REFLECTION, readStatus)) {
String payloadSystemPropertyReflection = PreinstallUtil.getPayloadFromSystemPropertyReflection(
deviceInfo.packageName, logger);

if (payloadSystemPropertyReflection != null && !payloadSystemPropertyReflection.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyReflection, Constants.SYSTEM_PROPERTIES_REFLECTION);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_REFLECTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_PATH, readStatus)) {
String payloadSystemPropertyFilePath = PreinstallUtil.getPayloadFromSystemPropertyFilePath(
deviceInfo.packageName, logger);

if (payloadSystemPropertyFilePath != null && !payloadSystemPropertyFilePath.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyFilePath, Constants.SYSTEM_PROPERTIES_PATH);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_PATH, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_PATH_REFLECTION, readStatus)) {
String payloadSystemPropertyFilePathReflection = PreinstallUtil.getPayloadFromSystemPropertyFilePathReflection(
deviceInfo.packageName, logger);

if (payloadSystemPropertyFilePathReflection != null && !payloadSystemPropertyFilePathReflection.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyFilePathReflection, Constants.SYSTEM_PROPERTIES_PATH_REFLECTION);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_PATH_REFLECTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER, readStatus)) {
String payloadContentProviderDefault = PreinstallUtil.getPayloadFromContentProviderDefault(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadContentProviderDefault != null && !payloadContentProviderDefault.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadContentProviderDefault, Constants.CONTENT_PROVIDER);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER_INTENT_ACTION, readStatus)) {
List<String> payloadListContentProviderIntentAction = PreinstallUtil.getPayloadsFromContentProviderIntentAction(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadListContentProviderIntentAction != null && !payloadListContentProviderIntentAction.isEmpty()) {
for (String payload : payloadListContentProviderIntentAction) {
sdkClickHandler.sendPreinstallPayload(payload, Constants.CONTENT_PROVIDER_INTENT_ACTION);
}
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER_INTENT_ACTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER_NO_PERMISSION, readStatus)) {
List<String> payloadListContentProviderIntentAction = PreinstallUtil.getPayloadsFromContentProviderNoPermission(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadListContentProviderIntentAction != null && !payloadListContentProviderIntentAction.isEmpty()) {
for (String payload : payloadListContentProviderIntentAction) {
sdkClickHandler.sendPreinstallPayload(payload, Constants.CONTENT_PROVIDER_NO_PERMISSION);
}
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER_NO_PERMISSION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.FILE_SYSTEM, readStatus)) {
String payloadFileSystem = PreinstallUtil.getPayloadFromFileSystem(
deviceInfo.packageName,
adjustConfig.preinstallFilePath,
logger);

if (payloadFileSystem != null && !payloadFileSystem.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadFileSystem, Constants.FILE_SYSTEM);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.FILE_SYSTEM, readStatus);
}
}

sharedPreferencesManager.setPreinstallPayloadReadStatus(readStatus);

internalState.preinstallHasBeenRead = true;
}","private void checkForPreinstallI() {
if (activityState == null) return;
if (!activityState.enabled) return;
if (activityState.isGdprForgotten) return;

//comment
sendPreinstallReferrerI();

if (!adjustConfig.preinstallTrackingEnabled) return;
if (internalState.hasPreinstallBeenRead()) return;

if (deviceInfo.packageName == null || deviceInfo.packageName.isEmpty()) {
logger.debug(""Can't read preinstall payload, invalid package name"");
return;
}

SharedPreferencesManager sharedPreferencesManager = new SharedPreferencesManager(getContext());
long readStatus = sharedPreferencesManager.getPreinstallPayloadReadStatus();

if (PreinstallUtil.hasAllLocationsBeenRead(readStatus)) {
internalState.preinstallHasBeenRead = true;
return;
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES, readStatus)) {
String payloadSystemProperty = PreinstallUtil.getPayloadFromSystemProperty(
deviceInfo.packageName, logger);

if (payloadSystemProperty != null && !payloadSystemProperty.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemProperty, Constants.SYSTEM_PROPERTIES);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_REFLECTION, readStatus)) {
String payloadSystemPropertyReflection = PreinstallUtil.getPayloadFromSystemPropertyReflection(
deviceInfo.packageName, logger);

if (payloadSystemPropertyReflection != null && !payloadSystemPropertyReflection.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyReflection, Constants.SYSTEM_PROPERTIES_REFLECTION);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_REFLECTION, readStatus);
}
}

//comment
<start>if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_PATH, readStatus)) {
String payloadSystemPropertyFilePath = PreinstallUtil.getPayloadFromSystemPropertyFilePath(
deviceInfo.packageName, logger);

if (payloadSystemPropertyFilePath != null && !payloadSystemPropertyFilePath.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyFilePath, Constants.SYSTEM_PROPERTIES_PATH);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_PATH, readStatus);
}
}<end>

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_PATH_REFLECTION, readStatus)) {
String payloadSystemPropertyFilePathReflection = PreinstallUtil.getPayloadFromSystemPropertyFilePathReflection(
deviceInfo.packageName, logger);

if (payloadSystemPropertyFilePathReflection != null && !payloadSystemPropertyFilePathReflection.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyFilePathReflection, Constants.SYSTEM_PROPERTIES_PATH_REFLECTION);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_PATH_REFLECTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER, readStatus)) {
String payloadContentProviderDefault = PreinstallUtil.getPayloadFromContentProviderDefault(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadContentProviderDefault != null && !payloadContentProviderDefault.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadContentProviderDefault, Constants.CONTENT_PROVIDER);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER_INTENT_ACTION, readStatus)) {
List<String> payloadListContentProviderIntentAction = PreinstallUtil.getPayloadsFromContentProviderIntentAction(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadListContentProviderIntentAction != null && !payloadListContentProviderIntentAction.isEmpty()) {
for (String payload : payloadListContentProviderIntentAction) {
sdkClickHandler.sendPreinstallPayload(payload, Constants.CONTENT_PROVIDER_INTENT_ACTION);
}
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER_INTENT_ACTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER_NO_PERMISSION, readStatus)) {
List<String> payloadListContentProviderIntentAction = PreinstallUtil.getPayloadsFromContentProviderNoPermission(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadListContentProviderIntentAction != null && !payloadListContentProviderIntentAction.isEmpty()) {
for (String payload : payloadListContentProviderIntentAction) {
sdkClickHandler.sendPreinstallPayload(payload, Constants.CONTENT_PROVIDER_NO_PERMISSION);
}
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER_NO_PERMISSION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.FILE_SYSTEM, readStatus)) {
String payloadFileSystem = PreinstallUtil.getPayloadFromFileSystem(
deviceInfo.packageName,
adjustConfig.preinstallFilePath,
logger);

if (payloadFileSystem != null && !payloadFileSystem.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadFileSystem, Constants.FILE_SYSTEM);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.FILE_SYSTEM, readStatus);
}
}

sharedPreferencesManager.setPreinstallPayloadReadStatus(readStatus);

internalState.preinstallHasBeenRead = true;
}"
4036,"private void checkForPreinstallI() {
if (activityState == null) return;
if (!activityState.enabled) return;
if (activityState.isGdprForgotten) return;

//comment
sendPreinstallReferrerI();

if (!adjustConfig.preinstallTrackingEnabled) return;
if (internalState.hasPreinstallBeenRead()) return;

if (deviceInfo.packageName == null || deviceInfo.packageName.isEmpty()) {
logger.debug(""Can't read preinstall payload, invalid package name"");
return;
}

SharedPreferencesManager sharedPreferencesManager = new SharedPreferencesManager(getContext());
long readStatus = sharedPreferencesManager.getPreinstallPayloadReadStatus();

if (PreinstallUtil.hasAllLocationsBeenRead(readStatus)) {
internalState.preinstallHasBeenRead = true;
return;
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES, readStatus)) {
String payloadSystemProperty = PreinstallUtil.getPayloadFromSystemProperty(
deviceInfo.packageName, logger);

if (payloadSystemProperty != null && !payloadSystemProperty.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemProperty, Constants.SYSTEM_PROPERTIES);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_REFLECTION, readStatus)) {
String payloadSystemPropertyReflection = PreinstallUtil.getPayloadFromSystemPropertyReflection(
deviceInfo.packageName, logger);

if (payloadSystemPropertyReflection != null && !payloadSystemPropertyReflection.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyReflection, Constants.SYSTEM_PROPERTIES_REFLECTION);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_REFLECTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_PATH, readStatus)) {
String payloadSystemPropertyFilePath = PreinstallUtil.getPayloadFromSystemPropertyFilePath(
deviceInfo.packageName, logger);

if (payloadSystemPropertyFilePath != null && !payloadSystemPropertyFilePath.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyFilePath, Constants.SYSTEM_PROPERTIES_PATH);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_PATH, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_PATH_REFLECTION, readStatus)) {
<start>String payloadSystemPropertyFilePathReflection = PreinstallUtil.getPayloadFromSystemPropertyFilePathReflection(
deviceInfo.packageName, logger);<end>

if (payloadSystemPropertyFilePathReflection != null && !payloadSystemPropertyFilePathReflection.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyFilePathReflection, Constants.SYSTEM_PROPERTIES_PATH_REFLECTION);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_PATH_REFLECTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER, readStatus)) {
String payloadContentProviderDefault = PreinstallUtil.getPayloadFromContentProviderDefault(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadContentProviderDefault != null && !payloadContentProviderDefault.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadContentProviderDefault, Constants.CONTENT_PROVIDER);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER_INTENT_ACTION, readStatus)) {
List<String> payloadListContentProviderIntentAction = PreinstallUtil.getPayloadsFromContentProviderIntentAction(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadListContentProviderIntentAction != null && !payloadListContentProviderIntentAction.isEmpty()) {
for (String payload : payloadListContentProviderIntentAction) {
sdkClickHandler.sendPreinstallPayload(payload, Constants.CONTENT_PROVIDER_INTENT_ACTION);
}
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER_INTENT_ACTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER_NO_PERMISSION, readStatus)) {
List<String> payloadListContentProviderIntentAction = PreinstallUtil.getPayloadsFromContentProviderNoPermission(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadListContentProviderIntentAction != null && !payloadListContentProviderIntentAction.isEmpty()) {
for (String payload : payloadListContentProviderIntentAction) {
sdkClickHandler.sendPreinstallPayload(payload, Constants.CONTENT_PROVIDER_NO_PERMISSION);
}
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER_NO_PERMISSION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.FILE_SYSTEM, readStatus)) {
String payloadFileSystem = PreinstallUtil.getPayloadFromFileSystem(
deviceInfo.packageName,
adjustConfig.preinstallFilePath,
logger);

if (payloadFileSystem != null && !payloadFileSystem.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadFileSystem, Constants.FILE_SYSTEM);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.FILE_SYSTEM, readStatus);
}
}

sharedPreferencesManager.setPreinstallPayloadReadStatus(readStatus);

internalState.preinstallHasBeenRead = true;
}","private void checkForPreinstallI() {
if (activityState == null) return;
if (!activityState.enabled) return;
if (activityState.isGdprForgotten) return;

//comment
sendPreinstallReferrerI();

if (!adjustConfig.preinstallTrackingEnabled) return;
if (internalState.hasPreinstallBeenRead()) return;

if (deviceInfo.packageName == null || deviceInfo.packageName.isEmpty()) {
logger.debug(""Can't read preinstall payload, invalid package name"");
return;
}

SharedPreferencesManager sharedPreferencesManager = new SharedPreferencesManager(getContext());
long readStatus = sharedPreferencesManager.getPreinstallPayloadReadStatus();

if (PreinstallUtil.hasAllLocationsBeenRead(readStatus)) {
internalState.preinstallHasBeenRead = true;
return;
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES, readStatus)) {
String payloadSystemProperty = PreinstallUtil.getPayloadFromSystemProperty(
deviceInfo.packageName, logger);

if (payloadSystemProperty != null && !payloadSystemProperty.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemProperty, Constants.SYSTEM_PROPERTIES);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_REFLECTION, readStatus)) {
String payloadSystemPropertyReflection = PreinstallUtil.getPayloadFromSystemPropertyReflection(
deviceInfo.packageName, logger);

if (payloadSystemPropertyReflection != null && !payloadSystemPropertyReflection.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyReflection, Constants.SYSTEM_PROPERTIES_REFLECTION);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_REFLECTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_PATH, readStatus)) {
String payloadSystemPropertyFilePath = PreinstallUtil.getPayloadFromSystemPropertyFilePath(
deviceInfo.packageName, logger);

if (payloadSystemPropertyFilePath != null && !payloadSystemPropertyFilePath.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyFilePath, Constants.SYSTEM_PROPERTIES_PATH);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_PATH, readStatus);
}
}

//comment
<start>if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_PATH_REFLECTION, readStatus)) {
String payloadSystemPropertyFilePathReflection = PreinstallUtil.getPayloadFromSystemPropertyFilePathReflection(
deviceInfo.packageName, logger);

if (payloadSystemPropertyFilePathReflection != null && !payloadSystemPropertyFilePathReflection.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyFilePathReflection, Constants.SYSTEM_PROPERTIES_PATH_REFLECTION);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_PATH_REFLECTION, readStatus);
}
}<end>

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER, readStatus)) {
String payloadContentProviderDefault = PreinstallUtil.getPayloadFromContentProviderDefault(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadContentProviderDefault != null && !payloadContentProviderDefault.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadContentProviderDefault, Constants.CONTENT_PROVIDER);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER_INTENT_ACTION, readStatus)) {
List<String> payloadListContentProviderIntentAction = PreinstallUtil.getPayloadsFromContentProviderIntentAction(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadListContentProviderIntentAction != null && !payloadListContentProviderIntentAction.isEmpty()) {
for (String payload : payloadListContentProviderIntentAction) {
sdkClickHandler.sendPreinstallPayload(payload, Constants.CONTENT_PROVIDER_INTENT_ACTION);
}
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER_INTENT_ACTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER_NO_PERMISSION, readStatus)) {
List<String> payloadListContentProviderIntentAction = PreinstallUtil.getPayloadsFromContentProviderNoPermission(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadListContentProviderIntentAction != null && !payloadListContentProviderIntentAction.isEmpty()) {
for (String payload : payloadListContentProviderIntentAction) {
sdkClickHandler.sendPreinstallPayload(payload, Constants.CONTENT_PROVIDER_NO_PERMISSION);
}
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER_NO_PERMISSION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.FILE_SYSTEM, readStatus)) {
String payloadFileSystem = PreinstallUtil.getPayloadFromFileSystem(
deviceInfo.packageName,
adjustConfig.preinstallFilePath,
logger);

if (payloadFileSystem != null && !payloadFileSystem.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadFileSystem, Constants.FILE_SYSTEM);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.FILE_SYSTEM, readStatus);
}
}

sharedPreferencesManager.setPreinstallPayloadReadStatus(readStatus);

internalState.preinstallHasBeenRead = true;
}"
4037,"private void checkForPreinstallI() {
if (activityState == null) return;
if (!activityState.enabled) return;
if (activityState.isGdprForgotten) return;

//comment
sendPreinstallReferrerI();

if (!adjustConfig.preinstallTrackingEnabled) return;
if (internalState.hasPreinstallBeenRead()) return;

if (deviceInfo.packageName == null || deviceInfo.packageName.isEmpty()) {
logger.debug(""Can't read preinstall payload, invalid package name"");
return;
}

SharedPreferencesManager sharedPreferencesManager = new SharedPreferencesManager(getContext());
long readStatus = sharedPreferencesManager.getPreinstallPayloadReadStatus();

if (PreinstallUtil.hasAllLocationsBeenRead(readStatus)) {
internalState.preinstallHasBeenRead = true;
return;
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES, readStatus)) {
String payloadSystemProperty = PreinstallUtil.getPayloadFromSystemProperty(
deviceInfo.packageName, logger);

if (payloadSystemProperty != null && !payloadSystemProperty.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemProperty, Constants.SYSTEM_PROPERTIES);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_REFLECTION, readStatus)) {
String payloadSystemPropertyReflection = PreinstallUtil.getPayloadFromSystemPropertyReflection(
deviceInfo.packageName, logger);

if (payloadSystemPropertyReflection != null && !payloadSystemPropertyReflection.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyReflection, Constants.SYSTEM_PROPERTIES_REFLECTION);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_REFLECTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_PATH, readStatus)) {
String payloadSystemPropertyFilePath = PreinstallUtil.getPayloadFromSystemPropertyFilePath(
deviceInfo.packageName, logger);

if (payloadSystemPropertyFilePath != null && !payloadSystemPropertyFilePath.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyFilePath, Constants.SYSTEM_PROPERTIES_PATH);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_PATH, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_PATH_REFLECTION, readStatus)) {
String payloadSystemPropertyFilePathReflection = PreinstallUtil.getPayloadFromSystemPropertyFilePathReflection(
deviceInfo.packageName, logger);

if (payloadSystemPropertyFilePathReflection != null && !payloadSystemPropertyFilePathReflection.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyFilePathReflection, Constants.SYSTEM_PROPERTIES_PATH_REFLECTION);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_PATH_REFLECTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER, readStatus)) {
String payloadContentProviderDefault = PreinstallUtil.getPayloadFromContentProviderDefault(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadContentProviderDefault != null && !payloadContentProviderDefault.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadContentProviderDefault, Constants.CONTENT_PROVIDER);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER_INTENT_ACTION, readStatus)) {
List<String> payloadListContentProviderIntentAction = PreinstallUtil.getPayloadsFromContentProviderIntentAction(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadListContentProviderIntentAction != null && !payloadListContentProviderIntentAction.isEmpty()) {
for (String payload : payloadListContentProviderIntentAction) {
sdkClickHandler.sendPreinstallPayload(payload, Constants.CONTENT_PROVIDER_INTENT_ACTION);
}
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER_INTENT_ACTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER_NO_PERMISSION, readStatus)) {
List<String> payloadListContentProviderIntentAction = PreinstallUtil.getPayloadsFromContentProviderNoPermission(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadListContentProviderIntentAction != null && !payloadListContentProviderIntentAction.isEmpty()) {
for (String payload : payloadListContentProviderIntentAction) {
sdkClickHandler.sendPreinstallPayload(payload, Constants.CONTENT_PROVIDER_NO_PERMISSION);
}
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER_NO_PERMISSION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.FILE_SYSTEM, readStatus)) {
String payloadFileSystem = PreinstallUtil.getPayloadFromFileSystem(
deviceInfo.packageName,
adjustConfig.preinstallFilePath,
logger);

if (payloadFileSystem != null && !payloadFileSystem.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadFileSystem, Constants.FILE_SYSTEM);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.FILE_SYSTEM, readStatus);
}
}

sharedPreferencesManager.setPreinstallPayloadReadStatus(readStatus);

internalState.preinstallHasBeenRead = true;
}","private void checkForPreinstallI() {
if (activityState == null) return;
if (!activityState.enabled) return;
if (activityState.isGdprForgotten) return;

//comment
sendPreinstallReferrerI();

if (!adjustConfig.preinstallTrackingEnabled) return;
if (internalState.hasPreinstallBeenRead()) return;

if (deviceInfo.packageName == null || deviceInfo.packageName.isEmpty()) {
logger.debug(""Can't read preinstall payload, invalid package name"");
return;
}

SharedPreferencesManager sharedPreferencesManager = new SharedPreferencesManager(getContext());
long readStatus = sharedPreferencesManager.getPreinstallPayloadReadStatus();

if (PreinstallUtil.hasAllLocationsBeenRead(readStatus)) {
internalState.preinstallHasBeenRead = true;
return;
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES, readStatus)) {
String payloadSystemProperty = PreinstallUtil.getPayloadFromSystemProperty(
deviceInfo.packageName, logger);

if (payloadSystemProperty != null && !payloadSystemProperty.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemProperty, Constants.SYSTEM_PROPERTIES);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_REFLECTION, readStatus)) {
String payloadSystemPropertyReflection = PreinstallUtil.getPayloadFromSystemPropertyReflection(
deviceInfo.packageName, logger);

if (payloadSystemPropertyReflection != null && !payloadSystemPropertyReflection.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyReflection, Constants.SYSTEM_PROPERTIES_REFLECTION);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_REFLECTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_PATH, readStatus)) {
String payloadSystemPropertyFilePath = PreinstallUtil.getPayloadFromSystemPropertyFilePath(
deviceInfo.packageName, logger);

if (payloadSystemPropertyFilePath != null && !payloadSystemPropertyFilePath.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyFilePath, Constants.SYSTEM_PROPERTIES_PATH);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_PATH, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_PATH_REFLECTION, readStatus)) {
String payloadSystemPropertyFilePathReflection = PreinstallUtil.getPayloadFromSystemPropertyFilePathReflection(
deviceInfo.packageName, logger);

if (payloadSystemPropertyFilePathReflection != null && !payloadSystemPropertyFilePathReflection.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyFilePathReflection, Constants.SYSTEM_PROPERTIES_PATH_REFLECTION);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_PATH_REFLECTION, readStatus);
}
}

//comment
<start>if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER, readStatus)) {
String payloadContentProviderDefault = PreinstallUtil.getPayloadFromContentProviderDefault(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadContentProviderDefault != null && !payloadContentProviderDefault.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadContentProviderDefault, Constants.CONTENT_PROVIDER);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER, readStatus);
}
}<end>

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER_INTENT_ACTION, readStatus)) {
List<String> payloadListContentProviderIntentAction = PreinstallUtil.getPayloadsFromContentProviderIntentAction(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadListContentProviderIntentAction != null && !payloadListContentProviderIntentAction.isEmpty()) {
for (String payload : payloadListContentProviderIntentAction) {
sdkClickHandler.sendPreinstallPayload(payload, Constants.CONTENT_PROVIDER_INTENT_ACTION);
}
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER_INTENT_ACTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER_NO_PERMISSION, readStatus)) {
List<String> payloadListContentProviderIntentAction = PreinstallUtil.getPayloadsFromContentProviderNoPermission(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadListContentProviderIntentAction != null && !payloadListContentProviderIntentAction.isEmpty()) {
for (String payload : payloadListContentProviderIntentAction) {
sdkClickHandler.sendPreinstallPayload(payload, Constants.CONTENT_PROVIDER_NO_PERMISSION);
}
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER_NO_PERMISSION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.FILE_SYSTEM, readStatus)) {
String payloadFileSystem = PreinstallUtil.getPayloadFromFileSystem(
deviceInfo.packageName,
adjustConfig.preinstallFilePath,
logger);

if (payloadFileSystem != null && !payloadFileSystem.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadFileSystem, Constants.FILE_SYSTEM);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.FILE_SYSTEM, readStatus);
}
}

sharedPreferencesManager.setPreinstallPayloadReadStatus(readStatus);

internalState.preinstallHasBeenRead = true;
}"
4038,"private void checkForPreinstallI() {
if (activityState == null) return;
if (!activityState.enabled) return;
if (activityState.isGdprForgotten) return;

//comment
sendPreinstallReferrerI();

if (!adjustConfig.preinstallTrackingEnabled) return;
if (internalState.hasPreinstallBeenRead()) return;

if (deviceInfo.packageName == null || deviceInfo.packageName.isEmpty()) {
logger.debug(""Can't read preinstall payload, invalid package name"");
return;
}

SharedPreferencesManager sharedPreferencesManager = new SharedPreferencesManager(getContext());
long readStatus = sharedPreferencesManager.getPreinstallPayloadReadStatus();

if (PreinstallUtil.hasAllLocationsBeenRead(readStatus)) {
internalState.preinstallHasBeenRead = true;
return;
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES, readStatus)) {
String payloadSystemProperty = PreinstallUtil.getPayloadFromSystemProperty(
deviceInfo.packageName, logger);

if (payloadSystemProperty != null && !payloadSystemProperty.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemProperty, Constants.SYSTEM_PROPERTIES);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_REFLECTION, readStatus)) {
String payloadSystemPropertyReflection = PreinstallUtil.getPayloadFromSystemPropertyReflection(
deviceInfo.packageName, logger);

if (payloadSystemPropertyReflection != null && !payloadSystemPropertyReflection.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyReflection, Constants.SYSTEM_PROPERTIES_REFLECTION);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_REFLECTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_PATH, readStatus)) {
String payloadSystemPropertyFilePath = PreinstallUtil.getPayloadFromSystemPropertyFilePath(
deviceInfo.packageName, logger);

if (payloadSystemPropertyFilePath != null && !payloadSystemPropertyFilePath.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyFilePath, Constants.SYSTEM_PROPERTIES_PATH);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_PATH, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_PATH_REFLECTION, readStatus)) {
String payloadSystemPropertyFilePathReflection = PreinstallUtil.getPayloadFromSystemPropertyFilePathReflection(
deviceInfo.packageName, logger);

if (payloadSystemPropertyFilePathReflection != null && !payloadSystemPropertyFilePathReflection.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyFilePathReflection, Constants.SYSTEM_PROPERTIES_PATH_REFLECTION);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_PATH_REFLECTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER, readStatus)) {
String payloadContentProviderDefault = PreinstallUtil.getPayloadFromContentProviderDefault(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadContentProviderDefault != null && !payloadContentProviderDefault.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadContentProviderDefault, Constants.CONTENT_PROVIDER);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER_INTENT_ACTION, readStatus)) {
List<String> payloadListContentProviderIntentAction = PreinstallUtil.getPayloadsFromContentProviderIntentAction(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadListContentProviderIntentAction != null && !payloadListContentProviderIntentAction.isEmpty()) {
for (String payload : payloadListContentProviderIntentAction) {
sdkClickHandler.sendPreinstallPayload(payload, Constants.CONTENT_PROVIDER_INTENT_ACTION);
}
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER_INTENT_ACTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER_NO_PERMISSION, readStatus)) {
List<String> payloadListContentProviderIntentAction = PreinstallUtil.getPayloadsFromContentProviderNoPermission(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadListContentProviderIntentAction != null && !payloadListContentProviderIntentAction.isEmpty()) {
for (String payload : payloadListContentProviderIntentAction) {
sdkClickHandler.sendPreinstallPayload(payload, Constants.CONTENT_PROVIDER_NO_PERMISSION);
}
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER_NO_PERMISSION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.FILE_SYSTEM, readStatus)) {
String payloadFileSystem = PreinstallUtil.getPayloadFromFileSystem(
deviceInfo.packageName,
adjustConfig.preinstallFilePath,
logger);

if (payloadFileSystem != null && !payloadFileSystem.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadFileSystem, Constants.FILE_SYSTEM);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.FILE_SYSTEM, readStatus);
}
}

sharedPreferencesManager.setPreinstallPayloadReadStatus(readStatus);

internalState.preinstallHasBeenRead = true;
}","private void checkForPreinstallI() {
if (activityState == null) return;
if (!activityState.enabled) return;
if (activityState.isGdprForgotten) return;

//comment
sendPreinstallReferrerI();

if (!adjustConfig.preinstallTrackingEnabled) return;
if (internalState.hasPreinstallBeenRead()) return;

if (deviceInfo.packageName == null || deviceInfo.packageName.isEmpty()) {
logger.debug(""Can't read preinstall payload, invalid package name"");
return;
}

SharedPreferencesManager sharedPreferencesManager = new SharedPreferencesManager(getContext());
long readStatus = sharedPreferencesManager.getPreinstallPayloadReadStatus();

if (PreinstallUtil.hasAllLocationsBeenRead(readStatus)) {
internalState.preinstallHasBeenRead = true;
return;
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES, readStatus)) {
String payloadSystemProperty = PreinstallUtil.getPayloadFromSystemProperty(
deviceInfo.packageName, logger);

if (payloadSystemProperty != null && !payloadSystemProperty.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemProperty, Constants.SYSTEM_PROPERTIES);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_REFLECTION, readStatus)) {
String payloadSystemPropertyReflection = PreinstallUtil.getPayloadFromSystemPropertyReflection(
deviceInfo.packageName, logger);

if (payloadSystemPropertyReflection != null && !payloadSystemPropertyReflection.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyReflection, Constants.SYSTEM_PROPERTIES_REFLECTION);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_REFLECTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_PATH, readStatus)) {
String payloadSystemPropertyFilePath = PreinstallUtil.getPayloadFromSystemPropertyFilePath(
deviceInfo.packageName, logger);

if (payloadSystemPropertyFilePath != null && !payloadSystemPropertyFilePath.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyFilePath, Constants.SYSTEM_PROPERTIES_PATH);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_PATH, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_PATH_REFLECTION, readStatus)) {
String payloadSystemPropertyFilePathReflection = PreinstallUtil.getPayloadFromSystemPropertyFilePathReflection(
deviceInfo.packageName, logger);

if (payloadSystemPropertyFilePathReflection != null && !payloadSystemPropertyFilePathReflection.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyFilePathReflection, Constants.SYSTEM_PROPERTIES_PATH_REFLECTION);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_PATH_REFLECTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER, readStatus)) {
String payloadContentProviderDefault = PreinstallUtil.getPayloadFromContentProviderDefault(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadContentProviderDefault != null && !payloadContentProviderDefault.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadContentProviderDefault, Constants.CONTENT_PROVIDER);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER, readStatus);
}
}

//comment
<start>if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER_INTENT_ACTION, readStatus)) {
List<String> payloadListContentProviderIntentAction = PreinstallUtil.getPayloadsFromContentProviderIntentAction(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadListContentProviderIntentAction != null && !payloadListContentProviderIntentAction.isEmpty()) {
for (String payload : payloadListContentProviderIntentAction) {
sdkClickHandler.sendPreinstallPayload(payload, Constants.CONTENT_PROVIDER_INTENT_ACTION);
}
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER_INTENT_ACTION, readStatus);
}
}<end>

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER_NO_PERMISSION, readStatus)) {
List<String> payloadListContentProviderIntentAction = PreinstallUtil.getPayloadsFromContentProviderNoPermission(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadListContentProviderIntentAction != null && !payloadListContentProviderIntentAction.isEmpty()) {
for (String payload : payloadListContentProviderIntentAction) {
sdkClickHandler.sendPreinstallPayload(payload, Constants.CONTENT_PROVIDER_NO_PERMISSION);
}
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER_NO_PERMISSION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.FILE_SYSTEM, readStatus)) {
String payloadFileSystem = PreinstallUtil.getPayloadFromFileSystem(
deviceInfo.packageName,
adjustConfig.preinstallFilePath,
logger);

if (payloadFileSystem != null && !payloadFileSystem.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadFileSystem, Constants.FILE_SYSTEM);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.FILE_SYSTEM, readStatus);
}
}

sharedPreferencesManager.setPreinstallPayloadReadStatus(readStatus);

internalState.preinstallHasBeenRead = true;
}"
4039,"private void checkForPreinstallI() {
if (activityState == null) return;
if (!activityState.enabled) return;
if (activityState.isGdprForgotten) return;

//comment
sendPreinstallReferrerI();

if (!adjustConfig.preinstallTrackingEnabled) return;
if (internalState.hasPreinstallBeenRead()) return;

if (deviceInfo.packageName == null || deviceInfo.packageName.isEmpty()) {
logger.debug(""Can't read preinstall payload, invalid package name"");
return;
}

SharedPreferencesManager sharedPreferencesManager = new SharedPreferencesManager(getContext());
long readStatus = sharedPreferencesManager.getPreinstallPayloadReadStatus();

if (PreinstallUtil.hasAllLocationsBeenRead(readStatus)) {
internalState.preinstallHasBeenRead = true;
return;
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES, readStatus)) {
String payloadSystemProperty = PreinstallUtil.getPayloadFromSystemProperty(
deviceInfo.packageName, logger);

if (payloadSystemProperty != null && !payloadSystemProperty.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemProperty, Constants.SYSTEM_PROPERTIES);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_REFLECTION, readStatus)) {
String payloadSystemPropertyReflection = PreinstallUtil.getPayloadFromSystemPropertyReflection(
deviceInfo.packageName, logger);

if (payloadSystemPropertyReflection != null && !payloadSystemPropertyReflection.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyReflection, Constants.SYSTEM_PROPERTIES_REFLECTION);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_REFLECTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_PATH, readStatus)) {
String payloadSystemPropertyFilePath = PreinstallUtil.getPayloadFromSystemPropertyFilePath(
deviceInfo.packageName, logger);

if (payloadSystemPropertyFilePath != null && !payloadSystemPropertyFilePath.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyFilePath, Constants.SYSTEM_PROPERTIES_PATH);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_PATH, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_PATH_REFLECTION, readStatus)) {
String payloadSystemPropertyFilePathReflection = PreinstallUtil.getPayloadFromSystemPropertyFilePathReflection(
deviceInfo.packageName, logger);

if (payloadSystemPropertyFilePathReflection != null && !payloadSystemPropertyFilePathReflection.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyFilePathReflection, Constants.SYSTEM_PROPERTIES_PATH_REFLECTION);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_PATH_REFLECTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER, readStatus)) {
String payloadContentProviderDefault = PreinstallUtil.getPayloadFromContentProviderDefault(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadContentProviderDefault != null && !payloadContentProviderDefault.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadContentProviderDefault, Constants.CONTENT_PROVIDER);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER_INTENT_ACTION, readStatus)) {
List<String> payloadListContentProviderIntentAction = PreinstallUtil.getPayloadsFromContentProviderIntentAction(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadListContentProviderIntentAction != null && !payloadListContentProviderIntentAction.isEmpty()) {
for (String payload : payloadListContentProviderIntentAction) {
sdkClickHandler.sendPreinstallPayload(payload, Constants.CONTENT_PROVIDER_INTENT_ACTION);
}
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER_INTENT_ACTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER_NO_PERMISSION, readStatus)) {
List<String> payloadListContentProviderIntentAction = PreinstallUtil.getPayloadsFromContentProviderNoPermission(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadListContentProviderIntentAction != null && !payloadListContentProviderIntentAction.isEmpty()) {
for (String payload : payloadListContentProviderIntentAction) {
sdkClickHandler.sendPreinstallPayload(payload, Constants.CONTENT_PROVIDER_NO_PERMISSION);
}
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER_NO_PERMISSION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.FILE_SYSTEM, readStatus)) {
String payloadFileSystem = PreinstallUtil.getPayloadFromFileSystem(
deviceInfo.packageName,
adjustConfig.preinstallFilePath,
logger);

if (payloadFileSystem != null && !payloadFileSystem.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadFileSystem, Constants.FILE_SYSTEM);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.FILE_SYSTEM, readStatus);
}
}

sharedPreferencesManager.setPreinstallPayloadReadStatus(readStatus);

internalState.preinstallHasBeenRead = true;
}","private void checkForPreinstallI() {
if (activityState == null) return;
if (!activityState.enabled) return;
if (activityState.isGdprForgotten) return;

//comment
sendPreinstallReferrerI();

if (!adjustConfig.preinstallTrackingEnabled) return;
if (internalState.hasPreinstallBeenRead()) return;

if (deviceInfo.packageName == null || deviceInfo.packageName.isEmpty()) {
logger.debug(""Can't read preinstall payload, invalid package name"");
return;
}

SharedPreferencesManager sharedPreferencesManager = new SharedPreferencesManager(getContext());
long readStatus = sharedPreferencesManager.getPreinstallPayloadReadStatus();

if (PreinstallUtil.hasAllLocationsBeenRead(readStatus)) {
internalState.preinstallHasBeenRead = true;
return;
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES, readStatus)) {
String payloadSystemProperty = PreinstallUtil.getPayloadFromSystemProperty(
deviceInfo.packageName, logger);

if (payloadSystemProperty != null && !payloadSystemProperty.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemProperty, Constants.SYSTEM_PROPERTIES);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_REFLECTION, readStatus)) {
String payloadSystemPropertyReflection = PreinstallUtil.getPayloadFromSystemPropertyReflection(
deviceInfo.packageName, logger);

if (payloadSystemPropertyReflection != null && !payloadSystemPropertyReflection.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyReflection, Constants.SYSTEM_PROPERTIES_REFLECTION);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_REFLECTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_PATH, readStatus)) {
String payloadSystemPropertyFilePath = PreinstallUtil.getPayloadFromSystemPropertyFilePath(
deviceInfo.packageName, logger);

if (payloadSystemPropertyFilePath != null && !payloadSystemPropertyFilePath.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyFilePath, Constants.SYSTEM_PROPERTIES_PATH);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_PATH, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_PATH_REFLECTION, readStatus)) {
String payloadSystemPropertyFilePathReflection = PreinstallUtil.getPayloadFromSystemPropertyFilePathReflection(
deviceInfo.packageName, logger);

if (payloadSystemPropertyFilePathReflection != null && !payloadSystemPropertyFilePathReflection.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyFilePathReflection, Constants.SYSTEM_PROPERTIES_PATH_REFLECTION);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_PATH_REFLECTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER, readStatus)) {
String payloadContentProviderDefault = PreinstallUtil.getPayloadFromContentProviderDefault(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadContentProviderDefault != null && !payloadContentProviderDefault.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadContentProviderDefault, Constants.CONTENT_PROVIDER);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER_INTENT_ACTION, readStatus)) {
List<String> payloadListContentProviderIntentAction = PreinstallUtil.getPayloadsFromContentProviderIntentAction(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadListContentProviderIntentAction != null && !payloadListContentProviderIntentAction.isEmpty()) {
for (String payload : payloadListContentProviderIntentAction) {
sdkClickHandler.sendPreinstallPayload(payload, Constants.CONTENT_PROVIDER_INTENT_ACTION);
}
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER_INTENT_ACTION, readStatus);
}
}

//comment
<start>if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER_NO_PERMISSION, readStatus)) {
List<String> payloadListContentProviderIntentAction = PreinstallUtil.getPayloadsFromContentProviderNoPermission(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadListContentProviderIntentAction != null && !payloadListContentProviderIntentAction.isEmpty()) {
for (String payload : payloadListContentProviderIntentAction) {
sdkClickHandler.sendPreinstallPayload(payload, Constants.CONTENT_PROVIDER_NO_PERMISSION);
}
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER_NO_PERMISSION, readStatus);
}
}<end>

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.FILE_SYSTEM, readStatus)) {
String payloadFileSystem = PreinstallUtil.getPayloadFromFileSystem(
deviceInfo.packageName,
adjustConfig.preinstallFilePath,
logger);

if (payloadFileSystem != null && !payloadFileSystem.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadFileSystem, Constants.FILE_SYSTEM);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.FILE_SYSTEM, readStatus);
}
}

sharedPreferencesManager.setPreinstallPayloadReadStatus(readStatus);

internalState.preinstallHasBeenRead = true;
}"
4040,"private void checkForPreinstallI() {
if (activityState == null) return;
if (!activityState.enabled) return;
if (activityState.isGdprForgotten) return;

//comment
sendPreinstallReferrerI();

if (!adjustConfig.preinstallTrackingEnabled) return;
if (internalState.hasPreinstallBeenRead()) return;

if (deviceInfo.packageName == null || deviceInfo.packageName.isEmpty()) {
logger.debug(""Can't read preinstall payload, invalid package name"");
return;
}

SharedPreferencesManager sharedPreferencesManager = new SharedPreferencesManager(getContext());
long readStatus = sharedPreferencesManager.getPreinstallPayloadReadStatus();

if (PreinstallUtil.hasAllLocationsBeenRead(readStatus)) {
internalState.preinstallHasBeenRead = true;
return;
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES, readStatus)) {
String payloadSystemProperty = PreinstallUtil.getPayloadFromSystemProperty(
deviceInfo.packageName, logger);

if (payloadSystemProperty != null && !payloadSystemProperty.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemProperty, Constants.SYSTEM_PROPERTIES);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_REFLECTION, readStatus)) {
String payloadSystemPropertyReflection = PreinstallUtil.getPayloadFromSystemPropertyReflection(
deviceInfo.packageName, logger);

if (payloadSystemPropertyReflection != null && !payloadSystemPropertyReflection.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyReflection, Constants.SYSTEM_PROPERTIES_REFLECTION);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_REFLECTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_PATH, readStatus)) {
String payloadSystemPropertyFilePath = PreinstallUtil.getPayloadFromSystemPropertyFilePath(
deviceInfo.packageName, logger);

if (payloadSystemPropertyFilePath != null && !payloadSystemPropertyFilePath.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyFilePath, Constants.SYSTEM_PROPERTIES_PATH);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_PATH, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_PATH_REFLECTION, readStatus)) {
String payloadSystemPropertyFilePathReflection = PreinstallUtil.getPayloadFromSystemPropertyFilePathReflection(
deviceInfo.packageName, logger);

if (payloadSystemPropertyFilePathReflection != null && !payloadSystemPropertyFilePathReflection.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyFilePathReflection, Constants.SYSTEM_PROPERTIES_PATH_REFLECTION);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_PATH_REFLECTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER, readStatus)) {
String payloadContentProviderDefault = PreinstallUtil.getPayloadFromContentProviderDefault(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadContentProviderDefault != null && !payloadContentProviderDefault.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadContentProviderDefault, Constants.CONTENT_PROVIDER);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER_INTENT_ACTION, readStatus)) {
List<String> payloadListContentProviderIntentAction = PreinstallUtil.getPayloadsFromContentProviderIntentAction(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadListContentProviderIntentAction != null && !payloadListContentProviderIntentAction.isEmpty()) {
for (String payload : payloadListContentProviderIntentAction) {
sdkClickHandler.sendPreinstallPayload(payload, Constants.CONTENT_PROVIDER_INTENT_ACTION);
}
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER_INTENT_ACTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER_NO_PERMISSION, readStatus)) {
List<String> payloadListContentProviderIntentAction = PreinstallUtil.getPayloadsFromContentProviderNoPermission(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadListContentProviderIntentAction != null && !payloadListContentProviderIntentAction.isEmpty()) {
for (String payload : payloadListContentProviderIntentAction) {
sdkClickHandler.sendPreinstallPayload(payload, Constants.CONTENT_PROVIDER_NO_PERMISSION);
}
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER_NO_PERMISSION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.FILE_SYSTEM, readStatus)) {
String payloadFileSystem = PreinstallUtil.getPayloadFromFileSystem(
deviceInfo.packageName,
adjustConfig.preinstallFilePath,
logger);

if (payloadFileSystem != null && !payloadFileSystem.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadFileSystem, Constants.FILE_SYSTEM);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.FILE_SYSTEM, readStatus);
}
}

sharedPreferencesManager.setPreinstallPayloadReadStatus(readStatus);

internalState.preinstallHasBeenRead = true;
}","private void checkForPreinstallI() {
if (activityState == null) return;
if (!activityState.enabled) return;
if (activityState.isGdprForgotten) return;

//comment
sendPreinstallReferrerI();

if (!adjustConfig.preinstallTrackingEnabled) return;
if (internalState.hasPreinstallBeenRead()) return;

if (deviceInfo.packageName == null || deviceInfo.packageName.isEmpty()) {
logger.debug(""Can't read preinstall payload, invalid package name"");
return;
}

SharedPreferencesManager sharedPreferencesManager = new SharedPreferencesManager(getContext());
long readStatus = sharedPreferencesManager.getPreinstallPayloadReadStatus();

if (PreinstallUtil.hasAllLocationsBeenRead(readStatus)) {
internalState.preinstallHasBeenRead = true;
return;
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES, readStatus)) {
String payloadSystemProperty = PreinstallUtil.getPayloadFromSystemProperty(
deviceInfo.packageName, logger);

if (payloadSystemProperty != null && !payloadSystemProperty.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemProperty, Constants.SYSTEM_PROPERTIES);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_REFLECTION, readStatus)) {
String payloadSystemPropertyReflection = PreinstallUtil.getPayloadFromSystemPropertyReflection(
deviceInfo.packageName, logger);

if (payloadSystemPropertyReflection != null && !payloadSystemPropertyReflection.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyReflection, Constants.SYSTEM_PROPERTIES_REFLECTION);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_REFLECTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_PATH, readStatus)) {
String payloadSystemPropertyFilePath = PreinstallUtil.getPayloadFromSystemPropertyFilePath(
deviceInfo.packageName, logger);

if (payloadSystemPropertyFilePath != null && !payloadSystemPropertyFilePath.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyFilePath, Constants.SYSTEM_PROPERTIES_PATH);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_PATH, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_PATH_REFLECTION, readStatus)) {
String payloadSystemPropertyFilePathReflection = PreinstallUtil.getPayloadFromSystemPropertyFilePathReflection(
deviceInfo.packageName, logger);

if (payloadSystemPropertyFilePathReflection != null && !payloadSystemPropertyFilePathReflection.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyFilePathReflection, Constants.SYSTEM_PROPERTIES_PATH_REFLECTION);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_PATH_REFLECTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER, readStatus)) {
String payloadContentProviderDefault = PreinstallUtil.getPayloadFromContentProviderDefault(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadContentProviderDefault != null && !payloadContentProviderDefault.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadContentProviderDefault, Constants.CONTENT_PROVIDER);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER_INTENT_ACTION, readStatus)) {
List<String> payloadListContentProviderIntentAction = PreinstallUtil.getPayloadsFromContentProviderIntentAction(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadListContentProviderIntentAction != null && !payloadListContentProviderIntentAction.isEmpty()) {
for (String payload : payloadListContentProviderIntentAction) {
sdkClickHandler.sendPreinstallPayload(payload, Constants.CONTENT_PROVIDER_INTENT_ACTION);
}
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER_INTENT_ACTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER_NO_PERMISSION, readStatus)) {
List<String> payloadListContentProviderIntentAction = PreinstallUtil.getPayloadsFromContentProviderNoPermission(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadListContentProviderIntentAction != null && !payloadListContentProviderIntentAction.isEmpty()) {
for (String payload : payloadListContentProviderIntentAction) {
sdkClickHandler.sendPreinstallPayload(payload, Constants.CONTENT_PROVIDER_NO_PERMISSION);
}
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER_NO_PERMISSION, readStatus);
}
}

//comment
<start>if (PreinstallUtil.hasNotBeenRead(Constants.FILE_SYSTEM, readStatus)) {
String payloadFileSystem = PreinstallUtil.getPayloadFromFileSystem(
deviceInfo.packageName,
adjustConfig.preinstallFilePath,
logger);

if (payloadFileSystem != null && !payloadFileSystem.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadFileSystem, Constants.FILE_SYSTEM);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.FILE_SYSTEM, readStatus);
}
}<end>

sharedPreferencesManager.setPreinstallPayloadReadStatus(readStatus);

internalState.preinstallHasBeenRead = true;
}"
4041,"<start>    private void startI() {<end>
//comment
if (internalState.hasFirstSdkStartNotOcurred()) {
AdjustSigner.onResume(adjustConfig.logger);
startFirstSessionI();
return;
}

//comment
if (!activityState.enabled) {
return;
}

AdjustSigner.onResume(adjustConfig.logger);

updateHandlersStatusAndSendI();

processSessionI();

checkAttributionStateI();

processCachedDeeplinkI();
}","    private void startI() {
//comment
<start>if (internalState.hasFirstSdkStartNotOcurred()) {<end>
AdjustSigner.onResume(adjustConfig.logger);
startFirstSessionI();
return;
}

//comment
if (!activityState.enabled) {
return;
}

AdjustSigner.onResume(adjustConfig.logger);

updateHandlersStatusAndSendI();

processSessionI();

checkAttributionStateI();

processCachedDeeplinkI();
}"
4043,"<start>private void startFirstSessionI() {<end>
activityState = new ActivityState();
internalState.firstSdkStart = true;

//comment
<start>updateHandlersStatusAndSendI();<end>

long now = System.currentTimeMillis();

SharedPreferencesManager sharedPreferencesManager = new SharedPreferencesManager(getContext());
activityState.pushToken = sharedPreferencesManager.getPushToken();
//comment

//comment
if (internalState.isEnabled()) {
if (sharedPreferencesManager.getGdprForgetMe()) {
gdprForgetMeI();
} else {
//comment
if (sharedPreferencesManager.getDisableThirdPartySharing()) {
disableThirdPartySharingI();
}
for (AdjustThirdPartySharing adjustThirdPartySharing :
adjustConfig.preLaunchActions.preLaunchAdjustThirdPartySharingArray)
{
trackThirdPartySharingI(adjustThirdPartySharing);
}
if (adjustConfig.preLaunchActions.lastMeasurementConsentTracked != null) {
trackMeasurementConsentI(
adjustConfig.preLaunchActions.
lastMeasurementConsentTracked.booleanValue());
}

adjustConfig.preLaunchActions.preLaunchAdjustThirdPartySharingArray =
new ArrayList<>();
adjustConfig.preLaunchActions.lastMeasurementConsentTracked = null;


activityState.sessionCount = 1;
transferSessionPackageI(now);
checkAfterNewStartI(sharedPreferencesManager);
}
}

activityState.resetSessionAttributes(now);
activityState.enabled = internalState.isEnabled();
activityState.updatePackages = internalState.itHasToUpdatePackages();

writeActivityStateI();
sharedPreferencesManager.removePushToken();
sharedPreferencesManager.removeGdprForgetMe();
sharedPreferencesManager.removeDisableThirdPartySharing();

//comment
processCachedDeeplinkI();

//comment
}","private void startFirstSessionI() {
activityState = new ActivityState();
internalState.firstSdkStart = true;

//comment
<start>updateHandlersStatusAndSendI();<end>

long now = System.currentTimeMillis();

SharedPreferencesManager sharedPreferencesManager = new SharedPreferencesManager(getContext());
activityState.pushToken = sharedPreferencesManager.getPushToken();
//comment

//comment
if (internalState.isEnabled()) {
if (sharedPreferencesManager.getGdprForgetMe()) {
gdprForgetMeI();
} else {
//comment
if (sharedPreferencesManager.getDisableThirdPartySharing()) {
disableThirdPartySharingI();
}
for (AdjustThirdPartySharing adjustThirdPartySharing :
adjustConfig.preLaunchActions.preLaunchAdjustThirdPartySharingArray)
{
trackThirdPartySharingI(adjustThirdPartySharing);
}
if (adjustConfig.preLaunchActions.lastMeasurementConsentTracked != null) {
trackMeasurementConsentI(
adjustConfig.preLaunchActions.
lastMeasurementConsentTracked.booleanValue());
}

adjustConfig.preLaunchActions.preLaunchAdjustThirdPartySharingArray =
new ArrayList<>();
adjustConfig.preLaunchActions.lastMeasurementConsentTracked = null;


activityState.sessionCount = 1;
transferSessionPackageI(now);
checkAfterNewStartI(sharedPreferencesManager);
}
}

activityState.resetSessionAttributes(now);
activityState.enabled = internalState.isEnabled();
activityState.updatePackages = internalState.itHasToUpdatePackages();

writeActivityStateI();
sharedPreferencesManager.removePushToken();
sharedPreferencesManager.removeGdprForgetMe();
sharedPreferencesManager.removeDisableThirdPartySharing();

//comment
processCachedDeeplinkI();

//comment
}"
4044,"private void startFirstSessionI() {
activityState = new ActivityState();
internalState.firstSdkStart = true;

//comment
updateHandlersStatusAndSendI();

long now = System.currentTimeMillis();

SharedPreferencesManager sharedPreferencesManager = new SharedPreferencesManager(getContext());
activityState.pushToken = sharedPreferencesManager.getPushToken();
//comment

//comment
if (internalState.isEnabled()) {
if (sharedPreferencesManager.getGdprForgetMe()) {
<start>gdprForgetMeI();<end>
} else {
//comment
if (sharedPreferencesManager.getDisableThirdPartySharing()) {
disableThirdPartySharingI();
}
for (AdjustThirdPartySharing adjustThirdPartySharing :
adjustConfig.preLaunchActions.preLaunchAdjustThirdPartySharingArray)
{
trackThirdPartySharingI(adjustThirdPartySharing);
}
if (adjustConfig.preLaunchActions.lastMeasurementConsentTracked != null) {
trackMeasurementConsentI(
adjustConfig.preLaunchActions.
lastMeasurementConsentTracked.booleanValue());
}

adjustConfig.preLaunchActions.preLaunchAdjustThirdPartySharingArray =
new ArrayList<>();
adjustConfig.preLaunchActions.lastMeasurementConsentTracked = null;


activityState.sessionCount = 1;
transferSessionPackageI(now);
checkAfterNewStartI(sharedPreferencesManager);
}
}

activityState.resetSessionAttributes(now);
activityState.enabled = internalState.isEnabled();
activityState.updatePackages = internalState.itHasToUpdatePackages();

writeActivityStateI();
sharedPreferencesManager.removePushToken();
sharedPreferencesManager.removeGdprForgetMe();
sharedPreferencesManager.removeDisableThirdPartySharing();

//comment
processCachedDeeplinkI();

//comment
}","private void startFirstSessionI() {
activityState = new ActivityState();
internalState.firstSdkStart = true;

//comment
updateHandlersStatusAndSendI();

long now = System.currentTimeMillis();

SharedPreferencesManager sharedPreferencesManager = new SharedPreferencesManager(getContext());
activityState.pushToken = sharedPreferencesManager.getPushToken();
//comment

//comment
<start>if (internalState.isEnabled()) {<end>
if (sharedPreferencesManager.getGdprForgetMe()) {
gdprForgetMeI();
} else {
//comment
if (sharedPreferencesManager.getDisableThirdPartySharing()) {
disableThirdPartySharingI();
}
for (AdjustThirdPartySharing adjustThirdPartySharing :
adjustConfig.preLaunchActions.preLaunchAdjustThirdPartySharingArray)
{
trackThirdPartySharingI(adjustThirdPartySharing);
}
if (adjustConfig.preLaunchActions.lastMeasurementConsentTracked != null) {
trackMeasurementConsentI(
adjustConfig.preLaunchActions.
lastMeasurementConsentTracked.booleanValue());
}

adjustConfig.preLaunchActions.preLaunchAdjustThirdPartySharingArray =
new ArrayList<>();
adjustConfig.preLaunchActions.lastMeasurementConsentTracked = null;


activityState.sessionCount = 1;
<start>transferSessionPackageI(now);<end>
checkAfterNewStartI(sharedPreferencesManager);
}
}

activityState.resetSessionAttributes(now);
activityState.enabled = internalState.isEnabled();
activityState.updatePackages = internalState.itHasToUpdatePackages();

writeActivityStateI();
sharedPreferencesManager.removePushToken();
sharedPreferencesManager.removeGdprForgetMe();
sharedPreferencesManager.removeDisableThirdPartySharing();

//comment
processCachedDeeplinkI();

//comment
}"
4045,"private void startFirstSessionI() {
activityState = new ActivityState();
internalState.firstSdkStart = true;

//comment
updateHandlersStatusAndSendI();

long now = System.currentTimeMillis();

SharedPreferencesManager sharedPreferencesManager = new SharedPreferencesManager(getContext());
activityState.pushToken = sharedPreferencesManager.getPushToken();
//comment

//comment
if (internalState.isEnabled()) {
if (sharedPreferencesManager.getGdprForgetMe()) {
gdprForgetMeI();
} else {
//comment
if (sharedPreferencesManager.getDisableThirdPartySharing()) {
<start>disableThirdPartySharingI();<end>
}
<start>for (AdjustThirdPartySharing adjustThirdPartySharing :
adjustConfig.preLaunchActions.preLaunchAdjustThirdPartySharingArray)
{
trackThirdPartySharingI(adjustThirdPartySharing);
}<end>
if (adjustConfig.preLaunchActions.lastMeasurementConsentTracked != null) {
trackMeasurementConsentI(
adjustConfig.preLaunchActions.
lastMeasurementConsentTracked.booleanValue());
}

adjustConfig.preLaunchActions.preLaunchAdjustThirdPartySharingArray =
new ArrayList<>();
adjustConfig.preLaunchActions.lastMeasurementConsentTracked = null;


activityState.sessionCount = 1;
transferSessionPackageI(now);
checkAfterNewStartI(sharedPreferencesManager);
}
}

activityState.resetSessionAttributes(now);
activityState.enabled = internalState.isEnabled();
activityState.updatePackages = internalState.itHasToUpdatePackages();

writeActivityStateI();
sharedPreferencesManager.removePushToken();
sharedPreferencesManager.removeGdprForgetMe();
sharedPreferencesManager.removeDisableThirdPartySharing();

//comment
processCachedDeeplinkI();

//comment
}","private void startFirstSessionI() {
activityState = new ActivityState();
internalState.firstSdkStart = true;

//comment
updateHandlersStatusAndSendI();

long now = System.currentTimeMillis();

SharedPreferencesManager sharedPreferencesManager = new SharedPreferencesManager(getContext());
activityState.pushToken = sharedPreferencesManager.getPushToken();
//comment

//comment
if (internalState.isEnabled()) {
if (sharedPreferencesManager.getGdprForgetMe()) {
gdprForgetMeI();
} else {
//comment
<start>if (sharedPreferencesManager.getDisableThirdPartySharing()) {
disableThirdPartySharingI();
}<end>
for (AdjustThirdPartySharing adjustThirdPartySharing :
adjustConfig.preLaunchActions.preLaunchAdjustThirdPartySharingArray)
{
trackThirdPartySharingI(adjustThirdPartySharing);
}
if (adjustConfig.preLaunchActions.lastMeasurementConsentTracked != null) {
trackMeasurementConsentI(
adjustConfig.preLaunchActions.
lastMeasurementConsentTracked.booleanValue());
}

adjustConfig.preLaunchActions.preLaunchAdjustThirdPartySharingArray =
new ArrayList<>();
adjustConfig.preLaunchActions.lastMeasurementConsentTracked = null;


activityState.sessionCount = 1;
transferSessionPackageI(now);
checkAfterNewStartI(sharedPreferencesManager);
}
}

activityState.resetSessionAttributes(now);
activityState.enabled = internalState.isEnabled();
activityState.updatePackages = internalState.itHasToUpdatePackages();

writeActivityStateI();
sharedPreferencesManager.removePushToken();
sharedPreferencesManager.removeGdprForgetMe();
sharedPreferencesManager.removeDisableThirdPartySharing();

//comment
processCachedDeeplinkI();

//comment
}"
4046,"private void startFirstSessionI() {
activityState = new ActivityState();
internalState.firstSdkStart = true;

//comment
updateHandlersStatusAndSendI();

long now = System.currentTimeMillis();

SharedPreferencesManager sharedPreferencesManager = new SharedPreferencesManager(getContext());
activityState.pushToken = sharedPreferencesManager.getPushToken();
//comment

//comment
if (internalState.isEnabled()) {
if (sharedPreferencesManager.getGdprForgetMe()) {
gdprForgetMeI();
} else {
//comment
if (sharedPreferencesManager.getDisableThirdPartySharing()) {
disableThirdPartySharingI();
}
for (AdjustThirdPartySharing adjustThirdPartySharing :
adjustConfig.preLaunchActions.preLaunchAdjustThirdPartySharingArray)
{
trackThirdPartySharingI(adjustThirdPartySharing);
}
if (adjustConfig.preLaunchActions.lastMeasurementConsentTracked != null) {
trackMeasurementConsentI(
adjustConfig.preLaunchActions.
lastMeasurementConsentTracked.booleanValue());
}

adjustConfig.preLaunchActions.preLaunchAdjustThirdPartySharingArray =
new ArrayList<>();
adjustConfig.preLaunchActions.lastMeasurementConsentTracked = null;


activityState.sessionCount = 1;
transferSessionPackageI(now);
checkAfterNewStartI(sharedPreferencesManager);
}
}

activityState.resetSessionAttributes(now);
activityState.enabled = internalState.isEnabled();
activityState.updatePackages = internalState.itHasToUpdatePackages();

writeActivityStateI();
sharedPreferencesManager.removePushToken();
sharedPreferencesManager.removeGdprForgetMe();
sharedPreferencesManager.removeDisableThirdPartySharing();

//comment
<start>processCachedDeeplinkI();<end>

//comment
}","private void startFirstSessionI() {
activityState = new ActivityState();
internalState.firstSdkStart = true;

//comment
updateHandlersStatusAndSendI();

long now = System.currentTimeMillis();

SharedPreferencesManager sharedPreferencesManager = new SharedPreferencesManager(getContext());
activityState.pushToken = sharedPreferencesManager.getPushToken();
//comment

//comment
if (internalState.isEnabled()) {
if (sharedPreferencesManager.getGdprForgetMe()) {
gdprForgetMeI();
} else {
//comment
if (sharedPreferencesManager.getDisableThirdPartySharing()) {
disableThirdPartySharingI();
}
for (AdjustThirdPartySharing adjustThirdPartySharing :
adjustConfig.preLaunchActions.preLaunchAdjustThirdPartySharingArray)
{
trackThirdPartySharingI(adjustThirdPartySharing);
}
if (adjustConfig.preLaunchActions.lastMeasurementConsentTracked != null) {
trackMeasurementConsentI(
adjustConfig.preLaunchActions.
lastMeasurementConsentTracked.booleanValue());
}

adjustConfig.preLaunchActions.preLaunchAdjustThirdPartySharingArray =
new ArrayList<>();
adjustConfig.preLaunchActions.lastMeasurementConsentTracked = null;


activityState.sessionCount = 1;
transferSessionPackageI(now);
checkAfterNewStartI(sharedPreferencesManager);
}
}

activityState.resetSessionAttributes(now);
activityState.enabled = internalState.isEnabled();
activityState.updatePackages = internalState.itHasToUpdatePackages();

writeActivityStateI();
sharedPreferencesManager.removePushToken();
sharedPreferencesManager.removeGdprForgetMe();
sharedPreferencesManager.removeDisableThirdPartySharing();

//comment
<start>processCachedDeeplinkI();<end>

//comment
}"
4048,"private void processSessionI() {
if (activityState.isGdprForgotten) {
return;
}

long now = System.currentTimeMillis();

long lastInterval = now - activityState.lastActivity;

if (lastInterval < 0) {
logger.error(TIME_TRAVEL);
activityState.lastActivity = now;
writeActivityStateI();
return;
}

//comment
if (lastInterval > SESSION_INTERVAL) {
trackNewSessionI(now);
checkAfterNewStartI();
return;
}

//comment
if (lastInterval > SUBSESSION_INTERVAL) {
activityState.subsessionCount++;
activityState.sessionLength += lastInterval;
activityState.lastActivity = now;
logger.verbose(""Started subsession %d of session %d"",
activityState.subsessionCount,
activityState.sessionCount);
writeActivityStateI();

checkForPreinstallI();

//comment
<start>installReferrer.startConnection();<end>
installReferrerHuawei.readReferrer();

return;
}

logger.verbose(""Time span since last activity too short for a new subsession"");
}","private void processSessionI() {
if (activityState.isGdprForgotten) {
return;
}

long now = System.currentTimeMillis();

long lastInterval = now - activityState.lastActivity;

if (lastInterval < 0) {
logger.error(TIME_TRAVEL);
activityState.lastActivity = now;
writeActivityStateI();
return;
}

//comment
if (lastInterval > SESSION_INTERVAL) {
trackNewSessionI(now);
checkAfterNewStartI();
return;
}

//comment
if (lastInterval > SUBSESSION_INTERVAL) {
activityState.subsessionCount++;
activityState.sessionLength += lastInterval;
activityState.lastActivity = now;
logger.verbose(""Started subsession %d of session %d"",
activityState.subsessionCount,
activityState.sessionCount);
writeActivityStateI();

checkForPreinstallI();

//comment
<start>installReferrer.startConnection();
installReferrerHuawei.readReferrer();<end>

return;
}

logger.verbose(""Time span since last activity too short for a new subsession"");
}"
4049,"    private void checkAttributionStateI() {
if (!checkActivityStateI(activityState)) { return; }

//comment
if (internalState.isFirstLaunch()) {
//comment
if (internalState.hasSessionResponseNotBeenProcessed()) {
return;
}
}

//comment
if (attribution != null && !activityState.askingAttribution) {
return;
}

attributionHandler.getAttribution();
}","    private void checkAttributionStateI() {
if (!checkActivityStateI(activityState)) { return; }

//comment
<start>if (internalState.isFirstLaunch()) {<end>
//comment
if (internalState.hasSessionResponseNotBeenProcessed()) {
return;
}
}

//comment
if (attribution != null && !activityState.askingAttribution) {
return;
}

attributionHandler.getAttribution();
}"
4050,"    private void checkAttributionStateI() {
if (!checkActivityStateI(activityState)) { return; }

//comment
<start>if (internalState.isFirstLaunch()) {
//comment
if (internalState.hasSessionResponseNotBeenProcessed()) {
return;
}
}<end>

//comment
if (attribution != null && !activityState.askingAttribution) {
return;
}

attributionHandler.getAttribution();
}","    private void checkAttributionStateI() {
if (!checkActivityStateI(activityState)) { return; }

//comment
<start>if (internalState.isFirstLaunch()) {
//comment
if (internalState.hasSessionResponseNotBeenProcessed()) {
return;
}
}<end>

//comment
if (attribution != null && !activityState.askingAttribution) {
return;
}

attributionHandler.getAttribution();
}"
4051,"    private void checkAttributionStateI() {
if (!checkActivityStateI(activityState)) { return; }

//comment
if (internalState.isFirstLaunch()) {
//comment
if (internalState.hasSessionResponseNotBeenProcessed()) {
return;
}
}

//comment
<start>if (attribution != null && !activityState.askingAttribution) {
return;
}<end>

attributionHandler.getAttribution();
}","    private void checkAttributionStateI() {
if (!checkActivityStateI(activityState)) { return; }

//comment
if (internalState.isFirstLaunch()) {
//comment
if (internalState.hasSessionResponseNotBeenProcessed()) {
return;
}
}

//comment
<start>if (attribution != null && !activityState.askingAttribution) {
return;
}<end>

attributionHandler.getAttribution();
}"
4052,"    private void endI() {
//comment
<start>if (!toSendI()) {
pauseSendingI();
}<end>

if (updateActivityStateI(System.currentTimeMillis())) {
writeActivityStateI();
}
}","    private void endI() {
//comment
<start>if (!toSendI()) {
pauseSendingI();
}<end>

if (updateActivityStateI(System.currentTimeMillis())) {
writeActivityStateI();
}
}"
4057,"private Map<String, String> getInfoParameters(String source) {
ContentResolver contentResolver = adjustConfig.context.getContentResolver();
Map<String, String> parameters = new HashMap<String, String>();
Map<String, String> imeiParameters = Reflection.getImeiParameters(adjustConfig.context, logger);

//comment
<start>if (imeiParameters != null) {
parameters.putAll(imeiParameters);
}<end>

//comment
Map<String, String> oaidParameters = Reflection.getOaidParameters(adjustConfig.context, logger);
if (oaidParameters != null) {
parameters.putAll(oaidParameters);
}

//comment
deviceInfo.reloadPlayIds(adjustConfig.context);
PackageBuilder.addString(parameters, ""android_uuid"", activityStateCopy.uuid);
PackageBuilder.addString(parameters, ""gps_adid"", deviceInfo.playAdId);
PackageBuilder.addLong(parameters, ""gps_adid_attempt"", deviceInfo.playAdIdAttempt);
PackageBuilder.addString(parameters, ""gps_adid_src"", deviceInfo.playAdIdSource);
PackageBuilder.addBoolean(parameters, ""tracking_enabled"", deviceInfo.isTrackingEnabled);
PackageBuilder.addString(parameters, ""fire_adid"", Util.getFireAdvertisingId(contentResolver));
PackageBuilder.addBoolean(parameters, ""fire_tracking_enabled"", Util.getFireTrackingEnabled(contentResolver));

if (!containsPlayIds(parameters) && !containsFireIds(parameters)) {
logger.warn(""Google Advertising ID or Fire Advertising ID not detected, "" +
""fallback to non Google Play and Fire identifiers will take place"");
deviceInfo.reloadNonPlayIds(adjustConfig.context);
PackageBuilder.addString(parameters, ""android_id"", deviceInfo.androidId);
PackageBuilder.addString(parameters, ""mac_md5"", deviceInfo.macShortMd5);
PackageBuilder.addString(parameters, ""mac_sha1"", deviceInfo.macSha1);
}

//comment
PackageBuilder.addString(parameters, ""app_secret"", adjustConfig.appSecret);
PackageBuilder.addString(parameters, ""app_token"", adjustConfig.appToken);
PackageBuilder.addBoolean(parameters, ""attribution_deeplink"", true);
PackageBuilder.addDateInMilliseconds(parameters, ""created_at"", createdAt);
PackageBuilder.addBoolean(parameters, ""device_known"", adjustConfig.deviceKnown);
PackageBuilder.addBoolean(parameters, ""needs_cost"", adjustConfig.needsCost);
PackageBuilder.addString(parameters, ""environment"", adjustConfig.environment);
PackageBuilder.addBoolean(parameters, ""event_buffering_enabled"", adjustConfig.eventBufferingEnabled);
PackageBuilder.addString(parameters, ""external_device_id"", adjustConfig.externalDeviceId);
PackageBuilder.addBoolean(parameters, ""needs_response_details"", true);
PackageBuilder.addString(parameters, ""push_token"", activityStateCopy.pushToken);
PackageBuilder.addString(parameters, ""secret_id"", adjustConfig.secretId);
PackageBuilder.addString(parameters, ""source"", source);

checkDeviceIds(parameters);
return parameters;
}","private Map<String, String> getInfoParameters(String source) {
ContentResolver contentResolver = adjustConfig.context.getContentResolver();
Map<String, String> parameters = new HashMap<String, String>();
Map<String, String> imeiParameters = Reflection.getImeiParameters(adjustConfig.context, logger);

//comment
<start>if (imeiParameters != null) {
parameters.putAll(imeiParameters);
}<end>

//comment
Map<String, String> oaidParameters = Reflection.getOaidParameters(adjustConfig.context, logger);
if (oaidParameters != null) {
parameters.putAll(oaidParameters);
}

//comment
deviceInfo.reloadPlayIds(adjustConfig.context);
PackageBuilder.addString(parameters, ""android_uuid"", activityStateCopy.uuid);
PackageBuilder.addString(parameters, ""gps_adid"", deviceInfo.playAdId);
PackageBuilder.addLong(parameters, ""gps_adid_attempt"", deviceInfo.playAdIdAttempt);
PackageBuilder.addString(parameters, ""gps_adid_src"", deviceInfo.playAdIdSource);
PackageBuilder.addBoolean(parameters, ""tracking_enabled"", deviceInfo.isTrackingEnabled);
PackageBuilder.addString(parameters, ""fire_adid"", Util.getFireAdvertisingId(contentResolver));
PackageBuilder.addBoolean(parameters, ""fire_tracking_enabled"", Util.getFireTrackingEnabled(contentResolver));

if (!containsPlayIds(parameters) && !containsFireIds(parameters)) {
logger.warn(""Google Advertising ID or Fire Advertising ID not detected, "" +
""fallback to non Google Play and Fire identifiers will take place"");
deviceInfo.reloadNonPlayIds(adjustConfig.context);
PackageBuilder.addString(parameters, ""android_id"", deviceInfo.androidId);
PackageBuilder.addString(parameters, ""mac_md5"", deviceInfo.macShortMd5);
PackageBuilder.addString(parameters, ""mac_sha1"", deviceInfo.macSha1);
}

//comment
PackageBuilder.addString(parameters, ""app_secret"", adjustConfig.appSecret);
PackageBuilder.addString(parameters, ""app_token"", adjustConfig.appToken);
PackageBuilder.addBoolean(parameters, ""attribution_deeplink"", true);
PackageBuilder.addDateInMilliseconds(parameters, ""created_at"", createdAt);
PackageBuilder.addBoolean(parameters, ""device_known"", adjustConfig.deviceKnown);
PackageBuilder.addBoolean(parameters, ""needs_cost"", adjustConfig.needsCost);
PackageBuilder.addString(parameters, ""environment"", adjustConfig.environment);
PackageBuilder.addBoolean(parameters, ""event_buffering_enabled"", adjustConfig.eventBufferingEnabled);
PackageBuilder.addString(parameters, ""external_device_id"", adjustConfig.externalDeviceId);
PackageBuilder.addBoolean(parameters, ""needs_response_details"", true);
PackageBuilder.addString(parameters, ""push_token"", activityStateCopy.pushToken);
PackageBuilder.addString(parameters, ""secret_id"", adjustConfig.secretId);
PackageBuilder.addString(parameters, ""source"", source);

checkDeviceIds(parameters);
return parameters;
}"
4058,"private Map<String, String> getInfoParameters(String source) {
ContentResolver contentResolver = adjustConfig.context.getContentResolver();
Map<String, String> parameters = new HashMap<String, String>();
Map<String, String> imeiParameters = Reflection.getImeiParameters(adjustConfig.context, logger);

//comment
if (imeiParameters != null) {
parameters.putAll(imeiParameters);
}

//comment
<start>Map<String, String> oaidParameters = Reflection.getOaidParameters(adjustConfig.context, logger);
if (oaidParameters != null) {
parameters.putAll(oaidParameters);
}<end>

//comment
deviceInfo.reloadPlayIds(adjustConfig.context);
PackageBuilder.addString(parameters, ""android_uuid"", activityStateCopy.uuid);
PackageBuilder.addString(parameters, ""gps_adid"", deviceInfo.playAdId);
PackageBuilder.addLong(parameters, ""gps_adid_attempt"", deviceInfo.playAdIdAttempt);
PackageBuilder.addString(parameters, ""gps_adid_src"", deviceInfo.playAdIdSource);
PackageBuilder.addBoolean(parameters, ""tracking_enabled"", deviceInfo.isTrackingEnabled);
PackageBuilder.addString(parameters, ""fire_adid"", Util.getFireAdvertisingId(contentResolver));
PackageBuilder.addBoolean(parameters, ""fire_tracking_enabled"", Util.getFireTrackingEnabled(contentResolver));

if (!containsPlayIds(parameters) && !containsFireIds(parameters)) {
logger.warn(""Google Advertising ID or Fire Advertising ID not detected, "" +
""fallback to non Google Play and Fire identifiers will take place"");
deviceInfo.reloadNonPlayIds(adjustConfig.context);
PackageBuilder.addString(parameters, ""android_id"", deviceInfo.androidId);
PackageBuilder.addString(parameters, ""mac_md5"", deviceInfo.macShortMd5);
PackageBuilder.addString(parameters, ""mac_sha1"", deviceInfo.macSha1);
}

//comment
PackageBuilder.addString(parameters, ""app_secret"", adjustConfig.appSecret);
PackageBuilder.addString(parameters, ""app_token"", adjustConfig.appToken);
PackageBuilder.addBoolean(parameters, ""attribution_deeplink"", true);
PackageBuilder.addDateInMilliseconds(parameters, ""created_at"", createdAt);
PackageBuilder.addBoolean(parameters, ""device_known"", adjustConfig.deviceKnown);
PackageBuilder.addBoolean(parameters, ""needs_cost"", adjustConfig.needsCost);
PackageBuilder.addString(parameters, ""environment"", adjustConfig.environment);
PackageBuilder.addBoolean(parameters, ""event_buffering_enabled"", adjustConfig.eventBufferingEnabled);
PackageBuilder.addString(parameters, ""external_device_id"", adjustConfig.externalDeviceId);
PackageBuilder.addBoolean(parameters, ""needs_response_details"", true);
PackageBuilder.addString(parameters, ""push_token"", activityStateCopy.pushToken);
PackageBuilder.addString(parameters, ""secret_id"", adjustConfig.secretId);
PackageBuilder.addString(parameters, ""source"", source);

checkDeviceIds(parameters);
return parameters;
}","private Map<String, String> getInfoParameters(String source) {
ContentResolver contentResolver = adjustConfig.context.getContentResolver();
Map<String, String> parameters = new HashMap<String, String>();
Map<String, String> imeiParameters = Reflection.getImeiParameters(adjustConfig.context, logger);

//comment
if (imeiParameters != null) {
parameters.putAll(imeiParameters);
}

//comment
<start>Map<String, String> oaidParameters = Reflection.getOaidParameters(adjustConfig.context, logger);
if (oaidParameters != null) {
parameters.putAll(oaidParameters);
}<end>

//comment
deviceInfo.reloadPlayIds(adjustConfig.context);
PackageBuilder.addString(parameters, ""android_uuid"", activityStateCopy.uuid);
PackageBuilder.addString(parameters, ""gps_adid"", deviceInfo.playAdId);
PackageBuilder.addLong(parameters, ""gps_adid_attempt"", deviceInfo.playAdIdAttempt);
PackageBuilder.addString(parameters, ""gps_adid_src"", deviceInfo.playAdIdSource);
PackageBuilder.addBoolean(parameters, ""tracking_enabled"", deviceInfo.isTrackingEnabled);
PackageBuilder.addString(parameters, ""fire_adid"", Util.getFireAdvertisingId(contentResolver));
PackageBuilder.addBoolean(parameters, ""fire_tracking_enabled"", Util.getFireTrackingEnabled(contentResolver));

if (!containsPlayIds(parameters) && !containsFireIds(parameters)) {
logger.warn(""Google Advertising ID or Fire Advertising ID not detected, "" +
""fallback to non Google Play and Fire identifiers will take place"");
deviceInfo.reloadNonPlayIds(adjustConfig.context);
PackageBuilder.addString(parameters, ""android_id"", deviceInfo.androidId);
PackageBuilder.addString(parameters, ""mac_md5"", deviceInfo.macShortMd5);
PackageBuilder.addString(parameters, ""mac_sha1"", deviceInfo.macSha1);
}

//comment
PackageBuilder.addString(parameters, ""app_secret"", adjustConfig.appSecret);
PackageBuilder.addString(parameters, ""app_token"", adjustConfig.appToken);
PackageBuilder.addBoolean(parameters, ""attribution_deeplink"", true);
PackageBuilder.addDateInMilliseconds(parameters, ""created_at"", createdAt);
PackageBuilder.addBoolean(parameters, ""device_known"", adjustConfig.deviceKnown);
PackageBuilder.addBoolean(parameters, ""needs_cost"", adjustConfig.needsCost);
PackageBuilder.addString(parameters, ""environment"", adjustConfig.environment);
PackageBuilder.addBoolean(parameters, ""event_buffering_enabled"", adjustConfig.eventBufferingEnabled);
PackageBuilder.addString(parameters, ""external_device_id"", adjustConfig.externalDeviceId);
PackageBuilder.addBoolean(parameters, ""needs_response_details"", true);
PackageBuilder.addString(parameters, ""push_token"", activityStateCopy.pushToken);
PackageBuilder.addString(parameters, ""secret_id"", adjustConfig.secretId);
PackageBuilder.addString(parameters, ""source"", source);

checkDeviceIds(parameters);
return parameters;
}"
152,"    private static PackageBuilder queryStringClickPackageBuilder(
final List<UrlQuerySanitizer.ParameterValuePair> queryList,
final ActivityState activityState,
final AdjustConfig adjustConfig,
final DeviceInfo deviceInfo,
final SessionParameters sessionParameters) {
if (queryList == null) {
return null;
}

Map<String, String> queryStringParameters = new LinkedHashMap<String, String>();
AdjustAttribution queryStringAttribution = new AdjustAttribution();

for (UrlQuerySanitizer.ParameterValuePair parameterValuePair : queryList) {
readQueryString(
parameterValuePair.mParameter,
parameterValuePair.mValue,
queryStringParameters,
queryStringAttribution);
}

long now = System.currentTimeMillis();
String reftag = queryStringParameters.remove(Constants.REFTAG);

//comment
//comment
<start>if (activityState != null) {
long lastInterval = now - activityState.lastActivity;
activityState.lastInterval = lastInterval;
}<end>

PackageBuilder builder = new PackageBuilder(
adjustConfig,
deviceInfo,
activityState,
sessionParameters,
now);

builder.extraParameters = queryStringParameters;
builder.attribution = queryStringAttribution;
builder.reftag = reftag;

return builder;
}","    private static PackageBuilder queryStringClickPackageBuilder(
final List<UrlQuerySanitizer.ParameterValuePair> queryList,
final ActivityState activityState,
final AdjustConfig adjustConfig,
final DeviceInfo deviceInfo,
final SessionParameters sessionParameters) {
if (queryList == null) {
return null;
}

Map<String, String> queryStringParameters = new LinkedHashMap<String, String>();
AdjustAttribution queryStringAttribution = new AdjustAttribution();

for (UrlQuerySanitizer.ParameterValuePair parameterValuePair : queryList) {
readQueryString(
parameterValuePair.mParameter,
parameterValuePair.mValue,
queryStringParameters,
queryStringAttribution);
}

long now = System.currentTimeMillis();
String reftag = queryStringParameters.remove(Constants.REFTAG);

//comment
//comment
<start>if (activityState != null) {<end>
long lastInterval = now - activityState.lastActivity;
activityState.lastInterval = lastInterval;
}

PackageBuilder builder = new PackageBuilder(
adjustConfig,
deviceInfo,
activityState,
sessionParameters,
now);

builder.extraParameters = queryStringParameters;
builder.attribution = queryStringAttribution;
builder.reftag = reftag;

return builder;
}"
915,"    private static PackageBuilder queryStringClickPackageBuilder(
final List<UrlQuerySanitizer.ParameterValuePair> queryList,
final ActivityState activityState,
final AdjustConfig adjustConfig,
final DeviceInfo deviceInfo,
final SessionParameters sessionParameters) {
if (queryList == null) {
return null;
}

Map<String, String> queryStringParameters = new LinkedHashMap<String, String>();
AdjustAttribution queryStringAttribution = new AdjustAttribution();

for (UrlQuerySanitizer.ParameterValuePair parameterValuePair : queryList) {
readQueryString(
parameterValuePair.mParameter,
parameterValuePair.mValue,
queryStringParameters,
queryStringAttribution);
}

long now = System.currentTimeMillis();
String reftag = queryStringParameters.remove(Constants.REFTAG);

//comment
//comment
<start>if (activityState != null) {
long lastInterval = now - activityState.lastActivity;
activityState.lastInterval = lastInterval;
}<end>

PackageBuilder builder = new PackageBuilder(
adjustConfig,
deviceInfo,
activityState,
sessionParameters,
now);

builder.extraParameters = queryStringParameters;
builder.attribution = queryStringAttribution;
builder.reftag = reftag;

return builder;
}","    private static PackageBuilder queryStringClickPackageBuilder(
final List<UrlQuerySanitizer.ParameterValuePair> queryList,
final ActivityState activityState,
final AdjustConfig adjustConfig,
final DeviceInfo deviceInfo,
final SessionParameters sessionParameters) {
if (queryList == null) {
return null;
}

Map<String, String> queryStringParameters = new LinkedHashMap<String, String>();
AdjustAttribution queryStringAttribution = new AdjustAttribution();

for (UrlQuerySanitizer.ParameterValuePair parameterValuePair : queryList) {
readQueryString(
parameterValuePair.mParameter,
parameterValuePair.mValue,
queryStringParameters,
queryStringAttribution);
}

long now = System.currentTimeMillis();
String reftag = queryStringParameters.remove(Constants.REFTAG);

//comment
//comment
<start>if (activityState != null) {
long lastInterval = now - activityState.lastActivity;
activityState.lastInterval = lastInterval;
}<end>

PackageBuilder builder = new PackageBuilder(
adjustConfig,
deviceInfo,
activityState,
sessionParameters,
now);

builder.extraParameters = queryStringParameters;
builder.attribution = queryStringAttribution;
builder.reftag = reftag;

return builder;
}"
1787,"<start>public static boolean hasAllLocationsBeenRead(long status) {
//comment
//comment
return (status & ALL_LOCATION_BITMASK) == ALL_LOCATION_BITMASK;<end>
}","public static boolean hasAllLocationsBeenRead(long status) {
//comment
//comment
<start>return (status & ALL_LOCATION_BITMASK) == ALL_LOCATION_BITMASK;<end>
}"
1788,"<start>public static boolean hasNotBeenRead(String location, long status) {<end>
//comment
switch(location) {
case Constants.SYSTEM_PROPERTIES :
return (status & SYSTEM_PROPERTY_BITMASK) != SYSTEM_PROPERTY_BITMASK;
case Constants.SYSTEM_PROPERTIES_REFLECTION :
return (status & SYSTEM_PROPERTY_REFLECTION_BITMASK) != SYSTEM_PROPERTY_REFLECTION_BITMASK;
case Constants.SYSTEM_PROPERTIES_PATH :
return (status & SYSTEM_PROPERTY_PATH_BITMASK) != SYSTEM_PROPERTY_PATH_BITMASK;
case Constants.SYSTEM_PROPERTIES_PATH_REFLECTION :
return (status & SYSTEM_PROPERTY_PATH_REFLECTION_BITMASK) != SYSTEM_PROPERTY_PATH_REFLECTION_BITMASK;
case Constants.CONTENT_PROVIDER :
return (status & CONTENT_PROVIDER_BITMASK) != CONTENT_PROVIDER_BITMASK;
case Constants.CONTENT_PROVIDER_INTENT_ACTION :
return (status & CONTENT_PROVIDER_INTENT_ACTION_BITMASK) != CONTENT_PROVIDER_INTENT_ACTION_BITMASK;
case Constants.FILE_SYSTEM :
return (status & FILE_SYSTEM_BITMASK) != FILE_SYSTEM_BITMASK;
case Constants.CONTENT_PROVIDER_NO_PERMISSION:
return (status & CONTENT_PROVIDER_NO_PERMISSION_BITMASK) != CONTENT_PROVIDER_NO_PERMISSION_BITMASK;
}
return false;
}","public static boolean hasNotBeenRead(String location, long status) {
//comment
<start>switch(location) {
case Constants.SYSTEM_PROPERTIES :
return (status & SYSTEM_PROPERTY_BITMASK) != SYSTEM_PROPERTY_BITMASK;
case Constants.SYSTEM_PROPERTIES_REFLECTION :
return (status & SYSTEM_PROPERTY_REFLECTION_BITMASK) != SYSTEM_PROPERTY_REFLECTION_BITMASK;
case Constants.SYSTEM_PROPERTIES_PATH :
return (status & SYSTEM_PROPERTY_PATH_BITMASK) != SYSTEM_PROPERTY_PATH_BITMASK;
case Constants.SYSTEM_PROPERTIES_PATH_REFLECTION :
return (status & SYSTEM_PROPERTY_PATH_REFLECTION_BITMASK) != SYSTEM_PROPERTY_PATH_REFLECTION_BITMASK;
case Constants.CONTENT_PROVIDER :
return (status & CONTENT_PROVIDER_BITMASK) != CONTENT_PROVIDER_BITMASK;
case Constants.CONTENT_PROVIDER_INTENT_ACTION :
return (status & CONTENT_PROVIDER_INTENT_ACTION_BITMASK) != CONTENT_PROVIDER_INTENT_ACTION_BITMASK;
case Constants.FILE_SYSTEM :
return (status & FILE_SYSTEM_BITMASK) != FILE_SYSTEM_BITMASK;
case Constants.CONTENT_PROVIDER_NO_PERMISSION:
return (status & CONTENT_PROVIDER_NO_PERMISSION_BITMASK) != CONTENT_PROVIDER_NO_PERMISSION_BITMASK;
}<end>
return false;
}"
1789,"public static long markAsRead(String location, long status) {
//comment
switch(location) {
case Constants.SYSTEM_PROPERTIES :
return (status | SYSTEM_PROPERTY_BITMASK);
<start>case Constants.SYSTEM_PROPERTIES_REFLECTION :
return (status | SYSTEM_PROPERTY_REFLECTION_BITMASK);<end>
case Constants.SYSTEM_PROPERTIES_PATH :
return (status | SYSTEM_PROPERTY_PATH_BITMASK);
case Constants.SYSTEM_PROPERTIES_PATH_REFLECTION :
return (status | SYSTEM_PROPERTY_PATH_REFLECTION_BITMASK);
case Constants.CONTENT_PROVIDER :
return (status | CONTENT_PROVIDER_BITMASK);
case Constants.CONTENT_PROVIDER_INTENT_ACTION :
return (status | CONTENT_PROVIDER_INTENT_ACTION_BITMASK);
case Constants.FILE_SYSTEM :
return (status | FILE_SYSTEM_BITMASK);
case Constants.CONTENT_PROVIDER_NO_PERMISSION:
return (status | CONTENT_PROVIDER_NO_PERMISSION_BITMASK);
}
return status;
}","public static long markAsRead(String location, long status) {
//comment
<start>switch(location) {
case Constants.SYSTEM_PROPERTIES :
return (status | SYSTEM_PROPERTY_BITMASK);
case Constants.SYSTEM_PROPERTIES_REFLECTION :
return (status | SYSTEM_PROPERTY_REFLECTION_BITMASK);
case Constants.SYSTEM_PROPERTIES_PATH :
return (status | SYSTEM_PROPERTY_PATH_BITMASK);
case Constants.SYSTEM_PROPERTIES_PATH_REFLECTION :
return (status | SYSTEM_PROPERTY_PATH_REFLECTION_BITMASK);
case Constants.CONTENT_PROVIDER :
return (status | CONTENT_PROVIDER_BITMASK);
case Constants.CONTENT_PROVIDER_INTENT_ACTION :
return (status | CONTENT_PROVIDER_INTENT_ACTION_BITMASK);
case Constants.FILE_SYSTEM :
return (status | FILE_SYSTEM_BITMASK);
case Constants.CONTENT_PROVIDER_NO_PERMISSION:
return (status | CONTENT_PROVIDER_NO_PERMISSION_BITMASK);
}<end>
return status;
}"
1430,"    @Override
public void onWindowShown() {
super.onWindowShown();

//comment
<start>Adjust.onResume();<end>
}","    @Override
public void onWindowShown() {
super.onWindowShown();

//comment
<start>Adjust.onResume();<end>
}"
1431,"    @Override
public void onWindowHidden() {
super.onWindowHidden();

//comment
<start>Adjust.onPause();<end>
}","    @Override
public void onWindowHidden() {
super.onWindowHidden();

//comment
<start>Adjust.onPause();<end>
}"
1432,"public void onTrackSimpleEventClick() {
AdjustEvent event = new AdjustEvent(""g3mfiw"");

//comment
<start>event.setCallbackId(""PrettyRandomIdentifier"");<end>

Adjust.trackEvent(event);
}","public void onTrackSimpleEventClick() {
<start>AdjustEvent event = new AdjustEvent(""g3mfiw"");<end>

//comment
<start>event.setCallbackId(""PrettyRandomIdentifier"");<end>

<start>Adjust.trackEvent(event);<end>
}"
4072,"private void checkForPreinstallI() {
if (activityState == null) return;
if (!activityState.enabled) return;
if (activityState.isGdprForgotten) return;

//comment
<start>sendPreinstallReferrerI();<end>

if (!adjustConfig.preinstallTrackingEnabled) return;
if (internalState.hasPreinstallBeenRead()) return;

if (deviceInfo.packageName == null || deviceInfo.packageName.isEmpty()) {
logger.debug(""Can't read preinstall payload, invalid package name"");
return;
}

SharedPreferencesManager sharedPreferencesManager = new SharedPreferencesManager(getContext());
long readStatus = sharedPreferencesManager.getPreinstallPayloadReadStatus();

if (PreinstallUtil.hasAllLocationsBeenRead(readStatus)) {
internalState.preinstallHasBeenRead = true;
return;
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES, readStatus)) {
String payloadSystemProperty = PreinstallUtil.getPayloadFromSystemProperty(
deviceInfo.packageName, logger);

if (payloadSystemProperty != null && !payloadSystemProperty.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemProperty, Constants.SYSTEM_PROPERTIES);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_REFLECTION, readStatus)) {
String payloadSystemPropertyReflection = PreinstallUtil.getPayloadFromSystemPropertyReflection(
deviceInfo.packageName, logger);

if (payloadSystemPropertyReflection != null && !payloadSystemPropertyReflection.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyReflection, Constants.SYSTEM_PROPERTIES_REFLECTION);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_REFLECTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_PATH, readStatus)) {
String payloadSystemPropertyFilePath = PreinstallUtil.getPayloadFromSystemPropertyFilePath(
deviceInfo.packageName, logger);

if (payloadSystemPropertyFilePath != null && !payloadSystemPropertyFilePath.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyFilePath, Constants.SYSTEM_PROPERTIES_PATH);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_PATH, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_PATH_REFLECTION, readStatus)) {
String payloadSystemPropertyFilePathReflection = PreinstallUtil.getPayloadFromSystemPropertyFilePathReflection(
deviceInfo.packageName, logger);

if (payloadSystemPropertyFilePathReflection != null && !payloadSystemPropertyFilePathReflection.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyFilePathReflection, Constants.SYSTEM_PROPERTIES_PATH_REFLECTION);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_PATH_REFLECTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER, readStatus)) {
String payloadContentProviderDefault = PreinstallUtil.getPayloadFromContentProviderDefault(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadContentProviderDefault != null && !payloadContentProviderDefault.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadContentProviderDefault, Constants.CONTENT_PROVIDER);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER_INTENT_ACTION, readStatus)) {
List<String> payloadListContentProviderIntentAction = PreinstallUtil.getPayloadsFromContentProviderIntentAction(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadListContentProviderIntentAction != null && !payloadListContentProviderIntentAction.isEmpty()) {
for (String payload : payloadListContentProviderIntentAction) {
sdkClickHandler.sendPreinstallPayload(payload, Constants.CONTENT_PROVIDER_INTENT_ACTION);
}
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER_INTENT_ACTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER_NO_PERMISSION, readStatus)) {
List<String> payloadListContentProviderIntentAction = PreinstallUtil.getPayloadsFromContentProviderNoPermission(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadListContentProviderIntentAction != null && !payloadListContentProviderIntentAction.isEmpty()) {
for (String payload : payloadListContentProviderIntentAction) {
sdkClickHandler.sendPreinstallPayload(payload, Constants.CONTENT_PROVIDER_NO_PERMISSION);
}
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER_NO_PERMISSION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.FILE_SYSTEM, readStatus)) {
String payloadFileSystem = PreinstallUtil.getPayloadFromFileSystem(
deviceInfo.packageName,
adjustConfig.preinstallFilePath,
logger);

if (payloadFileSystem != null && !payloadFileSystem.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadFileSystem, Constants.FILE_SYSTEM);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.FILE_SYSTEM, readStatus);
}
}

sharedPreferencesManager.setPreinstallPayloadReadStatus(readStatus);

internalState.preinstallHasBeenRead = true;
}","private void checkForPreinstallI() {
if (activityState == null) return;
if (!activityState.enabled) return;
if (activityState.isGdprForgotten) return;

//comment
<start>sendPreinstallReferrerI();<end>

<start>if (!adjustConfig.preinstallTrackingEnabled) return;<end>
if (internalState.hasPreinstallBeenRead()) return;

if (deviceInfo.packageName == null || deviceInfo.packageName.isEmpty()) {
logger.debug(""Can't read preinstall payload, invalid package name"");
return;
}

SharedPreferencesManager sharedPreferencesManager = new SharedPreferencesManager(getContext());
long readStatus = sharedPreferencesManager.getPreinstallPayloadReadStatus();

if (PreinstallUtil.hasAllLocationsBeenRead(readStatus)) {
internalState.preinstallHasBeenRead = true;
return;
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES, readStatus)) {
String payloadSystemProperty = PreinstallUtil.getPayloadFromSystemProperty(
deviceInfo.packageName, logger);

if (payloadSystemProperty != null && !payloadSystemProperty.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemProperty, Constants.SYSTEM_PROPERTIES);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_REFLECTION, readStatus)) {
String payloadSystemPropertyReflection = PreinstallUtil.getPayloadFromSystemPropertyReflection(
deviceInfo.packageName, logger);

if (payloadSystemPropertyReflection != null && !payloadSystemPropertyReflection.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyReflection, Constants.SYSTEM_PROPERTIES_REFLECTION);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_REFLECTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_PATH, readStatus)) {
String payloadSystemPropertyFilePath = PreinstallUtil.getPayloadFromSystemPropertyFilePath(
deviceInfo.packageName, logger);

if (payloadSystemPropertyFilePath != null && !payloadSystemPropertyFilePath.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyFilePath, Constants.SYSTEM_PROPERTIES_PATH);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_PATH, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.SYSTEM_PROPERTIES_PATH_REFLECTION, readStatus)) {
String payloadSystemPropertyFilePathReflection = PreinstallUtil.getPayloadFromSystemPropertyFilePathReflection(
deviceInfo.packageName, logger);

if (payloadSystemPropertyFilePathReflection != null && !payloadSystemPropertyFilePathReflection.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadSystemPropertyFilePathReflection, Constants.SYSTEM_PROPERTIES_PATH_REFLECTION);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.SYSTEM_PROPERTIES_PATH_REFLECTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER, readStatus)) {
String payloadContentProviderDefault = PreinstallUtil.getPayloadFromContentProviderDefault(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadContentProviderDefault != null && !payloadContentProviderDefault.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadContentProviderDefault, Constants.CONTENT_PROVIDER);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER_INTENT_ACTION, readStatus)) {
List<String> payloadListContentProviderIntentAction = PreinstallUtil.getPayloadsFromContentProviderIntentAction(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadListContentProviderIntentAction != null && !payloadListContentProviderIntentAction.isEmpty()) {
for (String payload : payloadListContentProviderIntentAction) {
sdkClickHandler.sendPreinstallPayload(payload, Constants.CONTENT_PROVIDER_INTENT_ACTION);
}
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER_INTENT_ACTION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.CONTENT_PROVIDER_NO_PERMISSION, readStatus)) {
List<String> payloadListContentProviderIntentAction = PreinstallUtil.getPayloadsFromContentProviderNoPermission(
adjustConfig.context,
deviceInfo.packageName,
logger);

if (payloadListContentProviderIntentAction != null && !payloadListContentProviderIntentAction.isEmpty()) {
for (String payload : payloadListContentProviderIntentAction) {
sdkClickHandler.sendPreinstallPayload(payload, Constants.CONTENT_PROVIDER_NO_PERMISSION);
}
} else {
readStatus = PreinstallUtil.markAsRead(Constants.CONTENT_PROVIDER_NO_PERMISSION, readStatus);
}
}

//comment
if (PreinstallUtil.hasNotBeenRead(Constants.FILE_SYSTEM, readStatus)) {
String payloadFileSystem = PreinstallUtil.getPayloadFromFileSystem(
deviceInfo.packageName,
adjustConfig.preinstallFilePath,
logger);

if (payloadFileSystem != null && !payloadFileSystem.isEmpty()) {
sdkClickHandler.sendPreinstallPayload(payloadFileSystem, Constants.FILE_SYSTEM);
} else {
readStatus = PreinstallUtil.markAsRead(Constants.FILE_SYSTEM, readStatus);
}
}

sharedPreferencesManager.setPreinstallPayloadReadStatus(readStatus);

internalState.preinstallHasBeenRead = true;
}"
4088,"    private void checkAttributionStateI() {
if (!checkActivityStateI(activityState)) { return; }

//comment
if (internalState.isFirstLaunch()) {
//comment
<start>if (internalState.hasSessionResponseNotBeenProcessed()) {
return;
}<end>
}

//comment
if (attribution != null && !activityState.askingAttribution) {
return;
}

attributionHandler.getAttribution();
}","    private void checkAttributionStateI() {
if (!checkActivityStateI(activityState)) { return; }

//comment
if (internalState.isFirstLaunch()) {
//comment
<start>if (internalState.hasSessionResponseNotBeenProcessed()) {<end>
return;
}
}

//comment
if (attribution != null && !activityState.askingAttribution) {
return;
}

attributionHandler.getAttribution();
}"
101,"private void getAttributionI(long delayInMilliseconds) {
//comment
<start>if (timer.getFireIn() > delayInMilliseconds) {
return;
}<end>

if (delayInMilliseconds != 0) {
double waitTimeSeconds = delayInMilliseconds / 1000.0;
String secondsString = Util.SecondsDisplayFormat.format(waitTimeSeconds);
logger.debug(""Waiting to query attribution in %s seconds"", secondsString);
}

//comment
timer.startIn(delayInMilliseconds);
}","private void getAttributionI(long delayInMilliseconds) {
//comment
<start>if (timer.getFireIn() > delayInMilliseconds) {
return;
}<end>

if (delayInMilliseconds != 0) {
double waitTimeSeconds = delayInMilliseconds / 1000.0;
String secondsString = Util.SecondsDisplayFormat.format(waitTimeSeconds);
logger.debug(""Waiting to query attribution in %s seconds"", secondsString);
}

//comment
timer.startIn(delayInMilliseconds);
}"
102,"private void getAttributionI(long delayInMilliseconds) {
//comment
if (timer.getFireIn() > delayInMilliseconds) {
return;
}

if (delayInMilliseconds != 0) {
double waitTimeSeconds = delayInMilliseconds / 1000.0;
String secondsString = Util.SecondsDisplayFormat.format(waitTimeSeconds);
logger.debug(""Waiting to query attribution in %s seconds"", secondsString);
}

//comment
<start>timer.startIn(delayInMilliseconds);<end>
}","private void getAttributionI(long delayInMilliseconds) {
//comment
if (timer.getFireIn() > delayInMilliseconds) {
return;
}

if (delayInMilliseconds != 0) {
double waitTimeSeconds = delayInMilliseconds / 1000.0;
String secondsString = Util.SecondsDisplayFormat.format(waitTimeSeconds);
logger.debug(""Waiting to query attribution in %s seconds"", secondsString);
}

//comment
<start>timer.startIn(delayInMilliseconds);<end>
}"
103,"    private void sendAttributionRequestI() {
if (activityHandlerWeakRef.get().getActivityState().isGdprForgotten) {
return;
}
if (paused) {
logger.debug(""Attribution handler is paused"");
return;
}

//comment
<start>ActivityPackage attributionPackage = buildAndGetAttributionPackage();
logger.verbose(""%s"", attributionPackage.getExtendedString());<end>

Map<String, String> sendingParameters = generateSendingParametersI();

activityPackageSender.sendActivityPackage(
attributionPackage,
sendingParameters,
this);
}","    private void sendAttributionRequestI() {
if (activityHandlerWeakRef.get().getActivityState().isGdprForgotten) {
return;
}
if (paused) {
logger.debug(""Attribution handler is paused"");
return;
}

//comment
<start>ActivityPackage attributionPackage = buildAndGetAttributionPackage();<end>
logger.verbose(""%s"", attributionPackage.getExtendedString());

Map<String, String> sendingParameters = generateSendingParametersI();

activityPackageSender.sendActivityPackage(
attributionPackage,
sendingParameters,
this);
}"
2672,"void reloadPlayIds(Context context) {
String previousPlayAdId = playAdId;
Boolean previousIsTrackingEnabled = isTrackingEnabled;

playAdId = null;
isTrackingEnabled = null;
playAdIdSource = null;
playAdIdAttempt = -1;


//comment
for (int serviceAttempt = 1; serviceAttempt <= 3; serviceAttempt += 1) {
try {
//comment
//comment
<start>long timeoutServiceMilli = Constants.ONE_SECOND * 3 * serviceAttempt;<end>
GooglePlayServicesClient.GooglePlayServicesInfo gpsInfo =
GooglePlayServicesClient.getGooglePlayServicesInfo(context,
timeoutServiceMilli);
if (playAdId == null) {
playAdId = gpsInfo.getGpsAdid();
}
if (isTrackingEnabled == null) {
isTrackingEnabled = gpsInfo.isTrackingEnabled();
}

if (playAdId != null && isTrackingEnabled != null) {
playAdIdSource = ""service"";
playAdIdAttempt = serviceAttempt;
return;
}
} catch (Exception e) {}
}

//comment
for (int libAttempt = 1; libAttempt <= 3; libAttempt += 1) {
//comment
Object advertisingInfoObject = Util.getAdvertisingInfoObject(
context, Constants.ONE_SECOND * 11);

if (advertisingInfoObject == null) {
continue;
}

if (playAdId == null) {
//comment
playAdId = Util.getPlayAdId(
context, advertisingInfoObject, Constants.ONE_SECOND);
}
if (isTrackingEnabled == null) {
//comment
isTrackingEnabled = Util.isPlayTrackingEnabled(
context, advertisingInfoObject, Constants.ONE_SECOND);
}

if (playAdId != null && isTrackingEnabled != null) {
playAdIdSource = ""library"";
playAdIdAttempt = libAttempt;
return;
}
}

//comment
if (playAdId == null) {
playAdId = previousPlayAdId;
}
if (isTrackingEnabled == null) {
isTrackingEnabled = previousIsTrackingEnabled;
}
}","void reloadPlayIds(Context context) {
String previousPlayAdId = playAdId;
Boolean previousIsTrackingEnabled = isTrackingEnabled;

playAdId = null;
isTrackingEnabled = null;
playAdIdSource = null;
playAdIdAttempt = -1;


//comment
for (int serviceAttempt = 1; serviceAttempt <= 3; serviceAttempt += 1) {
try {
//comment
//comment
long timeoutServiceMilli = Constants.ONE_SECOND * 3 * serviceAttempt;
<start>GooglePlayServicesClient.GooglePlayServicesInfo gpsInfo =
GooglePlayServicesClient.getGooglePlayServicesInfo(context,
timeoutServiceMilli);<end>
if (playAdId == null) {
playAdId = gpsInfo.getGpsAdid();
}
if (isTrackingEnabled == null) {
isTrackingEnabled = gpsInfo.isTrackingEnabled();
}

if (playAdId != null && isTrackingEnabled != null) {
playAdIdSource = ""service"";
playAdIdAttempt = serviceAttempt;
return;
}
} catch (Exception e) {}
}

//comment
for (int libAttempt = 1; libAttempt <= 3; libAttempt += 1) {
//comment
Object advertisingInfoObject = Util.getAdvertisingInfoObject(
context, Constants.ONE_SECOND * 11);

if (advertisingInfoObject == null) {
continue;
}

if (playAdId == null) {
//comment
playAdId = Util.getPlayAdId(
context, advertisingInfoObject, Constants.ONE_SECOND);
}
if (isTrackingEnabled == null) {
//comment
isTrackingEnabled = Util.isPlayTrackingEnabled(
context, advertisingInfoObject, Constants.ONE_SECOND);
}

if (playAdId != null && isTrackingEnabled != null) {
playAdIdSource = ""library"";
playAdIdAttempt = libAttempt;
return;
}
}

//comment
if (playAdId == null) {
playAdId = previousPlayAdId;
}
if (isTrackingEnabled == null) {
isTrackingEnabled = previousIsTrackingEnabled;
}
}"
519,"<start>    public OpenDeviceIdentifierService getOpenDeviceIdentifierService(long timeOut, TimeUnit timeUnit) {
//comment
IBinder service;<end>
try {
service = binders.poll(timeOut, timeUnit);
} catch (InterruptedException e) {
logger.error(""Waiting for OpenDeviceIdentifier Service interrupted: %s"",
e.getMessage());
return null;
}
if (service == null) {
logger.warn(""Timed out waiting for OpenDeviceIdentifier service connection"");
return null;
}

//comment
set(service);

return OpenDeviceIdentifierService.Stub.asInterface(service);
}","    public OpenDeviceIdentifierService getOpenDeviceIdentifierService(long timeOut, TimeUnit timeUnit) {
//comment
<start>IBinder service;<end>
try {
<start>service = binders.poll(timeOut, timeUnit);<end>
} catch (InterruptedException e) {
logger.error(""Waiting for OpenDeviceIdentifier Service interrupted: %s"",
e.getMessage());
return null;
}
if (service == null) {
logger.warn(""Timed out waiting for OpenDeviceIdentifier service connection"");
return null;
}

//comment
set(service);

return OpenDeviceIdentifierService.Stub.asInterface(service);
}"
520,"    public OpenDeviceIdentifierService getOpenDeviceIdentifierService(long timeOut, TimeUnit timeUnit) {
//comment
IBinder service;
try {
service = binders.poll(timeOut, timeUnit);
} catch (InterruptedException e) {
logger.error(""Waiting for OpenDeviceIdentifier Service interrupted: %s"",
e.getMessage());
return null;
}
if (service == null) {
logger.warn(""Timed out waiting for OpenDeviceIdentifier service connection"");
return null;
}

//comment
<start>set(service);<end>

return OpenDeviceIdentifierService.Stub.asInterface(service);
}","    public OpenDeviceIdentifierService getOpenDeviceIdentifierService(long timeOut, TimeUnit timeUnit) {
//comment
IBinder service;
try {
<start>service = binders.poll(timeOut, timeUnit);<end>
} catch (InterruptedException e) {
logger.error(""Waiting for OpenDeviceIdentifier Service interrupted: %s"",
e.getMessage());
return null;
}
if (service == null) {
logger.warn(""Timed out waiting for OpenDeviceIdentifier service connection"");
return null;
}

//comment
<start>set(service);<end>

return OpenDeviceIdentifierService.Stub.asInterface(service);
}"
3308,"public void registerFacebookSDKJSInterface() {
//comment
String fbApplicationId = FacebookSDKJSInterface.getApplicationId(application.getApplicationContext());
AdjustFactory.getLogger().info(""AdjustBridgeInstance fbApplicationId: %s"", fbApplicationId);

if (fbApplicationId == null) {
return;
}

this.facebookSDKJSInterface = new FacebookSDKJSInterface();

//comment
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
<start>this.webView.addJavascriptInterface(facebookSDKJSInterface,
FB_JAVASCRIPT_INTERFACE_NAME_PREFIX
+ fbApplicationId
);<end>
}
}","public void registerFacebookSDKJSInterface() {
//comment
String fbApplicationId = FacebookSDKJSInterface.getApplicationId(application.getApplicationContext());
AdjustFactory.getLogger().info(""AdjustBridgeInstance fbApplicationId: %s"", fbApplicationId);

if (fbApplicationId == null) {
return;
}

this.facebookSDKJSInterface = new FacebookSDKJSInterface();

//comment
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
<start>this.webView.addJavascriptInterface(facebookSDKJSInterface,
FB_JAVASCRIPT_INTERFACE_NAME_PREFIX
+ fbApplicationId
);<end>
}
}"
45,"    public static <V> ListenableFuture<V> whenAnyCompleteCancelOthers(Iterable<? extends ListenableFuture<? extends V>> futures)
{
requireNonNull(futures, ""futures is null"");
checkArgument(!isEmpty(futures), ""futures is empty"");

//comment
<start>ListenableFuture<V> anyComplete = whenAnyComplete(futures);<end>
anyComplete.addListener(
() -> {
for (ListenableFuture<?> future : futures) {
future.cancel(true);
}
},
directExecutor());
return anyComplete;
}","    public static <V> ListenableFuture<V> whenAnyCompleteCancelOthers(Iterable<? extends ListenableFuture<? extends V>> futures)
{
requireNonNull(futures, ""futures is null"");
checkArgument(!isEmpty(futures), ""futures is empty"");

//comment
<start>ListenableFuture<V> anyComplete = whenAnyComplete(futures);
anyComplete.addListener(
() -> {
for (ListenableFuture<?> future : futures) {
future.cancel(true);
}
},
directExecutor());<end>
return anyComplete;
}"
46,"    @Deprecated
public static <T> CompletableFuture<T> addTimeout(CompletableFuture<T> future, Callable<T> onTimeout, Duration timeout, ScheduledExecutorService executorService)
{
requireNonNull(future, ""future is null"");
requireNonNull(onTimeout, ""timeoutValue is null"");
requireNonNull(timeout, ""timeout is null"");
requireNonNull(executorService, ""executorService is null"");

//comment
<start>if (future.isDone()) {
return future;
}<end>

//comment
//comment
UnmodifiableCompletableFuture<T> futureWithTimeout = (UnmodifiableCompletableFuture<T>) unmodifiableFuture(future, true);

//comment
ScheduledFuture<?> timeoutTaskFuture = executorService.schedule(new TimeoutFutureTask<>(futureWithTimeout, onTimeout, future), timeout.toMillis(), MILLISECONDS);

//comment
future.whenCompleteAsync((value, exception) -> timeoutTaskFuture.cancel(false), executorService);

return futureWithTimeout;
}","    @Deprecated
public static <T> CompletableFuture<T> addTimeout(CompletableFuture<T> future, Callable<T> onTimeout, Duration timeout, ScheduledExecutorService executorService)
{
requireNonNull(future, ""future is null"");
requireNonNull(onTimeout, ""timeoutValue is null"");
requireNonNull(timeout, ""timeout is null"");
requireNonNull(executorService, ""executorService is null"");

//comment
<start>if (future.isDone()) {
return future;
}<end>

//comment
//comment
UnmodifiableCompletableFuture<T> futureWithTimeout = (UnmodifiableCompletableFuture<T>) unmodifiableFuture(future, true);

//comment
ScheduledFuture<?> timeoutTaskFuture = executorService.schedule(new TimeoutFutureTask<>(futureWithTimeout, onTimeout, future), timeout.toMillis(), MILLISECONDS);

//comment
future.whenCompleteAsync((value, exception) -> timeoutTaskFuture.cancel(false), executorService);

return futureWithTimeout;
}"
47,"    @Deprecated
public static <T> CompletableFuture<T> addTimeout(CompletableFuture<T> future, Callable<T> onTimeout, Duration timeout, ScheduledExecutorService executorService)
{
requireNonNull(future, ""future is null"");
requireNonNull(onTimeout, ""timeoutValue is null"");
requireNonNull(timeout, ""timeout is null"");
requireNonNull(executorService, ""executorService is null"");

//comment
if (future.isDone()) {
return future;
}

//comment
//comment
<start>UnmodifiableCompletableFuture<T> futureWithTimeout = (UnmodifiableCompletableFuture<T>) unmodifiableFuture(future, true);<end>

//comment
ScheduledFuture<?> timeoutTaskFuture = executorService.schedule(new TimeoutFutureTask<>(futureWithTimeout, onTimeout, future), timeout.toMillis(), MILLISECONDS);

//comment
future.whenCompleteAsync((value, exception) -> timeoutTaskFuture.cancel(false), executorService);

return futureWithTimeout;
}","    @Deprecated
public static <T> CompletableFuture<T> addTimeout(CompletableFuture<T> future, Callable<T> onTimeout, Duration timeout, ScheduledExecutorService executorService)
{
requireNonNull(future, ""future is null"");
requireNonNull(onTimeout, ""timeoutValue is null"");
requireNonNull(timeout, ""timeout is null"");
requireNonNull(executorService, ""executorService is null"");

//comment
if (future.isDone()) {
return future;
}

//comment
//comment
<start>UnmodifiableCompletableFuture<T> futureWithTimeout = (UnmodifiableCompletableFuture<T>) unmodifiableFuture(future, true);<end>

//comment
ScheduledFuture<?> timeoutTaskFuture = executorService.schedule(new TimeoutFutureTask<>(futureWithTimeout, onTimeout, future), timeout.toMillis(), MILLISECONDS);

//comment
future.whenCompleteAsync((value, exception) -> timeoutTaskFuture.cancel(false), executorService);

return futureWithTimeout;
}"
48,"    @Deprecated
public static <T> CompletableFuture<T> addTimeout(CompletableFuture<T> future, Callable<T> onTimeout, Duration timeout, ScheduledExecutorService executorService)
{
requireNonNull(future, ""future is null"");
requireNonNull(onTimeout, ""timeoutValue is null"");
requireNonNull(timeout, ""timeout is null"");
requireNonNull(executorService, ""executorService is null"");

//comment
if (future.isDone()) {
return future;
}

//comment
//comment
UnmodifiableCompletableFuture<T> futureWithTimeout = (UnmodifiableCompletableFuture<T>) unmodifiableFuture(future, true);

//comment
<start>ScheduledFuture<?> timeoutTaskFuture = executorService.schedule(new TimeoutFutureTask<>(futureWithTimeout, onTimeout, future), timeout.toMillis(), MILLISECONDS);<end>

//comment
future.whenCompleteAsync((value, exception) -> timeoutTaskFuture.cancel(false), executorService);

return futureWithTimeout;
}","    @Deprecated
public static <T> CompletableFuture<T> addTimeout(CompletableFuture<T> future, Callable<T> onTimeout, Duration timeout, ScheduledExecutorService executorService)
{
requireNonNull(future, ""future is null"");
requireNonNull(onTimeout, ""timeoutValue is null"");
requireNonNull(timeout, ""timeout is null"");
requireNonNull(executorService, ""executorService is null"");

//comment
if (future.isDone()) {
return future;
}

//comment
//comment
UnmodifiableCompletableFuture<T> futureWithTimeout = (UnmodifiableCompletableFuture<T>) unmodifiableFuture(future, true);

//comment
<start>ScheduledFuture<?> timeoutTaskFuture = executorService.schedule(new TimeoutFutureTask<>(futureWithTimeout, onTimeout, future), timeout.toMillis(), MILLISECONDS);<end>

//comment
future.whenCompleteAsync((value, exception) -> timeoutTaskFuture.cancel(false), executorService);

return futureWithTimeout;
}"
49,"    @Deprecated
public static <T> CompletableFuture<T> addTimeout(CompletableFuture<T> future, Callable<T> onTimeout, Duration timeout, ScheduledExecutorService executorService)
{
requireNonNull(future, ""future is null"");
requireNonNull(onTimeout, ""timeoutValue is null"");
requireNonNull(timeout, ""timeout is null"");
requireNonNull(executorService, ""executorService is null"");

//comment
if (future.isDone()) {
return future;
}

//comment
//comment
UnmodifiableCompletableFuture<T> futureWithTimeout = (UnmodifiableCompletableFuture<T>) unmodifiableFuture(future, true);

//comment
ScheduledFuture<?> timeoutTaskFuture = executorService.schedule(new TimeoutFutureTask<>(futureWithTimeout, onTimeout, future), timeout.toMillis(), MILLISECONDS);

//comment
<start>future.whenCompleteAsync((value, exception) -> timeoutTaskFuture.cancel(false), executorService);<end>

return futureWithTimeout;
}","    @Deprecated
public static <T> CompletableFuture<T> addTimeout(CompletableFuture<T> future, Callable<T> onTimeout, Duration timeout, ScheduledExecutorService executorService)
{
requireNonNull(future, ""future is null"");
requireNonNull(onTimeout, ""timeoutValue is null"");
requireNonNull(timeout, ""timeout is null"");
requireNonNull(executorService, ""executorService is null"");

//comment
if (future.isDone()) {
return future;
}

//comment
//comment
UnmodifiableCompletableFuture<T> futureWithTimeout = (UnmodifiableCompletableFuture<T>) unmodifiableFuture(future, true);

//comment
ScheduledFuture<?> timeoutTaskFuture = executorService.schedule(new TimeoutFutureTask<>(futureWithTimeout, onTimeout, future), timeout.toMillis(), MILLISECONDS);

//comment
<start>future.whenCompleteAsync((value, exception) -> timeoutTaskFuture.cancel(false), executorService);<end>

return futureWithTimeout;
}"
50,"        @Override
public void run()
{
if (settableFuture.isDone()) {
return;
}

//comment
try {
<start>T result = timeoutValue.call();
settableFuture.internalComplete(result);<end>
}
catch (Throwable t) {
settableFuture.internalCompleteExceptionally(t);
throwIfInstanceOf(t, RuntimeException.class);
}

//comment
Future<T> future = futureReference.get();
if (future != null) {
future.cancel(true);
}
}","        @Override
public void run()
{
if (settableFuture.isDone()) {
return;
}

//comment
<start>try {
T result = timeoutValue.call();
settableFuture.internalComplete(result);
}<end>
catch (Throwable t) {
settableFuture.internalCompleteExceptionally(t);
throwIfInstanceOf(t, RuntimeException.class);
}

//comment
Future<T> future = futureReference.get();
if (future != null) {
future.cancel(true);
}
}"
51,"        @Override
public void run()
{
if (settableFuture.isDone()) {
return;
}

//comment
try {
T result = timeoutValue.call();
settableFuture.internalComplete(result);
}
catch (Throwable t) {
settableFuture.internalCompleteExceptionally(t);
throwIfInstanceOf(t, RuntimeException.class);
}

//comment
<start>Future<T> future = futureReference.get();
if (future != null) {
future.cancel(true);
}<end>
}","        @Override
public void run()
{
if (settableFuture.isDone()) {
return;
}

//comment
try {
T result = timeoutValue.call();
settableFuture.internalComplete(result);
}
catch (Throwable t) {
settableFuture.internalCompleteExceptionally(t);
throwIfInstanceOf(t, RuntimeException.class);
}

//comment
<start>Future<T> future = futureReference.get();
if (future != null) {
future.cancel(true);
}<end>
}"
1809,"<start>    public void registerConfigurationClasses(Collection<? extends Module> modules)<end>
{
//comment
//comment
<start>modules.stream()
.filter(ConfigurationAwareModule.class::isInstance)
.map(ConfigurationAwareModule.class::cast)
.forEach(module -> module.setConfigurationFactory(this));<end>

for (Element element : Elements.getElements(modules)) {
element.acceptVisitor(new DefaultElementVisitor<Void>()
{
@Override
public <T> Void visit(Binding<T> binding)
{
if (binding instanceof InstanceBinding) {
InstanceBinding<T> instanceBinding = (InstanceBinding<T>) binding;

//comment
if (instanceBinding.getInstance() instanceof ConfigurationBindingListenerHolder) {
addConfigurationBindingListener(((ConfigurationBindingListenerHolder) instanceBinding.getInstance()).getConfigurationBindingListener());
}

//comment
if (instanceBinding.getInstance() instanceof ConfigDefaultsHolder) {
registerConfigDefaults((ConfigDefaultsHolder<?>) instanceBinding.getInstance());
}
}

//comment
if (binding instanceof ProviderInstanceBinding) {
ProviderInstanceBinding<?> providerInstanceBinding = (ProviderInstanceBinding<?>) binding;
Provider<?> provider = providerInstanceBinding.getUserSuppliedProvider();
if (provider instanceof ConfigurationProvider) {
registerConfigurationProvider((ConfigurationProvider<?>) provider, Optional.of(binding.getSource()));
}
}
return null;
}
});
}
}","    public void registerConfigurationClasses(Collection<? extends Module> modules)
{
//comment
//comment
<start>modules.stream()
.filter(ConfigurationAwareModule.class::isInstance)
.map(ConfigurationAwareModule.class::cast)
.forEach(module -> module.setConfigurationFactory(this));<end>

for (Element element : Elements.getElements(modules)) {
element.acceptVisitor(new DefaultElementVisitor<Void>()
{
@Override
public <T> Void visit(Binding<T> binding)
{
if (binding instanceof InstanceBinding) {
InstanceBinding<T> instanceBinding = (InstanceBinding<T>) binding;

//comment
if (instanceBinding.getInstance() instanceof ConfigurationBindingListenerHolder) {
addConfigurationBindingListener(((ConfigurationBindingListenerHolder) instanceBinding.getInstance()).getConfigurationBindingListener());
}

//comment
if (instanceBinding.getInstance() instanceof ConfigDefaultsHolder) {
registerConfigDefaults((ConfigDefaultsHolder<?>) instanceBinding.getInstance());
}
}

//comment
if (binding instanceof ProviderInstanceBinding) {
ProviderInstanceBinding<?> providerInstanceBinding = (ProviderInstanceBinding<?>) binding;
Provider<?> provider = providerInstanceBinding.getUserSuppliedProvider();
if (provider instanceof ConfigurationProvider) {
registerConfigurationProvider((ConfigurationProvider<?>) provider, Optional.of(binding.getSource()));
}
}
return null;
}
});
}
}"
1810,"    public void registerConfigurationClasses(Collection<? extends Module> modules)
{
//comment
//comment
modules.stream()
.filter(ConfigurationAwareModule.class::isInstance)
.map(ConfigurationAwareModule.class::cast)
.forEach(module -> module.setConfigurationFactory(this));

for (Element element : Elements.getElements(modules)) {
element.acceptVisitor(new DefaultElementVisitor<Void>()
{
@Override
public <T> Void visit(Binding<T> binding)
{
if (binding instanceof InstanceBinding) {
InstanceBinding<T> instanceBinding = (InstanceBinding<T>) binding;

//comment
<start>if (instanceBinding.getInstance() instanceof ConfigurationBindingListenerHolder) {
addConfigurationBindingListener(((ConfigurationBindingListenerHolder) instanceBinding.getInstance()).getConfigurationBindingListener());
}<end>

//comment
if (instanceBinding.getInstance() instanceof ConfigDefaultsHolder) {
registerConfigDefaults((ConfigDefaultsHolder<?>) instanceBinding.getInstance());
}
}

//comment
if (binding instanceof ProviderInstanceBinding) {
ProviderInstanceBinding<?> providerInstanceBinding = (ProviderInstanceBinding<?>) binding;
Provider<?> provider = providerInstanceBinding.getUserSuppliedProvider();
if (provider instanceof ConfigurationProvider) {
registerConfigurationProvider((ConfigurationProvider<?>) provider, Optional.of(binding.getSource()));
}
}
return null;
}
});
}
}","    public void registerConfigurationClasses(Collection<? extends Module> modules)
{
//comment
//comment
modules.stream()
.filter(ConfigurationAwareModule.class::isInstance)
.map(ConfigurationAwareModule.class::cast)
.forEach(module -> module.setConfigurationFactory(this));

for (Element element : Elements.getElements(modules)) {
element.acceptVisitor(new DefaultElementVisitor<Void>()
{
@Override
public <T> Void visit(Binding<T> binding)
{
if (binding instanceof InstanceBinding) {
InstanceBinding<T> instanceBinding = (InstanceBinding<T>) binding;

//comment
<start>if (instanceBinding.getInstance() instanceof ConfigurationBindingListenerHolder) {
addConfigurationBindingListener(((ConfigurationBindingListenerHolder) instanceBinding.getInstance()).getConfigurationBindingListener());
}<end>

//comment
if (instanceBinding.getInstance() instanceof ConfigDefaultsHolder) {
registerConfigDefaults((ConfigDefaultsHolder<?>) instanceBinding.getInstance());
}
}

//comment
if (binding instanceof ProviderInstanceBinding) {
ProviderInstanceBinding<?> providerInstanceBinding = (ProviderInstanceBinding<?>) binding;
Provider<?> provider = providerInstanceBinding.getUserSuppliedProvider();
if (provider instanceof ConfigurationProvider) {
registerConfigurationProvider((ConfigurationProvider<?>) provider, Optional.of(binding.getSource()));
}
}
return null;
}
});
}
}"
1811,"    public void registerConfigurationClasses(Collection<? extends Module> modules)
{
//comment
//comment
modules.stream()
.filter(ConfigurationAwareModule.class::isInstance)
.map(ConfigurationAwareModule.class::cast)
.forEach(module -> module.setConfigurationFactory(this));

for (Element element : Elements.getElements(modules)) {
element.acceptVisitor(new DefaultElementVisitor<Void>()
{
@Override
public <T> Void visit(Binding<T> binding)
{
if (binding instanceof InstanceBinding) {
InstanceBinding<T> instanceBinding = (InstanceBinding<T>) binding;

//comment
if (instanceBinding.getInstance() instanceof ConfigurationBindingListenerHolder) {
addConfigurationBindingListener(((ConfigurationBindingListenerHolder) instanceBinding.getInstance()).getConfigurationBindingListener());
}

//comment
<start>if (instanceBinding.getInstance() instanceof ConfigDefaultsHolder) {
registerConfigDefaults((ConfigDefaultsHolder<?>) instanceBinding.getInstance());
}<end>
}

//comment
if (binding instanceof ProviderInstanceBinding) {
ProviderInstanceBinding<?> providerInstanceBinding = (ProviderInstanceBinding<?>) binding;
Provider<?> provider = providerInstanceBinding.getUserSuppliedProvider();
if (provider instanceof ConfigurationProvider) {
registerConfigurationProvider((ConfigurationProvider<?>) provider, Optional.of(binding.getSource()));
}
}
return null;
}
});
}
}","    public void registerConfigurationClasses(Collection<? extends Module> modules)
{
//comment
//comment
modules.stream()
.filter(ConfigurationAwareModule.class::isInstance)
.map(ConfigurationAwareModule.class::cast)
.forEach(module -> module.setConfigurationFactory(this));

for (Element element : Elements.getElements(modules)) {
element.acceptVisitor(new DefaultElementVisitor<Void>()
{
@Override
public <T> Void visit(Binding<T> binding)
{
if (binding instanceof InstanceBinding) {
InstanceBinding<T> instanceBinding = (InstanceBinding<T>) binding;

//comment
if (instanceBinding.getInstance() instanceof ConfigurationBindingListenerHolder) {
addConfigurationBindingListener(((ConfigurationBindingListenerHolder) instanceBinding.getInstance()).getConfigurationBindingListener());
}

//comment
<start>if (instanceBinding.getInstance() instanceof ConfigDefaultsHolder) {
registerConfigDefaults((ConfigDefaultsHolder<?>) instanceBinding.getInstance());
}<end>
}

//comment
if (binding instanceof ProviderInstanceBinding) {
ProviderInstanceBinding<?> providerInstanceBinding = (ProviderInstanceBinding<?>) binding;
Provider<?> provider = providerInstanceBinding.getUserSuppliedProvider();
if (provider instanceof ConfigurationProvider) {
registerConfigurationProvider((ConfigurationProvider<?>) provider, Optional.of(binding.getSource()));
}
}
return null;
}
});
}
}"
1812,"    public void registerConfigurationClasses(Collection<? extends Module> modules)
{
//comment
//comment
modules.stream()
.filter(ConfigurationAwareModule.class::isInstance)
.map(ConfigurationAwareModule.class::cast)
.forEach(module -> module.setConfigurationFactory(this));

for (Element element : Elements.getElements(modules)) {
element.acceptVisitor(new DefaultElementVisitor<Void>()
{
@Override
public <T> Void visit(Binding<T> binding)
{
if (binding instanceof InstanceBinding) {
InstanceBinding<T> instanceBinding = (InstanceBinding<T>) binding;

//comment
if (instanceBinding.getInstance() instanceof ConfigurationBindingListenerHolder) {
addConfigurationBindingListener(((ConfigurationBindingListenerHolder) instanceBinding.getInstance()).getConfigurationBindingListener());
}

//comment
if (instanceBinding.getInstance() instanceof ConfigDefaultsHolder) {
registerConfigDefaults((ConfigDefaultsHolder<?>) instanceBinding.getInstance());
}
}

//comment
if (binding instanceof ProviderInstanceBinding) {
<start>ProviderInstanceBinding<?> providerInstanceBinding = (ProviderInstanceBinding<?>) binding;<end>
Provider<?> provider = providerInstanceBinding.getUserSuppliedProvider();
<start>if (provider instanceof ConfigurationProvider) {
registerConfigurationProvider((ConfigurationProvider<?>) provider, Optional.of(binding.getSource()));
}<end>
}
return null;
}
});
}
}","    public void registerConfigurationClasses(Collection<? extends Module> modules)
{
//comment
//comment
modules.stream()
.filter(ConfigurationAwareModule.class::isInstance)
.map(ConfigurationAwareModule.class::cast)
.forEach(module -> module.setConfigurationFactory(this));

for (Element element : Elements.getElements(modules)) {
element.acceptVisitor(new DefaultElementVisitor<Void>()
{
@Override
public <T> Void visit(Binding<T> binding)
{
if (binding instanceof InstanceBinding) {
InstanceBinding<T> instanceBinding = (InstanceBinding<T>) binding;

//comment
if (instanceBinding.getInstance() instanceof ConfigurationBindingListenerHolder) {
addConfigurationBindingListener(((ConfigurationBindingListenerHolder) instanceBinding.getInstance()).getConfigurationBindingListener());
}

//comment
if (instanceBinding.getInstance() instanceof ConfigDefaultsHolder) {
registerConfigDefaults((ConfigDefaultsHolder<?>) instanceBinding.getInstance());
}
}

//comment
<start>if (binding instanceof ProviderInstanceBinding) {
ProviderInstanceBinding<?> providerInstanceBinding = (ProviderInstanceBinding<?>) binding;
Provider<?> provider = providerInstanceBinding.getUserSuppliedProvider();
if (provider instanceof ConfigurationProvider) {
registerConfigurationProvider((ConfigurationProvider<?>) provider, Optional.of(binding.getSource()));
}
}<end>
return null;
}
});
}
}"
1813,"    public List<Message> validateRegisteredConfigurationProvider()
{
List<Message> messages = new ArrayList<>();
for (ConfigurationProvider<?> configurationProvider : ImmutableList.copyOf(registeredProviders)) {
try {
//comment
configurationProvider.get();
}
catch (ConfigurationException e) {
//comment
ImmutableList<Object> sources = configurationProvider.getBindingSource().map(ImmutableList::of).orElse(ImmutableList.of());
for (Message message : e.getErrorMessages()) {
messages.add(new Message(sources, message.getMessage(), message.getCause()));
}
}
}
return messages;
}","    public List<Message> validateRegisteredConfigurationProvider()
{
List<Message> messages = new ArrayList<>();
for (ConfigurationProvider<?> configurationProvider : ImmutableList.copyOf(registeredProviders)) {
try {
//comment
<start>configurationProvider.get();<end>
}
catch (ConfigurationException e) {
//comment
ImmutableList<Object> sources = configurationProvider.getBindingSource().map(ImmutableList::of).orElse(ImmutableList.of());
for (Message message : e.getErrorMessages()) {
messages.add(new Message(sources, message.getMessage(), message.getCause()));
}
}
}
return messages;
}"
1814,"    public List<Message> validateRegisteredConfigurationProvider()
{
List<Message> messages = new ArrayList<>();
for (ConfigurationProvider<?> configurationProvider : ImmutableList.copyOf(registeredProviders)) {
try {
//comment
configurationProvider.get();
}
catch (ConfigurationException e) {
//comment
ImmutableList<Object> sources = configurationProvider.getBindingSource().map(ImmutableList::of).orElse(ImmutableList.of());
for (Message message : e.getErrorMessages()) {
messages.add(new Message(sources, message.getMessage(), message.getCause()));
}
}
}
return messages;
}","    public List<Message> validateRegisteredConfigurationProvider()
{
List<Message> messages = new ArrayList<>();
for (ConfigurationProvider<?> configurationProvider : ImmutableList.copyOf(registeredProviders)) {
<start>try {
//comment
configurationProvider.get();
}
catch (ConfigurationException e) {
//comment
ImmutableList<Object> sources = configurationProvider.getBindingSource().map(ImmutableList::of).orElse(ImmutableList.of());
for (Message message : e.getErrorMessages()) {
messages.add(new Message(sources, message.getMessage(), message.getCause()));
}
}<end>
}
return messages;
}"
1815,"    private <T> ConfigurationHolder<T> build(Class<T> configClass, Optional<String> configPrefix, ConfigDefaults<T> configDefaults)
{
if (configClass == null) {
throw new NullPointerException(""configClass is null"");
}

String prefix = configPrefix
.map(value -> value + ""."")
.orElse("""");

ConfigurationMetadata<T> configurationMetadata = getMetadata(configClass);
configurationMetadata.getProblems().throwIfHasErrors();

T instance = newInstance(configurationMetadata);

configDefaults.setDefaults(instance);

Problems problems = new Problems(monitor);

for (AttributeMetadata attribute : configurationMetadata.getAttributes().values()) {
Problems attributeProblems = new Problems(monitor);
try {
setConfigProperty(instance, attribute, prefix, attributeProblems);
}
catch (InvalidConfigurationException e) {
attributeProblems.addError(e.getCause(), e.getMessage());
}
problems.record(attributeProblems);
}

//comment
if (configClass.isAnnotationPresent(DefunctConfig.class)) {
for (String value : configClass.getAnnotation(DefunctConfig.class).value()) {
String name = prefix + value;
if (!value.isEmpty() && properties.get(name) != null) {
problems.addError(""Defunct property '%s' (class [%s]) cannot be configured."", name, configClass.toString());
}
}
}

//comment
problems.throwIfHasErrors();

for (ConstraintViolation<?> violation : validate(instance)) {
String propertyFieldName = violation.getPropertyPath().toString();
//comment
String attributeName = LOWER_CAMEL.to(UPPER_CAMEL, propertyFieldName);
AttributeMetadata attribute = configurationMetadata.getAttributes().get(attributeName);
if (attribute != null && attribute.getInjectionPoint() != null) {
String propertyName = attribute.getInjectionPoint().getProperty();
if (!prefix.isEmpty()) {
propertyName = prefix + propertyName;
}
problems.addError(""Invalid configuration property %s: %s (for class %s.%s)"",
propertyName, violation.getMessage(), configClass.getName(), violation.getPropertyPath());
}
else {
problems.addError(""Invalid configuration property with prefix '%s': %s (for class %s.%s)"",
prefix, violation.getMessage(), configClass.getName(), violation.getPropertyPath());
}
}

problems.throwIfHasErrors();

return new ConfigurationHolder<>(instance, problems);
}","    private <T> ConfigurationHolder<T> build(Class<T> configClass, Optional<String> configPrefix, ConfigDefaults<T> configDefaults)
{
if (configClass == null) {
throw new NullPointerException(""configClass is null"");
}

String prefix = configPrefix
.map(value -> value + ""."")
.orElse("""");

ConfigurationMetadata<T> configurationMetadata = getMetadata(configClass);
configurationMetadata.getProblems().throwIfHasErrors();

T instance = newInstance(configurationMetadata);

configDefaults.setDefaults(instance);

Problems problems = new Problems(monitor);

for (AttributeMetadata attribute : configurationMetadata.getAttributes().values()) {
Problems attributeProblems = new Problems(monitor);
try {
setConfigProperty(instance, attribute, prefix, attributeProblems);
}
catch (InvalidConfigurationException e) {
attributeProblems.addError(e.getCause(), e.getMessage());
}
problems.record(attributeProblems);
}

//comment
<start>if (configClass.isAnnotationPresent(DefunctConfig.class)) {
for (String value : configClass.getAnnotation(DefunctConfig.class).value()) {
String name = prefix + value;
if (!value.isEmpty() && properties.get(name) != null) {
problems.addError(""Defunct property '%s' (class [%s]) cannot be configured."", name, configClass.toString());
}
}
}<end>

//comment
problems.throwIfHasErrors();

for (ConstraintViolation<?> violation : validate(instance)) {
String propertyFieldName = violation.getPropertyPath().toString();
//comment
String attributeName = LOWER_CAMEL.to(UPPER_CAMEL, propertyFieldName);
AttributeMetadata attribute = configurationMetadata.getAttributes().get(attributeName);
if (attribute != null && attribute.getInjectionPoint() != null) {
String propertyName = attribute.getInjectionPoint().getProperty();
if (!prefix.isEmpty()) {
propertyName = prefix + propertyName;
}
problems.addError(""Invalid configuration property %s: %s (for class %s.%s)"",
propertyName, violation.getMessage(), configClass.getName(), violation.getPropertyPath());
}
else {
problems.addError(""Invalid configuration property with prefix '%s': %s (for class %s.%s)"",
prefix, violation.getMessage(), configClass.getName(), violation.getPropertyPath());
}
}

problems.throwIfHasErrors();

return new ConfigurationHolder<>(instance, problems);
}"
1816,"    private <T> void setConfigProperty(T instance, AttributeMetadata attribute, String prefix, Problems problems)
throws InvalidConfigurationException
{
//comment
<start>ConfigurationMetadata.InjectionPointMetaData injectionPoint = findOperativeInjectionPoint(attribute, prefix, problems);<end>

//comment
if (injectionPoint == null) {
return;
}

if (injectionPoint.getSetter().isAnnotationPresent(Deprecated.class)) {
problems.addWarning(""Configuration property '%s' is deprecated and should not be used"", prefix + injectionPoint.getProperty());
}

Object value = getInjectedValue(attribute, injectionPoint, prefix);

try {
injectionPoint.getSetter().invoke(instance, value);
}
catch (Throwable e) {
if (e instanceof InvocationTargetException && e.getCause() != null) {
e = e.getCause();
}
throw new InvalidConfigurationException(e, format(""Error invoking configuration method [%s]"", injectionPoint.getSetter().toGenericString()));
}
}","    private <T> void setConfigProperty(T instance, AttributeMetadata attribute, String prefix, Problems problems)
throws InvalidConfigurationException
{
//comment
<start>ConfigurationMetadata.InjectionPointMetaData injectionPoint = findOperativeInjectionPoint(attribute, prefix, problems);<end>

//comment
if (injectionPoint == null) {
return;
}

if (injectionPoint.getSetter().isAnnotationPresent(Deprecated.class)) {
problems.addWarning(""Configuration property '%s' is deprecated and should not be used"", prefix + injectionPoint.getProperty());
}

Object value = getInjectedValue(attribute, injectionPoint, prefix);

try {
injectionPoint.getSetter().invoke(instance, value);
}
catch (Throwable e) {
if (e instanceof InvocationTargetException && e.getCause() != null) {
e = e.getCause();
}
throw new InvalidConfigurationException(e, format(""Error invoking configuration method [%s]"", injectionPoint.getSetter().toGenericString()));
}
}"
1817,"    private <T> void setConfigProperty(T instance, AttributeMetadata attribute, String prefix, Problems problems)
throws InvalidConfigurationException
{
//comment
ConfigurationMetadata.InjectionPointMetaData injectionPoint = findOperativeInjectionPoint(attribute, prefix, problems);

//comment
<start>if (injectionPoint == null) {
return;
}<end>

if (injectionPoint.getSetter().isAnnotationPresent(Deprecated.class)) {
problems.addWarning(""Configuration property '%s' is deprecated and should not be used"", prefix + injectionPoint.getProperty());
}

Object value = getInjectedValue(attribute, injectionPoint, prefix);

try {
injectionPoint.getSetter().invoke(instance, value);
}
catch (Throwable e) {
if (e instanceof InvocationTargetException && e.getCause() != null) {
e = e.getCause();
}
throw new InvalidConfigurationException(e, format(""Error invoking configuration method [%s]"", injectionPoint.getSetter().toGenericString()));
}
}","    private <T> void setConfigProperty(T instance, AttributeMetadata attribute, String prefix, Problems problems)
throws InvalidConfigurationException
{
//comment
ConfigurationMetadata.InjectionPointMetaData injectionPoint = findOperativeInjectionPoint(attribute, prefix, problems);

//comment
<start>if (injectionPoint == null) {
return;
}<end>

if (injectionPoint.getSetter().isAnnotationPresent(Deprecated.class)) {
problems.addWarning(""Configuration property '%s' is deprecated and should not be used"", prefix + injectionPoint.getProperty());
}

Object value = getInjectedValue(attribute, injectionPoint, prefix);

try {
injectionPoint.getSetter().invoke(instance, value);
}
catch (Throwable e) {
if (e instanceof InvocationTargetException && e.getCause() != null) {
e = e.getCause();
}
throw new InvalidConfigurationException(e, format(""Error invoking configuration method [%s]"", injectionPoint.getSetter().toGenericString()));
}
}"
1818,"private Object getInjectedValue(AttributeMetadata attribute, ConfigurationMetadata.InjectionPointMetaData injectionPoint, String prefix)
throws InvalidConfigurationException
{
<start>String name = prefix + injectionPoint.getProperty();<end>
usedProperties.add(name);

//comment
<start>String value = properties.get(name);
String printableValue = value;<end>
if (attribute.isSecuritySensitive()) {
<start>printableValue = ""[REDACTED]"";<end>
}

if (value == null) {
return null;
}

//comment
Class<?> propertyType = injectionPoint.getSetter().getParameterTypes()[0];

Object finalValue = coerce(propertyType, value);
if (finalValue == null) {
throw new InvalidConfigurationException(format(""Invalid value '%s' for type %s (property '%s') in order to call [%s]"",
printableValue,
propertyType.getName(),
name,
injectionPoint.getSetter().toGenericString()));
}
return finalValue;
}","private Object getInjectedValue(AttributeMetadata attribute, ConfigurationMetadata.InjectionPointMetaData injectionPoint, String prefix)
throws InvalidConfigurationException
{
String name = prefix + injectionPoint.getProperty();
usedProperties.add(name);

//comment
<start>String value = properties.get(name);<end>
String printableValue = value;
if (attribute.isSecuritySensitive()) {
printableValue = ""[REDACTED]"";
}

if (value == null) {
return null;
}

//comment
Class<?> propertyType = injectionPoint.getSetter().getParameterTypes()[0];

Object finalValue = coerce(propertyType, value);
if (finalValue == null) {
throw new InvalidConfigurationException(format(""Invalid value '%s' for type %s (property '%s') in order to call [%s]"",
printableValue,
propertyType.getName(),
name,
injectionPoint.getSetter().toGenericString()));
}
return finalValue;
}"
1819,"private Object getInjectedValue(AttributeMetadata attribute, ConfigurationMetadata.InjectionPointMetaData injectionPoint, String prefix)
throws InvalidConfigurationException
{
String name = prefix + injectionPoint.getProperty();
usedProperties.add(name);

//comment
String value = properties.get(name);
String printableValue = value;
if (attribute.isSecuritySensitive()) {
printableValue = ""[REDACTED]"";
}

if (value == null) {
return null;
}

//comment
<start>Class<?> propertyType = injectionPoint.getSetter().getParameterTypes()[0];<end>

Object finalValue = coerce(propertyType, value);
if (finalValue == null) {
throw new InvalidConfigurationException(format(""Invalid value '%s' for type %s (property '%s') in order to call [%s]"",
printableValue,
propertyType.getName(),
name,
injectionPoint.getSetter().toGenericString()));
}
return finalValue;
}","private Object getInjectedValue(AttributeMetadata attribute, ConfigurationMetadata.InjectionPointMetaData injectionPoint, String prefix)
throws InvalidConfigurationException
{
String name = prefix + injectionPoint.getProperty();
usedProperties.add(name);

//comment
String value = properties.get(name);
String printableValue = value;
if (attribute.isSecuritySensitive()) {
printableValue = ""[REDACTED]"";
}

if (value == null) {
return null;
}

//comment
<start>Class<?> propertyType = injectionPoint.getSetter().getParameterTypes()[0];<end>

Object finalValue = coerce(propertyType, value);
if (finalValue == null) {
throw new InvalidConfigurationException(format(""Invalid value '%s' for type %s (property '%s') in order to call [%s]"",
printableValue,
propertyType.getName(),
name,
injectionPoint.getSetter().toGenericString()));
}
return finalValue;
}"
1820,"    private static Object coerce(Class<?> type, String value)
{
if (type.isPrimitive() && value == null) {
return null;
}

try {
if (String.class == type) {
return value;
}
if (Boolean.class == type || boolean.class == type) {
//comment
if (""true"".equalsIgnoreCase(value)) {
return Boolean.TRUE;
}
if (""false"".equalsIgnoreCase(value)) {
return Boolean.FALSE;
}
return null;
}
if (Byte.class == type || byte.class == type) {
return Byte.valueOf(value);
}
if (Short.class == type || short.class == type) {
return Short.valueOf(value);
}
if (Integer.class == type || int.class == type) {
return Integer.valueOf(value);
}
if (Long.class == type || long.class == type) {
return Long.valueOf(value);
}
if (Float.class == type || float.class == type) {
return Float.valueOf(value);
}
if (Double.class == type || double.class == type) {
return Double.valueOf(value);
}
}
catch (Exception ignored) {
//comment
return null;
}

//comment
//comment
try {
<start>Method fromString = type.getMethod(""fromString"", String.class);<end>
if (fromString.getReturnType().isAssignableFrom(type)) {
try {
return fromString.invoke(null, value);
}
<start>catch (ReflectiveOperationException e) {<end>
return null;
}
}
}
catch (NoSuchMethodException ignored) {
}

if (type.isEnum()) {
try {
return Enum.valueOf(type.asSubclass(Enum.class), value);
}
catch (IllegalArgumentException ignored) {
}
Object match = null;
for (Enum<?> option : type.asSubclass(Enum.class).getEnumConstants()) {
String enumValue = value.replace(""-"", ""_"");
if (option.name().equalsIgnoreCase(enumValue)) {
if (match != null) {
//comment
return null;
}
match = option;
}
}
return match;
}

if (LIST_OF_STRINGS_TYPE_TOKEN.isSubtypeOf(TypeToken.of(type))) {
return VALUE_SPLITTER.splitToStream(value)
.collect(toImmutableList());
}

//comment
try {
Method valueOf = type.getMethod(""valueOf"", String.class);
if (valueOf.getReturnType().isAssignableFrom(type)) {
try {
return valueOf.invoke(null, value);
}
catch (ReflectiveOperationException e) {
return null;
}
}
}
catch (NoSuchMethodException ignored) {
}

//comment
try {
Constructor<?> constructor = type.getConstructor(String.class);
try {
return constructor.newInstance(value);
}
catch (ReflectiveOperationException e) {
return null;
}
}
catch (NoSuchMethodException ignored) {
}

return null;
}","    private static Object coerce(Class<?> type, String value)
{
if (type.isPrimitive() && value == null) {
return null;
}

try {
if (String.class == type) {
return value;
}
if (Boolean.class == type || boolean.class == type) {
//comment
if (""true"".equalsIgnoreCase(value)) {
return Boolean.TRUE;
}
if (""false"".equalsIgnoreCase(value)) {
return Boolean.FALSE;
}
return null;
}
if (Byte.class == type || byte.class == type) {
return Byte.valueOf(value);
}
if (Short.class == type || short.class == type) {
return Short.valueOf(value);
}
if (Integer.class == type || int.class == type) {
return Integer.valueOf(value);
}
if (Long.class == type || long.class == type) {
return Long.valueOf(value);
}
if (Float.class == type || float.class == type) {
return Float.valueOf(value);
}
if (Double.class == type || double.class == type) {
return Double.valueOf(value);
}
}
catch (Exception ignored) {
//comment
return null;
}

//comment
//comment
<start>try {
Method fromString = type.getMethod(""fromString"", String.class);
if (fromString.getReturnType().isAssignableFrom(type)) {
try {
return fromString.invoke(null, value);
}
catch (ReflectiveOperationException e) {
return null;
}
}
}
catch (NoSuchMethodException ignored) {
}<end>

if (type.isEnum()) {
try {
return Enum.valueOf(type.asSubclass(Enum.class), value);
}
catch (IllegalArgumentException ignored) {
}
Object match = null;
for (Enum<?> option : type.asSubclass(Enum.class).getEnumConstants()) {
String enumValue = value.replace(""-"", ""_"");
if (option.name().equalsIgnoreCase(enumValue)) {
if (match != null) {
//comment
return null;
}
match = option;
}
}
return match;
}

if (LIST_OF_STRINGS_TYPE_TOKEN.isSubtypeOf(TypeToken.of(type))) {
return VALUE_SPLITTER.splitToStream(value)
.collect(toImmutableList());
}

//comment
try {
Method valueOf = type.getMethod(""valueOf"", String.class);
if (valueOf.getReturnType().isAssignableFrom(type)) {
try {
return valueOf.invoke(null, value);
}
catch (ReflectiveOperationException e) {
return null;
}
}
}
catch (NoSuchMethodException ignored) {
}

//comment
try {
Constructor<?> constructor = type.getConstructor(String.class);
try {
return constructor.newInstance(value);
}
catch (ReflectiveOperationException e) {
return null;
}
}
catch (NoSuchMethodException ignored) {
}

return null;
}"
1821,"    private static Object coerce(Class<?> type, String value)
{
if (type.isPrimitive() && value == null) {
return null;
}

try {
if (String.class == type) {
return value;
}
if (Boolean.class == type || boolean.class == type) {
//comment
if (""true"".equalsIgnoreCase(value)) {
return Boolean.TRUE;
}
if (""false"".equalsIgnoreCase(value)) {
return Boolean.FALSE;
}
return null;
}
if (Byte.class == type || byte.class == type) {
return Byte.valueOf(value);
}
if (Short.class == type || short.class == type) {
return Short.valueOf(value);
}
if (Integer.class == type || int.class == type) {
return Integer.valueOf(value);
}
if (Long.class == type || long.class == type) {
return Long.valueOf(value);
}
if (Float.class == type || float.class == type) {
return Float.valueOf(value);
}
if (Double.class == type || double.class == type) {
return Double.valueOf(value);
}
}
catch (Exception ignored) {
//comment
return null;
}

//comment
//comment
try {
Method fromString = type.getMethod(""fromString"", String.class);
if (fromString.getReturnType().isAssignableFrom(type)) {
try {
return fromString.invoke(null, value);
}
catch (ReflectiveOperationException e) {
return null;
}
}
}
catch (NoSuchMethodException ignored) {
}

if (type.isEnum()) {
try {
return Enum.valueOf(type.asSubclass(Enum.class), value);
}
catch (IllegalArgumentException ignored) {
}
Object match = null;
for (Enum<?> option : type.asSubclass(Enum.class).getEnumConstants()) {
String enumValue = value.replace(""-"", ""_"");
if (option.name().equalsIgnoreCase(enumValue)) {
if (match != null) {
//comment
return null;
}
match = option;
}
}
return match;
}

if (LIST_OF_STRINGS_TYPE_TOKEN.isSubtypeOf(TypeToken.of(type))) {
return VALUE_SPLITTER.splitToStream(value)
.collect(toImmutableList());
}

//comment
try {
<start>Method valueOf = type.getMethod(""valueOf"", String.class);<end>
if (valueOf.getReturnType().isAssignableFrom(type)) {
try {
<start>return valueOf.invoke(null, value);<end>
}
catch (ReflectiveOperationException e) {
return null;
}
}
}
catch (NoSuchMethodException ignored) {
}

//comment
try {
Constructor<?> constructor = type.getConstructor(String.class);
try {
return constructor.newInstance(value);
}
catch (ReflectiveOperationException e) {
return null;
}
}
catch (NoSuchMethodException ignored) {
}

return null;
}","    private static Object coerce(Class<?> type, String value)
{
if (type.isPrimitive() && value == null) {
return null;
}

try {
if (String.class == type) {
return value;
}
if (Boolean.class == type || boolean.class == type) {
//comment
if (""true"".equalsIgnoreCase(value)) {
return Boolean.TRUE;
}
if (""false"".equalsIgnoreCase(value)) {
return Boolean.FALSE;
}
return null;
}
if (Byte.class == type || byte.class == type) {
return Byte.valueOf(value);
}
if (Short.class == type || short.class == type) {
return Short.valueOf(value);
}
if (Integer.class == type || int.class == type) {
return Integer.valueOf(value);
}
if (Long.class == type || long.class == type) {
return Long.valueOf(value);
}
if (Float.class == type || float.class == type) {
return Float.valueOf(value);
}
if (Double.class == type || double.class == type) {
return Double.valueOf(value);
}
}
catch (Exception ignored) {
//comment
return null;
}

//comment
//comment
try {
Method fromString = type.getMethod(""fromString"", String.class);
if (fromString.getReturnType().isAssignableFrom(type)) {
try {
return fromString.invoke(null, value);
}
catch (ReflectiveOperationException e) {
return null;
}
}
}
catch (NoSuchMethodException ignored) {
}

if (type.isEnum()) {
try {
return Enum.valueOf(type.asSubclass(Enum.class), value);
}
catch (IllegalArgumentException ignored) {
}
Object match = null;
for (Enum<?> option : type.asSubclass(Enum.class).getEnumConstants()) {
String enumValue = value.replace(""-"", ""_"");
if (option.name().equalsIgnoreCase(enumValue)) {
if (match != null) {
//comment
return null;
}
match = option;
}
}
return match;
}

if (LIST_OF_STRINGS_TYPE_TOKEN.isSubtypeOf(TypeToken.of(type))) {
return VALUE_SPLITTER.splitToStream(value)
.collect(toImmutableList());
}

//comment
<start>try {
Method valueOf = type.getMethod(""valueOf"", String.class);
if (valueOf.getReturnType().isAssignableFrom(type)) {
try {
return valueOf.invoke(null, value);
}
catch (ReflectiveOperationException e) {
return null;
}
}
}
catch (NoSuchMethodException ignored) {
}<end>

//comment
try {
Constructor<?> constructor = type.getConstructor(String.class);
try {
return constructor.newInstance(value);
}
catch (ReflectiveOperationException e) {
return null;
}
}
catch (NoSuchMethodException ignored) {
}

return null;
}"
1822,"    private static Object coerce(Class<?> type, String value)
{
if (type.isPrimitive() && value == null) {
return null;
}

try {
if (String.class == type) {
return value;
}
if (Boolean.class == type || boolean.class == type) {
//comment
if (""true"".equalsIgnoreCase(value)) {
return Boolean.TRUE;
}
if (""false"".equalsIgnoreCase(value)) {
return Boolean.FALSE;
}
return null;
}
if (Byte.class == type || byte.class == type) {
return Byte.valueOf(value);
}
if (Short.class == type || short.class == type) {
return Short.valueOf(value);
}
if (Integer.class == type || int.class == type) {
return Integer.valueOf(value);
}
if (Long.class == type || long.class == type) {
return Long.valueOf(value);
}
if (Float.class == type || float.class == type) {
return Float.valueOf(value);
}
if (Double.class == type || double.class == type) {
return Double.valueOf(value);
}
}
catch (Exception ignored) {
//comment
return null;
}

//comment
//comment
try {
Method fromString = type.getMethod(""fromString"", String.class);
if (fromString.getReturnType().isAssignableFrom(type)) {
try {
return fromString.invoke(null, value);
}
catch (ReflectiveOperationException e) {
return null;
}
}
}
catch (NoSuchMethodException ignored) {
}

if (type.isEnum()) {
try {
return Enum.valueOf(type.asSubclass(Enum.class), value);
}
catch (IllegalArgumentException ignored) {
}
Object match = null;
for (Enum<?> option : type.asSubclass(Enum.class).getEnumConstants()) {
String enumValue = value.replace(""-"", ""_"");
if (option.name().equalsIgnoreCase(enumValue)) {
if (match != null) {
//comment
return null;
}
match = option;
}
}
return match;
}

if (LIST_OF_STRINGS_TYPE_TOKEN.isSubtypeOf(TypeToken.of(type))) {
return VALUE_SPLITTER.splitToStream(value)
.collect(toImmutableList());
}

//comment
try {
Method valueOf = type.getMethod(""valueOf"", String.class);
if (valueOf.getReturnType().isAssignableFrom(type)) {
try {
return valueOf.invoke(null, value);
}
catch (ReflectiveOperationException e) {
return null;
}
}
}
catch (NoSuchMethodException ignored) {
}

//comment
try {
<start>Constructor<?> constructor = type.getConstructor(String.class);<end>
try {
return constructor.newInstance(value);
}
<start>catch (ReflectiveOperationException e) {<end>
return null;
}
}
catch (NoSuchMethodException ignored) {
}

return null;
}","    private static Object coerce(Class<?> type, String value)
{
if (type.isPrimitive() && value == null) {
return null;
}

try {
if (String.class == type) {
return value;
}
if (Boolean.class == type || boolean.class == type) {
//comment
if (""true"".equalsIgnoreCase(value)) {
return Boolean.TRUE;
}
if (""false"".equalsIgnoreCase(value)) {
return Boolean.FALSE;
}
return null;
}
if (Byte.class == type || byte.class == type) {
return Byte.valueOf(value);
}
if (Short.class == type || short.class == type) {
return Short.valueOf(value);
}
if (Integer.class == type || int.class == type) {
return Integer.valueOf(value);
}
if (Long.class == type || long.class == type) {
return Long.valueOf(value);
}
if (Float.class == type || float.class == type) {
return Float.valueOf(value);
}
if (Double.class == type || double.class == type) {
return Double.valueOf(value);
}
}
catch (Exception ignored) {
//comment
return null;
}

//comment
//comment
try {
Method fromString = type.getMethod(""fromString"", String.class);
if (fromString.getReturnType().isAssignableFrom(type)) {
try {
return fromString.invoke(null, value);
}
catch (ReflectiveOperationException e) {
return null;
}
}
}
catch (NoSuchMethodException ignored) {
}

if (type.isEnum()) {
try {
return Enum.valueOf(type.asSubclass(Enum.class), value);
}
catch (IllegalArgumentException ignored) {
}
Object match = null;
for (Enum<?> option : type.asSubclass(Enum.class).getEnumConstants()) {
String enumValue = value.replace(""-"", ""_"");
if (option.name().equalsIgnoreCase(enumValue)) {
if (match != null) {
//comment
return null;
}
match = option;
}
}
return match;
}

if (LIST_OF_STRINGS_TYPE_TOKEN.isSubtypeOf(TypeToken.of(type))) {
return VALUE_SPLITTER.splitToStream(value)
.collect(toImmutableList());
}

//comment
try {
Method valueOf = type.getMethod(""valueOf"", String.class);
if (valueOf.getReturnType().isAssignableFrom(type)) {
try {
return valueOf.invoke(null, value);
}
catch (ReflectiveOperationException e) {
return null;
}
}
}
catch (NoSuchMethodException ignored) {
}

//comment
<start>try {
Constructor<?> constructor = type.getConstructor(String.class);
try {
return constructor.newInstance(value);
}
catch (ReflectiveOperationException e) {
return null;
}
}
catch (NoSuchMethodException ignored) {
}<end>

return null;
}"
2968,"    private Map<String, AttributeMetadata> buildAttributeMetadata(Class<T> configClass)
{
Map<String, AttributeMetadata> attributes = new HashMap<>();
<start>for (Method configMethod : findConfigMethods(configClass)) {
AttributeMetadata attribute = buildAttributeMetadata(configClass, configMethod);

if (attribute != null) {
if (attributes.containsKey(attribute.getName())) {
problems.addError(""Configuration class [%s] Multiple methods are annotated for @Config attribute [%s]"", configClass.getName(), attribute.getName());
}
attributes.put(attribute.getName(), attribute);
}
}<end>

//comment
<start>Collection<Method> legacyMethods = findLegacyConfigMethods(configClass);<end>
for (AttributeMetadata attribute : attributes.values()) {
for (InjectionPointMetaData injectionPoint : attribute.getLegacyInjectionPoints()) {
if (legacyMethods.contains(injectionPoint.getSetter())) {
//comment
legacyMethods.remove(injectionPoint.getSetter());
}
}
}
for (Method method : legacyMethods) {
if (!method.isAnnotationPresent(Config.class)) {
validateSetter(method);
problems.addError(""@LegacyConfig method [%s] is not associated with any valid @Config attribute."", method.toGenericString());
}
}

//comment
Collection<Method> sensitiveMethods = findSensitiveConfigMethods(configClass);
for (Method method : sensitiveMethods) {
if (!method.isAnnotationPresent(Config.class)) {
problems.addError(""@ConfigSecuritySensitive method [%s] is not annotated with @Config."", method.toGenericString());
}
}

//comment
Collection<Method> hiddenMethods = findHiddenConfigMethods(configClass);
for (Method method : hiddenMethods) {
if (!method.isAnnotationPresent(Config.class)) {
problems.addError(""@ConfigHidden method [%s] is not annotated with @Config."", method.toGenericString());
}
}

return attributes;
}","    private Map<String, AttributeMetadata> buildAttributeMetadata(Class<T> configClass)
{
Map<String, AttributeMetadata> attributes = new HashMap<>();
for (Method configMethod : findConfigMethods(configClass)) {
AttributeMetadata attribute = buildAttributeMetadata(configClass, configMethod);

if (attribute != null) {
if (attributes.containsKey(attribute.getName())) {
problems.addError(""Configuration class [%s] Multiple methods are annotated for @Config attribute [%s]"", configClass.getName(), attribute.getName());
}
attributes.put(attribute.getName(), attribute);
}
}

//comment
<start>Collection<Method> legacyMethods = findLegacyConfigMethods(configClass);
for (AttributeMetadata attribute : attributes.values()) {
for (InjectionPointMetaData injectionPoint : attribute.getLegacyInjectionPoints()) {
if (legacyMethods.contains(injectionPoint.getSetter())) {
//comment
legacyMethods.remove(injectionPoint.getSetter());
}
}
}<end>
for (Method method : legacyMethods) {
if (!method.isAnnotationPresent(Config.class)) {
validateSetter(method);
problems.addError(""@LegacyConfig method [%s] is not associated with any valid @Config attribute."", method.toGenericString());
}
}

//comment
Collection<Method> sensitiveMethods = findSensitiveConfigMethods(configClass);
for (Method method : sensitiveMethods) {
if (!method.isAnnotationPresent(Config.class)) {
problems.addError(""@ConfigSecuritySensitive method [%s] is not annotated with @Config."", method.toGenericString());
}
}

//comment
Collection<Method> hiddenMethods = findHiddenConfigMethods(configClass);
for (Method method : hiddenMethods) {
if (!method.isAnnotationPresent(Config.class)) {
problems.addError(""@ConfigHidden method [%s] is not annotated with @Config."", method.toGenericString());
}
}

return attributes;
}"
2969,"    private Map<String, AttributeMetadata> buildAttributeMetadata(Class<T> configClass)
{
Map<String, AttributeMetadata> attributes = new HashMap<>();
for (Method configMethod : findConfigMethods(configClass)) {
AttributeMetadata attribute = buildAttributeMetadata(configClass, configMethod);

if (attribute != null) {
if (attributes.containsKey(attribute.getName())) {
problems.addError(""Configuration class [%s] Multiple methods are annotated for @Config attribute [%s]"", configClass.getName(), attribute.getName());
}
attributes.put(attribute.getName(), attribute);
}
}

//comment
Collection<Method> legacyMethods = findLegacyConfigMethods(configClass);
for (AttributeMetadata attribute : attributes.values()) {
for (InjectionPointMetaData injectionPoint : attribute.getLegacyInjectionPoints()) {
if (legacyMethods.contains(injectionPoint.getSetter())) {
//comment
legacyMethods.remove(injectionPoint.getSetter());
}
}
}
<start>for (Method method : legacyMethods) {
if (!method.isAnnotationPresent(Config.class)) {
validateSetter(method);
problems.addError(""@LegacyConfig method [%s] is not associated with any valid @Config attribute."", method.toGenericString());
}
}<end>

//comment
<start>Collection<Method> sensitiveMethods = findSensitiveConfigMethods(configClass);
for (Method method : sensitiveMethods) {
if (!method.isAnnotationPresent(Config.class)) {
problems.addError(""@ConfigSecuritySensitive method [%s] is not annotated with @Config."", method.toGenericString());
}
}<end>

//comment
Collection<Method> hiddenMethods = findHiddenConfigMethods(configClass);
for (Method method : hiddenMethods) {
if (!method.isAnnotationPresent(Config.class)) {
problems.addError(""@ConfigHidden method [%s] is not annotated with @Config."", method.toGenericString());
}
}

return attributes;
}","    private Map<String, AttributeMetadata> buildAttributeMetadata(Class<T> configClass)
{
Map<String, AttributeMetadata> attributes = new HashMap<>();
for (Method configMethod : findConfigMethods(configClass)) {
AttributeMetadata attribute = buildAttributeMetadata(configClass, configMethod);

if (attribute != null) {
if (attributes.containsKey(attribute.getName())) {
problems.addError(""Configuration class [%s] Multiple methods are annotated for @Config attribute [%s]"", configClass.getName(), attribute.getName());
}
attributes.put(attribute.getName(), attribute);
}
}

//comment
Collection<Method> legacyMethods = findLegacyConfigMethods(configClass);
for (AttributeMetadata attribute : attributes.values()) {
for (InjectionPointMetaData injectionPoint : attribute.getLegacyInjectionPoints()) {
if (legacyMethods.contains(injectionPoint.getSetter())) {
//comment
legacyMethods.remove(injectionPoint.getSetter());
}
}
}
for (Method method : legacyMethods) {
if (!method.isAnnotationPresent(Config.class)) {
validateSetter(method);
problems.addError(""@LegacyConfig method [%s] is not associated with any valid @Config attribute."", method.toGenericString());
}
}

//comment
<start>Collection<Method> sensitiveMethods = findSensitiveConfigMethods(configClass);
for (Method method : sensitiveMethods) {
if (!method.isAnnotationPresent(Config.class)) {
problems.addError(""@ConfigSecuritySensitive method [%s] is not annotated with @Config."", method.toGenericString());
}
}<end>

//comment
Collection<Method> hiddenMethods = findHiddenConfigMethods(configClass);
for (Method method : hiddenMethods) {
if (!method.isAnnotationPresent(Config.class)) {
problems.addError(""@ConfigHidden method [%s] is not annotated with @Config."", method.toGenericString());
}
}

return attributes;
}"
2970,"private AttributeMetadata buildAttributeMetadata(Class<T> configClass, Method configMethod)
{
checkArgument(configMethod.isAnnotationPresent(Config.class));

if (!validateAnnotations(configMethod)) {
return null;
}

String propertyName = configMethod.getAnnotation(Config.class).value();
final boolean securitySensitive = configMethod.isAnnotationPresent(ConfigSecuritySensitive.class);
final boolean hidden = configMethod.isAnnotationPresent(ConfigHidden.class);

//comment
<start>if (!validateSetter(configMethod)) {
return null;
}<end>

//comment
String attributeName = configMethod.getName().substring(3);

AttributeMetaDataBuilder builder = new AttributeMetaDataBuilder(configClass, attributeName, securitySensitive, hidden);

if (configMethod.isAnnotationPresent(ConfigDescription.class)) {
builder.setDescription(configMethod.getAnnotation(ConfigDescription.class).value());
}

//comment
Method getter = findGetter(configClass, configMethod, attributeName);
if (getter != null) {
builder.setGetter(getter);

if (configMethod.isAnnotationPresent(Deprecated.class) != getter.isAnnotationPresent(Deprecated.class)) {
problems.addError(""Methods [%s] and [%s] must be @Deprecated together"", configMethod, getter);
}
}

if (defunctConfig.contains(propertyName)) {
problems.addError(""@Config property '%s' on method [%s] is defunct on class [%s]"", propertyName, configMethod, configClass);
}

//comment
builder.addInjectionPoint(InjectionPointMetaData.newCurrent(configClass, propertyName, configMethod));

//comment
for (InjectionPointMetaData injectionPoint : findLegacySetters(configClass, propertyName, attributeName)) {
if (!injectionPoint.getSetter().isAnnotationPresent(Config.class) && !injectionPoint.getSetter().isAnnotationPresent(Deprecated.class)) {
problems.addWarning(""Replaced @LegacyConfig method [%s] should be @Deprecated"", injectionPoint.getSetter().toGenericString());
}

builder.addInjectionPoint(injectionPoint);
}

return builder.build();
}","private AttributeMetadata buildAttributeMetadata(Class<T> configClass, Method configMethod)
{
checkArgument(configMethod.isAnnotationPresent(Config.class));

if (!validateAnnotations(configMethod)) {
return null;
}

String propertyName = configMethod.getAnnotation(Config.class).value();
final boolean securitySensitive = configMethod.isAnnotationPresent(ConfigSecuritySensitive.class);
final boolean hidden = configMethod.isAnnotationPresent(ConfigHidden.class);

//comment
<start>if (!validateSetter(configMethod)) {
return null;
}<end>

//comment
String attributeName = configMethod.getName().substring(3);

AttributeMetaDataBuilder builder = new AttributeMetaDataBuilder(configClass, attributeName, securitySensitive, hidden);

if (configMethod.isAnnotationPresent(ConfigDescription.class)) {
builder.setDescription(configMethod.getAnnotation(ConfigDescription.class).value());
}

//comment
Method getter = findGetter(configClass, configMethod, attributeName);
if (getter != null) {
builder.setGetter(getter);

if (configMethod.isAnnotationPresent(Deprecated.class) != getter.isAnnotationPresent(Deprecated.class)) {
problems.addError(""Methods [%s] and [%s] must be @Deprecated together"", configMethod, getter);
}
}

if (defunctConfig.contains(propertyName)) {
problems.addError(""@Config property '%s' on method [%s] is defunct on class [%s]"", propertyName, configMethod, configClass);
}

//comment
builder.addInjectionPoint(InjectionPointMetaData.newCurrent(configClass, propertyName, configMethod));

//comment
for (InjectionPointMetaData injectionPoint : findLegacySetters(configClass, propertyName, attributeName)) {
if (!injectionPoint.getSetter().isAnnotationPresent(Config.class) && !injectionPoint.getSetter().isAnnotationPresent(Deprecated.class)) {
problems.addWarning(""Replaced @LegacyConfig method [%s] should be @Deprecated"", injectionPoint.getSetter().toGenericString());
}

builder.addInjectionPoint(injectionPoint);
}

return builder.build();
}"
2971,"private AttributeMetadata buildAttributeMetadata(Class<T> configClass, Method configMethod)
{
checkArgument(configMethod.isAnnotationPresent(Config.class));

if (!validateAnnotations(configMethod)) {
return null;
}

String propertyName = configMethod.getAnnotation(Config.class).value();
final boolean securitySensitive = configMethod.isAnnotationPresent(ConfigSecuritySensitive.class);
final boolean hidden = configMethod.isAnnotationPresent(ConfigHidden.class);

//comment
if (!validateSetter(configMethod)) {
return null;
}

//comment
<start>String attributeName = configMethod.getName().substring(3);<end>

AttributeMetaDataBuilder builder = new AttributeMetaDataBuilder(configClass, attributeName, securitySensitive, hidden);

if (configMethod.isAnnotationPresent(ConfigDescription.class)) {
builder.setDescription(configMethod.getAnnotation(ConfigDescription.class).value());
}

//comment
Method getter = findGetter(configClass, configMethod, attributeName);
if (getter != null) {
builder.setGetter(getter);

if (configMethod.isAnnotationPresent(Deprecated.class) != getter.isAnnotationPresent(Deprecated.class)) {
problems.addError(""Methods [%s] and [%s] must be @Deprecated together"", configMethod, getter);
}
}

if (defunctConfig.contains(propertyName)) {
problems.addError(""@Config property '%s' on method [%s] is defunct on class [%s]"", propertyName, configMethod, configClass);
}

//comment
builder.addInjectionPoint(InjectionPointMetaData.newCurrent(configClass, propertyName, configMethod));

//comment
for (InjectionPointMetaData injectionPoint : findLegacySetters(configClass, propertyName, attributeName)) {
if (!injectionPoint.getSetter().isAnnotationPresent(Config.class) && !injectionPoint.getSetter().isAnnotationPresent(Deprecated.class)) {
problems.addWarning(""Replaced @LegacyConfig method [%s] should be @Deprecated"", injectionPoint.getSetter().toGenericString());
}

builder.addInjectionPoint(injectionPoint);
}

return builder.build();
}","private AttributeMetadata buildAttributeMetadata(Class<T> configClass, Method configMethod)
{
checkArgument(configMethod.isAnnotationPresent(Config.class));

if (!validateAnnotations(configMethod)) {
return null;
}

String propertyName = configMethod.getAnnotation(Config.class).value();
final boolean securitySensitive = configMethod.isAnnotationPresent(ConfigSecuritySensitive.class);
final boolean hidden = configMethod.isAnnotationPresent(ConfigHidden.class);

//comment
if (!validateSetter(configMethod)) {
return null;
}

//comment
<start>String attributeName = configMethod.getName().substring(3);<end>

AttributeMetaDataBuilder builder = new AttributeMetaDataBuilder(configClass, attributeName, securitySensitive, hidden);

if (configMethod.isAnnotationPresent(ConfigDescription.class)) {
builder.setDescription(configMethod.getAnnotation(ConfigDescription.class).value());
}

//comment
Method getter = findGetter(configClass, configMethod, attributeName);
if (getter != null) {
builder.setGetter(getter);

if (configMethod.isAnnotationPresent(Deprecated.class) != getter.isAnnotationPresent(Deprecated.class)) {
problems.addError(""Methods [%s] and [%s] must be @Deprecated together"", configMethod, getter);
}
}

if (defunctConfig.contains(propertyName)) {
problems.addError(""@Config property '%s' on method [%s] is defunct on class [%s]"", propertyName, configMethod, configClass);
}

//comment
builder.addInjectionPoint(InjectionPointMetaData.newCurrent(configClass, propertyName, configMethod));

//comment
for (InjectionPointMetaData injectionPoint : findLegacySetters(configClass, propertyName, attributeName)) {
if (!injectionPoint.getSetter().isAnnotationPresent(Config.class) && !injectionPoint.getSetter().isAnnotationPresent(Deprecated.class)) {
problems.addWarning(""Replaced @LegacyConfig method [%s] should be @Deprecated"", injectionPoint.getSetter().toGenericString());
}

builder.addInjectionPoint(injectionPoint);
}

return builder.build();
}"
2972,"private AttributeMetadata buildAttributeMetadata(Class<T> configClass, Method configMethod)
{
checkArgument(configMethod.isAnnotationPresent(Config.class));

if (!validateAnnotations(configMethod)) {
return null;
}

String propertyName = configMethod.getAnnotation(Config.class).value();
final boolean securitySensitive = configMethod.isAnnotationPresent(ConfigSecuritySensitive.class);
final boolean hidden = configMethod.isAnnotationPresent(ConfigHidden.class);

//comment
if (!validateSetter(configMethod)) {
return null;
}

//comment
String attributeName = configMethod.getName().substring(3);

AttributeMetaDataBuilder builder = new AttributeMetaDataBuilder(configClass, attributeName, securitySensitive, hidden);

if (configMethod.isAnnotationPresent(ConfigDescription.class)) {
builder.setDescription(configMethod.getAnnotation(ConfigDescription.class).value());
}

//comment
<start>Method getter = findGetter(configClass, configMethod, attributeName);<end>
if (getter != null) {
builder.setGetter(getter);

if (configMethod.isAnnotationPresent(Deprecated.class) != getter.isAnnotationPresent(Deprecated.class)) {
problems.addError(""Methods [%s] and [%s] must be @Deprecated together"", configMethod, getter);
}
}

if (defunctConfig.contains(propertyName)) {
problems.addError(""@Config property '%s' on method [%s] is defunct on class [%s]"", propertyName, configMethod, configClass);
}

//comment
builder.addInjectionPoint(InjectionPointMetaData.newCurrent(configClass, propertyName, configMethod));

//comment
for (InjectionPointMetaData injectionPoint : findLegacySetters(configClass, propertyName, attributeName)) {
if (!injectionPoint.getSetter().isAnnotationPresent(Config.class) && !injectionPoint.getSetter().isAnnotationPresent(Deprecated.class)) {
problems.addWarning(""Replaced @LegacyConfig method [%s] should be @Deprecated"", injectionPoint.getSetter().toGenericString());
}

builder.addInjectionPoint(injectionPoint);
}

return builder.build();
}","private AttributeMetadata buildAttributeMetadata(Class<T> configClass, Method configMethod)
{
checkArgument(configMethod.isAnnotationPresent(Config.class));

if (!validateAnnotations(configMethod)) {
return null;
}

String propertyName = configMethod.getAnnotation(Config.class).value();
final boolean securitySensitive = configMethod.isAnnotationPresent(ConfigSecuritySensitive.class);
final boolean hidden = configMethod.isAnnotationPresent(ConfigHidden.class);

//comment
if (!validateSetter(configMethod)) {
return null;
}

//comment
String attributeName = configMethod.getName().substring(3);

AttributeMetaDataBuilder builder = new AttributeMetaDataBuilder(configClass, attributeName, securitySensitive, hidden);

if (configMethod.isAnnotationPresent(ConfigDescription.class)) {
builder.setDescription(configMethod.getAnnotation(ConfigDescription.class).value());
}

//comment
<start>Method getter = findGetter(configClass, configMethod, attributeName);
if (getter != null) {
builder.setGetter(getter);<end>

<start>if (configMethod.isAnnotationPresent(Deprecated.class) != getter.isAnnotationPresent(Deprecated.class)) {
problems.addError(""Methods [%s] and [%s] must be @Deprecated together"", configMethod, getter);
}
}<end>

if (defunctConfig.contains(propertyName)) {
problems.addError(""@Config property '%s' on method [%s] is defunct on class [%s]"", propertyName, configMethod, configClass);
}

//comment
builder.addInjectionPoint(InjectionPointMetaData.newCurrent(configClass, propertyName, configMethod));

//comment
for (InjectionPointMetaData injectionPoint : findLegacySetters(configClass, propertyName, attributeName)) {
if (!injectionPoint.getSetter().isAnnotationPresent(Config.class) && !injectionPoint.getSetter().isAnnotationPresent(Deprecated.class)) {
problems.addWarning(""Replaced @LegacyConfig method [%s] should be @Deprecated"", injectionPoint.getSetter().toGenericString());
}

builder.addInjectionPoint(injectionPoint);
}

return builder.build();
}"
2973,"private AttributeMetadata buildAttributeMetadata(Class<T> configClass, Method configMethod)
{
checkArgument(configMethod.isAnnotationPresent(Config.class));

if (!validateAnnotations(configMethod)) {
return null;
}

String propertyName = configMethod.getAnnotation(Config.class).value();
final boolean securitySensitive = configMethod.isAnnotationPresent(ConfigSecuritySensitive.class);
final boolean hidden = configMethod.isAnnotationPresent(ConfigHidden.class);

//comment
if (!validateSetter(configMethod)) {
return null;
}

//comment
String attributeName = configMethod.getName().substring(3);

AttributeMetaDataBuilder builder = new AttributeMetaDataBuilder(configClass, attributeName, securitySensitive, hidden);

if (configMethod.isAnnotationPresent(ConfigDescription.class)) {
builder.setDescription(configMethod.getAnnotation(ConfigDescription.class).value());
}

//comment
Method getter = findGetter(configClass, configMethod, attributeName);
if (getter != null) {
builder.setGetter(getter);

if (configMethod.isAnnotationPresent(Deprecated.class) != getter.isAnnotationPresent(Deprecated.class)) {
problems.addError(""Methods [%s] and [%s] must be @Deprecated together"", configMethod, getter);
}
}

if (defunctConfig.contains(propertyName)) {
problems.addError(""@Config property '%s' on method [%s] is defunct on class [%s]"", propertyName, configMethod, configClass);
}

//comment
<start>builder.addInjectionPoint(InjectionPointMetaData.newCurrent(configClass, propertyName, configMethod));<end>

//comment
for (InjectionPointMetaData injectionPoint : findLegacySetters(configClass, propertyName, attributeName)) {
if (!injectionPoint.getSetter().isAnnotationPresent(Config.class) && !injectionPoint.getSetter().isAnnotationPresent(Deprecated.class)) {
problems.addWarning(""Replaced @LegacyConfig method [%s] should be @Deprecated"", injectionPoint.getSetter().toGenericString());
}

builder.addInjectionPoint(injectionPoint);
}

return builder.build();
}","private AttributeMetadata buildAttributeMetadata(Class<T> configClass, Method configMethod)
{
checkArgument(configMethod.isAnnotationPresent(Config.class));

if (!validateAnnotations(configMethod)) {
return null;
}

String propertyName = configMethod.getAnnotation(Config.class).value();
final boolean securitySensitive = configMethod.isAnnotationPresent(ConfigSecuritySensitive.class);
final boolean hidden = configMethod.isAnnotationPresent(ConfigHidden.class);

//comment
if (!validateSetter(configMethod)) {
return null;
}

//comment
String attributeName = configMethod.getName().substring(3);

AttributeMetaDataBuilder builder = new AttributeMetaDataBuilder(configClass, attributeName, securitySensitive, hidden);

if (configMethod.isAnnotationPresent(ConfigDescription.class)) {
builder.setDescription(configMethod.getAnnotation(ConfigDescription.class).value());
}

//comment
Method getter = findGetter(configClass, configMethod, attributeName);
if (getter != null) {
builder.setGetter(getter);

if (configMethod.isAnnotationPresent(Deprecated.class) != getter.isAnnotationPresent(Deprecated.class)) {
problems.addError(""Methods [%s] and [%s] must be @Deprecated together"", configMethod, getter);
}
}

if (defunctConfig.contains(propertyName)) {
problems.addError(""@Config property '%s' on method [%s] is defunct on class [%s]"", propertyName, configMethod, configClass);
}

//comment
<start>builder.addInjectionPoint(InjectionPointMetaData.newCurrent(configClass, propertyName, configMethod));<end>

//comment
for (InjectionPointMetaData injectionPoint : findLegacySetters(configClass, propertyName, attributeName)) {
if (!injectionPoint.getSetter().isAnnotationPresent(Config.class) && !injectionPoint.getSetter().isAnnotationPresent(Deprecated.class)) {
problems.addWarning(""Replaced @LegacyConfig method [%s] should be @Deprecated"", injectionPoint.getSetter().toGenericString());
}

builder.addInjectionPoint(injectionPoint);
}

return builder.build();
}"
2974,"private AttributeMetadata buildAttributeMetadata(Class<T> configClass, Method configMethod)
{
checkArgument(configMethod.isAnnotationPresent(Config.class));

if (!validateAnnotations(configMethod)) {
return null;
}

String propertyName = configMethod.getAnnotation(Config.class).value();
final boolean securitySensitive = configMethod.isAnnotationPresent(ConfigSecuritySensitive.class);
final boolean hidden = configMethod.isAnnotationPresent(ConfigHidden.class);

//comment
if (!validateSetter(configMethod)) {
return null;
}

//comment
String attributeName = configMethod.getName().substring(3);

AttributeMetaDataBuilder builder = new AttributeMetaDataBuilder(configClass, attributeName, securitySensitive, hidden);

if (configMethod.isAnnotationPresent(ConfigDescription.class)) {
builder.setDescription(configMethod.getAnnotation(ConfigDescription.class).value());
}

//comment
Method getter = findGetter(configClass, configMethod, attributeName);
if (getter != null) {
builder.setGetter(getter);

if (configMethod.isAnnotationPresent(Deprecated.class) != getter.isAnnotationPresent(Deprecated.class)) {
problems.addError(""Methods [%s] and [%s] must be @Deprecated together"", configMethod, getter);
}
}

if (defunctConfig.contains(propertyName)) {
problems.addError(""@Config property '%s' on method [%s] is defunct on class [%s]"", propertyName, configMethod, configClass);
}

//comment
builder.addInjectionPoint(InjectionPointMetaData.newCurrent(configClass, propertyName, configMethod));

//comment
for (InjectionPointMetaData injectionPoint : findLegacySetters(configClass, propertyName, attributeName)) {
if (!injectionPoint.getSetter().isAnnotationPresent(Config.class) && !injectionPoint.getSetter().isAnnotationPresent(Deprecated.class)) {
<start>problems.addWarning(""Replaced @LegacyConfig method [%s] should be @Deprecated"", injectionPoint.getSetter().toGenericString());<end>
}

builder.addInjectionPoint(injectionPoint);
}

return builder.build();
}","private AttributeMetadata buildAttributeMetadata(Class<T> configClass, Method configMethod)
{
checkArgument(configMethod.isAnnotationPresent(Config.class));

if (!validateAnnotations(configMethod)) {
return null;
}

String propertyName = configMethod.getAnnotation(Config.class).value();
final boolean securitySensitive = configMethod.isAnnotationPresent(ConfigSecuritySensitive.class);
final boolean hidden = configMethod.isAnnotationPresent(ConfigHidden.class);

//comment
if (!validateSetter(configMethod)) {
return null;
}

//comment
String attributeName = configMethod.getName().substring(3);

AttributeMetaDataBuilder builder = new AttributeMetaDataBuilder(configClass, attributeName, securitySensitive, hidden);

if (configMethod.isAnnotationPresent(ConfigDescription.class)) {
builder.setDescription(configMethod.getAnnotation(ConfigDescription.class).value());
}

//comment
Method getter = findGetter(configClass, configMethod, attributeName);
if (getter != null) {
builder.setGetter(getter);

if (configMethod.isAnnotationPresent(Deprecated.class) != getter.isAnnotationPresent(Deprecated.class)) {
problems.addError(""Methods [%s] and [%s] must be @Deprecated together"", configMethod, getter);
}
}

if (defunctConfig.contains(propertyName)) {
problems.addError(""@Config property '%s' on method [%s] is defunct on class [%s]"", propertyName, configMethod, configClass);
}

//comment
builder.addInjectionPoint(InjectionPointMetaData.newCurrent(configClass, propertyName, configMethod));

//comment
<start>for (InjectionPointMetaData injectionPoint : findLegacySetters(configClass, propertyName, attributeName)) {
if (!injectionPoint.getSetter().isAnnotationPresent(Config.class) && !injectionPoint.getSetter().isAnnotationPresent(Deprecated.class)) {
problems.addWarning(""Replaced @LegacyConfig method [%s] should be @Deprecated"", injectionPoint.getSetter().toGenericString());
}

builder.addInjectionPoint(injectionPoint);
}<end>

return builder.build();
}"
2975,"    private static Collection<Method> findAnnotatedMethods(Class<?> configClass, Class<? extends java.lang.annotation.Annotation> annotation)
{
List<Method> result = new ArrayList<>();

//comment
//comment
for (Method method : configClass.getMethods()) {
//comment
if (method.isSynthetic() || method.isBridge() || Modifier.isStatic(method.getModifiers())) {
<start>continue;<end>
}

//comment
Method managedMethod = findAnnotatedMethod(configClass, annotation, method.getName(), method.getParameterTypes());
if (managedMethod != null) {
result.add(managedMethod);
}
}

return result;
}","    private static Collection<Method> findAnnotatedMethods(Class<?> configClass, Class<? extends java.lang.annotation.Annotation> annotation)
{
List<Method> result = new ArrayList<>();

//comment
//comment
<start>for (Method method : configClass.getMethods()) {
//comment
if (method.isSynthetic() || method.isBridge() || Modifier.isStatic(method.getModifiers())) {
continue;
}<end>

//comment
<start>Method managedMethod = findAnnotatedMethod(configClass, annotation, method.getName(), method.getParameterTypes());
if (managedMethod != null) {
result.add(managedMethod);
}
}<end>

return result;
}"
2976,"    private static Collection<Method> findAnnotatedMethods(Class<?> configClass, Class<? extends java.lang.annotation.Annotation> annotation)
{
List<Method> result = new ArrayList<>();

//comment
//comment
for (Method method : configClass.getMethods()) {
//comment
<start>if (method.isSynthetic() || method.isBridge() || Modifier.isStatic(method.getModifiers())) {
continue;
}<end>

//comment
Method managedMethod = findAnnotatedMethod(configClass, annotation, method.getName(), method.getParameterTypes());
if (managedMethod != null) {
result.add(managedMethod);
}
}

return result;
}","    private static Collection<Method> findAnnotatedMethods(Class<?> configClass, Class<? extends java.lang.annotation.Annotation> annotation)
{
List<Method> result = new ArrayList<>();

//comment
//comment
for (Method method : configClass.getMethods()) {
//comment
<start>if (method.isSynthetic() || method.isBridge() || Modifier.isStatic(method.getModifiers())) {
continue;
}<end>

//comment
Method managedMethod = findAnnotatedMethod(configClass, annotation, method.getName(), method.getParameterTypes());
if (managedMethod != null) {
result.add(managedMethod);
}
}

return result;
}"
2977,"    private static Collection<Method> findAnnotatedMethods(Class<?> configClass, Class<? extends java.lang.annotation.Annotation> annotation)
{
List<Method> result = new ArrayList<>();

//comment
//comment
for (Method method : configClass.getMethods()) {
//comment
if (method.isSynthetic() || method.isBridge() || Modifier.isStatic(method.getModifiers())) {
continue;
}

//comment
<start>Method managedMethod = findAnnotatedMethod(configClass, annotation, method.getName(), method.getParameterTypes());
if (managedMethod != null) {
result.add(managedMethod);
}<end>
}

return result;
}","    private static Collection<Method> findAnnotatedMethods(Class<?> configClass, Class<? extends java.lang.annotation.Annotation> annotation)
{
List<Method> result = new ArrayList<>();

//comment
//comment
for (Method method : configClass.getMethods()) {
//comment
if (method.isSynthetic() || method.isBridge() || Modifier.isStatic(method.getModifiers())) {
continue;
}

//comment
<start>Method managedMethod = findAnnotatedMethod(configClass, annotation, method.getName(), method.getParameterTypes());
if (managedMethod != null) {
result.add(managedMethod);
}<end>
}

return result;
}"
2978,"<start>private Method findGetter(Class<?> configClass, Method configMethod, String attributeName)<end>
{
//comment
<start>String getterName = ""get"" + attributeName;<end>
String isName = ""is"" + attributeName;

List<Method> getters = new ArrayList<>();
List<Method> unusableGetters = new ArrayList<>();
for (Class<?> clazz = configClass; (clazz != null) && !clazz.equals(Object.class); clazz = clazz.getSuperclass()) {
for (Method method : clazz.getDeclaredMethods()) {
if (method.getName().equals(getterName) || method.getName().equals(isName)) {
if (isUsableMethod(method) && !method.getReturnType().equals(Void.TYPE) && method.getParameterTypes().length == 0) {
getters.add(method);
}
else {
unusableGetters.add(method);
}
}
}
}

//comment
if (getters.isEmpty()) {
String unusable = """";
if (!unusableGetters.isEmpty()) {
StringBuilder builder = new StringBuilder("" The following methods are unusable: "");
for (Method method : unusableGetters) {
builder.append('[').append(method.toGenericString()).append(']');
}
unusable = builder.toString();
}
problems.addError(""No getter for @Config method [%s].%s"", configMethod.toGenericString(), unusable);
return null;
}

//comment
if (getters.size() > 1) {
//comment
problems.addError(""Multiple getters found for @Config setter [%s]"", configMethod.toGenericString());
return null;
}

//comment
return getters.get(0);
}","private Method findGetter(Class<?> configClass, Method configMethod, String attributeName)
{
//comment
<start>String getterName = ""get"" + attributeName;
String isName = ""is"" + attributeName;

List<Method> getters = new ArrayList<>();
List<Method> unusableGetters = new ArrayList<>();
for (Class<?> clazz = configClass; (clazz != null) && !clazz.equals(Object.class); clazz = clazz.getSuperclass()) {
for (Method method : clazz.getDeclaredMethods()) {
if (method.getName().equals(getterName) || method.getName().equals(isName)) {
if (isUsableMethod(method) && !method.getReturnType().equals(Void.TYPE) && method.getParameterTypes().length == 0) {
getters.add(method);
}
else {
unusableGetters.add(method);
}
}
}
}<end>

//comment
if (getters.isEmpty()) {
String unusable = """";
if (!unusableGetters.isEmpty()) {
StringBuilder builder = new StringBuilder("" The following methods are unusable: "");
for (Method method : unusableGetters) {
builder.append('[').append(method.toGenericString()).append(']');
}
unusable = builder.toString();
}
problems.addError(""No getter for @Config method [%s].%s"", configMethod.toGenericString(), unusable);
return null;
}

//comment
if (getters.size() > 1) {
//comment
problems.addError(""Multiple getters found for @Config setter [%s]"", configMethod.toGenericString());
return null;
}

//comment
return getters.get(0);
}"
1581,"    public void bindGenericEventClient(List<Class<?>> eventTypes)
{
requireNonNull(eventTypes, ""eventTypes is null"");
checkArgument(!eventTypes.isEmpty(), ""eventTypes is empty"");

Binder sourcedBinder = binder.withSource(getCaller());
Multibinder<EventTypeMetadata<?>> metadataBinder = newSetBinder(binder, new TypeLiteral<EventTypeMetadata<?>>() {});

//comment
<start>for (Class<?> eventType : eventTypes) {
EventTypeMetadata<?> eventTypeMetadata = getEventTypeMetadata(eventType);
metadataBinder.addBinding().toInstance(eventTypeMetadata);
for (String error : eventTypeMetadata.getErrors()) {
sourcedBinder.addError(error);
}
}<end>
}","    public void bindGenericEventClient(List<Class<?>> eventTypes)
{
requireNonNull(eventTypes, ""eventTypes is null"");
checkArgument(!eventTypes.isEmpty(), ""eventTypes is empty"");

Binder sourcedBinder = binder.withSource(getCaller());
Multibinder<EventTypeMetadata<?>> metadataBinder = newSetBinder(binder, new TypeLiteral<EventTypeMetadata<?>>() {});

//comment
<start>for (Class<?> eventType : eventTypes) {
EventTypeMetadata<?> eventTypeMetadata = getEventTypeMetadata(eventType);
metadataBinder.addBinding().toInstance(eventTypeMetadata);
for (String error : eventTypeMetadata.getErrors()) {
sourcedBinder.addError(error);
}
}<end>
}"
1582,"<start>    private static StackTraceElement getCaller()<end>
{
//comment
<start>StackTraceElement[] stack = Thread.currentThread().getStackTrace();
boolean foundThisClass = false;<end>
for (StackTraceElement element : stack) {
if (!foundThisClass) {
if (element.getClassName().equals(EventBinder.class.getName())) {
foundThisClass = true;
}
}
else {
if (!element.getClassName().equals(EventBinder.class.getName())) {
return element;
}
}
}
return null;
}","    private static StackTraceElement getCaller()
{
//comment
<start>StackTraceElement[] stack = Thread.currentThread().getStackTrace();
boolean foundThisClass = false;
for (StackTraceElement element : stack) {
if (!foundThisClass) {
if (element.getClassName().equals(EventBinder.class.getName())) {
foundThisClass = true;
}
}
else {
if (!element.getClassName().equals(EventBinder.class.getName())) {
return element;
}
}
}
return null;<end>
}"
1387,"@Override
public Object readFrom(Class<Object> type,
Type genericType,
Annotation[] annotations,
MediaType mediaType,
MultivaluedMap<String, String> httpHeaders,
InputStream inputStream)
throws IOException
{
try {
JsonParser jsonParser = getReaderJsonFactory().createParser(inputStream);

//comment
jsonParser.disable(JsonParser.Feature.AUTO_CLOSE_SOURCE);

return objectMapper.readValue(jsonParser, objectMapper.getTypeFactory().constructType(genericType));
}
<start>catch (Exception e) {
//comment
if (e instanceof IOException && !(e instanceof JsonProcessingException) && !(e instanceof EOFException)) {
throw e;
}<end>

//comment
//comment
log.debug(e, ""Invalid JSON for Java type: %s"", type);

//comment
throw new JsonMapperParsingException(type, e);
}
}","@Override
public Object readFrom(Class<Object> type,
Type genericType,
Annotation[] annotations,
MediaType mediaType,
MultivaluedMap<String, String> httpHeaders,
InputStream inputStream)
throws IOException
{
<start>try {<end>
JsonParser jsonParser = getReaderJsonFactory().createParser(inputStream);

//comment
jsonParser.disable(JsonParser.Feature.AUTO_CLOSE_SOURCE);

return objectMapper.readValue(jsonParser, objectMapper.getTypeFactory().constructType(genericType));
<start>}
catch (Exception e) {
//comment
if (e instanceof IOException && !(e instanceof JsonProcessingException) && !(e instanceof EOFException)) {
throw e;
}<end>

//comment
//comment
log.debug(e, ""Invalid JSON for Java type: %s"", type);

//comment
throw new JsonMapperParsingException(type, e);
<start>}<end>
}"
1388,"@Override
public Object readFrom(Class<Object> type,
Type genericType,
Annotation[] annotations,
MediaType mediaType,
MultivaluedMap<String, String> httpHeaders,
InputStream inputStream)
throws IOException
{
try {
JsonParser jsonParser = getReaderJsonFactory().createParser(inputStream);

//comment
jsonParser.disable(JsonParser.Feature.AUTO_CLOSE_SOURCE);

return objectMapper.readValue(jsonParser, objectMapper.getTypeFactory().constructType(genericType));
}
catch (Exception e) {
//comment
if (e instanceof IOException && !(e instanceof JsonProcessingException) && !(e instanceof EOFException)) {
throw e;
}

//comment
//comment
<start>log.debug(e, ""Invalid JSON for Java type: %s"", type);<end>

//comment
throw new JsonMapperParsingException(type, e);
}
}","@Override
public Object readFrom(Class<Object> type,
Type genericType,
Annotation[] annotations,
MediaType mediaType,
MultivaluedMap<String, String> httpHeaders,
InputStream inputStream)
throws IOException
{
try {
JsonParser jsonParser = getReaderJsonFactory().createParser(inputStream);

//comment
jsonParser.disable(JsonParser.Feature.AUTO_CLOSE_SOURCE);

return objectMapper.readValue(jsonParser, objectMapper.getTypeFactory().constructType(genericType));
}
catch (Exception e) {
//comment
if (e instanceof IOException && !(e instanceof JsonProcessingException) && !(e instanceof EOFException)) {
throw e;
}

//comment
//comment
<start>log.debug(e, ""Invalid JSON for Java type: %s"", type);<end>

//comment
throw new JsonMapperParsingException(type, e);
}
}"
1389,"@Override
public Object readFrom(Class<Object> type,
Type genericType,
Annotation[] annotations,
MediaType mediaType,
MultivaluedMap<String, String> httpHeaders,
InputStream inputStream)
throws IOException
{
try {
JsonParser jsonParser = getReaderJsonFactory().createParser(inputStream);

//comment
jsonParser.disable(JsonParser.Feature.AUTO_CLOSE_SOURCE);

return objectMapper.readValue(jsonParser, objectMapper.getTypeFactory().constructType(genericType));
}
catch (Exception e) {
//comment
if (e instanceof IOException && !(e instanceof JsonProcessingException) && !(e instanceof EOFException)) {
throw e;
}

//comment
//comment
log.debug(e, ""Invalid JSON for Java type: %s"", type);

//comment
<start>throw new JsonMapperParsingException(type, e);<end>
}
}","@Override
public Object readFrom(Class<Object> type,
Type genericType,
Annotation[] annotations,
MediaType mediaType,
MultivaluedMap<String, String> httpHeaders,
InputStream inputStream)
throws IOException
{
try {
JsonParser jsonParser = getReaderJsonFactory().createParser(inputStream);

//comment
jsonParser.disable(JsonParser.Feature.AUTO_CLOSE_SOURCE);

return objectMapper.readValue(jsonParser, objectMapper.getTypeFactory().constructType(genericType));
}
catch (Exception e) {
//comment
if (e instanceof IOException && !(e instanceof JsonProcessingException) && !(e instanceof EOFException)) {
throw e;
}

//comment
//comment
log.debug(e, ""Invalid JSON for Java type: %s"", type);

//comment
<start>throw new JsonMapperParsingException(type, e);<end>
}
}"
1532,"public static LogFileName generateNextLogFileName(Path masterLogFile, Optional<String> compressionExtension)
{
LocalDateTime dateTime = LocalDateTime.now().withNano(0);
String suffix = DATE_TIME_FORMATTER.format(dateTime);
for (int index = 0; index < MAX_GENERATED_INDEX; index++) {
String newFileName = masterLogFile.getFileName() + suffix + (index > 0 ? ""-"" + index : """");
Path newFile = masterLogFile.resolveSibling(newFileName);
if (!fileAlreadyExists(newFile, compressionExtension)) {
return new LogFileName(newFileName, dateTime, OptionalInt.of(index), OptionalInt.empty(), Optional.empty(), false);
}
}
//comment
String slug = randomUUID().toString();
String randomFileName = masterLogFile.getFileName() + suffix + ""--"" + slug;
return new LogFileName(randomFileName, dateTime, OptionalInt.of(0), OptionalInt.empty(), Optional.of(slug), false);
}","public static LogFileName generateNextLogFileName(Path masterLogFile, Optional<String> compressionExtension)
{
LocalDateTime dateTime = LocalDateTime.now().withNano(0);
String suffix = DATE_TIME_FORMATTER.format(dateTime);
for (int index = 0; index < MAX_GENERATED_INDEX; index++) {
String newFileName = masterLogFile.getFileName() + suffix + (index > 0 ? ""-"" + index : """");
Path newFile = masterLogFile.resolveSibling(newFileName);
if (!fileAlreadyExists(newFile, compressionExtension)) {
return new LogFileName(newFileName, dateTime, OptionalInt.of(index), OptionalInt.empty(), Optional.empty(), false);
}
}
//comment
<start>String slug = randomUUID().toString();<end>
String randomFileName = masterLogFile.getFileName() + suffix + ""--"" + slug;
return new LogFileName(randomFileName, dateTime, OptionalInt.of(0), OptionalInt.empty(), Optional.of(slug), false);
}"
1276,"@Override
public synchronized void close()
throws IOException
{
IOException exception = new IOException(""Exception thrown attempting to close the file output."");

if (currentOutputStream != null) {
try {
currentOutputStream.flush();
}
catch (IOException e) {
exception.addSuppressed(e);
}
try {
currentOutputStream.close();
}
catch (IOException e) {
exception.addSuppressed(e);
}
}

//comment
if (compressionExecutor != null) {
<start>compressionExecutor.shutdown();<end>
try {
compressionExecutor.awaitTermination(1, TimeUnit.MINUTES);
}
catch (InterruptedException e) {
Thread.currentThread().interrupt();
}
}

currentOutputStream = null;
currentOutputFile = null;
currentOutputFileName = null;
currentFileSize = 0;

if (exception.getSuppressed().length > 0) {
throw exception;
}
}","@Override
public synchronized void close()
throws IOException
{
IOException exception = new IOException(""Exception thrown attempting to close the file output."");

if (currentOutputStream != null) {
try {
currentOutputStream.flush();
}
catch (IOException e) {
exception.addSuppressed(e);
}
try {
currentOutputStream.close();
}
catch (IOException e) {
exception.addSuppressed(e);
}
}

//comment
if (compressionExecutor != null) {
compressionExecutor.shutdown();
try {
<start>compressionExecutor.awaitTermination(1, TimeUnit.MINUTES);<end>
}
catch (InterruptedException e) {
Thread.currentThread().interrupt();
}
}

currentOutputStream = null;
currentOutputFile = null;
currentOutputFileName = null;
currentFileSize = 0;

if (exception.getSuppressed().length > 0) {
throw exception;
}
}"
1277,"private synchronized void rollFile()
throws IOException
{
//comment

LogFileName newFileName = null;
Path newFile = null;
OutputStream newOutputStream = null;
<start>for (int i = 0; i < MAX_OPEN_NEW_LOG_ATTEMPTS; i++) {
try {
newFileName = LogFileName.generateNextLogFileName(symlink, compressionType.getExtension());
newFile = symlink.resolveSibling(newFileName.getFileName());
newOutputStream = new BufferedOutputStream(Files.newOutputStream(newFile, CREATE_NEW), MAX_BATCH_BYTES);
break;
}
catch (FileAlreadyExistsException ignore) {
}
}<end>

//comment
<start>if (newOutputStream == null) {
throw new IOException(""Could not create new a unique log file: "" + newFile);
}<end>

//comment
//comment
IOException exception = new IOException(String.format(""Unable to %s log file"", currentOutputStream == null ? ""setup initial"" : ""roll""));

//comment
if (currentOutputStream != null) {
try {
currentOutputStream.close();
}
catch (IOException e) {
exception.addSuppressed(new IOException(""Unable to close old output stream: "" + currentOutputFile, e));
}
historyManager.addFile(currentOutputFile, currentOutputFileName, currentFileSize);
if (compressionExecutor != null) {
Path originalFile = currentOutputFile;
LogFileName originalLogFileName = currentOutputFileName;
long originalFileSize = currentFileSize;
compressionExecutor.submit(() -> {
try {
compressInternal(originalFile, originalLogFileName, originalFileSize);
}
catch (IOException e) {
exception.addSuppressed(e);
}
});
}
}

currentOutputFile = newFile;
currentOutputFileName = newFileName;
currentOutputStream = newOutputStream;
currentFileSize = 0;

//comment
try {
if (Files.exists(symlink)) {
Files.delete(symlink);
}
Files.createSymbolicLink(symlink, newFile);
}
catch (IOException e) {
exception.addSuppressed(new IOException(""Unable to update symlink"", e));
}

if (exception.getSuppressed().length > 0) {
throw exception;
}
}","private synchronized void rollFile()
throws IOException
{
//comment

LogFileName newFileName = null;
Path newFile = null;
OutputStream newOutputStream = null;
for (int i = 0; i < MAX_OPEN_NEW_LOG_ATTEMPTS; i++) {
try {
newFileName = LogFileName.generateNextLogFileName(symlink, compressionType.getExtension());
newFile = symlink.resolveSibling(newFileName.getFileName());
newOutputStream = new BufferedOutputStream(Files.newOutputStream(newFile, CREATE_NEW), MAX_BATCH_BYTES);
break;
}
catch (FileAlreadyExistsException ignore) {
}
}

//comment
<start>if (newOutputStream == null) {
throw new IOException(""Could not create new a unique log file: "" + newFile);
}<end>

//comment
//comment
IOException exception = new IOException(String.format(""Unable to %s log file"", currentOutputStream == null ? ""setup initial"" : ""roll""));

//comment
if (currentOutputStream != null) {
try {
currentOutputStream.close();
}
catch (IOException e) {
exception.addSuppressed(new IOException(""Unable to close old output stream: "" + currentOutputFile, e));
}
historyManager.addFile(currentOutputFile, currentOutputFileName, currentFileSize);
if (compressionExecutor != null) {
Path originalFile = currentOutputFile;
LogFileName originalLogFileName = currentOutputFileName;
long originalFileSize = currentFileSize;
compressionExecutor.submit(() -> {
try {
compressInternal(originalFile, originalLogFileName, originalFileSize);
}
catch (IOException e) {
exception.addSuppressed(e);
}
});
}
}

currentOutputFile = newFile;
currentOutputFileName = newFileName;
currentOutputStream = newOutputStream;
currentFileSize = 0;

//comment
try {
if (Files.exists(symlink)) {
Files.delete(symlink);
}
Files.createSymbolicLink(symlink, newFile);
}
catch (IOException e) {
exception.addSuppressed(new IOException(""Unable to update symlink"", e));
}

if (exception.getSuppressed().length > 0) {
throw exception;
}
}"
1278,"private synchronized void rollFile()
throws IOException
{
//comment

LogFileName newFileName = null;
Path newFile = null;
OutputStream newOutputStream = null;
for (int i = 0; i < MAX_OPEN_NEW_LOG_ATTEMPTS; i++) {
try {
newFileName = LogFileName.generateNextLogFileName(symlink, compressionType.getExtension());
newFile = symlink.resolveSibling(newFileName.getFileName());
newOutputStream = new BufferedOutputStream(Files.newOutputStream(newFile, CREATE_NEW), MAX_BATCH_BYTES);
break;
}
catch (FileAlreadyExistsException ignore) {
}
}

//comment
if (newOutputStream == null) {
throw new IOException(""Could not create new a unique log file: "" + newFile);
}

//comment
//comment
<start>IOException exception = new IOException(String.format(""Unable to %s log file"", currentOutputStream == null ? ""setup initial"" : ""roll""));<end>

//comment
if (currentOutputStream != null) {
try {
currentOutputStream.close();
}
catch (IOException e) {
exception.addSuppressed(new IOException(""Unable to close old output stream: "" + currentOutputFile, e));
}
historyManager.addFile(currentOutputFile, currentOutputFileName, currentFileSize);
if (compressionExecutor != null) {
Path originalFile = currentOutputFile;
LogFileName originalLogFileName = currentOutputFileName;
long originalFileSize = currentFileSize;
compressionExecutor.submit(() -> {
try {
compressInternal(originalFile, originalLogFileName, originalFileSize);
}
catch (IOException e) {
exception.addSuppressed(e);
}
});
}
}

currentOutputFile = newFile;
currentOutputFileName = newFileName;
currentOutputStream = newOutputStream;
currentFileSize = 0;

//comment
try {
if (Files.exists(symlink)) {
Files.delete(symlink);
}
Files.createSymbolicLink(symlink, newFile);
}
catch (IOException e) {
exception.addSuppressed(new IOException(""Unable to update symlink"", e));
}

if (exception.getSuppressed().length > 0) {
throw exception;
}
}","private synchronized void rollFile()
throws IOException
{
//comment

LogFileName newFileName = null;
Path newFile = null;
OutputStream newOutputStream = null;
for (int i = 0; i < MAX_OPEN_NEW_LOG_ATTEMPTS; i++) {
try {
newFileName = LogFileName.generateNextLogFileName(symlink, compressionType.getExtension());
newFile = symlink.resolveSibling(newFileName.getFileName());
newOutputStream = new BufferedOutputStream(Files.newOutputStream(newFile, CREATE_NEW), MAX_BATCH_BYTES);
break;
}
catch (FileAlreadyExistsException ignore) {
}
}

//comment
if (newOutputStream == null) {
throw new IOException(""Could not create new a unique log file: "" + newFile);
}

//comment
//comment
<start>IOException exception = new IOException(String.format(""Unable to %s log file"", currentOutputStream == null ? ""setup initial"" : ""roll""));<end>

//comment
if (currentOutputStream != null) {
try {
currentOutputStream.close();
}
catch (IOException e) {
exception.addSuppressed(new IOException(""Unable to close old output stream: "" + currentOutputFile, e));
}
historyManager.addFile(currentOutputFile, currentOutputFileName, currentFileSize);
if (compressionExecutor != null) {
Path originalFile = currentOutputFile;
LogFileName originalLogFileName = currentOutputFileName;
long originalFileSize = currentFileSize;
compressionExecutor.submit(() -> {
try {
compressInternal(originalFile, originalLogFileName, originalFileSize);
}
catch (IOException e) {
exception.addSuppressed(e);
}
});
}
}

currentOutputFile = newFile;
currentOutputFileName = newFileName;
currentOutputStream = newOutputStream;
currentFileSize = 0;

//comment
try {
if (Files.exists(symlink)) {
Files.delete(symlink);
}
Files.createSymbolicLink(symlink, newFile);
}
catch (IOException e) {
exception.addSuppressed(new IOException(""Unable to update symlink"", e));
}

if (exception.getSuppressed().length > 0) {
throw exception;
}
}"
1279,"private synchronized void rollFile()
throws IOException
{
//comment

LogFileName newFileName = null;
Path newFile = null;
OutputStream newOutputStream = null;
for (int i = 0; i < MAX_OPEN_NEW_LOG_ATTEMPTS; i++) {
try {
newFileName = LogFileName.generateNextLogFileName(symlink, compressionType.getExtension());
newFile = symlink.resolveSibling(newFileName.getFileName());
newOutputStream = new BufferedOutputStream(Files.newOutputStream(newFile, CREATE_NEW), MAX_BATCH_BYTES);
break;
}
catch (FileAlreadyExistsException ignore) {
}
}

//comment
if (newOutputStream == null) {
throw new IOException(""Could not create new a unique log file: "" + newFile);
}

//comment
//comment
IOException exception = new IOException(String.format(""Unable to %s log file"", currentOutputStream == null ? ""setup initial"" : ""roll""));

//comment
if (currentOutputStream != null) {
try {
currentOutputStream.close();
}
catch (IOException e) {
exception.addSuppressed(new IOException(""Unable to close old output stream: "" + currentOutputFile, e));
}
historyManager.addFile(currentOutputFile, currentOutputFileName, currentFileSize);
if (compressionExecutor != null) {
Path originalFile = currentOutputFile;
LogFileName originalLogFileName = currentOutputFileName;
long originalFileSize = currentFileSize;
compressionExecutor.submit(() -> {
try {
compressInternal(originalFile, originalLogFileName, originalFileSize);
}
catch (IOException e) {
exception.addSuppressed(e);
}
});
}
}

currentOutputFile = newFile;
currentOutputFileName = newFileName;
currentOutputStream = newOutputStream;
currentFileSize = 0;

//comment
try {
if (Files.exists(symlink)) {
Files.delete(symlink);
}
Files.createSymbolicLink(symlink, newFile);
}
catch (IOException e) {
exception.addSuppressed(new IOException(""Unable to update symlink"", e));
}

if (exception.getSuppressed().length > 0) {
throw exception;
}
}","private synchronized void rollFile()
throws IOException
{
//comment

LogFileName newFileName = null;
Path newFile = null;
OutputStream newOutputStream = null;
for (int i = 0; i < MAX_OPEN_NEW_LOG_ATTEMPTS; i++) {
try {
newFileName = LogFileName.generateNextLogFileName(symlink, compressionType.getExtension());
newFile = symlink.resolveSibling(newFileName.getFileName());
newOutputStream = new BufferedOutputStream(Files.newOutputStream(newFile, CREATE_NEW), MAX_BATCH_BYTES);
break;
}
catch (FileAlreadyExistsException ignore) {
}
}

//comment
if (newOutputStream == null) {
throw new IOException(""Could not create new a unique log file: "" + newFile);
}

//comment
//comment
IOException exception = new IOException(String.format(""Unable to %s log file"", currentOutputStream == null ? ""setup initial"" : ""roll""));

//comment
<start>if (currentOutputStream != null) {
try {
currentOutputStream.close();
}
catch (IOException e) {
exception.addSuppressed(new IOException(""Unable to close old output stream: "" + currentOutputFile, e));
}
historyManager.addFile(currentOutputFile, currentOutputFileName, currentFileSize);
if (compressionExecutor != null) {
Path originalFile = currentOutputFile;
LogFileName originalLogFileName = currentOutputFileName;
long originalFileSize = currentFileSize;
compressionExecutor.submit(() -> {
try {
compressInternal(originalFile, originalLogFileName, originalFileSize);
}
catch (IOException e) {
exception.addSuppressed(e);
}
});
}
}<end>

currentOutputFile = newFile;
currentOutputFileName = newFileName;
currentOutputStream = newOutputStream;
currentFileSize = 0;

//comment
try {
if (Files.exists(symlink)) {
Files.delete(symlink);
}
Files.createSymbolicLink(symlink, newFile);
}
catch (IOException e) {
exception.addSuppressed(new IOException(""Unable to update symlink"", e));
}

if (exception.getSuppressed().length > 0) {
throw exception;
}
}"
1280,"private synchronized void rollFile()
throws IOException
{
//comment

LogFileName newFileName = null;
Path newFile = null;
OutputStream newOutputStream = null;
for (int i = 0; i < MAX_OPEN_NEW_LOG_ATTEMPTS; i++) {
try {
newFileName = LogFileName.generateNextLogFileName(symlink, compressionType.getExtension());
newFile = symlink.resolveSibling(newFileName.getFileName());
newOutputStream = new BufferedOutputStream(Files.newOutputStream(newFile, CREATE_NEW), MAX_BATCH_BYTES);
break;
}
catch (FileAlreadyExistsException ignore) {
}
}

//comment
if (newOutputStream == null) {
throw new IOException(""Could not create new a unique log file: "" + newFile);
}

//comment
//comment
IOException exception = new IOException(String.format(""Unable to %s log file"", currentOutputStream == null ? ""setup initial"" : ""roll""));

//comment
if (currentOutputStream != null) {
try {
currentOutputStream.close();
}
catch (IOException e) {
exception.addSuppressed(new IOException(""Unable to close old output stream: "" + currentOutputFile, e));
}
historyManager.addFile(currentOutputFile, currentOutputFileName, currentFileSize);
if (compressionExecutor != null) {
Path originalFile = currentOutputFile;
LogFileName originalLogFileName = currentOutputFileName;
long originalFileSize = currentFileSize;
compressionExecutor.submit(() -> {
try {
compressInternal(originalFile, originalLogFileName, originalFileSize);
}
catch (IOException e) {
exception.addSuppressed(e);
}
});
}
}

currentOutputFile = newFile;
currentOutputFileName = newFileName;
currentOutputStream = newOutputStream;
currentFileSize = 0;

//comment
try {
if (Files.exists(symlink)) {
<start>Files.delete(symlink);<end>
}
Files.createSymbolicLink(symlink, newFile);
}
catch (IOException e) {
exception.addSuppressed(new IOException(""Unable to update symlink"", e));
}

if (exception.getSuppressed().length > 0) {
throw exception;
}
}","private synchronized void rollFile()
throws IOException
{
//comment

LogFileName newFileName = null;
Path newFile = null;
OutputStream newOutputStream = null;
for (int i = 0; i < MAX_OPEN_NEW_LOG_ATTEMPTS; i++) {
try {
newFileName = LogFileName.generateNextLogFileName(symlink, compressionType.getExtension());
newFile = symlink.resolveSibling(newFileName.getFileName());
newOutputStream = new BufferedOutputStream(Files.newOutputStream(newFile, CREATE_NEW), MAX_BATCH_BYTES);
break;
}
catch (FileAlreadyExistsException ignore) {
}
}

//comment
if (newOutputStream == null) {
throw new IOException(""Could not create new a unique log file: "" + newFile);
}

//comment
//comment
IOException exception = new IOException(String.format(""Unable to %s log file"", currentOutputStream == null ? ""setup initial"" : ""roll""));

//comment
if (currentOutputStream != null) {
try {
currentOutputStream.close();
}
catch (IOException e) {
exception.addSuppressed(new IOException(""Unable to close old output stream: "" + currentOutputFile, e));
}
historyManager.addFile(currentOutputFile, currentOutputFileName, currentFileSize);
if (compressionExecutor != null) {
Path originalFile = currentOutputFile;
LogFileName originalLogFileName = currentOutputFileName;
long originalFileSize = currentFileSize;
compressionExecutor.submit(() -> {
try {
compressInternal(originalFile, originalLogFileName, originalFileSize);
}
catch (IOException e) {
exception.addSuppressed(e);
}
});
}
}

currentOutputFile = newFile;
currentOutputFileName = newFileName;
currentOutputStream = newOutputStream;
currentFileSize = 0;

//comment
<start>try {
if (Files.exists(symlink)) {
Files.delete(symlink);
}
Files.createSymbolicLink(symlink, newFile);
}
catch (IOException e) {
exception.addSuppressed(new IOException(""Unable to update symlink"", e));
}<end>

if (exception.getSuppressed().length > 0) {
throw exception;
}
}"
1281,"private void compressInternal(Path originalFile, LogFileName originalLogFileName, long originalFileSize)
throws IOException
{
tryCleanupTempFiles(symlink);

String compressionExtension = compressionType.getExtension().orElseThrow(IllegalStateException::new);

//comment
<start>Path tempFile = originalFile.resolveSibling(TEMP_PREFIX + originalFile.getFileName() + compressionExtension);
try (
InputStream input = Files.newInputStream(originalFile);
GZIPOutputStream gzipOutputStream = new GZIPOutputStream(Files.newOutputStream(tempFile))) {
ByteStreams.copy(input, gzipOutputStream);
}
catch (IOException e) {
throw new IOException(""Unable to compress log file"", e);
}<end>

//comment
long compressedSize;
try {
compressedSize = Files.size(tempFile);
}
catch (IOException e) {
throw new IOException(""Unable to get size of compress log file"", e);
}

//comment
synchronized (this) {
//comment
if (!historyManager.removeFile(originalFile)) {
//comment
try {
Files.deleteIfExists(tempFile);
}
catch (IOException e) {
throw new IOException(""Unable to delete compress log file"", e);
}
return;
}

Path compressedFile = originalFile.resolveSibling(originalFile.getFileName() + compressionExtension);

//comment
LogFileName compressedFileName = originalLogFileName.withCompression(compressedFile);
try {
Files.move(tempFile, compressedFile, ATOMIC_MOVE);
}
catch (IOException e) {
//comment
historyManager.addFile(originalFile, originalLogFileName, originalFileSize);

//comment
try {
Files.deleteIfExists(tempFile);
}
catch (IOException ignored) {
//comment
}
}
historyManager.addFile(compressedFile, compressedFileName, compressedSize);

//comment
try {
Files.deleteIfExists(originalFile);
}
catch (IOException deleteException) {
//comment
try {
Files.move(originalFile, originalFile.resolveSibling(DELETED_PREFIX + originalFile.getFileName()), ATOMIC_MOVE);
}
catch (IOException ignored) {
//comment
throw new IOException(""Unable to delete original file after compression"", deleteException);
}
}
}
}","private void compressInternal(Path originalFile, LogFileName originalLogFileName, long originalFileSize)
throws IOException
{
tryCleanupTempFiles(symlink);

String compressionExtension = compressionType.getExtension().orElseThrow(IllegalStateException::new);

//comment
<start>Path tempFile = originalFile.resolveSibling(TEMP_PREFIX + originalFile.getFileName() + compressionExtension);<end>
try (
<start>InputStream input = Files.newInputStream(originalFile);
GZIPOutputStream gzipOutputStream = new GZIPOutputStream(Files.newOutputStream(tempFile))) {
ByteStreams.copy(input, gzipOutputStream);<end>
}
catch (IOException e) {
throw new IOException(""Unable to compress log file"", e);
}

//comment
long compressedSize;
try {
compressedSize = Files.size(tempFile);
}
catch (IOException e) {
throw new IOException(""Unable to get size of compress log file"", e);
}

//comment
synchronized (this) {
//comment
if (!historyManager.removeFile(originalFile)) {
//comment
try {
Files.deleteIfExists(tempFile);
}
catch (IOException e) {
throw new IOException(""Unable to delete compress log file"", e);
}
return;
}

Path compressedFile = originalFile.resolveSibling(originalFile.getFileName() + compressionExtension);

//comment
LogFileName compressedFileName = originalLogFileName.withCompression(compressedFile);
try {
Files.move(tempFile, compressedFile, ATOMIC_MOVE);
}
catch (IOException e) {
//comment
historyManager.addFile(originalFile, originalLogFileName, originalFileSize);

//comment
try {
Files.deleteIfExists(tempFile);
}
catch (IOException ignored) {
//comment
}
}
historyManager.addFile(compressedFile, compressedFileName, compressedSize);

//comment
try {
Files.deleteIfExists(originalFile);
}
catch (IOException deleteException) {
//comment
try {
Files.move(originalFile, originalFile.resolveSibling(DELETED_PREFIX + originalFile.getFileName()), ATOMIC_MOVE);
}
catch (IOException ignored) {
//comment
throw new IOException(""Unable to delete original file after compression"", deleteException);
}
}
}
}"
1282,"private void compressInternal(Path originalFile, LogFileName originalLogFileName, long originalFileSize)
throws IOException
{
tryCleanupTempFiles(symlink);

String compressionExtension = compressionType.getExtension().orElseThrow(IllegalStateException::new);

//comment
Path tempFile = originalFile.resolveSibling(TEMP_PREFIX + originalFile.getFileName() + compressionExtension);
try (
InputStream input = Files.newInputStream(originalFile);
GZIPOutputStream gzipOutputStream = new GZIPOutputStream(Files.newOutputStream(tempFile))) {
ByteStreams.copy(input, gzipOutputStream);
}
catch (IOException e) {
throw new IOException(""Unable to compress log file"", e);
}

//comment
long compressedSize;
try {
compressedSize = Files.size(tempFile);
}
catch (IOException e) {
throw new IOException(""Unable to get size of compress log file"", e);
}

//comment
<start>synchronized (this) {<end>
//comment
if (!historyManager.removeFile(originalFile)) {
//comment
try {
Files.deleteIfExists(tempFile);
}
catch (IOException e) {
throw new IOException(""Unable to delete compress log file"", e);
}
return;
}

Path compressedFile = originalFile.resolveSibling(originalFile.getFileName() + compressionExtension);

//comment
LogFileName compressedFileName = originalLogFileName.withCompression(compressedFile);
try {
Files.move(tempFile, compressedFile, ATOMIC_MOVE);
}
catch (IOException e) {
//comment
historyManager.addFile(originalFile, originalLogFileName, originalFileSize);

//comment
try {
Files.deleteIfExists(tempFile);
}
catch (IOException ignored) {
//comment
}
}
historyManager.addFile(compressedFile, compressedFileName, compressedSize);

//comment
try {
Files.deleteIfExists(originalFile);
}
catch (IOException deleteException) {
//comment
try {
Files.move(originalFile, originalFile.resolveSibling(DELETED_PREFIX + originalFile.getFileName()), ATOMIC_MOVE);
}
catch (IOException ignored) {
//comment
throw new IOException(""Unable to delete original file after compression"", deleteException);
}
}
}
}","private void compressInternal(Path originalFile, LogFileName originalLogFileName, long originalFileSize)
throws IOException
{
tryCleanupTempFiles(symlink);

String compressionExtension = compressionType.getExtension().orElseThrow(IllegalStateException::new);

//comment
Path tempFile = originalFile.resolveSibling(TEMP_PREFIX + originalFile.getFileName() + compressionExtension);
try (
InputStream input = Files.newInputStream(originalFile);
GZIPOutputStream gzipOutputStream = new GZIPOutputStream(Files.newOutputStream(tempFile))) {
ByteStreams.copy(input, gzipOutputStream);
}
catch (IOException e) {
throw new IOException(""Unable to compress log file"", e);
}

//comment
long compressedSize;
try {
compressedSize = Files.size(tempFile);
}
catch (IOException e) {
throw new IOException(""Unable to get size of compress log file"", e);
}

//comment
synchronized (this) {
//comment
<start>if (!historyManager.removeFile(originalFile)) {<end>
//comment
try {
<start>Files.deleteIfExists(tempFile);<end>
}
catch (IOException e) {
throw new IOException(""Unable to delete compress log file"", e);
}
return;
}

Path compressedFile = originalFile.resolveSibling(originalFile.getFileName() + compressionExtension);

//comment
LogFileName compressedFileName = originalLogFileName.withCompression(compressedFile);
try {
Files.move(tempFile, compressedFile, ATOMIC_MOVE);
}
catch (IOException e) {
//comment
historyManager.addFile(originalFile, originalLogFileName, originalFileSize);

//comment
try {
Files.deleteIfExists(tempFile);
}
catch (IOException ignored) {
//comment
}
}
historyManager.addFile(compressedFile, compressedFileName, compressedSize);

//comment
try {
Files.deleteIfExists(originalFile);
}
catch (IOException deleteException) {
//comment
try {
Files.move(originalFile, originalFile.resolveSibling(DELETED_PREFIX + originalFile.getFileName()), ATOMIC_MOVE);
}
catch (IOException ignored) {
//comment
throw new IOException(""Unable to delete original file after compression"", deleteException);
}
}
}
}"
1283,"private void compressInternal(Path originalFile, LogFileName originalLogFileName, long originalFileSize)
throws IOException
{
tryCleanupTempFiles(symlink);

String compressionExtension = compressionType.getExtension().orElseThrow(IllegalStateException::new);

//comment
Path tempFile = originalFile.resolveSibling(TEMP_PREFIX + originalFile.getFileName() + compressionExtension);
try (
InputStream input = Files.newInputStream(originalFile);
GZIPOutputStream gzipOutputStream = new GZIPOutputStream(Files.newOutputStream(tempFile))) {
ByteStreams.copy(input, gzipOutputStream);
}
catch (IOException e) {
throw new IOException(""Unable to compress log file"", e);
}

//comment
long compressedSize;
try {
compressedSize = Files.size(tempFile);
}
catch (IOException e) {
throw new IOException(""Unable to get size of compress log file"", e);
}

//comment
synchronized (this) {
//comment
if (!historyManager.removeFile(originalFile)) {
//comment
try {
Files.deleteIfExists(tempFile);
}
catch (IOException e) {
throw new IOException(""Unable to delete compress log file"", e);
}
return;
}

Path compressedFile = originalFile.resolveSibling(originalFile.getFileName() + compressionExtension);

//comment
LogFileName compressedFileName = originalLogFileName.withCompression(compressedFile);
try {
Files.move(tempFile, compressedFile, ATOMIC_MOVE);
}
catch (IOException e) {
//comment
historyManager.addFile(originalFile, originalLogFileName, originalFileSize);

//comment
try {
Files.deleteIfExists(tempFile);
}
catch (IOException ignored) {
//comment
}
}
historyManager.addFile(compressedFile, compressedFileName, compressedSize);

//comment
try {
Files.deleteIfExists(originalFile);
}
catch (IOException deleteException) {
//comment
try {
Files.move(originalFile, originalFile.resolveSibling(DELETED_PREFIX + originalFile.getFileName()), ATOMIC_MOVE);
}
catch (IOException ignored) {
//comment
throw new IOException(""Unable to delete original file after compression"", deleteException);
}
}
}
}","private void compressInternal(Path originalFile, LogFileName originalLogFileName, long originalFileSize)
throws IOException
{
tryCleanupTempFiles(symlink);

String compressionExtension = compressionType.getExtension().orElseThrow(IllegalStateException::new);

//comment
Path tempFile = originalFile.resolveSibling(TEMP_PREFIX + originalFile.getFileName() + compressionExtension);
try (
InputStream input = Files.newInputStream(originalFile);
GZIPOutputStream gzipOutputStream = new GZIPOutputStream(Files.newOutputStream(tempFile))) {
ByteStreams.copy(input, gzipOutputStream);
}
catch (IOException e) {
throw new IOException(""Unable to compress log file"", e);
}

//comment
long compressedSize;
try {
compressedSize = Files.size(tempFile);
}
catch (IOException e) {
throw new IOException(""Unable to get size of compress log file"", e);
}

//comment
synchronized (this) {
//comment
<start>if (!historyManager.removeFile(originalFile)) {
//comment
try {
Files.deleteIfExists(tempFile);
}
catch (IOException e) {
throw new IOException(""Unable to delete compress log file"", e);
}
return;
}<end>

Path compressedFile = originalFile.resolveSibling(originalFile.getFileName() + compressionExtension);

//comment
LogFileName compressedFileName = originalLogFileName.withCompression(compressedFile);
try {
Files.move(tempFile, compressedFile, ATOMIC_MOVE);
}
catch (IOException e) {
//comment
historyManager.addFile(originalFile, originalLogFileName, originalFileSize);

//comment
try {
Files.deleteIfExists(tempFile);
}
catch (IOException ignored) {
//comment
}
}
historyManager.addFile(compressedFile, compressedFileName, compressedSize);

//comment
try {
Files.deleteIfExists(originalFile);
}
catch (IOException deleteException) {
//comment
try {
Files.move(originalFile, originalFile.resolveSibling(DELETED_PREFIX + originalFile.getFileName()), ATOMIC_MOVE);
}
catch (IOException ignored) {
//comment
throw new IOException(""Unable to delete original file after compression"", deleteException);
}
}
}
}"
1284,"private void compressInternal(Path originalFile, LogFileName originalLogFileName, long originalFileSize)
throws IOException
{
tryCleanupTempFiles(symlink);

String compressionExtension = compressionType.getExtension().orElseThrow(IllegalStateException::new);

//comment
Path tempFile = originalFile.resolveSibling(TEMP_PREFIX + originalFile.getFileName() + compressionExtension);
try (
InputStream input = Files.newInputStream(originalFile);
GZIPOutputStream gzipOutputStream = new GZIPOutputStream(Files.newOutputStream(tempFile))) {
ByteStreams.copy(input, gzipOutputStream);
}
catch (IOException e) {
throw new IOException(""Unable to compress log file"", e);
}

//comment
long compressedSize;
try {
compressedSize = Files.size(tempFile);
}
catch (IOException e) {
throw new IOException(""Unable to get size of compress log file"", e);
}

//comment
synchronized (this) {
//comment
if (!historyManager.removeFile(originalFile)) {
//comment
try {
Files.deleteIfExists(tempFile);
}
catch (IOException e) {
throw new IOException(""Unable to delete compress log file"", e);
}
return;
}

Path compressedFile = originalFile.resolveSibling(originalFile.getFileName() + compressionExtension);

//comment
<start>LogFileName compressedFileName = originalLogFileName.withCompression(compressedFile);
try {
Files.move(tempFile, compressedFile, ATOMIC_MOVE);
}
catch (IOException e) {
//comment
historyManager.addFile(originalFile, originalLogFileName, originalFileSize);

//comment
try {
Files.deleteIfExists(tempFile);
}
catch (IOException ignored) {
//comment
}
}<end>
historyManager.addFile(compressedFile, compressedFileName, compressedSize);

//comment
try {
Files.deleteIfExists(originalFile);
}
catch (IOException deleteException) {
//comment
try {
Files.move(originalFile, originalFile.resolveSibling(DELETED_PREFIX + originalFile.getFileName()), ATOMIC_MOVE);
}
catch (IOException ignored) {
//comment
throw new IOException(""Unable to delete original file after compression"", deleteException);
}
}
}
}","private void compressInternal(Path originalFile, LogFileName originalLogFileName, long originalFileSize)
throws IOException
{
tryCleanupTempFiles(symlink);

String compressionExtension = compressionType.getExtension().orElseThrow(IllegalStateException::new);

//comment
Path tempFile = originalFile.resolveSibling(TEMP_PREFIX + originalFile.getFileName() + compressionExtension);
try (
InputStream input = Files.newInputStream(originalFile);
GZIPOutputStream gzipOutputStream = new GZIPOutputStream(Files.newOutputStream(tempFile))) {
ByteStreams.copy(input, gzipOutputStream);
}
catch (IOException e) {
throw new IOException(""Unable to compress log file"", e);
}

//comment
long compressedSize;
try {
compressedSize = Files.size(tempFile);
}
catch (IOException e) {
throw new IOException(""Unable to get size of compress log file"", e);
}

//comment
synchronized (this) {
//comment
if (!historyManager.removeFile(originalFile)) {
//comment
try {
Files.deleteIfExists(tempFile);
}
catch (IOException e) {
throw new IOException(""Unable to delete compress log file"", e);
}
return;
}

Path compressedFile = originalFile.resolveSibling(originalFile.getFileName() + compressionExtension);

//comment
<start>LogFileName compressedFileName = originalLogFileName.withCompression(compressedFile);<end>
try {
<start>Files.move(tempFile, compressedFile, ATOMIC_MOVE);<end>
}
catch (IOException e) {
//comment
historyManager.addFile(originalFile, originalLogFileName, originalFileSize);

//comment
try {
Files.deleteIfExists(tempFile);
}
catch (IOException ignored) {
//comment
}
}
historyManager.addFile(compressedFile, compressedFileName, compressedSize);

//comment
try {
Files.deleteIfExists(originalFile);
}
catch (IOException deleteException) {
//comment
try {
Files.move(originalFile, originalFile.resolveSibling(DELETED_PREFIX + originalFile.getFileName()), ATOMIC_MOVE);
}
catch (IOException ignored) {
//comment
throw new IOException(""Unable to delete original file after compression"", deleteException);
}
}
}
}"
1285,"private void compressInternal(Path originalFile, LogFileName originalLogFileName, long originalFileSize)
throws IOException
{
tryCleanupTempFiles(symlink);

String compressionExtension = compressionType.getExtension().orElseThrow(IllegalStateException::new);

//comment
Path tempFile = originalFile.resolveSibling(TEMP_PREFIX + originalFile.getFileName() + compressionExtension);
try (
InputStream input = Files.newInputStream(originalFile);
GZIPOutputStream gzipOutputStream = new GZIPOutputStream(Files.newOutputStream(tempFile))) {
ByteStreams.copy(input, gzipOutputStream);
}
catch (IOException e) {
throw new IOException(""Unable to compress log file"", e);
}

//comment
long compressedSize;
try {
compressedSize = Files.size(tempFile);
}
catch (IOException e) {
throw new IOException(""Unable to get size of compress log file"", e);
}

//comment
synchronized (this) {
//comment
if (!historyManager.removeFile(originalFile)) {
//comment
try {
Files.deleteIfExists(tempFile);
}
catch (IOException e) {
throw new IOException(""Unable to delete compress log file"", e);
}
return;
}

Path compressedFile = originalFile.resolveSibling(originalFile.getFileName() + compressionExtension);

//comment
LogFileName compressedFileName = originalLogFileName.withCompression(compressedFile);
try {
<start>Files.move(tempFile, compressedFile, ATOMIC_MOVE);<end>
}
<start>catch (IOException e) {
//comment
historyManager.addFile(originalFile, originalLogFileName, originalFileSize);<end>

//comment
try {
Files.deleteIfExists(tempFile);
}
catch (IOException ignored) {
//comment
}
}
historyManager.addFile(compressedFile, compressedFileName, compressedSize);

//comment
try {
Files.deleteIfExists(originalFile);
}
catch (IOException deleteException) {
//comment
try {
Files.move(originalFile, originalFile.resolveSibling(DELETED_PREFIX + originalFile.getFileName()), ATOMIC_MOVE);
}
catch (IOException ignored) {
//comment
throw new IOException(""Unable to delete original file after compression"", deleteException);
}
}
}
}","private void compressInternal(Path originalFile, LogFileName originalLogFileName, long originalFileSize)
throws IOException
{
tryCleanupTempFiles(symlink);

String compressionExtension = compressionType.getExtension().orElseThrow(IllegalStateException::new);

//comment
Path tempFile = originalFile.resolveSibling(TEMP_PREFIX + originalFile.getFileName() + compressionExtension);
try (
InputStream input = Files.newInputStream(originalFile);
GZIPOutputStream gzipOutputStream = new GZIPOutputStream(Files.newOutputStream(tempFile))) {
ByteStreams.copy(input, gzipOutputStream);
}
catch (IOException e) {
throw new IOException(""Unable to compress log file"", e);
}

//comment
long compressedSize;
try {
compressedSize = Files.size(tempFile);
}
catch (IOException e) {
throw new IOException(""Unable to get size of compress log file"", e);
}

//comment
synchronized (this) {
//comment
if (!historyManager.removeFile(originalFile)) {
//comment
try {
Files.deleteIfExists(tempFile);
}
catch (IOException e) {
throw new IOException(""Unable to delete compress log file"", e);
}
return;
}

Path compressedFile = originalFile.resolveSibling(originalFile.getFileName() + compressionExtension);

//comment
LogFileName compressedFileName = originalLogFileName.withCompression(compressedFile);
try {
Files.move(tempFile, compressedFile, ATOMIC_MOVE);
}
catch (IOException e) {
//comment
<start>historyManager.addFile(originalFile, originalLogFileName, originalFileSize);<end>

//comment
try {
Files.deleteIfExists(tempFile);
}
catch (IOException ignored) {
//comment
}
}
historyManager.addFile(compressedFile, compressedFileName, compressedSize);

//comment
try {
Files.deleteIfExists(originalFile);
}
catch (IOException deleteException) {
//comment
try {
Files.move(originalFile, originalFile.resolveSibling(DELETED_PREFIX + originalFile.getFileName()), ATOMIC_MOVE);
}
catch (IOException ignored) {
//comment
throw new IOException(""Unable to delete original file after compression"", deleteException);
}
}
}
}"
1286,"private void compressInternal(Path originalFile, LogFileName originalLogFileName, long originalFileSize)
throws IOException
{
tryCleanupTempFiles(symlink);

String compressionExtension = compressionType.getExtension().orElseThrow(IllegalStateException::new);

//comment
Path tempFile = originalFile.resolveSibling(TEMP_PREFIX + originalFile.getFileName() + compressionExtension);
try (
InputStream input = Files.newInputStream(originalFile);
GZIPOutputStream gzipOutputStream = new GZIPOutputStream(Files.newOutputStream(tempFile))) {
ByteStreams.copy(input, gzipOutputStream);
}
catch (IOException e) {
throw new IOException(""Unable to compress log file"", e);
}

//comment
long compressedSize;
try {
compressedSize = Files.size(tempFile);
}
catch (IOException e) {
throw new IOException(""Unable to get size of compress log file"", e);
}

//comment
synchronized (this) {
//comment
if (!historyManager.removeFile(originalFile)) {
//comment
try {
Files.deleteIfExists(tempFile);
}
catch (IOException e) {
throw new IOException(""Unable to delete compress log file"", e);
}
return;
}

Path compressedFile = originalFile.resolveSibling(originalFile.getFileName() + compressionExtension);

//comment
LogFileName compressedFileName = originalLogFileName.withCompression(compressedFile);
try {
Files.move(tempFile, compressedFile, ATOMIC_MOVE);
}
catch (IOException e) {
//comment
historyManager.addFile(originalFile, originalLogFileName, originalFileSize);

//comment
<start>try {
Files.deleteIfExists(tempFile);
}
catch (IOException ignored) {
//comment
}<end>
}
historyManager.addFile(compressedFile, compressedFileName, compressedSize);

//comment
try {
Files.deleteIfExists(originalFile);
}
catch (IOException deleteException) {
//comment
try {
Files.move(originalFile, originalFile.resolveSibling(DELETED_PREFIX + originalFile.getFileName()), ATOMIC_MOVE);
}
catch (IOException ignored) {
//comment
throw new IOException(""Unable to delete original file after compression"", deleteException);
}
}
}
}","private void compressInternal(Path originalFile, LogFileName originalLogFileName, long originalFileSize)
throws IOException
{
tryCleanupTempFiles(symlink);

String compressionExtension = compressionType.getExtension().orElseThrow(IllegalStateException::new);

//comment
Path tempFile = originalFile.resolveSibling(TEMP_PREFIX + originalFile.getFileName() + compressionExtension);
try (
InputStream input = Files.newInputStream(originalFile);
GZIPOutputStream gzipOutputStream = new GZIPOutputStream(Files.newOutputStream(tempFile))) {
ByteStreams.copy(input, gzipOutputStream);
}
catch (IOException e) {
throw new IOException(""Unable to compress log file"", e);
}

//comment
long compressedSize;
try {
compressedSize = Files.size(tempFile);
}
catch (IOException e) {
throw new IOException(""Unable to get size of compress log file"", e);
}

//comment
synchronized (this) {
//comment
if (!historyManager.removeFile(originalFile)) {
//comment
try {
Files.deleteIfExists(tempFile);
}
catch (IOException e) {
throw new IOException(""Unable to delete compress log file"", e);
}
return;
}

Path compressedFile = originalFile.resolveSibling(originalFile.getFileName() + compressionExtension);

//comment
LogFileName compressedFileName = originalLogFileName.withCompression(compressedFile);
<start>try {
Files.move(tempFile, compressedFile, ATOMIC_MOVE);
}
catch (IOException e) {<end>
//comment
historyManager.addFile(originalFile, originalLogFileName, originalFileSize);

//comment
try {
<start>Files.deleteIfExists(tempFile);<end>
}
catch (IOException ignored) {
//comment
}
<start>}<end>
historyManager.addFile(compressedFile, compressedFileName, compressedSize);

//comment
try {
Files.deleteIfExists(originalFile);
}
catch (IOException deleteException) {
//comment
try {
Files.move(originalFile, originalFile.resolveSibling(DELETED_PREFIX + originalFile.getFileName()), ATOMIC_MOVE);
}
catch (IOException ignored) {
//comment
throw new IOException(""Unable to delete original file after compression"", deleteException);
}
}
}
}"
1287,"private void compressInternal(Path originalFile, LogFileName originalLogFileName, long originalFileSize)
throws IOException
{
tryCleanupTempFiles(symlink);

String compressionExtension = compressionType.getExtension().orElseThrow(IllegalStateException::new);

//comment
Path tempFile = originalFile.resolveSibling(TEMP_PREFIX + originalFile.getFileName() + compressionExtension);
try (
InputStream input = Files.newInputStream(originalFile);
GZIPOutputStream gzipOutputStream = new GZIPOutputStream(Files.newOutputStream(tempFile))) {
ByteStreams.copy(input, gzipOutputStream);
}
catch (IOException e) {
throw new IOException(""Unable to compress log file"", e);
}

//comment
long compressedSize;
try {
compressedSize = Files.size(tempFile);
}
catch (IOException e) {
throw new IOException(""Unable to get size of compress log file"", e);
}

//comment
synchronized (this) {
//comment
if (!historyManager.removeFile(originalFile)) {
//comment
try {
Files.deleteIfExists(tempFile);
}
catch (IOException e) {
throw new IOException(""Unable to delete compress log file"", e);
}
return;
}

Path compressedFile = originalFile.resolveSibling(originalFile.getFileName() + compressionExtension);

//comment
LogFileName compressedFileName = originalLogFileName.withCompression(compressedFile);
try {
Files.move(tempFile, compressedFile, ATOMIC_MOVE);
}
catch (IOException e) {
//comment
historyManager.addFile(originalFile, originalLogFileName, originalFileSize);

//comment
try {
Files.deleteIfExists(tempFile);
}
catch (IOException ignored) {
//comment
}
}
historyManager.addFile(compressedFile, compressedFileName, compressedSize);

//comment
try {
<start>Files.deleteIfExists(originalFile);<end>
}
<start>catch (IOException deleteException) {<end>
//comment
try {
Files.move(originalFile, originalFile.resolveSibling(DELETED_PREFIX + originalFile.getFileName()), ATOMIC_MOVE);
}
catch (IOException ignored) {
//comment
throw new IOException(""Unable to delete original file after compression"", deleteException);
}
}
}
}","private void compressInternal(Path originalFile, LogFileName originalLogFileName, long originalFileSize)
throws IOException
{
tryCleanupTempFiles(symlink);

String compressionExtension = compressionType.getExtension().orElseThrow(IllegalStateException::new);

//comment
Path tempFile = originalFile.resolveSibling(TEMP_PREFIX + originalFile.getFileName() + compressionExtension);
try (
InputStream input = Files.newInputStream(originalFile);
GZIPOutputStream gzipOutputStream = new GZIPOutputStream(Files.newOutputStream(tempFile))) {
ByteStreams.copy(input, gzipOutputStream);
}
catch (IOException e) {
throw new IOException(""Unable to compress log file"", e);
}

//comment
long compressedSize;
try {
compressedSize = Files.size(tempFile);
}
catch (IOException e) {
throw new IOException(""Unable to get size of compress log file"", e);
}

//comment
synchronized (this) {
//comment
if (!historyManager.removeFile(originalFile)) {
//comment
try {
Files.deleteIfExists(tempFile);
}
catch (IOException e) {
throw new IOException(""Unable to delete compress log file"", e);
}
return;
}

Path compressedFile = originalFile.resolveSibling(originalFile.getFileName() + compressionExtension);

//comment
LogFileName compressedFileName = originalLogFileName.withCompression(compressedFile);
try {
Files.move(tempFile, compressedFile, ATOMIC_MOVE);
}
catch (IOException e) {
//comment
historyManager.addFile(originalFile, originalLogFileName, originalFileSize);

//comment
try {
Files.deleteIfExists(tempFile);
}
catch (IOException ignored) {
//comment
}
}
historyManager.addFile(compressedFile, compressedFileName, compressedSize);

//comment
try {
<start>Files.deleteIfExists(originalFile);<end>
}
catch (IOException deleteException) {
//comment
try {
Files.move(originalFile, originalFile.resolveSibling(DELETED_PREFIX + originalFile.getFileName()), ATOMIC_MOVE);
}
catch (IOException ignored) {
//comment
throw new IOException(""Unable to delete original file after compression"", deleteException);
}
}
}
}"
1288,"private void compressInternal(Path originalFile, LogFileName originalLogFileName, long originalFileSize)
throws IOException
{
tryCleanupTempFiles(symlink);

String compressionExtension = compressionType.getExtension().orElseThrow(IllegalStateException::new);

//comment
Path tempFile = originalFile.resolveSibling(TEMP_PREFIX + originalFile.getFileName() + compressionExtension);
try (
InputStream input = Files.newInputStream(originalFile);
GZIPOutputStream gzipOutputStream = new GZIPOutputStream(Files.newOutputStream(tempFile))) {
ByteStreams.copy(input, gzipOutputStream);
}
catch (IOException e) {
throw new IOException(""Unable to compress log file"", e);
}

//comment
long compressedSize;
try {
compressedSize = Files.size(tempFile);
}
catch (IOException e) {
throw new IOException(""Unable to get size of compress log file"", e);
}

//comment
synchronized (this) {
//comment
if (!historyManager.removeFile(originalFile)) {
//comment
try {
Files.deleteIfExists(tempFile);
}
catch (IOException e) {
throw new IOException(""Unable to delete compress log file"", e);
}
return;
}

Path compressedFile = originalFile.resolveSibling(originalFile.getFileName() + compressionExtension);

//comment
LogFileName compressedFileName = originalLogFileName.withCompression(compressedFile);
try {
Files.move(tempFile, compressedFile, ATOMIC_MOVE);
}
catch (IOException e) {
//comment
historyManager.addFile(originalFile, originalLogFileName, originalFileSize);

//comment
try {
Files.deleteIfExists(tempFile);
}
catch (IOException ignored) {
//comment
}
}
historyManager.addFile(compressedFile, compressedFileName, compressedSize);

//comment
try {
Files.deleteIfExists(originalFile);
}
catch (IOException deleteException) {
//comment
<start>try {
Files.move(originalFile, originalFile.resolveSibling(DELETED_PREFIX + originalFile.getFileName()), ATOMIC_MOVE);
}
catch (IOException ignored) {
//comment
throw new IOException(""Unable to delete original file after compression"", deleteException);
}<end>
}
}
}","private void compressInternal(Path originalFile, LogFileName originalLogFileName, long originalFileSize)
throws IOException
{
tryCleanupTempFiles(symlink);

String compressionExtension = compressionType.getExtension().orElseThrow(IllegalStateException::new);

//comment
Path tempFile = originalFile.resolveSibling(TEMP_PREFIX + originalFile.getFileName() + compressionExtension);
try (
InputStream input = Files.newInputStream(originalFile);
GZIPOutputStream gzipOutputStream = new GZIPOutputStream(Files.newOutputStream(tempFile))) {
ByteStreams.copy(input, gzipOutputStream);
}
catch (IOException e) {
throw new IOException(""Unable to compress log file"", e);
}

//comment
long compressedSize;
try {
compressedSize = Files.size(tempFile);
}
catch (IOException e) {
throw new IOException(""Unable to get size of compress log file"", e);
}

//comment
synchronized (this) {
//comment
if (!historyManager.removeFile(originalFile)) {
//comment
try {
Files.deleteIfExists(tempFile);
}
catch (IOException e) {
throw new IOException(""Unable to delete compress log file"", e);
}
return;
}

Path compressedFile = originalFile.resolveSibling(originalFile.getFileName() + compressionExtension);

//comment
LogFileName compressedFileName = originalLogFileName.withCompression(compressedFile);
try {
Files.move(tempFile, compressedFile, ATOMIC_MOVE);
}
catch (IOException e) {
//comment
historyManager.addFile(originalFile, originalLogFileName, originalFileSize);

//comment
try {
Files.deleteIfExists(tempFile);
}
catch (IOException ignored) {
//comment
}
}
historyManager.addFile(compressedFile, compressedFileName, compressedSize);

//comment
try {
Files.deleteIfExists(originalFile);
}
catch (IOException deleteException) {
//comment
try {
<start>Files.move(originalFile, originalFile.resolveSibling(DELETED_PREFIX + originalFile.getFileName()), ATOMIC_MOVE);<end>
}
catch (IOException ignored) {
//comment
throw new IOException(""Unable to delete original file after compression"", deleteException);
}
}
}
}"
1289,"private void compressInternal(Path originalFile, LogFileName originalLogFileName, long originalFileSize)
throws IOException
{
tryCleanupTempFiles(symlink);

String compressionExtension = compressionType.getExtension().orElseThrow(IllegalStateException::new);

//comment
Path tempFile = originalFile.resolveSibling(TEMP_PREFIX + originalFile.getFileName() + compressionExtension);
try (
InputStream input = Files.newInputStream(originalFile);
GZIPOutputStream gzipOutputStream = new GZIPOutputStream(Files.newOutputStream(tempFile))) {
ByteStreams.copy(input, gzipOutputStream);
}
catch (IOException e) {
throw new IOException(""Unable to compress log file"", e);
}

//comment
long compressedSize;
try {
compressedSize = Files.size(tempFile);
}
catch (IOException e) {
throw new IOException(""Unable to get size of compress log file"", e);
}

//comment
synchronized (this) {
//comment
if (!historyManager.removeFile(originalFile)) {
//comment
try {
Files.deleteIfExists(tempFile);
}
catch (IOException e) {
throw new IOException(""Unable to delete compress log file"", e);
}
return;
}

Path compressedFile = originalFile.resolveSibling(originalFile.getFileName() + compressionExtension);

//comment
LogFileName compressedFileName = originalLogFileName.withCompression(compressedFile);
try {
Files.move(tempFile, compressedFile, ATOMIC_MOVE);
}
catch (IOException e) {
//comment
historyManager.addFile(originalFile, originalLogFileName, originalFileSize);

//comment
try {
Files.deleteIfExists(tempFile);
}
catch (IOException ignored) {
//comment
}
}
historyManager.addFile(compressedFile, compressedFileName, compressedSize);

//comment
try {
Files.deleteIfExists(originalFile);
}
catch (IOException deleteException) {
//comment
try {
Files.move(originalFile, originalFile.resolveSibling(DELETED_PREFIX + originalFile.getFileName()), ATOMIC_MOVE);
}
<start>catch (IOException ignored) {<end>
//comment
throw new IOException(""Unable to delete original file after compression"", deleteException);
}
}
}
}","private void compressInternal(Path originalFile, LogFileName originalLogFileName, long originalFileSize)
throws IOException
{
tryCleanupTempFiles(symlink);

String compressionExtension = compressionType.getExtension().orElseThrow(IllegalStateException::new);

//comment
Path tempFile = originalFile.resolveSibling(TEMP_PREFIX + originalFile.getFileName() + compressionExtension);
try (
InputStream input = Files.newInputStream(originalFile);
GZIPOutputStream gzipOutputStream = new GZIPOutputStream(Files.newOutputStream(tempFile))) {
ByteStreams.copy(input, gzipOutputStream);
}
catch (IOException e) {
throw new IOException(""Unable to compress log file"", e);
}

//comment
long compressedSize;
try {
compressedSize = Files.size(tempFile);
}
catch (IOException e) {
throw new IOException(""Unable to get size of compress log file"", e);
}

//comment
synchronized (this) {
//comment
if (!historyManager.removeFile(originalFile)) {
//comment
try {
Files.deleteIfExists(tempFile);
}
catch (IOException e) {
throw new IOException(""Unable to delete compress log file"", e);
}
return;
}

Path compressedFile = originalFile.resolveSibling(originalFile.getFileName() + compressionExtension);

//comment
LogFileName compressedFileName = originalLogFileName.withCompression(compressedFile);
try {
Files.move(tempFile, compressedFile, ATOMIC_MOVE);
}
catch (IOException e) {
//comment
historyManager.addFile(originalFile, originalLogFileName, originalFileSize);

//comment
try {
Files.deleteIfExists(tempFile);
}
catch (IOException ignored) {
//comment
}
}
historyManager.addFile(compressedFile, compressedFileName, compressedSize);

//comment
try {
Files.deleteIfExists(originalFile);
}
catch (IOException deleteException) {
//comment
<start>try {
Files.move(originalFile, originalFile.resolveSibling(DELETED_PREFIX + originalFile.getFileName()), ATOMIC_MOVE);
}
catch (IOException ignored) {
//comment
throw new IOException(""Unable to delete original file after compression"", deleteException);
}<end>
}
}
}"
630,"public static KeyStore loadKeyStore(File certificateChainFile, File privateKeyFile, Optional<String> keyPassword, boolean storeKeyWithPassword)
throws IOException, GeneralSecurityException
{
PrivateKey key = loadPrivateKey(privateKeyFile, keyPassword);

List<X509Certificate> certificateChain = readCertificateChain(certificateChainFile);
if (certificateChain.isEmpty()) {
throw new CertificateException(""Certificate file does not contain any certificates: "" + certificateChainFile);
}

KeyStore keyStore = KeyStore.getInstance(""JKS"");
keyStore.load(null, null);

//comment
<start>Certificate[] certificates = certificateChain.toArray(new Certificate[0]);
boolean foundMatchingCertificate = false;
for (int i = 0; i < certificates.length; i++) {
Certificate certificate = certificates[i];
if (matches(key, certificate)) {
foundMatchingCertificate = true;
//comment
certificates[i] = certificates[0];
certificates[0] = certificate;
break;
}
}<end>
if (!foundMatchingCertificate) {
throw new KeyStoreException(""Private key does not match the public key of any certificate"");
}

char[] password = keyPassword.filter(value -> storeKeyWithPassword).orElse("""").toCharArray();
keyStore.setKeyEntry(""key"", key, password, certificates);
return keyStore;
}","public static KeyStore loadKeyStore(File certificateChainFile, File privateKeyFile, Optional<String> keyPassword, boolean storeKeyWithPassword)
throws IOException, GeneralSecurityException
{
PrivateKey key = loadPrivateKey(privateKeyFile, keyPassword);

List<X509Certificate> certificateChain = readCertificateChain(certificateChainFile);
if (certificateChain.isEmpty()) {
throw new CertificateException(""Certificate file does not contain any certificates: "" + certificateChainFile);
}

KeyStore keyStore = KeyStore.getInstance(""JKS"");
keyStore.load(null, null);

//comment
<start>Certificate[] certificates = certificateChain.toArray(new Certificate[0]);
boolean foundMatchingCertificate = false;
for (int i = 0; i < certificates.length; i++) {
Certificate certificate = certificates[i];
if (matches(key, certificate)) {
foundMatchingCertificate = true;
//comment
certificates[i] = certificates[0];
certificates[0] = certificate;
break;
}
}<end>
if (!foundMatchingCertificate) {
throw new KeyStoreException(""Private key does not match the public key of any certificate"");
}

char[] password = keyPassword.filter(value -> storeKeyWithPassword).orElse("""").toCharArray();
keyStore.setKeyEntry(""key"", key, password, certificates);
return keyStore;
}"
631,"public static KeyStore loadKeyStore(File certificateChainFile, File privateKeyFile, Optional<String> keyPassword, boolean storeKeyWithPassword)
throws IOException, GeneralSecurityException
{
PrivateKey key = loadPrivateKey(privateKeyFile, keyPassword);

List<X509Certificate> certificateChain = readCertificateChain(certificateChainFile);
if (certificateChain.isEmpty()) {
throw new CertificateException(""Certificate file does not contain any certificates: "" + certificateChainFile);
}

KeyStore keyStore = KeyStore.getInstance(""JKS"");
keyStore.load(null, null);

//comment
Certificate[] certificates = certificateChain.toArray(new Certificate[0]);
boolean foundMatchingCertificate = false;
for (int i = 0; i < certificates.length; i++) {
Certificate certificate = certificates[i];
if (matches(key, certificate)) {
foundMatchingCertificate = true;
//comment
certificates[i] = certificates[0];
<start>certificates[0] = certificate;<end>
break;
}
}
if (!foundMatchingCertificate) {
throw new KeyStoreException(""Private key does not match the public key of any certificate"");
}

char[] password = keyPassword.filter(value -> storeKeyWithPassword).orElse("""").toCharArray();
keyStore.setKeyEntry(""key"", key, password, certificates);
return keyStore;
}","public static KeyStore loadKeyStore(File certificateChainFile, File privateKeyFile, Optional<String> keyPassword, boolean storeKeyWithPassword)
throws IOException, GeneralSecurityException
{
PrivateKey key = loadPrivateKey(privateKeyFile, keyPassword);

List<X509Certificate> certificateChain = readCertificateChain(certificateChainFile);
if (certificateChain.isEmpty()) {
throw new CertificateException(""Certificate file does not contain any certificates: "" + certificateChainFile);
}

KeyStore keyStore = KeyStore.getInstance(""JKS"");
keyStore.load(null, null);

//comment
Certificate[] certificates = certificateChain.toArray(new Certificate[0]);
boolean foundMatchingCertificate = false;
for (int i = 0; i < certificates.length; i++) {
Certificate certificate = certificates[i];
if (matches(key, certificate)) {
foundMatchingCertificate = true;
//comment
certificates[i] = certificates[0];
<start>certificates[0] = certificate;<end>
break;
}
}
if (!foundMatchingCertificate) {
throw new KeyStoreException(""Private key does not match the public key of any certificate"");
}

char[] password = keyPassword.filter(value -> storeKeyWithPassword).orElse("""").toCharArray();
keyStore.setKeyEntry(""key"", key, password, certificates);
return keyStore;
}"
1064,"    public synchronized void merge(DecayCounter decayCounter)
{
<start>requireNonNull(decayCounter, ""decayCounter is null"");<end>
checkArgument(decayCounter.alpha == alpha, ""Expected decayCounter to have alpha %s, but was %s"", alpha, decayCounter.alpha);

<start>synchronized (decayCounter) {<end>
//comment
if (landmarkInSeconds < decayCounter.landmarkInSeconds) {
//comment
<start>rescaleToNewLandmark(decayCounter.landmarkInSeconds);<end>
count += decayCounter.count;
}
else {
//comment
double otherRescaledCount = decayCounter.count / weight(alpha, landmarkInSeconds, decayCounter.landmarkInSeconds);
count += otherRescaledCount;
}
}
}","    public synchronized void merge(DecayCounter decayCounter)
{
requireNonNull(decayCounter, ""decayCounter is null"");
checkArgument(decayCounter.alpha == alpha, ""Expected decayCounter to have alpha %s, but was %s"", alpha, decayCounter.alpha);

synchronized (decayCounter) {
//comment
<start>if (landmarkInSeconds < decayCounter.landmarkInSeconds) {<end>
//comment
rescaleToNewLandmark(decayCounter.landmarkInSeconds);
count += decayCounter.count;
}
else {
//comment
double otherRescaledCount = decayCounter.count / weight(alpha, landmarkInSeconds, decayCounter.landmarkInSeconds);
count += otherRescaledCount;
}
}
}"
1065,"    public synchronized void merge(DecayCounter decayCounter)
{
requireNonNull(decayCounter, ""decayCounter is null"");
checkArgument(decayCounter.alpha == alpha, ""Expected decayCounter to have alpha %s, but was %s"", alpha, decayCounter.alpha);

synchronized (decayCounter) {
//comment
if (landmarkInSeconds < decayCounter.landmarkInSeconds) {
//comment
rescaleToNewLandmark(decayCounter.landmarkInSeconds);
count += decayCounter.count;
}
else {
//comment
double otherRescaledCount = decayCounter.count / weight(alpha, landmarkInSeconds, decayCounter.landmarkInSeconds);
count += otherRescaledCount;
}
}
}","    public synchronized void merge(DecayCounter decayCounter)
{
requireNonNull(decayCounter, ""decayCounter is null"");
checkArgument(decayCounter.alpha == alpha, ""Expected decayCounter to have alpha %s, but was %s"", alpha, decayCounter.alpha);

synchronized (decayCounter) {
//comment
if (landmarkInSeconds < decayCounter.landmarkInSeconds) {
//comment
<start>rescaleToNewLandmark(decayCounter.landmarkInSeconds);
count += decayCounter.count;<end>
}
else {
//comment
double otherRescaledCount = decayCounter.count / weight(alpha, landmarkInSeconds, decayCounter.landmarkInSeconds);
count += otherRescaledCount;
}
}
}"
1066,"    public synchronized void merge(DecayCounter decayCounter)
{
requireNonNull(decayCounter, ""decayCounter is null"");
checkArgument(decayCounter.alpha == alpha, ""Expected decayCounter to have alpha %s, but was %s"", alpha, decayCounter.alpha);

synchronized (decayCounter) {
//comment
if (landmarkInSeconds < decayCounter.landmarkInSeconds) {
//comment
rescaleToNewLandmark(decayCounter.landmarkInSeconds);
count += decayCounter.count;
}
else {
//comment
<start>double otherRescaledCount = decayCounter.count / weight(alpha, landmarkInSeconds, decayCounter.landmarkInSeconds);<end>
count += otherRescaledCount;
}
}
}","    public synchronized void merge(DecayCounter decayCounter)
{
requireNonNull(decayCounter, ""decayCounter is null"");
checkArgument(decayCounter.alpha == alpha, ""Expected decayCounter to have alpha %s, but was %s"", alpha, decayCounter.alpha);

synchronized (decayCounter) {
//comment
if (landmarkInSeconds < decayCounter.landmarkInSeconds) {
//comment
rescaleToNewLandmark(decayCounter.landmarkInSeconds);
count += decayCounter.count;
}
else {
//comment
<start>double otherRescaledCount = decayCounter.count / weight(alpha, landmarkInSeconds, decayCounter.landmarkInSeconds);
count += otherRescaledCount;<end>
}
}
}"
1067,"<start>    private void rescaleToNewLandmark(long newLandMarkInSeconds)<end>
{
//comment
<start>count = count / weight(alpha, newLandMarkInSeconds, landmarkInSeconds);
landmarkInSeconds = newLandMarkInSeconds;<end>
}","    private void rescaleToNewLandmark(long newLandMarkInSeconds)
{
//comment
<start>count = count / weight(alpha, newLandMarkInSeconds, landmarkInSeconds);
landmarkInSeconds = newLandMarkInSeconds;<end>
}"
4474,"<start>public static double oneMinute()<end>
{
//comment
<start>return 1.0 / TimeUnit.MINUTES.toSeconds(1);<end>
}","public static double oneMinute()
{
//comment
<start>return 1.0 / TimeUnit.MINUTES.toSeconds(1);<end>
}"
4475,"<start>public static double fiveMinutes()<end>
{
//comment
<start>return 1.0 / TimeUnit.MINUTES.toSeconds(5);<end>
}","public static double fiveMinutes()
{
//comment
<start>return 1.0 / TimeUnit.MINUTES.toSeconds(5);<end>
}"
4476,"<start>public static double fifteenMinutes()<end>
{
//comment
<start>return 1.0 / TimeUnit.MINUTES.toSeconds(15);<end>
}","public static double fifteenMinutes()
{
//comment
<start>return 1.0 / TimeUnit.MINUTES.toSeconds(15);<end>
}"
4477,"<start>public static double seconds(int seconds)<end>
{
//comment
<start>return 1.0 / seconds;<end>
}","public static double seconds(int seconds)
{
//comment
<start>return 1.0 / seconds;<end>
}"
2786,"public void merge(QuantileDigest other)
{
rescaleToCommonLandmark(this, other);

//comment
<start>root = merge(root, other, other.root);<end>

max = Math.max(max, other.max);
min = Math.min(min, other.min);

//comment
compress();
}","public void merge(QuantileDigest other)
{
rescaleToCommonLandmark(this, other);

//comment
<start>root = merge(root, other, other.root);<end>

max = Math.max(max, other.max);
min = Math.min(min, other.min);

//comment
compress();
}"
2787,"public void merge(QuantileDigest other)
{
rescaleToCommonLandmark(this, other);

//comment
root = merge(root, other, other.root);

max = Math.max(max, other.max);
min = Math.min(min, other.min);

//comment
<start>compress();<end>
}","public void merge(QuantileDigest other)
{
rescaleToCommonLandmark(this, other);

//comment
root = merge(root, other, other.root);

max = Math.max(max, other.max);
min = Math.min(min, other.min);

//comment
<start>compress();<end>
}"
2788,"@VisibleForTesting
void compress()
{
double bound = Math.floor(weightedCount / calculateCompressionFactor());

<start>postOrderTraversal(root, node -> {<end>
//comment
int left = lefts[node];
int right = rights[node];

if (left == -1 && right == -1) {
//comment
return true;
}

double leftCount = (left == -1) ? 0.0 : counts[left];
double rightCount = (right == -1) ? 0.0 : counts[right];

boolean shouldCompress = (counts[node] + leftCount + rightCount) < bound;

if (left != -1 && (shouldCompress || leftCount < ZERO_WEIGHT_THRESHOLD)) {
lefts[node] = tryRemove(left);
counts[node] += leftCount;
}

if (right != -1 && (shouldCompress || rightCount < ZERO_WEIGHT_THRESHOLD)) {
rights[node] = tryRemove(right);
counts[node] += rightCount;
}

return true;
});

//comment
if (root != -1 && counts[root] < ZERO_WEIGHT_THRESHOLD) {
root = tryRemove(root);
}
}","@VisibleForTesting
void compress()
{
double bound = Math.floor(weightedCount / calculateCompressionFactor());

postOrderTraversal(root, node -> {
//comment
<start>int left = lefts[node];
int right = rights[node];<end>

if (left == -1 && right == -1) {
//comment
return true;
}

<start>double leftCount = (left == -1) ? 0.0 : counts[left];
double rightCount = (right == -1) ? 0.0 : counts[right];<end>

boolean shouldCompress = (counts[node] + leftCount + rightCount) < bound;

if (left != -1 && (shouldCompress || leftCount < ZERO_WEIGHT_THRESHOLD)) {
lefts[node] = tryRemove(left);
counts[node] += leftCount;
}

if (right != -1 && (shouldCompress || rightCount < ZERO_WEIGHT_THRESHOLD)) {
rights[node] = tryRemove(right);
counts[node] += rightCount;
}

return true;
});

//comment
if (root != -1 && counts[root] < ZERO_WEIGHT_THRESHOLD) {
root = tryRemove(root);
}
}"
2789,"<start>private void rescale(long newLandmarkInSeconds)<end>
{
//comment
<start>double factor = weight(alpha, newLandmarkInSeconds, landmarkInSeconds);
weightedCount /= factor;<end>
for (int i = 0; i < nextNode; i++) {
counts[i] /= factor;
}
landmarkInSeconds = newLandmarkInSeconds;
}","private void rescale(long newLandmarkInSeconds)
{
//comment
<start>double factor = weight(alpha, newLandmarkInSeconds, landmarkInSeconds);
weightedCount /= factor;
for (int i = 0; i < nextNode; i++) {
counts[i] /= factor;
}
landmarkInSeconds = newLandmarkInSeconds;<end>
}"
2790,"private void insert(long value, double count)
{
if (count < ZERO_WEIGHT_THRESHOLD) {
return;
}

long lastBranch = 0;
int parent = -1;
int current = root;

while (true) {
if (current == -1) {
setChild(parent, lastBranch, createLeaf(value, count));
return;
}

long currentValue = values[current];
byte currentLevel = levels[current];
<start>if (!inSameSubtree(value, currentValue, currentLevel)) {
//comment
//comment
setChild(parent, lastBranch, makeSiblings(current, createLeaf(value, count)));
return;
}<end>

if (currentLevel == 0 && currentValue == value) {
//comment
counts[current] += count;
weightedCount += count;
return;
}

//comment
long branch = value & getBranchMask(currentLevel);

parent = current;
lastBranch = branch;

if (branch == 0) {
current = lefts[current];
}
else {
current = rights[current];
}
}
}","private void insert(long value, double count)
{
if (count < ZERO_WEIGHT_THRESHOLD) {
return;
}

long lastBranch = 0;
int parent = -1;
int current = root;

while (true) {
if (current == -1) {
setChild(parent, lastBranch, createLeaf(value, count));
return;
}

long currentValue = values[current];
byte currentLevel = levels[current];
<start>if (!inSameSubtree(value, currentValue, currentLevel)) {
//comment
//comment
setChild(parent, lastBranch, makeSiblings(current, createLeaf(value, count)));
return;
}<end>

if (currentLevel == 0 && currentValue == value) {
//comment
counts[current] += count;
weightedCount += count;
return;
}

//comment
long branch = value & getBranchMask(currentLevel);

parent = current;
lastBranch = branch;

if (branch == 0) {
current = lefts[current];
}
else {
current = rights[current];
}
}
}"
881,"<start>    private void acquirePermit()<end>
{
<start>if (counter.incrementAndGet() <= maxPermits) {
//comment
submitExecutor.execute(runNextTask);
}<end>
}","    private void acquirePermit()
{
<start>if (counter.incrementAndGet() <= maxPermits) {
//comment
submitExecutor.execute(runNextTask);
}<end>
}"
882,"    private void releasePermit()
{
<start>if (counter.getAndDecrement() > maxPermits) {
//comment
submitExecutor.execute(runNextTask);
}<end>
}","    private void releasePermit()
{
<start>if (counter.getAndDecrement() > maxPermits) {
//comment
submitExecutor.execute(runNextTask);
}<end>
}"
56,"public void startFlashAnimation(final View flashOverlay) {
//comment
<start>if (mFlashAnim != null && mFlashAnim.isRunning()) {
mFlashAnim.cancel();
}<end>
//comment
mFlashAnim = ObjectAnimator.ofFloat(flashOverlay, ""alpha"",
AnimationManager.FLASH_ALPHA_START, AnimationManager.FLASH_ALPHA_END);
mFlashAnim.setDuration(AnimationManager.FLASH_DURATION);
mFlashAnim.addListener(new Animator.AnimatorListener() {
@Override
public void onAnimationStart(Animator animator) {
flashOverlay.setVisibility(View.VISIBLE);
}

@Override
public void onAnimationEnd(Animator animator) {
flashOverlay.setAlpha(0f);
flashOverlay.setVisibility(View.GONE);
mFlashAnim.removeAllListeners();
mFlashAnim = null;
}

@Override
public void onAnimationCancel(Animator animator) {
//comment
}

@Override
public void onAnimationRepeat(Animator animator) {
//comment
}
});
mFlashAnim.start();
}","public void startFlashAnimation(final View flashOverlay) {
//comment
<start>if (mFlashAnim != null && mFlashAnim.isRunning()) {
mFlashAnim.cancel();
}<end>
//comment
mFlashAnim = ObjectAnimator.ofFloat(flashOverlay, ""alpha"",
AnimationManager.FLASH_ALPHA_START, AnimationManager.FLASH_ALPHA_END);
mFlashAnim.setDuration(AnimationManager.FLASH_DURATION);
mFlashAnim.addListener(new Animator.AnimatorListener() {
@Override
public void onAnimationStart(Animator animator) {
flashOverlay.setVisibility(View.VISIBLE);
}

@Override
public void onAnimationEnd(Animator animator) {
flashOverlay.setAlpha(0f);
flashOverlay.setVisibility(View.GONE);
mFlashAnim.removeAllListeners();
mFlashAnim = null;
}

@Override
public void onAnimationCancel(Animator animator) {
//comment
}

@Override
public void onAnimationRepeat(Animator animator) {
//comment
}
});
mFlashAnim.start();
}"
57,"<start>public void startFlashAnimation(final View flashOverlay) {<end>
//comment
if (mFlashAnim != null && mFlashAnim.isRunning()) {
mFlashAnim.cancel();
}
//comment
mFlashAnim = ObjectAnimator.ofFloat(flashOverlay, ""alpha"",
AnimationManager.FLASH_ALPHA_START, AnimationManager.FLASH_ALPHA_END);
mFlashAnim.setDuration(AnimationManager.FLASH_DURATION);
mFlashAnim.addListener(new Animator.AnimatorListener() {
@Override
public void onAnimationStart(Animator animator) {
flashOverlay.setVisibility(View.VISIBLE);
}

@Override
public void onAnimationEnd(Animator animator) {
flashOverlay.setAlpha(0f);
flashOverlay.setVisibility(View.GONE);
mFlashAnim.removeAllListeners();
mFlashAnim = null;
}

@Override
public void onAnimationCancel(Animator animator) {
//comment
}

@Override
public void onAnimationRepeat(Animator animator) {
//comment
}
});
mFlashAnim.start();
}","public void startFlashAnimation(final View flashOverlay) {
//comment
if (mFlashAnim != null && mFlashAnim.isRunning()) {
mFlashAnim.cancel();
}
//comment
<start>mFlashAnim = ObjectAnimator.ofFloat(flashOverlay, ""alpha"",
AnimationManager.FLASH_ALPHA_START, AnimationManager.FLASH_ALPHA_END);
mFlashAnim.setDuration(AnimationManager.FLASH_DURATION);<end>
mFlashAnim.addListener(new Animator.AnimatorListener() {
@Override
public void onAnimationStart(Animator animator) {
flashOverlay.setVisibility(View.VISIBLE);
}

@Override
public void onAnimationEnd(Animator animator) {
flashOverlay.setAlpha(0f);
flashOverlay.setVisibility(View.GONE);
mFlashAnim.removeAllListeners();
mFlashAnim = null;
}

@Override
public void onAnimationCancel(Animator animator) {
//comment
}

@Override
public void onAnimationRepeat(Animator animator) {
//comment
}
});
mFlashAnim.start();
}"
58,"<start>    public void cancelAnimations() {
//comment
if (mFlashAnim != null && mFlashAnim.isRunning()) {
mFlashAnim.cancel();
}<end>
if (mCaptureAnimator != null && mCaptureAnimator.isStarted()) {
mCaptureAnimator.cancel();
}
}","    public void cancelAnimations() {
//comment
<start>if (mFlashAnim != null && mFlashAnim.isRunning()) {
mFlashAnim.cancel();
}<end>
if (mCaptureAnimator != null && mCaptureAnimator.isStarted()) {
mCaptureAnimator.cancel();
}
}"
59,"<start>    public void setParameters(Parameters parameters) {
//comment
//comment
//comment
//comment
if (parameters == null) return;
mParameters = parameters;
mFocusAreaSupported = CameraUtil.isFocusAreaSupported(parameters);<end>
mMeteringAreaSupported = CameraUtil.isMeteringAreaSupported(parameters);
mLockAeAwbNeeded = (CameraUtil.isAutoExposureLockSupported(mParameters) ||
CameraUtil.isAutoWhiteBalanceLockSupported(mParameters));
}","    public void setParameters(Parameters parameters) {
//comment
//comment
//comment
//comment
<start>if (parameters == null) return;
mParameters = parameters;
mFocusAreaSupported = CameraUtil.isFocusAreaSupported(parameters);
mMeteringAreaSupported = CameraUtil.isMeteringAreaSupported(parameters);
mLockAeAwbNeeded = (CameraUtil.isAutoExposureLockSupported(mParameters) ||
CameraUtil.isAutoWhiteBalanceLockSupported(mParameters));<end>
}"
60,"private void setMatrix() {
if (mPreviewRect.width() != 0 && mPreviewRect.height() != 0) {
Matrix matrix = new Matrix();
<start>CameraUtil.prepareMatrix(matrix, mMirror, mDisplayOrientation, getPreviewRect());
//comment
//comment
//comment
matrix.invert(mMatrix);
mInitialized = true;<end>
}
}","private void setMatrix() {
if (mPreviewRect.width() != 0 && mPreviewRect.height() != 0) {
<start>Matrix matrix = new Matrix();
CameraUtil.prepareMatrix(matrix, mMirror, mDisplayOrientation, getPreviewRect());
//comment
//comment
//comment
matrix.invert(mMatrix);
mInitialized = true;<end>
}
}"
61,"    public void onShutterDown() {
if (!mInitialized) return;

boolean autoFocusCalled = false;
if (needAutoFocusCall()) {
//comment
if (mState != STATE_SUCCESS && mState != STATE_FAIL) {
<start>autoFocus();<end>
autoFocusCalled = true;
}
}

if (!autoFocusCalled) lockAeAwbIfNeeded();
}","    public void onShutterDown() {
if (!mInitialized) return;

boolean autoFocusCalled = false;
if (needAutoFocusCall()) {
//comment
<start>if (mState != STATE_SUCCESS && mState != STATE_FAIL) {
autoFocus();
autoFocusCalled = true;
}<end>
}

if (!autoFocusCalled) lockAeAwbIfNeeded();
}"
62,"    public void onShutterUp() {
if (!mInitialized) return;

if (needAutoFocusCall()) {
//comment
if (mState == STATE_SUCCESS
|| mState == STATE_FAIL) {
cancelAutoFocus();
}
}

//comment
//comment
unlockAeAwbIfNeeded();
}","    public void onShutterUp() {
if (!mInitialized) return;

if (needAutoFocusCall()) {
//comment
<start>if (mState == STATE_SUCCESS
|| mState == STATE_FAIL) {
cancelAutoFocus();
}<end>
}

//comment
//comment
unlockAeAwbIfNeeded();
}"
63,"    public void doSnap() {
if (!mInitialized) return;

//comment
//comment
//comment
if (!needAutoFocusCall() || (mState == STATE_SUCCESS || mState == STATE_FAIL)) {
<start>capture();
} else if (mState == STATE_FOCUSING) {<end>
//comment
//comment
//comment
mState = STATE_FOCUSING_SNAP_ON_FINISH;
} else if (mState == STATE_IDLE) {
//comment
//comment
//comment
//comment
capture();
}
}","    public void doSnap() {
if (!mInitialized) return;

//comment
//comment
//comment
<start>if (!needAutoFocusCall() || (mState == STATE_SUCCESS || mState == STATE_FAIL)) {
capture();
} else if (mState == STATE_FOCUSING) {
//comment
//comment
//comment
mState = STATE_FOCUSING_SNAP_ON_FINISH;
} else if (mState == STATE_IDLE) {
//comment
//comment
//comment
//comment
capture();
}<end>
}"
64,"    public void doSnap() {
if (!mInitialized) return;

//comment
//comment
//comment
if (!needAutoFocusCall() || (mState == STATE_SUCCESS || mState == STATE_FAIL)) {
capture();
} else if (mState == STATE_FOCUSING) {
//comment
//comment
//comment
<start>mState = STATE_FOCUSING_SNAP_ON_FINISH;<end>
} else if (mState == STATE_IDLE) {
//comment
//comment
//comment
//comment
capture();
}
}","    public void doSnap() {
if (!mInitialized) return;

//comment
//comment
//comment
if (!needAutoFocusCall() || (mState == STATE_SUCCESS || mState == STATE_FAIL)) {
capture();
<start>} else if (mState == STATE_FOCUSING) {
//comment
//comment
//comment
mState = STATE_FOCUSING_SNAP_ON_FINISH;
} else if (mState == STATE_IDLE) {<end>
//comment
//comment
//comment
//comment
capture();
}
}"
65,"    public void doSnap() {
if (!mInitialized) return;

//comment
//comment
//comment
if (!needAutoFocusCall() || (mState == STATE_SUCCESS || mState == STATE_FAIL)) {
capture();
} else if (mState == STATE_FOCUSING) {
//comment
//comment
//comment
mState = STATE_FOCUSING_SNAP_ON_FINISH;
} else if (mState == STATE_IDLE) {
//comment
//comment
//comment
//comment
capture();
}
}","    public void doSnap() {
if (!mInitialized) return;

//comment
//comment
//comment
if (!needAutoFocusCall() || (mState == STATE_SUCCESS || mState == STATE_FAIL)) {
capture();
} else if (mState == STATE_FOCUSING) {
//comment
//comment
//comment
mState = STATE_FOCUSING_SNAP_ON_FINISH;
<start>} else if (mState == STATE_IDLE) {
//comment
//comment
//comment
//comment
capture();
}<end>
}"
66,"public void onAutoFocus(boolean focused, boolean shutterButtonPressed) {
if (mState == STATE_FOCUSING_SNAP_ON_FINISH) {
//comment
//comment
//comment
if (focused) {
mState = STATE_SUCCESS;
} else {
mState = STATE_FAIL;
}
updateFocusUI();
capture();
} else if (mState == STATE_FOCUSING) {
//comment
//comment
//comment
if (focused) {
mState = STATE_SUCCESS;
} else {
mState = STATE_FAIL;
}
updateFocusUI();
//comment
//comment
if (mFocusArea != null) {
mHandler.sendEmptyMessageDelayed(RESET_TOUCH_FOCUS, RESET_TOUCH_FOCUS_DELAY);
}
if (shutterButtonPressed) {
//comment
lockAeAwbIfNeeded();
}
} else if (mState == STATE_IDLE) {
//comment
//comment
}
}","public void onAutoFocus(boolean focused, boolean shutterButtonPressed) {
if (mState == STATE_FOCUSING_SNAP_ON_FINISH) {
//comment
//comment
//comment
<start>if (focused) {
mState = STATE_SUCCESS;
} else {
mState = STATE_FAIL;
}
updateFocusUI();
capture();<end>
} else if (mState == STATE_FOCUSING) {
//comment
//comment
//comment
if (focused) {
mState = STATE_SUCCESS;
} else {
mState = STATE_FAIL;
}
updateFocusUI();
//comment
//comment
if (mFocusArea != null) {
mHandler.sendEmptyMessageDelayed(RESET_TOUCH_FOCUS, RESET_TOUCH_FOCUS_DELAY);
}
if (shutterButtonPressed) {
//comment
lockAeAwbIfNeeded();
}
} else if (mState == STATE_IDLE) {
//comment
//comment
}
}"
67,"public void onAutoFocus(boolean focused, boolean shutterButtonPressed) {
if (mState == STATE_FOCUSING_SNAP_ON_FINISH) {
//comment
//comment
//comment
if (focused) {
mState = STATE_SUCCESS;
} else {
mState = STATE_FAIL;
}
updateFocusUI();
capture();
<start>} else if (mState == STATE_FOCUSING) {<end>
//comment
//comment
//comment
if (focused) {
mState = STATE_SUCCESS;
} else {
<start>mState = STATE_FAIL;<end>
}
<start>updateFocusUI();<end>
//comment
//comment
if (mFocusArea != null) {
<start>mHandler.sendEmptyMessageDelayed(RESET_TOUCH_FOCUS, RESET_TOUCH_FOCUS_DELAY);<end>
}
if (shutterButtonPressed) {
//comment
lockAeAwbIfNeeded();
}
} else if (mState == STATE_IDLE) {
//comment
//comment
}
}","public void onAutoFocus(boolean focused, boolean shutterButtonPressed) {
if (mState == STATE_FOCUSING_SNAP_ON_FINISH) {
//comment
//comment
//comment
if (focused) {
mState = STATE_SUCCESS;
} else {
mState = STATE_FAIL;
}
updateFocusUI();
capture();
} else if (mState == STATE_FOCUSING) {
//comment
//comment
//comment
if (focused) {
mState = STATE_SUCCESS;
} else {
mState = STATE_FAIL;
}
updateFocusUI();
//comment
//comment
<start>if (mFocusArea != null) {
mHandler.sendEmptyMessageDelayed(RESET_TOUCH_FOCUS, RESET_TOUCH_FOCUS_DELAY);
}<end>
if (shutterButtonPressed) {
//comment
lockAeAwbIfNeeded();
}
} else if (mState == STATE_IDLE) {
//comment
//comment
}
}"
68,"public void onAutoFocus(boolean focused, boolean shutterButtonPressed) {
if (mState == STATE_FOCUSING_SNAP_ON_FINISH) {
//comment
//comment
//comment
if (focused) {
mState = STATE_SUCCESS;
} else {
mState = STATE_FAIL;
}
updateFocusUI();
capture();
} else if (mState == STATE_FOCUSING) {
//comment
//comment
//comment
if (focused) {
mState = STATE_SUCCESS;
} else {
mState = STATE_FAIL;
}
updateFocusUI();
//comment
//comment
if (mFocusArea != null) {
mHandler.sendEmptyMessageDelayed(RESET_TOUCH_FOCUS, RESET_TOUCH_FOCUS_DELAY);
}
<start>if (shutterButtonPressed) {
//comment
lockAeAwbIfNeeded();
}<end>
} else if (mState == STATE_IDLE) {
//comment
//comment
}
}","public void onAutoFocus(boolean focused, boolean shutterButtonPressed) {
if (mState == STATE_FOCUSING_SNAP_ON_FINISH) {
//comment
//comment
//comment
if (focused) {
mState = STATE_SUCCESS;
} else {
mState = STATE_FAIL;
}
updateFocusUI();
capture();
} else if (mState == STATE_FOCUSING) {
//comment
//comment
//comment
if (focused) {
mState = STATE_SUCCESS;
} else {
mState = STATE_FAIL;
}
updateFocusUI();
//comment
//comment
if (mFocusArea != null) {
mHandler.sendEmptyMessageDelayed(RESET_TOUCH_FOCUS, RESET_TOUCH_FOCUS_DELAY);
}
<start>if (shutterButtonPressed) {
//comment
lockAeAwbIfNeeded();
}<end>
} else if (mState == STATE_IDLE) {
//comment
//comment
}
}"
69,"public void onAutoFocusMoving(boolean moving) {
if (!mInitialized) return;


//comment
if (mUI.hasFaces()) {
mUI.clearFocus();
if (mIsAFRunning) {
mUI.onFocusSucceeded(true);
mIsAFRunning = false;
}
return;
}

//comment
//comment
if (mState != STATE_IDLE) return;

//comment
if (moving && !mPreviousMoving) {
mUI.onFocusStarted();
mIsAFRunning = true;
} else if (!moving) {
mUI.onFocusSucceeded(true);
mIsAFRunning = false;
}

mHandler.sendEmptyMessageDelayed(RESET_FACE_DETECTION, RESET_FACE_DETECTION_DELAY);
mPreviousMoving = moving;
}","public void onAutoFocusMoving(boolean moving) {
if (!mInitialized) return;


//comment
<start>if (mUI.hasFaces()) {
mUI.clearFocus();
if (mIsAFRunning) {
mUI.onFocusSucceeded(true);
mIsAFRunning = false;
}
return;
}<end>

//comment
//comment
if (mState != STATE_IDLE) return;

//comment
if (moving && !mPreviousMoving) {
mUI.onFocusStarted();
mIsAFRunning = true;
} else if (!moving) {
mUI.onFocusSucceeded(true);
mIsAFRunning = false;
}

mHandler.sendEmptyMessageDelayed(RESET_FACE_DETECTION, RESET_FACE_DETECTION_DELAY);
mPreviousMoving = moving;
}"
70,"public void onAutoFocusMoving(boolean moving) {
if (!mInitialized) return;


//comment
if (mUI.hasFaces()) {
mUI.clearFocus();
if (mIsAFRunning) {
mUI.onFocusSucceeded(true);
mIsAFRunning = false;
}
return;
}

//comment
//comment
<start>if (mState != STATE_IDLE) return;<end>

//comment
if (moving && !mPreviousMoving) {
mUI.onFocusStarted();
mIsAFRunning = true;
} else if (!moving) {
mUI.onFocusSucceeded(true);
mIsAFRunning = false;
}

mHandler.sendEmptyMessageDelayed(RESET_FACE_DETECTION, RESET_FACE_DETECTION_DELAY);
mPreviousMoving = moving;
}","public void onAutoFocusMoving(boolean moving) {
if (!mInitialized) return;


//comment
if (mUI.hasFaces()) {
mUI.clearFocus();
if (mIsAFRunning) {
mUI.onFocusSucceeded(true);
mIsAFRunning = false;
}
return;
}

//comment
//comment
<start>if (mState != STATE_IDLE) return;<end>

//comment
if (moving && !mPreviousMoving) {
mUI.onFocusStarted();
mIsAFRunning = true;
} else if (!moving) {
mUI.onFocusSucceeded(true);
mIsAFRunning = false;
}

mHandler.sendEmptyMessageDelayed(RESET_FACE_DETECTION, RESET_FACE_DETECTION_DELAY);
mPreviousMoving = moving;
}"
71,"@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
private void initializeFocusAreas(int x, int y) {
if (mFocusArea == null) {
mFocusArea = new ArrayList<Object>();
mFocusArea.add(new Area(new Rect(), 1));
}

//comment
<start>calculateTapArea(x, y, 1f, ((Area) mFocusArea.get(0)).rect);<end>
}","@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
private void initializeFocusAreas(int x, int y) {
if (mFocusArea == null) {
mFocusArea = new ArrayList<Object>();
mFocusArea.add(new Area(new Rect(), 1));
}

//comment
<start>calculateTapArea(x, y, 1f, ((Area) mFocusArea.get(0)).rect);<end>
}"
72,"@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
private void initializeMeteringAreas(int x, int y) {
if (mMeteringArea == null) {
mMeteringArea = new ArrayList<Object>();
mMeteringArea.add(new Area(new Rect(), 1));
}

//comment
//comment
//comment
<start>calculateTapArea(x, y, 1.5f, ((Area) mMeteringArea.get(0)).rect);<end>
}","@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
private void initializeMeteringAreas(int x, int y) {
if (mMeteringArea == null) {
mMeteringArea = new ArrayList<Object>();
mMeteringArea.add(new Area(new Rect(), 1));
}

//comment
//comment
//comment
<start>calculateTapArea(x, y, 1.5f, ((Area) mMeteringArea.get(0)).rect);<end>
}"
73,"public void onSingleTapUp(int x, int y) {
if (!mInitialized || mState == STATE_FOCUSING_SNAP_ON_FINISH) return;

UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,
UsageStatistics.ACTION_TOUCH_FOCUS, x + "","" + y);

//comment
if ((mState == STATE_FOCUSING ||
<start>mState == STATE_SUCCESS || mState == STATE_FAIL)) {
cancelAutoFocus();<end>
}
if (mPreviewRect.width() == 0 || mPreviewRect.height() == 0) return;
//comment
//comment
if (mFocusAreaSupported) {
initializeFocusAreas(x, y);
}
//comment
if (mMeteringAreaSupported) {
initializeMeteringAreas(x, y);
}

//comment
mUI.setFocusPosition(x, y);

if (mZslEnabled) {
mTouchAFRunning = true;
}

//comment
mListener.stopFaceDetection();

//comment
mListener.setFocusParameters();
if (mFocusAreaSupported) {
autoFocus();
} else {
updateFocusUI();
//comment
mHandler.removeMessages(RESET_TOUCH_FOCUS);
mHandler.sendEmptyMessageDelayed(RESET_TOUCH_FOCUS, RESET_TOUCH_FOCUS_DELAY);
}
}","public void onSingleTapUp(int x, int y) {
if (!mInitialized || mState == STATE_FOCUSING_SNAP_ON_FINISH) return;

UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,
UsageStatistics.ACTION_TOUCH_FOCUS, x + "","" + y);

//comment
<start>if ((mState == STATE_FOCUSING ||
mState == STATE_SUCCESS || mState == STATE_FAIL)) {
cancelAutoFocus();
}<end>
if (mPreviewRect.width() == 0 || mPreviewRect.height() == 0) return;
//comment
//comment
if (mFocusAreaSupported) {
initializeFocusAreas(x, y);
}
//comment
if (mMeteringAreaSupported) {
initializeMeteringAreas(x, y);
}

//comment
mUI.setFocusPosition(x, y);

if (mZslEnabled) {
mTouchAFRunning = true;
}

//comment
mListener.stopFaceDetection();

//comment
mListener.setFocusParameters();
if (mFocusAreaSupported) {
autoFocus();
} else {
updateFocusUI();
//comment
mHandler.removeMessages(RESET_TOUCH_FOCUS);
mHandler.sendEmptyMessageDelayed(RESET_TOUCH_FOCUS, RESET_TOUCH_FOCUS_DELAY);
}
}"
74,"public void onSingleTapUp(int x, int y) {
if (!mInitialized || mState == STATE_FOCUSING_SNAP_ON_FINISH) return;

UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,
UsageStatistics.ACTION_TOUCH_FOCUS, x + "","" + y);

//comment
if ((mState == STATE_FOCUSING ||
mState == STATE_SUCCESS || mState == STATE_FAIL)) {
cancelAutoFocus();
}
if (mPreviewRect.width() == 0 || mPreviewRect.height() == 0) return;
//comment
//comment
if (mFocusAreaSupported) {
<start>initializeFocusAreas(x, y);<end>
}
//comment
if (mMeteringAreaSupported) {
initializeMeteringAreas(x, y);
}

//comment
mUI.setFocusPosition(x, y);

if (mZslEnabled) {
mTouchAFRunning = true;
}

//comment
mListener.stopFaceDetection();

//comment
mListener.setFocusParameters();
if (mFocusAreaSupported) {
autoFocus();
} else {
updateFocusUI();
//comment
mHandler.removeMessages(RESET_TOUCH_FOCUS);
mHandler.sendEmptyMessageDelayed(RESET_TOUCH_FOCUS, RESET_TOUCH_FOCUS_DELAY);
}
}","public void onSingleTapUp(int x, int y) {
if (!mInitialized || mState == STATE_FOCUSING_SNAP_ON_FINISH) return;

UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,
UsageStatistics.ACTION_TOUCH_FOCUS, x + "","" + y);

//comment
if ((mState == STATE_FOCUSING ||
mState == STATE_SUCCESS || mState == STATE_FAIL)) {
cancelAutoFocus();
}
if (mPreviewRect.width() == 0 || mPreviewRect.height() == 0) return;
//comment
//comment
<start>if (mFocusAreaSupported) {
initializeFocusAreas(x, y);
}<end>
//comment
if (mMeteringAreaSupported) {
initializeMeteringAreas(x, y);
}

//comment
mUI.setFocusPosition(x, y);

if (mZslEnabled) {
mTouchAFRunning = true;
}

//comment
mListener.stopFaceDetection();

//comment
mListener.setFocusParameters();
if (mFocusAreaSupported) {
autoFocus();
} else {
updateFocusUI();
//comment
mHandler.removeMessages(RESET_TOUCH_FOCUS);
mHandler.sendEmptyMessageDelayed(RESET_TOUCH_FOCUS, RESET_TOUCH_FOCUS_DELAY);
}
}"
75,"public void onSingleTapUp(int x, int y) {
if (!mInitialized || mState == STATE_FOCUSING_SNAP_ON_FINISH) return;

UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,
UsageStatistics.ACTION_TOUCH_FOCUS, x + "","" + y);

//comment
if ((mState == STATE_FOCUSING ||
mState == STATE_SUCCESS || mState == STATE_FAIL)) {
cancelAutoFocus();
}
if (mPreviewRect.width() == 0 || mPreviewRect.height() == 0) return;
//comment
//comment
<start>if (mFocusAreaSupported) {
initializeFocusAreas(x, y);
}
//comment
if (mMeteringAreaSupported) {
initializeMeteringAreas(x, y);
}<end>

//comment
mUI.setFocusPosition(x, y);

if (mZslEnabled) {
mTouchAFRunning = true;
}

//comment
mListener.stopFaceDetection();

//comment
mListener.setFocusParameters();
if (mFocusAreaSupported) {
autoFocus();
} else {
updateFocusUI();
//comment
mHandler.removeMessages(RESET_TOUCH_FOCUS);
mHandler.sendEmptyMessageDelayed(RESET_TOUCH_FOCUS, RESET_TOUCH_FOCUS_DELAY);
}
}","public void onSingleTapUp(int x, int y) {
if (!mInitialized || mState == STATE_FOCUSING_SNAP_ON_FINISH) return;

UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,
UsageStatistics.ACTION_TOUCH_FOCUS, x + "","" + y);

//comment
if ((mState == STATE_FOCUSING ||
mState == STATE_SUCCESS || mState == STATE_FAIL)) {
cancelAutoFocus();
}
if (mPreviewRect.width() == 0 || mPreviewRect.height() == 0) return;
//comment
//comment
if (mFocusAreaSupported) {
initializeFocusAreas(x, y);
}
//comment
<start>if (mMeteringAreaSupported) {
initializeMeteringAreas(x, y);
}<end>

//comment
mUI.setFocusPosition(x, y);

if (mZslEnabled) {
mTouchAFRunning = true;
}

//comment
mListener.stopFaceDetection();

//comment
mListener.setFocusParameters();
if (mFocusAreaSupported) {
autoFocus();
} else {
updateFocusUI();
//comment
mHandler.removeMessages(RESET_TOUCH_FOCUS);
mHandler.sendEmptyMessageDelayed(RESET_TOUCH_FOCUS, RESET_TOUCH_FOCUS_DELAY);
}
}"
76,"public void onSingleTapUp(int x, int y) {
if (!mInitialized || mState == STATE_FOCUSING_SNAP_ON_FINISH) return;

UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,
UsageStatistics.ACTION_TOUCH_FOCUS, x + "","" + y);

//comment
if ((mState == STATE_FOCUSING ||
mState == STATE_SUCCESS || mState == STATE_FAIL)) {
cancelAutoFocus();
}
if (mPreviewRect.width() == 0 || mPreviewRect.height() == 0) return;
//comment
//comment
if (mFocusAreaSupported) {
initializeFocusAreas(x, y);
}
//comment
if (mMeteringAreaSupported) {
initializeMeteringAreas(x, y);
}

//comment
<start>mUI.setFocusPosition(x, y);<end>

if (mZslEnabled) {
mTouchAFRunning = true;
}

//comment
mListener.stopFaceDetection();

//comment
mListener.setFocusParameters();
if (mFocusAreaSupported) {
autoFocus();
} else {
updateFocusUI();
//comment
mHandler.removeMessages(RESET_TOUCH_FOCUS);
mHandler.sendEmptyMessageDelayed(RESET_TOUCH_FOCUS, RESET_TOUCH_FOCUS_DELAY);
}
}","public void onSingleTapUp(int x, int y) {
if (!mInitialized || mState == STATE_FOCUSING_SNAP_ON_FINISH) return;

UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,
UsageStatistics.ACTION_TOUCH_FOCUS, x + "","" + y);

//comment
if ((mState == STATE_FOCUSING ||
mState == STATE_SUCCESS || mState == STATE_FAIL)) {
cancelAutoFocus();
}
if (mPreviewRect.width() == 0 || mPreviewRect.height() == 0) return;
//comment
//comment
if (mFocusAreaSupported) {
initializeFocusAreas(x, y);
}
//comment
if (mMeteringAreaSupported) {
initializeMeteringAreas(x, y);
}

//comment
<start>mUI.setFocusPosition(x, y);<end>

if (mZslEnabled) {
mTouchAFRunning = true;
}

//comment
mListener.stopFaceDetection();

//comment
mListener.setFocusParameters();
if (mFocusAreaSupported) {
autoFocus();
} else {
updateFocusUI();
//comment
mHandler.removeMessages(RESET_TOUCH_FOCUS);
mHandler.sendEmptyMessageDelayed(RESET_TOUCH_FOCUS, RESET_TOUCH_FOCUS_DELAY);
}
}"
77,"public void onSingleTapUp(int x, int y) {
if (!mInitialized || mState == STATE_FOCUSING_SNAP_ON_FINISH) return;

UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,
UsageStatistics.ACTION_TOUCH_FOCUS, x + "","" + y);

//comment
if ((mState == STATE_FOCUSING ||
mState == STATE_SUCCESS || mState == STATE_FAIL)) {
cancelAutoFocus();
}
if (mPreviewRect.width() == 0 || mPreviewRect.height() == 0) return;
//comment
//comment
if (mFocusAreaSupported) {
initializeFocusAreas(x, y);
}
//comment
if (mMeteringAreaSupported) {
initializeMeteringAreas(x, y);
}

//comment
mUI.setFocusPosition(x, y);

if (mZslEnabled) {
mTouchAFRunning = true;
}

//comment
<start>mListener.stopFaceDetection();<end>

//comment
mListener.setFocusParameters();
if (mFocusAreaSupported) {
autoFocus();
} else {
updateFocusUI();
//comment
mHandler.removeMessages(RESET_TOUCH_FOCUS);
mHandler.sendEmptyMessageDelayed(RESET_TOUCH_FOCUS, RESET_TOUCH_FOCUS_DELAY);
}
}","public void onSingleTapUp(int x, int y) {
if (!mInitialized || mState == STATE_FOCUSING_SNAP_ON_FINISH) return;

UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,
UsageStatistics.ACTION_TOUCH_FOCUS, x + "","" + y);

//comment
if ((mState == STATE_FOCUSING ||
mState == STATE_SUCCESS || mState == STATE_FAIL)) {
cancelAutoFocus();
}
if (mPreviewRect.width() == 0 || mPreviewRect.height() == 0) return;
//comment
//comment
if (mFocusAreaSupported) {
initializeFocusAreas(x, y);
}
//comment
if (mMeteringAreaSupported) {
initializeMeteringAreas(x, y);
}

//comment
mUI.setFocusPosition(x, y);

if (mZslEnabled) {
mTouchAFRunning = true;
}

//comment
<start>mListener.stopFaceDetection();<end>

//comment
mListener.setFocusParameters();
if (mFocusAreaSupported) {
autoFocus();
} else {
updateFocusUI();
//comment
mHandler.removeMessages(RESET_TOUCH_FOCUS);
mHandler.sendEmptyMessageDelayed(RESET_TOUCH_FOCUS, RESET_TOUCH_FOCUS_DELAY);
}
}"
78,"public void onSingleTapUp(int x, int y) {
if (!mInitialized || mState == STATE_FOCUSING_SNAP_ON_FINISH) return;

UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,
UsageStatistics.ACTION_TOUCH_FOCUS, x + "","" + y);

//comment
if ((mState == STATE_FOCUSING ||
mState == STATE_SUCCESS || mState == STATE_FAIL)) {
cancelAutoFocus();
}
if (mPreviewRect.width() == 0 || mPreviewRect.height() == 0) return;
//comment
//comment
if (mFocusAreaSupported) {
initializeFocusAreas(x, y);
}
//comment
if (mMeteringAreaSupported) {
initializeMeteringAreas(x, y);
}

//comment
mUI.setFocusPosition(x, y);

if (mZslEnabled) {
mTouchAFRunning = true;
}

//comment
mListener.stopFaceDetection();

//comment
<start>mListener.setFocusParameters();<end>
if (mFocusAreaSupported) {
<start>autoFocus();
} else {<end>
updateFocusUI();
//comment
mHandler.removeMessages(RESET_TOUCH_FOCUS);
mHandler.sendEmptyMessageDelayed(RESET_TOUCH_FOCUS, RESET_TOUCH_FOCUS_DELAY);
}
}","public void onSingleTapUp(int x, int y) {
if (!mInitialized || mState == STATE_FOCUSING_SNAP_ON_FINISH) return;

UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,
UsageStatistics.ACTION_TOUCH_FOCUS, x + "","" + y);

//comment
if ((mState == STATE_FOCUSING ||
mState == STATE_SUCCESS || mState == STATE_FAIL)) {
cancelAutoFocus();
}
if (mPreviewRect.width() == 0 || mPreviewRect.height() == 0) return;
//comment
//comment
if (mFocusAreaSupported) {
initializeFocusAreas(x, y);
}
//comment
if (mMeteringAreaSupported) {
initializeMeteringAreas(x, y);
}

//comment
mUI.setFocusPosition(x, y);

if (mZslEnabled) {
mTouchAFRunning = true;
}

//comment
mListener.stopFaceDetection();

//comment
<start>mListener.setFocusParameters();
if (mFocusAreaSupported) {
autoFocus();
} else {
updateFocusUI();
//comment
mHandler.removeMessages(RESET_TOUCH_FOCUS);
mHandler.sendEmptyMessageDelayed(RESET_TOUCH_FOCUS, RESET_TOUCH_FOCUS_DELAY);
}<end>
}"
79,"public void onSingleTapUp(int x, int y) {
if (!mInitialized || mState == STATE_FOCUSING_SNAP_ON_FINISH) return;

UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,
UsageStatistics.ACTION_TOUCH_FOCUS, x + "","" + y);

//comment
if ((mState == STATE_FOCUSING ||
mState == STATE_SUCCESS || mState == STATE_FAIL)) {
cancelAutoFocus();
}
if (mPreviewRect.width() == 0 || mPreviewRect.height() == 0) return;
//comment
//comment
if (mFocusAreaSupported) {
initializeFocusAreas(x, y);
}
//comment
if (mMeteringAreaSupported) {
initializeMeteringAreas(x, y);
}

//comment
mUI.setFocusPosition(x, y);

if (mZslEnabled) {
mTouchAFRunning = true;
}

//comment
mListener.stopFaceDetection();

//comment
mListener.setFocusParameters();
if (mFocusAreaSupported) {
autoFocus();
} else {
updateFocusUI();
//comment
mHandler.removeMessages(RESET_TOUCH_FOCUS);
<start>mHandler.sendEmptyMessageDelayed(RESET_TOUCH_FOCUS, RESET_TOUCH_FOCUS_DELAY);<end>
}
}","public void onSingleTapUp(int x, int y) {
if (!mInitialized || mState == STATE_FOCUSING_SNAP_ON_FINISH) return;

UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,
UsageStatistics.ACTION_TOUCH_FOCUS, x + "","" + y);

//comment
if ((mState == STATE_FOCUSING ||
mState == STATE_SUCCESS || mState == STATE_FAIL)) {
cancelAutoFocus();
}
if (mPreviewRect.width() == 0 || mPreviewRect.height() == 0) return;
//comment
//comment
if (mFocusAreaSupported) {
initializeFocusAreas(x, y);
}
//comment
if (mMeteringAreaSupported) {
initializeMeteringAreas(x, y);
}

//comment
mUI.setFocusPosition(x, y);

if (mZslEnabled) {
mTouchAFRunning = true;
}

//comment
mListener.stopFaceDetection();

//comment
mListener.setFocusParameters();
if (mFocusAreaSupported) {
autoFocus();
} else {
updateFocusUI();
//comment
<start>mHandler.removeMessages(RESET_TOUCH_FOCUS);
mHandler.sendEmptyMessageDelayed(RESET_TOUCH_FOCUS, RESET_TOUCH_FOCUS_DELAY);<end>
}
}"
373,"        private void doAlignFrame() {
mInputSurfaceTexture.updateTexImage();
mInputSurfaceTexture.getTransformMatrix(mTransformMatrix);

//comment
<start>MosaicRenderer.setPreviewBackground(true);
MosaicRenderer.preprocess(mTransformMatrix);<end>
MosaicRenderer.step();
<start>MosaicRenderer.setPreviewBackground(false);<end>

MosaicRenderer.setWarping(true);
MosaicRenderer.transferGPUtoCPU();
MosaicRenderer.updateMatrix();
MosaicRenderer.step();
}","        private void doAlignFrame() {
mInputSurfaceTexture.updateTexImage();
mInputSurfaceTexture.getTransformMatrix(mTransformMatrix);

//comment
<start>MosaicRenderer.setPreviewBackground(true);
MosaicRenderer.preprocess(mTransformMatrix);
MosaicRenderer.step();
MosaicRenderer.setPreviewBackground(false);

MosaicRenderer.setWarping(true);
MosaicRenderer.transferGPUtoCPU();
MosaicRenderer.updateMatrix();
MosaicRenderer.step();<end>
}"
374,"<start>        private void doShowPreviewFrame() {<end>
mInputSurfaceTexture.updateTexImage();
mInputSurfaceTexture.getTransformMatrix(mTransformMatrix);

<start>MosaicRenderer.setWarping(false);
//comment
MosaicRenderer.preprocess(mTransformMatrix);
MosaicRenderer.updateMatrix();<end>
MosaicRenderer.step();
}","        private void doShowPreviewFrame() {
mInputSurfaceTexture.updateTexImage();
mInputSurfaceTexture.getTransformMatrix(mTransformMatrix);

MosaicRenderer.setWarping(false);
//comment
<start>MosaicRenderer.preprocess(mTransformMatrix);
MosaicRenderer.updateMatrix();
MosaicRenderer.step();<end>
}"
4884,"<start>private void setTransformMatrix(int width, int height) {<end>
mMatrix = mSurfaceView.getMatrix();

//comment
<start>RectF previewRect = new RectF(0, 0, width, height);
mMatrix.mapRect(previewRect);
mController.onPreviewRectChanged(CameraUtil.rectFToRect(previewRect));<end>
}","private void setTransformMatrix(int width, int height) {
mMatrix = mSurfaceView.getMatrix();

//comment
<start>RectF previewRect = new RectF(0, 0, width, height);
mMatrix.mapRect(previewRect);<end>
mController.onPreviewRectChanged(CameraUtil.rectFToRect(previewRect));
}"
4885,"<start>    public void initializeShutterButton() {
//comment
mShutterButton.setImageResource(R.drawable.btn_new_shutter_panorama);<end>
mShutterButton.setOnClickListener(new OnClickListener() {
@Override
public void onClick(View v) {
//comment
}
});
mShutterButton.setOnShutterButtonListener(mController);
mShutterButton.setVisibility(View.VISIBLE);
}","    public void initializeShutterButton() {
//comment
<start>mShutterButton.setImageResource(R.drawable.btn_new_shutter_panorama);
mShutterButton.setOnClickListener(new OnClickListener() {
@Override
public void onClick(View v) {
//comment
}
});
mShutterButton.setOnShutterButtonListener(mController);
mShutterButton.setVisibility(View.VISIBLE);<end>
}"
4886,"public boolean onBackPressed() {
//comment
//comment
//comment
if (mController.isImageCaptureIntent()) {
<start>mController.onCaptureCancelled();
return true;<end>
} else if (!mController.isCameraIdle()) {
//comment
return true;
}
if (mSwitcher != null && mSwitcher.showsPopup()) {
mSwitcher.closePopup();
return true;
} else {
return false;
}
}","public boolean onBackPressed() {
//comment
//comment
//comment
<start>if (mController.isImageCaptureIntent()) {
mController.onCaptureCancelled();
return true;
} else if (!mController.isCameraIdle()) {
//comment
return true;
}
if (mSwitcher != null && mSwitcher.showsPopup()) {
mSwitcher.closePopup();
return true;
} else {
return false;
}<end>
}"
4887,"public boolean onBackPressed() {
//comment
//comment
//comment
if (mController.isImageCaptureIntent()) {
mController.onCaptureCancelled();
return true;
} else if (!mController.isCameraIdle()) {
//comment
<start>return true;<end>
}
if (mSwitcher != null && mSwitcher.showsPopup()) {
mSwitcher.closePopup();
return true;
} else {
return false;
}
}","public boolean onBackPressed() {
//comment
//comment
//comment
if (mController.isImageCaptureIntent()) {
mController.onCaptureCancelled();
return true;
<start>} else if (!mController.isCameraIdle()) {
//comment
return true;<end>
}
if (mSwitcher != null && mSwitcher.showsPopup()) {
mSwitcher.closePopup();
return true;
} else {
return false;
}
}"
1880,"    public void onCameraOpened(PreferenceGroup prefGroup, ComboPreferences prefs,
Camera.Parameters params, OnPreferenceChangedListener listener, MakeupLevelListener makeupListener) {
if (mPieRenderer == null) {
mPieRenderer = new PieRenderer(mActivity);
mPieRenderer.setPieListener(this);
mRenderOverlay.addRenderer(mPieRenderer);
}

if (mMenu == null) {
mMenu = new PhotoMenu(mActivity, this, makeupListener);
mMenu.setListener(listener);
}
mMenu.initialize(prefGroup);
mMenuInitialized = true;

if (mZoomRenderer == null) {
mZoomRenderer = new ZoomRenderer(mActivity);
mRenderOverlay.addRenderer(mZoomRenderer);
}

if (mGestures == null) {
//comment
<start>mGestures = new PreviewGestures(mActivity, this, mZoomRenderer, mPieRenderer, null);
mRenderOverlay.setGestures(mGestures);<end>
}
mGestures.setPhotoMenu(mMenu);

mGestures.setZoomEnabled(params.isZoomSupported());
mGestures.setRenderOverlay(mRenderOverlay);
mRenderOverlay.requestLayout();

initializeZoom(params);
updateOnScreenIndicators(params, prefGroup, prefs);
mActivity.setPreviewGestures(mGestures);
}","    public void onCameraOpened(PreferenceGroup prefGroup, ComboPreferences prefs,
Camera.Parameters params, OnPreferenceChangedListener listener, MakeupLevelListener makeupListener) {
if (mPieRenderer == null) {
mPieRenderer = new PieRenderer(mActivity);
mPieRenderer.setPieListener(this);
mRenderOverlay.addRenderer(mPieRenderer);
}

if (mMenu == null) {
mMenu = new PhotoMenu(mActivity, this, makeupListener);
mMenu.setListener(listener);
}
mMenu.initialize(prefGroup);
mMenuInitialized = true;

if (mZoomRenderer == null) {
mZoomRenderer = new ZoomRenderer(mActivity);
mRenderOverlay.addRenderer(mZoomRenderer);
}

if (mGestures == null) {
//comment
<start>mGestures = new PreviewGestures(mActivity, this, mZoomRenderer, mPieRenderer, null);
mRenderOverlay.setGestures(mGestures);<end>
}
mGestures.setPhotoMenu(mMenu);

mGestures.setZoomEnabled(params.isZoomSupported());
mGestures.setRenderOverlay(mRenderOverlay);
mRenderOverlay.requestLayout();

initializeZoom(params);
updateOnScreenIndicators(params, prefGroup, prefs);
mActivity.setPreviewGestures(mGestures);
}"
1881,"<start>    public void animateCapture(final byte[] jpegData) {<end>
//comment
mActivity.updateThumbnail(jpegData);
}","    public void animateCapture(final byte[] jpegData) {
//comment
<start>mActivity.updateThumbnail(jpegData);<end>
}"
1882,"    private void openMenu() {
if (mPieRenderer != null) {
//comment
//comment
<start>if (mController.getCameraState() == PhotoController.FOCUSING) {
mController.cancelAutoFocus();
}<end>
mPieRenderer.showInCenter();
}
}","    private void openMenu() {
if (mPieRenderer != null) {
//comment
//comment
<start>if (mController.getCameraState() == PhotoController.FOCUSING) {
mController.cancelAutoFocus();
}<end>
mPieRenderer.showInCenter();
}
}"
1883,"public void updateOnScreenIndicators(Camera.Parameters params,
PreferenceGroup group, ComboPreferences prefs) {
if (params == null || group == null) return;
mOnScreenIndicators.updateSceneOnScreenIndicator(params.getSceneMode());
mOnScreenIndicators.updateExposureOnScreenIndicator(params,
CameraSettings.readExposure(prefs));
mOnScreenIndicators.updateFlashOnScreenIndicator(params.getFlashMode());
int wbIndex = -1;
String wb = Camera.Parameters.WHITE_BALANCE_AUTO;
if (Camera.Parameters.SCENE_MODE_AUTO.equals(params.getSceneMode())) {
wb = params.getWhiteBalance();
}
ListPreference pref = group.findPreference(CameraSettings.KEY_WHITE_BALANCE);
<start>if (pref != null) {
wbIndex = pref.findIndexOfValue(wb);
}<end>
//comment
//comment
mOnScreenIndicators.updateWBIndicator(wbIndex < 0 ? 2 : wbIndex);
boolean location = RecordLocationPreference.get(prefs, CameraSettings.KEY_RECORD_LOCATION);
mOnScreenIndicators.updateLocationIndicator(location);
}","public void updateOnScreenIndicators(Camera.Parameters params,
PreferenceGroup group, ComboPreferences prefs) {
if (params == null || group == null) return;
mOnScreenIndicators.updateSceneOnScreenIndicator(params.getSceneMode());
mOnScreenIndicators.updateExposureOnScreenIndicator(params,
CameraSettings.readExposure(prefs));
mOnScreenIndicators.updateFlashOnScreenIndicator(params.getFlashMode());
int wbIndex = -1;
String wb = Camera.Parameters.WHITE_BALANCE_AUTO;
if (Camera.Parameters.SCENE_MODE_AUTO.equals(params.getSceneMode())) {
wb = params.getWhiteBalance();
}
ListPreference pref = group.findPreference(CameraSettings.KEY_WHITE_BALANCE);
if (pref != null) {
wbIndex = pref.findIndexOfValue(wb);
}
//comment
//comment
<start>mOnScreenIndicators.updateWBIndicator(wbIndex < 0 ? 2 : wbIndex);<end>
boolean location = RecordLocationPreference.get(prefs, CameraSettings.KEY_RECORD_LOCATION);
mOnScreenIndicators.updateLocationIndicator(location);
}"
1884,"public boolean onBackPressed() {
if (mMenu != null && mMenu.handleBackKey()) {
return true;
}

<start>if (mPieRenderer != null && mPieRenderer.showsItems()) {
mPieRenderer.hide();
return true;
}<end>
//comment
//comment
//comment
if (mController.isImageCaptureIntent()) {
<start>mController.onCaptureCancelled();
return true;<end>
} else if (!mController.isCameraIdle()) {
//comment
return true;
} if (mSwitcher != null && mSwitcher.showsPopup()) {
mSwitcher.closePopup();
return true;
} else {
return false;
}
}","public boolean onBackPressed() {
if (mMenu != null && mMenu.handleBackKey()) {
return true;
}

if (mPieRenderer != null && mPieRenderer.showsItems()) {
mPieRenderer.hide();
return true;
}
//comment
//comment
//comment
<start>if (mController.isImageCaptureIntent()) {
mController.onCaptureCancelled();
return true;
} else if (!mController.isCameraIdle()) {
//comment
return true;
} if (mSwitcher != null && mSwitcher.showsPopup()) {
mSwitcher.closePopup();
return true;
} else {
return false;
}<end>
}"
1885,"    public boolean collapseCameraControls() {
//comment
//comment
<start>mSwitcher.closePopup();<end>
//comment
boolean ret = false;
if (mMenu != null) {
mMenu.removeAllView();
}
if (mPopup != null) {
dismissAllPopup();
ret = true;
}
onShowSwitcherPopup();
mCameraControls.showRefocusToast(false);
return ret;
}","    public boolean collapseCameraControls() {
//comment
//comment
mSwitcher.closePopup();
//comment
boolean ret = false;
if (mMenu != null) {
mMenu.removeAllView();
}
if (mPopup != null) {
<start>dismissAllPopup();<end>
ret = true;
}
onShowSwitcherPopup();
mCameraControls.showRefocusToast(false);
return ret;
}"
634,"        @Override
public boolean onSingleTapUp (MotionEvent e) {
//comment
if (mPie == null || !mPie.showsItems()) {
mTapListener.onSingleTapUp(null, (int) e.getX(), (int) e.getY());
return true;
}
return false;
}","        @Override
public boolean onSingleTapUp (MotionEvent e) {
//comment
<start>if (mPie == null || !mPie.showsItems()) {
mTapListener.onSingleTapUp(null, (int) e.getX(), (int) e.getY());
return true;
}<end>
return false;
}"
635,"    public boolean dispatchTouch(MotionEvent m) {
if (setToFalse) {
waitUntilNextDown = false;
setToFalse = false;
}
if (waitUntilNextDown) {
if (MotionEvent.ACTION_UP != m.getActionMasked()
&& MotionEvent.ACTION_CANCEL != m.getActionMasked())
return true;
else {
setToFalse = true;
return true;
}
}
if (!mEnabled) {
return false;
}
mCurrent = m;
if (MotionEvent.ACTION_DOWN == m.getActionMasked()) {
mMode = MODE_NONE;
mDown = MotionEvent.obtain(m);
}

//comment
<start>if (mPie != null && mPie.isOpen()) {
return sendToPie(m);
}<end>

if (mTrackingFocus != null && mTrackingFocus.isVisible()) {
return sendToTrackingFocus(m);
}

if (mCaptureUI != null) {
if (mCaptureUI.isPreviewMenuBeingShown()) {
waitUntilNextDown = true;
mCaptureUI.removeFilterMenu(true);
return true;
}
}

if (mPhotoMenu != null) {
if (mPhotoMenu.isMenuBeingShown()) {
if (!mPhotoMenu.isMenuBeingAnimated()) {
waitUntilNextDown = true;
mPhotoMenu.closeView();
}
return true;
}
if (mPhotoMenu.isPreviewMenuBeingShown()) {
waitUntilNextDown = true;
mPhotoMenu.animateSlideOutPreviewMenu();
return true;
}
}

if (mVideoMenu != null) {
if (mVideoMenu.isMenuBeingShown()) {
if (!mVideoMenu.isMenuBeingAnimated()) {
waitUntilNextDown = true;
mVideoMenu.closeView();
}
return true;
}

if (mVideoMenu.isPreviewMenuBeingShown()) {
waitUntilNextDown = true;
mVideoMenu.animateSlideOutPreviewMenu();
return true;
}
}

//comment
//comment
mGestureDetector.onTouchEvent(m);
if (mZoom != null) {
mScale.onTouchEvent(m);
if (MotionEvent.ACTION_POINTER_DOWN == m.getActionMasked()) {
mMode = MODE_ZOOM;
if (mZoomEnabled) {
//comment
mZoom.onScaleBegin(mScale);
}
} else if (MotionEvent.ACTION_POINTER_UP == m.getActionMasked()) {
mZoom.onScaleEnd(mScale);
}
}
return true;
}","    public boolean dispatchTouch(MotionEvent m) {
if (setToFalse) {
waitUntilNextDown = false;
setToFalse = false;
}
if (waitUntilNextDown) {
if (MotionEvent.ACTION_UP != m.getActionMasked()
&& MotionEvent.ACTION_CANCEL != m.getActionMasked())
return true;
else {
setToFalse = true;
return true;
}
}
if (!mEnabled) {
return false;
}
mCurrent = m;
if (MotionEvent.ACTION_DOWN == m.getActionMasked()) {
mMode = MODE_NONE;
mDown = MotionEvent.obtain(m);
}

//comment
<start>if (mPie != null && mPie.isOpen()) {
return sendToPie(m);
}<end>

if (mTrackingFocus != null && mTrackingFocus.isVisible()) {
return sendToTrackingFocus(m);
}

if (mCaptureUI != null) {
if (mCaptureUI.isPreviewMenuBeingShown()) {
waitUntilNextDown = true;
mCaptureUI.removeFilterMenu(true);
return true;
}
}

if (mPhotoMenu != null) {
if (mPhotoMenu.isMenuBeingShown()) {
if (!mPhotoMenu.isMenuBeingAnimated()) {
waitUntilNextDown = true;
mPhotoMenu.closeView();
}
return true;
}
if (mPhotoMenu.isPreviewMenuBeingShown()) {
waitUntilNextDown = true;
mPhotoMenu.animateSlideOutPreviewMenu();
return true;
}
}

if (mVideoMenu != null) {
if (mVideoMenu.isMenuBeingShown()) {
if (!mVideoMenu.isMenuBeingAnimated()) {
waitUntilNextDown = true;
mVideoMenu.closeView();
}
return true;
}

if (mVideoMenu.isPreviewMenuBeingShown()) {
waitUntilNextDown = true;
mVideoMenu.animateSlideOutPreviewMenu();
return true;
}
}

//comment
//comment
mGestureDetector.onTouchEvent(m);
if (mZoom != null) {
mScale.onTouchEvent(m);
if (MotionEvent.ACTION_POINTER_DOWN == m.getActionMasked()) {
mMode = MODE_ZOOM;
if (mZoomEnabled) {
//comment
mZoom.onScaleBegin(mScale);
}
} else if (MotionEvent.ACTION_POINTER_UP == m.getActionMasked()) {
mZoom.onScaleEnd(mScale);
}
}
return true;
}"
636,"    public boolean dispatchTouch(MotionEvent m) {
if (setToFalse) {
waitUntilNextDown = false;
setToFalse = false;
}
if (waitUntilNextDown) {
if (MotionEvent.ACTION_UP != m.getActionMasked()
&& MotionEvent.ACTION_CANCEL != m.getActionMasked())
return true;
else {
setToFalse = true;
return true;
}
}
if (!mEnabled) {
return false;
}
mCurrent = m;
if (MotionEvent.ACTION_DOWN == m.getActionMasked()) {
mMode = MODE_NONE;
mDown = MotionEvent.obtain(m);
}

//comment
if (mPie != null && mPie.isOpen()) {
return sendToPie(m);
}

if (mTrackingFocus != null && mTrackingFocus.isVisible()) {
return sendToTrackingFocus(m);
}

if (mCaptureUI != null) {
if (mCaptureUI.isPreviewMenuBeingShown()) {
waitUntilNextDown = true;
mCaptureUI.removeFilterMenu(true);
return true;
}
}

if (mPhotoMenu != null) {
if (mPhotoMenu.isMenuBeingShown()) {
if (!mPhotoMenu.isMenuBeingAnimated()) {
waitUntilNextDown = true;
mPhotoMenu.closeView();
}
return true;
}
if (mPhotoMenu.isPreviewMenuBeingShown()) {
waitUntilNextDown = true;
mPhotoMenu.animateSlideOutPreviewMenu();
return true;
}
}

if (mVideoMenu != null) {
if (mVideoMenu.isMenuBeingShown()) {
if (!mVideoMenu.isMenuBeingAnimated()) {
waitUntilNextDown = true;
mVideoMenu.closeView();
}
return true;
}

if (mVideoMenu.isPreviewMenuBeingShown()) {
waitUntilNextDown = true;
mVideoMenu.animateSlideOutPreviewMenu();
return true;
}
}

//comment
//comment
<start>mGestureDetector.onTouchEvent(m);<end>
if (mZoom != null) {
<start>mScale.onTouchEvent(m);<end>
if (MotionEvent.ACTION_POINTER_DOWN == m.getActionMasked()) {
mMode = MODE_ZOOM;
if (mZoomEnabled) {
//comment
mZoom.onScaleBegin(mScale);
}
} else if (MotionEvent.ACTION_POINTER_UP == m.getActionMasked()) {
mZoom.onScaleEnd(mScale);
}
}
return true;
}","    public boolean dispatchTouch(MotionEvent m) {
if (setToFalse) {
waitUntilNextDown = false;
setToFalse = false;
}
if (waitUntilNextDown) {
if (MotionEvent.ACTION_UP != m.getActionMasked()
&& MotionEvent.ACTION_CANCEL != m.getActionMasked())
return true;
else {
setToFalse = true;
return true;
}
}
if (!mEnabled) {
return false;
}
mCurrent = m;
if (MotionEvent.ACTION_DOWN == m.getActionMasked()) {
mMode = MODE_NONE;
mDown = MotionEvent.obtain(m);
}

//comment
if (mPie != null && mPie.isOpen()) {
return sendToPie(m);
}

if (mTrackingFocus != null && mTrackingFocus.isVisible()) {
return sendToTrackingFocus(m);
}

if (mCaptureUI != null) {
if (mCaptureUI.isPreviewMenuBeingShown()) {
waitUntilNextDown = true;
mCaptureUI.removeFilterMenu(true);
return true;
}
}

if (mPhotoMenu != null) {
if (mPhotoMenu.isMenuBeingShown()) {
if (!mPhotoMenu.isMenuBeingAnimated()) {
waitUntilNextDown = true;
mPhotoMenu.closeView();
}
return true;
}
if (mPhotoMenu.isPreviewMenuBeingShown()) {
waitUntilNextDown = true;
mPhotoMenu.animateSlideOutPreviewMenu();
return true;
}
}

if (mVideoMenu != null) {
if (mVideoMenu.isMenuBeingShown()) {
if (!mVideoMenu.isMenuBeingAnimated()) {
waitUntilNextDown = true;
mVideoMenu.closeView();
}
return true;
}

if (mVideoMenu.isPreviewMenuBeingShown()) {
waitUntilNextDown = true;
mVideoMenu.animateSlideOutPreviewMenu();
return true;
}
}

//comment
//comment
<start>mGestureDetector.onTouchEvent(m);
if (mZoom != null) {
mScale.onTouchEvent(m);
if (MotionEvent.ACTION_POINTER_DOWN == m.getActionMasked()) {
mMode = MODE_ZOOM;
if (mZoomEnabled) {
//comment
mZoom.onScaleBegin(mScale);
}
} else if (MotionEvent.ACTION_POINTER_UP == m.getActionMasked()) {
mZoom.onScaleEnd(mScale);
}
}<end>
return true;
}"
721,"@Override
public void onOrientationChanged(int orientation) {
//comment
//comment
//comment
if (orientation == ORIENTATION_UNKNOWN) return;
int oldOrientation = mDeviceOrientation;
<start>mDeviceOrientation = CameraUtil.roundOrientation(orientation, mDeviceOrientation);
//comment
//comment
int orientationCompensation = mDeviceOrientation
+ CameraUtil.getDisplayRotation(mActivity) % 360;
if (mOrientationCompensation != orientationCompensation) {
mOrientationCompensation = orientationCompensation;
}<end>
if (oldOrientation != mDeviceOrientation
&& oldOrientation != OrientationEventListener.ORIENTATION_UNKNOWN) {
mPreviewLayoutChanged = true;
if (!mOrientationLocked)
mUI.setOrientation(mDeviceOrientation, true);
}
}","@Override
public void onOrientationChanged(int orientation) {
//comment
//comment
//comment
if (orientation == ORIENTATION_UNKNOWN) return;
int oldOrientation = mDeviceOrientation;
mDeviceOrientation = CameraUtil.roundOrientation(orientation, mDeviceOrientation);
//comment
//comment
<start>int orientationCompensation = mDeviceOrientation
+ CameraUtil.getDisplayRotation(mActivity) % 360;<end>
if (mOrientationCompensation != orientationCompensation) {
mOrientationCompensation = orientationCompensation;
}
if (oldOrientation != mDeviceOrientation
&& oldOrientation != OrientationEventListener.ORIENTATION_UNKNOWN) {
mPreviewLayoutChanged = true;
if (!mOrientationLocked)
mUI.setOrientation(mDeviceOrientation, true);
}
}"
722,"private boolean openCamera() {
int cameraId = CameraHolder.instance().getBackCameraId();
//comment
//comment
//comment
//comment
if (cameraId == -1) cameraId = 0;

//comment
if (mCameraDevice == null) {
<start>mCameraDevice = CameraUtil.openCamera(mActivity, cameraId,
mMainHandler, mActivity.getCameraOpenErrorCallback());<end>
if (mCameraDevice == null) {
return false;
}
}
mCameraOrientation = CameraUtil.getCameraOrientation(cameraId);
if (cameraId == CameraHolder.instance().getFrontCameraId()) mUsingFrontCamera = true;
return true;
}","private boolean openCamera() {
int cameraId = CameraHolder.instance().getBackCameraId();
//comment
//comment
//comment
//comment
if (cameraId == -1) cameraId = 0;

//comment
<start>if (mCameraDevice == null) {<end>
mCameraDevice = CameraUtil.openCamera(mActivity, cameraId,
mMainHandler, mActivity.getCameraOpenErrorCallback());
if (mCameraDevice == null) {
return false;
}
}
mCameraOrientation = CameraUtil.getCameraOrientation(cameraId);
if (cameraId == CameraHolder.instance().getFrontCameraId()) mUsingFrontCamera = true;
return true;
}"
723,"private boolean findBestPreviewSize(List<Size> supportedSizes, boolean need4To3,
boolean needSmaller) {
int pixelsDiff = DEFAULT_CAPTURE_PIXELS;
boolean hasFound = false;
for (Size size : supportedSizes) {
int h = size.height;
<start>int w = size.width;
//comment
int d = DEFAULT_CAPTURE_PIXELS - h * w;<end>
if (needSmaller && d < 0) {
continue;
}
if (need4To3 && (h * 4 != w * 3)) {
continue;
}
d = Math.abs(d);
if (d < pixelsDiff) {
mCameraPreviewWidth = w;
mCameraPreviewHeight = h;
pixelsDiff = d;
hasFound = true;
}
}
return hasFound;
}","private boolean findBestPreviewSize(List<Size> supportedSizes, boolean need4To3,
boolean needSmaller) {
int pixelsDiff = DEFAULT_CAPTURE_PIXELS;
boolean hasFound = false;
for (Size size : supportedSizes) {
int h = size.height;
int w = size.width;
//comment
int d = DEFAULT_CAPTURE_PIXELS - h * w;
if (needSmaller && d < 0) {
continue;
}
<start>if (need4To3 && (h * 4 != w * 3)) {
continue;
}<end>
d = Math.abs(d);
if (d < pixelsDiff) {
mCameraPreviewWidth = w;
mCameraPreviewHeight = h;
pixelsDiff = d;
hasFound = true;
}
}
return hasFound;
}"
724,"private void setupCaptureParams(Parameters parameters) {
List<Size> supportedSizes = parameters.getSupportedPreviewSizes();
if (!findBestPreviewSize(supportedSizes, true, true)) {
Log.w(TAG, ""No 4:3 ratio preview size supported."");
if (!findBestPreviewSize(supportedSizes, false, true)) {
Log.w(TAG, ""Can't find a supported preview size smaller than 960x720."");
findBestPreviewSize(supportedSizes, false, false);
}
}
Log.d(TAG, ""camera preview h = ""
+ mCameraPreviewHeight + "" , w = "" + mCameraPreviewWidth);
parameters.setPreviewSize(mCameraPreviewWidth, mCameraPreviewHeight);

List<int[]> frameRates = parameters.getSupportedPreviewFpsRange();
int last = frameRates.size() - 1;
int minFps = (frameRates.get(last))[Parameters.PREVIEW_FPS_MIN_INDEX];
int maxFps = (frameRates.get(last))[Parameters.PREVIEW_FPS_MAX_INDEX];
parameters.setPreviewFpsRange(minFps, maxFps);
Log.d(TAG, ""preview fps: "" + minFps + "", "" + maxFps);

List<String> supportedFocusModes = parameters.getSupportedFocusModes();
if (supportedFocusModes.indexOf(mTargetFocusMode) >= 0) {
parameters.setFocusMode(mTargetFocusMode);
<start>} else {
//comment
Log.w(TAG, ""Cannot set the focus mode to "" + mTargetFocusMode +
"" becuase the mode is not supported."");<end>
}

parameters.set(CameraUtil.RECORDING_HINT, CameraUtil.FALSE);

mHorizontalViewAngle = parameters.getHorizontalViewAngle();
mVerticalViewAngle =  parameters.getVerticalViewAngle();
}","private void setupCaptureParams(Parameters parameters) {
List<Size> supportedSizes = parameters.getSupportedPreviewSizes();
if (!findBestPreviewSize(supportedSizes, true, true)) {
Log.w(TAG, ""No 4:3 ratio preview size supported."");
if (!findBestPreviewSize(supportedSizes, false, true)) {
Log.w(TAG, ""Can't find a supported preview size smaller than 960x720."");
findBestPreviewSize(supportedSizes, false, false);
}
}
Log.d(TAG, ""camera preview h = ""
+ mCameraPreviewHeight + "" , w = "" + mCameraPreviewWidth);
parameters.setPreviewSize(mCameraPreviewWidth, mCameraPreviewHeight);

List<int[]> frameRates = parameters.getSupportedPreviewFpsRange();
int last = frameRates.size() - 1;
int minFps = (frameRates.get(last))[Parameters.PREVIEW_FPS_MIN_INDEX];
int maxFps = (frameRates.get(last))[Parameters.PREVIEW_FPS_MAX_INDEX];
parameters.setPreviewFpsRange(minFps, maxFps);
Log.d(TAG, ""preview fps: "" + minFps + "", "" + maxFps);

List<String> supportedFocusModes = parameters.getSupportedFocusModes();
if (supportedFocusModes.indexOf(mTargetFocusMode) >= 0) {
parameters.setFocusMode(mTargetFocusMode);
} else {
//comment
<start>Log.w(TAG, ""Cannot set the focus mode to "" + mTargetFocusMode +
"" becuase the mode is not supported."");<end>
}

parameters.set(CameraUtil.RECORDING_HINT, CameraUtil.FALSE);

mHorizontalViewAngle = parameters.getHorizontalViewAngle();
mVerticalViewAngle =  parameters.getVerticalViewAngle();
}"
1413,"    protected static String getFileExtension(String requestFormat) {
String outputFormat = (requestFormat == null)
? ""jpg""
: requestFormat;
outputFormat = outputFormat.toLowerCase();
<start>return (outputFormat.equals(""png"") || outputFormat.equals(""gif""))
? ""png""
: ""jpg"";<end>
}","    protected static String getFileExtension(String requestFormat) {
String outputFormat = (requestFormat == null)
? ""jpg""
: requestFormat;
outputFormat = outputFormat.toLowerCase();
<start>return (outputFormat.equals(""png"") || outputFormat.equals(""gif""))
? ""png""
: ""jpg"";<end>
}"
815,"    public static File getFinalSaveDirectory(Context context, Uri sourceUri) {
File saveDirectory = SaveImage.getSaveDirectory(context, sourceUri);
if ((saveDirectory == null) || !saveDirectory.canWrite()) {
saveDirectory = new File(Environment.getExternalStorageDirectory(),
SaveImage.DEFAULT_SAVE_DIRECTORY);
}
//comment
<start>if (!saveDirectory.exists())
saveDirectory.mkdirs();
return saveDirectory;<end>
}","    public static File getFinalSaveDirectory(Context context, Uri sourceUri) {
File saveDirectory = SaveImage.getSaveDirectory(context, sourceUri);
if ((saveDirectory == null) || !saveDirectory.canWrite()) {
saveDirectory = new File(Environment.getExternalStorageDirectory(),
SaveImage.DEFAULT_SAVE_DIRECTORY);
}
//comment
<start>if (!saveDirectory.exists())
saveDirectory.mkdirs();<end>
return saveDirectory;
}"
816,"public static void deleteAuxFiles(ContentResolver contentResolver,
Uri srcContentUri) {
final String[] fullPath = new String[1];
String[] queryProjection = new String[] { ImageColumns.DATA };
querySourceFromContentResolver(contentResolver,
srcContentUri, queryProjection,
new ContentResolverQueryCallback() {
@Override
public void onCursorResult(Cursor cursor) {
fullPath[0] = cursor.getString(0);
}
}
);
if (fullPath[0] != null) {
//comment
//comment
//comment
<start>File currentFile = new File(fullPath[0]);<end>

String filename = currentFile.getName();
int firstDotPos = filename.indexOf(""."");
final String filenameNoExt = (firstDotPos == -1) ? filename :
filename.substring(0, firstDotPos);
File auxDir = getLocalAuxDirectory(currentFile);
if (auxDir.exists()) {
FilenameFilter filter = new FilenameFilter() {
@Override
public boolean accept(File dir, String name) {
if (name.startsWith(filenameNoExt + ""."")) {
return true;
} else {
return false;
}
}
};

//comment
//comment
File[] auxFiles = auxDir.listFiles(filter);
for (File file : auxFiles) {
file.delete();
}
}
}
}","public static void deleteAuxFiles(ContentResolver contentResolver,
Uri srcContentUri) {
final String[] fullPath = new String[1];
String[] queryProjection = new String[] { ImageColumns.DATA };
querySourceFromContentResolver(contentResolver,
srcContentUri, queryProjection,
new ContentResolverQueryCallback() {
@Override
public void onCursorResult(Cursor cursor) {
fullPath[0] = cursor.getString(0);
}
}
);
if (fullPath[0] != null) {
//comment
//comment
//comment
<start>File currentFile = new File(fullPath[0]);

String filename = currentFile.getName();
int firstDotPos = filename.indexOf(""."");
final String filenameNoExt = (firstDotPos == -1) ? filename :
filename.substring(0, firstDotPos);
File auxDir = getLocalAuxDirectory(currentFile);
if (auxDir.exists()) {
FilenameFilter filter = new FilenameFilter() {
@Override
public boolean accept(File dir, String name) {
if (name.startsWith(filenameNoExt + ""."")) {
return true;
} else {
return false;
}
}
};

//comment
//comment
File[] auxFiles = auxDir.listFiles(filter);
for (File file : auxFiles) {
file.delete();
}
}
}<end>
}"
817,"public static void deleteAuxFiles(ContentResolver contentResolver,
Uri srcContentUri) {
final String[] fullPath = new String[1];
String[] queryProjection = new String[] { ImageColumns.DATA };
querySourceFromContentResolver(contentResolver,
srcContentUri, queryProjection,
new ContentResolverQueryCallback() {
@Override
public void onCursorResult(Cursor cursor) {
fullPath[0] = cursor.getString(0);
}
}
);
if (fullPath[0] != null) {
//comment
//comment
//comment
File currentFile = new File(fullPath[0]);

String filename = currentFile.getName();
int firstDotPos = filename.indexOf(""."");
final String filenameNoExt = (firstDotPos == -1) ? filename :
filename.substring(0, firstDotPos);
File auxDir = getLocalAuxDirectory(currentFile);
if (auxDir.exists()) {
FilenameFilter filter = new FilenameFilter() {
@Override
public boolean accept(File dir, String name) {
if (name.startsWith(filenameNoExt + ""."")) {
return true;
} else {
return false;
}
}
};

//comment
//comment
<start>File[] auxFiles = auxDir.listFiles(filter);
for (File file : auxFiles) {
file.delete();
}<end>
}
}
}","public static void deleteAuxFiles(ContentResolver contentResolver,
Uri srcContentUri) {
final String[] fullPath = new String[1];
String[] queryProjection = new String[] { ImageColumns.DATA };
querySourceFromContentResolver(contentResolver,
srcContentUri, queryProjection,
new ContentResolverQueryCallback() {
@Override
public void onCursorResult(Cursor cursor) {
fullPath[0] = cursor.getString(0);
}
}
);
if (fullPath[0] != null) {
//comment
//comment
//comment
File currentFile = new File(fullPath[0]);

String filename = currentFile.getName();
int firstDotPos = filename.indexOf(""."");
final String filenameNoExt = (firstDotPos == -1) ? filename :
filename.substring(0, firstDotPos);
File auxDir = getLocalAuxDirectory(currentFile);
if (auxDir.exists()) {
FilenameFilter filter = new FilenameFilter() {
@Override
public boolean accept(File dir, String name) {
if (name.startsWith(filenameNoExt + ""."")) {
return true;
} else {
return false;
}
}
};

//comment
//comment
<start>File[] auxFiles = auxDir.listFiles(filter);
for (File file : auxFiles) {
file.delete();
}<end>
}
}
}"
818,"private Uri moveSrcToAuxIfNeeded(Uri srcUri, File dstFile) {
File srcFile = getLocalFileFromUri(mContext, srcUri);
if (srcFile == null) {
Log.d(LOGTAG, ""Source file is not a local file, no update."");
return srcUri;
}

//comment
//comment
<start>File auxDiretory = getLocalAuxDirectory(dstFile);<end>
if (!auxDiretory.exists()) {
boolean success = auxDiretory.mkdirs();
if (!success) {
<start>return srcUri;<end>
}
}

//comment
//comment
File noMedia = new File(auxDiretory, "".nomedia"");
if (!noMedia.exists()) {
try {
noMedia.createNewFile();
} catch (IOException e) {
Log.e(LOGTAG, ""Can't create the nomedia"");
return srcUri;
}
}
//comment
//comment
File newSrcFile = new File(auxDiretory, dstFile.getName());
//comment
String to = newSrcFile.getName();
String from = srcFile.getName();
to = to.substring(to.lastIndexOf("".""));
from = from.substring(from.lastIndexOf("".""));

if (!to.equals(from)) {
String name = dstFile.getName();
name = name.substring(0, name.lastIndexOf(""."")) + from;
newSrcFile = new File(auxDiretory, name);
}

if (!newSrcFile.exists()) {
boolean success = srcFile.renameTo(newSrcFile);
if (!success) {
return srcUri;
}
}

return Uri.fromFile(newSrcFile);

}","private Uri moveSrcToAuxIfNeeded(Uri srcUri, File dstFile) {
File srcFile = getLocalFileFromUri(mContext, srcUri);
if (srcFile == null) {
Log.d(LOGTAG, ""Source file is not a local file, no update."");
return srcUri;
}

//comment
//comment
<start>File auxDiretory = getLocalAuxDirectory(dstFile);
if (!auxDiretory.exists()) {
boolean success = auxDiretory.mkdirs();
if (!success) {
return srcUri;
}
}<end>

//comment
//comment
File noMedia = new File(auxDiretory, "".nomedia"");
if (!noMedia.exists()) {
try {
noMedia.createNewFile();
} catch (IOException e) {
Log.e(LOGTAG, ""Can't create the nomedia"");
return srcUri;
}
}
//comment
//comment
File newSrcFile = new File(auxDiretory, dstFile.getName());
//comment
String to = newSrcFile.getName();
String from = srcFile.getName();
to = to.substring(to.lastIndexOf("".""));
from = from.substring(from.lastIndexOf("".""));

if (!to.equals(from)) {
String name = dstFile.getName();
name = name.substring(0, name.lastIndexOf(""."")) + from;
newSrcFile = new File(auxDiretory, name);
}

if (!newSrcFile.exists()) {
boolean success = srcFile.renameTo(newSrcFile);
if (!success) {
return srcUri;
}
}

return Uri.fromFile(newSrcFile);

}"
819,"private Uri moveSrcToAuxIfNeeded(Uri srcUri, File dstFile) {
File srcFile = getLocalFileFromUri(mContext, srcUri);
if (srcFile == null) {
Log.d(LOGTAG, ""Source file is not a local file, no update."");
return srcUri;
}

//comment
//comment
File auxDiretory = getLocalAuxDirectory(dstFile);
if (!auxDiretory.exists()) {
boolean success = auxDiretory.mkdirs();
if (!success) {
return srcUri;
}
}

//comment
//comment
<start>File noMedia = new File(auxDiretory, "".nomedia"");<end>
if (!noMedia.exists()) {
try {
<start>noMedia.createNewFile();<end>
} catch (IOException e) {
Log.e(LOGTAG, ""Can't create the nomedia"");
return srcUri;
}
}
//comment
//comment
File newSrcFile = new File(auxDiretory, dstFile.getName());
//comment
String to = newSrcFile.getName();
String from = srcFile.getName();
to = to.substring(to.lastIndexOf("".""));
from = from.substring(from.lastIndexOf("".""));

if (!to.equals(from)) {
String name = dstFile.getName();
name = name.substring(0, name.lastIndexOf(""."")) + from;
newSrcFile = new File(auxDiretory, name);
}

if (!newSrcFile.exists()) {
boolean success = srcFile.renameTo(newSrcFile);
if (!success) {
return srcUri;
}
}

return Uri.fromFile(newSrcFile);

}","private Uri moveSrcToAuxIfNeeded(Uri srcUri, File dstFile) {
File srcFile = getLocalFileFromUri(mContext, srcUri);
if (srcFile == null) {
Log.d(LOGTAG, ""Source file is not a local file, no update."");
return srcUri;
}

//comment
//comment
File auxDiretory = getLocalAuxDirectory(dstFile);
if (!auxDiretory.exists()) {
boolean success = auxDiretory.mkdirs();
if (!success) {
return srcUri;
}
}

//comment
//comment
<start>File noMedia = new File(auxDiretory, "".nomedia"");
if (!noMedia.exists()) {
try {
noMedia.createNewFile();
} catch (IOException e) {
Log.e(LOGTAG, ""Can't create the nomedia"");
return srcUri;
}
}<end>
//comment
//comment
File newSrcFile = new File(auxDiretory, dstFile.getName());
//comment
String to = newSrcFile.getName();
String from = srcFile.getName();
to = to.substring(to.lastIndexOf("".""));
from = from.substring(from.lastIndexOf("".""));

if (!to.equals(from)) {
String name = dstFile.getName();
name = name.substring(0, name.lastIndexOf(""."")) + from;
newSrcFile = new File(auxDiretory, name);
}

if (!newSrcFile.exists()) {
boolean success = srcFile.renameTo(newSrcFile);
if (!success) {
return srcUri;
}
}

return Uri.fromFile(newSrcFile);

}"
982,"    private synchronized void onLoadingDone(PanoramaMetadata metadata) {
mPanoramaMetadata = metadata;
if (mPanoramaMetadata == null) {
//comment
mPanoramaMetadata = PhotoSphereHelper.NOT_PANORAMA;
}
for (PanoramaMetadataCallback cb : mCallbacksWaiting) {
cb.onPanoramaMetadataLoaded(mPanoramaMetadata);
}
<start>mCallbacksWaiting = null;<end>
}","    private synchronized void onLoadingDone(PanoramaMetadata metadata) {
mPanoramaMetadata = metadata;
<start>if (mPanoramaMetadata == null) {
//comment
mPanoramaMetadata = PhotoSphereHelper.NOT_PANORAMA;
}<end>
for (PanoramaMetadataCallback cb : mCallbacksWaiting) {
cb.onPanoramaMetadataLoaded(mPanoramaMetadata);
}
mCallbacksWaiting = null;
}"
2486,"@Override
public void write(byte[] buffer, int offset, int length) throws IOException {
while ((mByteToSkip > 0 || mByteToCopy > 0 || mState != STATE_JPEG_DATA)
&& length > 0) {
if (mByteToSkip > 0) {
int byteToProcess = length > mByteToSkip ? mByteToSkip : length;
length -= byteToProcess;
mByteToSkip -= byteToProcess;
offset += byteToProcess;
}
if (mByteToCopy > 0) {
int byteToProcess = length > mByteToCopy ? mByteToCopy : length;
out.write(buffer, offset, byteToProcess);
mSize += byteToProcess;
length -= byteToProcess;
mByteToCopy -= byteToProcess;
offset += byteToProcess;
}
if (length == 0) {
return;
}
switch (mState) {
case STATE_SOI:
int byteRead = requestByteToBuffer(2, buffer, offset, length);
offset += byteRead;
length -= byteRead;
if (mBuffer.position() < 2) {
return;
}
mBuffer.rewind();
if (mBuffer.getShort() != JpegHeader.SOI) {
throw new IOException(""Not a valid jpeg image, cannot write exif"");
}
out.write(mBuffer.array(), 0, 2);
mSize += 2;
mState = STATE_FRAME_HEADER;
mBuffer.rewind();
writeExifData();
break;
case STATE_FRAME_HEADER:
//comment
//comment
byteRead = requestByteToBuffer(4, buffer, offset, length);
offset += byteRead;
length -= byteRead;
//comment
if (mBuffer.position() == 2) {
<start>short tag = mBuffer.getShort();<end>
if (tag == JpegHeader.EOI) {
out.write(mBuffer.array(), 0, 2);
mSize += 2;
mBuffer.rewind();
}
}
if (mBuffer.position() < 4) {
return;
}
mBuffer.rewind();
short marker = mBuffer.getShort();
if (marker == JpegHeader.APP1) {
mByteToSkip = (mBuffer.getShort() & 0x0000ffff) - 2;
mState = STATE_JPEG_DATA;
} else if (!JpegHeader.isSofMarker(marker)) {
out.write(mBuffer.array(), 0, 4);
mSize += 4;
mByteToCopy = (mBuffer.getShort() & 0x0000ffff) - 2;
} else {
out.write(mBuffer.array(), 0, 4);
mSize += 4;
mState = STATE_JPEG_DATA;
}
mBuffer.rewind();
}
}
if (length > 0) {
out.write(buffer, offset, length);
mSize += length;
}
}","@Override
public void write(byte[] buffer, int offset, int length) throws IOException {
while ((mByteToSkip > 0 || mByteToCopy > 0 || mState != STATE_JPEG_DATA)
&& length > 0) {
if (mByteToSkip > 0) {
int byteToProcess = length > mByteToSkip ? mByteToSkip : length;
length -= byteToProcess;
mByteToSkip -= byteToProcess;
offset += byteToProcess;
}
if (mByteToCopy > 0) {
int byteToProcess = length > mByteToCopy ? mByteToCopy : length;
out.write(buffer, offset, byteToProcess);
mSize += byteToProcess;
length -= byteToProcess;
mByteToCopy -= byteToProcess;
offset += byteToProcess;
}
if (length == 0) {
return;
}
switch (mState) {
case STATE_SOI:
int byteRead = requestByteToBuffer(2, buffer, offset, length);
offset += byteRead;
length -= byteRead;
if (mBuffer.position() < 2) {
return;
}
mBuffer.rewind();
if (mBuffer.getShort() != JpegHeader.SOI) {
throw new IOException(""Not a valid jpeg image, cannot write exif"");
}
out.write(mBuffer.array(), 0, 2);
mSize += 2;
mState = STATE_FRAME_HEADER;
mBuffer.rewind();
writeExifData();
break;
case STATE_FRAME_HEADER:
//comment
//comment
byteRead = requestByteToBuffer(4, buffer, offset, length);
offset += byteRead;
length -= byteRead;
//comment
<start>if (mBuffer.position() == 2) {
short tag = mBuffer.getShort();
if (tag == JpegHeader.EOI) {
out.write(mBuffer.array(), 0, 2);
mSize += 2;
mBuffer.rewind();
}
}<end>
if (mBuffer.position() < 4) {
return;
}
mBuffer.rewind();
short marker = mBuffer.getShort();
if (marker == JpegHeader.APP1) {
mByteToSkip = (mBuffer.getShort() & 0x0000ffff) - 2;
mState = STATE_JPEG_DATA;
} else if (!JpegHeader.isSofMarker(marker)) {
out.write(mBuffer.array(), 0, 4);
mSize += 4;
mByteToCopy = (mBuffer.getShort() & 0x0000ffff) - 2;
} else {
out.write(mBuffer.array(), 0, 4);
mSize += 4;
mState = STATE_JPEG_DATA;
}
mBuffer.rewind();
}
}
if (length > 0) {
out.write(buffer, offset, length);
mSize += length;
}
}"
2487,"private void createRequiredIfdAndTag() throws IOException {
//comment
IfdData ifd0 = mExifData.getIfdData(IfdId.TYPE_IFD_0);
if (ifd0 == null) {
ifd0 = new IfdData(IfdId.TYPE_IFD_0);
mExifData.addIfdData(ifd0);
}
ExifTag exifOffsetTag = mInterface.buildUninitializedTag(ExifInterface.TAG_EXIF_IFD);
if (exifOffsetTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_EXIF_IFD);
}
ifd0.setTag(exifOffsetTag);

//comment
IfdData exifIfd = mExifData.getIfdData(IfdId.TYPE_IFD_EXIF);
if (exifIfd == null) {
exifIfd = new IfdData(IfdId.TYPE_IFD_EXIF);
mExifData.addIfdData(exifIfd);
}

//comment
IfdData gpsIfd = mExifData.getIfdData(IfdId.TYPE_IFD_GPS);
if (gpsIfd != null) {
ExifTag gpsOffsetTag = mInterface.buildUninitializedTag(ExifInterface.TAG_GPS_IFD);
if (gpsOffsetTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_GPS_IFD);
}
ifd0.setTag(gpsOffsetTag);
}

//comment
IfdData interIfd = mExifData.getIfdData(IfdId.TYPE_IFD_INTEROPERABILITY);
if (interIfd != null) {
ExifTag interOffsetTag = mInterface
.buildUninitializedTag(ExifInterface.TAG_INTEROPERABILITY_IFD);
if (interOffsetTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_INTEROPERABILITY_IFD);
}
exifIfd.setTag(interOffsetTag);
}

IfdData ifd1 = mExifData.getIfdData(IfdId.TYPE_IFD_1);

//comment
if (mExifData.hasCompressedThumbnail()) {

if (ifd1 == null) {
ifd1 = new IfdData(IfdId.TYPE_IFD_1);
mExifData.addIfdData(ifd1);
}

ExifTag offsetTag = mInterface
.buildUninitializedTag(ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT);
if (offsetTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT);
}

ifd1.setTag(offsetTag);
ExifTag lengthTag = mInterface
.buildUninitializedTag(ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT_LENGTH);
if (lengthTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT_LENGTH);
}

lengthTag.setValue(mExifData.getCompressedThumbnail().length);
ifd1.setTag(lengthTag);

//comment
<start>ifd1.removeTag(ExifInterface.getTrueTagKey(ExifInterface.TAG_STRIP_OFFSETS));<end>
ifd1.removeTag(ExifInterface.getTrueTagKey(ExifInterface.TAG_STRIP_BYTE_COUNTS));
} else if (mExifData.hasUncompressedStrip()) {
if (ifd1 == null) {
ifd1 = new IfdData(IfdId.TYPE_IFD_1);
mExifData.addIfdData(ifd1);
}
int stripCount = mExifData.getStripCount();
ExifTag offsetTag = mInterface.buildUninitializedTag(ExifInterface.TAG_STRIP_OFFSETS);
if (offsetTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_STRIP_OFFSETS);
}
ExifTag lengthTag = mInterface
.buildUninitializedTag(ExifInterface.TAG_STRIP_BYTE_COUNTS);
if (lengthTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_STRIP_BYTE_COUNTS);
}
long[] lengths = new long[stripCount];
for (int i = 0; i < mExifData.getStripCount(); i++) {
lengths[i] = mExifData.getStrip(i).length;
}
lengthTag.setValue(lengths);
ifd1.setTag(offsetTag);
ifd1.setTag(lengthTag);
//comment
ifd1.removeTag(ExifInterface.getTrueTagKey(ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT));
ifd1.removeTag(ExifInterface
.getTrueTagKey(ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT_LENGTH));
} else if (ifd1 != null) {
//comment
ifd1.removeTag(ExifInterface.getTrueTagKey(ExifInterface.TAG_STRIP_OFFSETS));
ifd1.removeTag(ExifInterface.getTrueTagKey(ExifInterface.TAG_STRIP_BYTE_COUNTS));
ifd1.removeTag(ExifInterface.getTrueTagKey(ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT));
ifd1.removeTag(ExifInterface
.getTrueTagKey(ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT_LENGTH));
}
}","private void createRequiredIfdAndTag() throws IOException {
//comment
IfdData ifd0 = mExifData.getIfdData(IfdId.TYPE_IFD_0);
if (ifd0 == null) {
ifd0 = new IfdData(IfdId.TYPE_IFD_0);
mExifData.addIfdData(ifd0);
}
ExifTag exifOffsetTag = mInterface.buildUninitializedTag(ExifInterface.TAG_EXIF_IFD);
if (exifOffsetTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_EXIF_IFD);
}
ifd0.setTag(exifOffsetTag);

//comment
IfdData exifIfd = mExifData.getIfdData(IfdId.TYPE_IFD_EXIF);
if (exifIfd == null) {
exifIfd = new IfdData(IfdId.TYPE_IFD_EXIF);
mExifData.addIfdData(exifIfd);
}

//comment
IfdData gpsIfd = mExifData.getIfdData(IfdId.TYPE_IFD_GPS);
if (gpsIfd != null) {
ExifTag gpsOffsetTag = mInterface.buildUninitializedTag(ExifInterface.TAG_GPS_IFD);
if (gpsOffsetTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_GPS_IFD);
}
ifd0.setTag(gpsOffsetTag);
}

//comment
IfdData interIfd = mExifData.getIfdData(IfdId.TYPE_IFD_INTEROPERABILITY);
if (interIfd != null) {
ExifTag interOffsetTag = mInterface
.buildUninitializedTag(ExifInterface.TAG_INTEROPERABILITY_IFD);
if (interOffsetTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_INTEROPERABILITY_IFD);
}
exifIfd.setTag(interOffsetTag);
}

IfdData ifd1 = mExifData.getIfdData(IfdId.TYPE_IFD_1);

//comment
if (mExifData.hasCompressedThumbnail()) {

if (ifd1 == null) {
ifd1 = new IfdData(IfdId.TYPE_IFD_1);
mExifData.addIfdData(ifd1);
}

ExifTag offsetTag = mInterface
.buildUninitializedTag(ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT);
if (offsetTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT);
}

ifd1.setTag(offsetTag);
ExifTag lengthTag = mInterface
.buildUninitializedTag(ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT_LENGTH);
if (lengthTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT_LENGTH);
}

lengthTag.setValue(mExifData.getCompressedThumbnail().length);
ifd1.setTag(lengthTag);

//comment
<start>ifd1.removeTag(ExifInterface.getTrueTagKey(ExifInterface.TAG_STRIP_OFFSETS));
ifd1.removeTag(ExifInterface.getTrueTagKey(ExifInterface.TAG_STRIP_BYTE_COUNTS));<end>
} else if (mExifData.hasUncompressedStrip()) {
if (ifd1 == null) {
ifd1 = new IfdData(IfdId.TYPE_IFD_1);
mExifData.addIfdData(ifd1);
}
int stripCount = mExifData.getStripCount();
ExifTag offsetTag = mInterface.buildUninitializedTag(ExifInterface.TAG_STRIP_OFFSETS);
if (offsetTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_STRIP_OFFSETS);
}
ExifTag lengthTag = mInterface
.buildUninitializedTag(ExifInterface.TAG_STRIP_BYTE_COUNTS);
if (lengthTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_STRIP_BYTE_COUNTS);
}
long[] lengths = new long[stripCount];
for (int i = 0; i < mExifData.getStripCount(); i++) {
lengths[i] = mExifData.getStrip(i).length;
}
lengthTag.setValue(lengths);
ifd1.setTag(offsetTag);
ifd1.setTag(lengthTag);
//comment
ifd1.removeTag(ExifInterface.getTrueTagKey(ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT));
ifd1.removeTag(ExifInterface
.getTrueTagKey(ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT_LENGTH));
} else if (ifd1 != null) {
//comment
ifd1.removeTag(ExifInterface.getTrueTagKey(ExifInterface.TAG_STRIP_OFFSETS));
ifd1.removeTag(ExifInterface.getTrueTagKey(ExifInterface.TAG_STRIP_BYTE_COUNTS));
ifd1.removeTag(ExifInterface.getTrueTagKey(ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT));
ifd1.removeTag(ExifInterface
.getTrueTagKey(ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT_LENGTH));
}
}"
2488,"private void createRequiredIfdAndTag() throws IOException {
//comment
IfdData ifd0 = mExifData.getIfdData(IfdId.TYPE_IFD_0);
if (ifd0 == null) {
ifd0 = new IfdData(IfdId.TYPE_IFD_0);
mExifData.addIfdData(ifd0);
}
ExifTag exifOffsetTag = mInterface.buildUninitializedTag(ExifInterface.TAG_EXIF_IFD);
if (exifOffsetTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_EXIF_IFD);
}
ifd0.setTag(exifOffsetTag);

//comment
IfdData exifIfd = mExifData.getIfdData(IfdId.TYPE_IFD_EXIF);
if (exifIfd == null) {
exifIfd = new IfdData(IfdId.TYPE_IFD_EXIF);
mExifData.addIfdData(exifIfd);
}

//comment
IfdData gpsIfd = mExifData.getIfdData(IfdId.TYPE_IFD_GPS);
if (gpsIfd != null) {
ExifTag gpsOffsetTag = mInterface.buildUninitializedTag(ExifInterface.TAG_GPS_IFD);
if (gpsOffsetTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_GPS_IFD);
}
ifd0.setTag(gpsOffsetTag);
}

//comment
IfdData interIfd = mExifData.getIfdData(IfdId.TYPE_IFD_INTEROPERABILITY);
if (interIfd != null) {
ExifTag interOffsetTag = mInterface
.buildUninitializedTag(ExifInterface.TAG_INTEROPERABILITY_IFD);
if (interOffsetTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_INTEROPERABILITY_IFD);
}
exifIfd.setTag(interOffsetTag);
}

IfdData ifd1 = mExifData.getIfdData(IfdId.TYPE_IFD_1);

//comment
if (mExifData.hasCompressedThumbnail()) {

if (ifd1 == null) {
ifd1 = new IfdData(IfdId.TYPE_IFD_1);
mExifData.addIfdData(ifd1);
}

ExifTag offsetTag = mInterface
.buildUninitializedTag(ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT);
if (offsetTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT);
}

ifd1.setTag(offsetTag);
ExifTag lengthTag = mInterface
.buildUninitializedTag(ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT_LENGTH);
if (lengthTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT_LENGTH);
}

lengthTag.setValue(mExifData.getCompressedThumbnail().length);
ifd1.setTag(lengthTag);

//comment
ifd1.removeTag(ExifInterface.getTrueTagKey(ExifInterface.TAG_STRIP_OFFSETS));
ifd1.removeTag(ExifInterface.getTrueTagKey(ExifInterface.TAG_STRIP_BYTE_COUNTS));
} else if (mExifData.hasUncompressedStrip()) {
if (ifd1 == null) {
ifd1 = new IfdData(IfdId.TYPE_IFD_1);
mExifData.addIfdData(ifd1);
}
int stripCount = mExifData.getStripCount();
ExifTag offsetTag = mInterface.buildUninitializedTag(ExifInterface.TAG_STRIP_OFFSETS);
if (offsetTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_STRIP_OFFSETS);
}
ExifTag lengthTag = mInterface
.buildUninitializedTag(ExifInterface.TAG_STRIP_BYTE_COUNTS);
if (lengthTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_STRIP_BYTE_COUNTS);
}
long[] lengths = new long[stripCount];
for (int i = 0; i < mExifData.getStripCount(); i++) {
<start>lengths[i] = mExifData.getStrip(i).length;<end>
}
lengthTag.setValue(lengths);
ifd1.setTag(offsetTag);
ifd1.setTag(lengthTag);
//comment
<start>ifd1.removeTag(ExifInterface.getTrueTagKey(ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT));<end>
ifd1.removeTag(ExifInterface
.getTrueTagKey(ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT_LENGTH));
<start>} else if (ifd1 != null) {<end>
//comment
ifd1.removeTag(ExifInterface.getTrueTagKey(ExifInterface.TAG_STRIP_OFFSETS));
ifd1.removeTag(ExifInterface.getTrueTagKey(ExifInterface.TAG_STRIP_BYTE_COUNTS));
ifd1.removeTag(ExifInterface.getTrueTagKey(ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT));
ifd1.removeTag(ExifInterface
.getTrueTagKey(ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT_LENGTH));
}
}","private void createRequiredIfdAndTag() throws IOException {
//comment
IfdData ifd0 = mExifData.getIfdData(IfdId.TYPE_IFD_0);
if (ifd0 == null) {
ifd0 = new IfdData(IfdId.TYPE_IFD_0);
mExifData.addIfdData(ifd0);
}
ExifTag exifOffsetTag = mInterface.buildUninitializedTag(ExifInterface.TAG_EXIF_IFD);
if (exifOffsetTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_EXIF_IFD);
}
ifd0.setTag(exifOffsetTag);

//comment
IfdData exifIfd = mExifData.getIfdData(IfdId.TYPE_IFD_EXIF);
if (exifIfd == null) {
exifIfd = new IfdData(IfdId.TYPE_IFD_EXIF);
mExifData.addIfdData(exifIfd);
}

//comment
IfdData gpsIfd = mExifData.getIfdData(IfdId.TYPE_IFD_GPS);
if (gpsIfd != null) {
ExifTag gpsOffsetTag = mInterface.buildUninitializedTag(ExifInterface.TAG_GPS_IFD);
if (gpsOffsetTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_GPS_IFD);
}
ifd0.setTag(gpsOffsetTag);
}

//comment
IfdData interIfd = mExifData.getIfdData(IfdId.TYPE_IFD_INTEROPERABILITY);
if (interIfd != null) {
ExifTag interOffsetTag = mInterface
.buildUninitializedTag(ExifInterface.TAG_INTEROPERABILITY_IFD);
if (interOffsetTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_INTEROPERABILITY_IFD);
}
exifIfd.setTag(interOffsetTag);
}

IfdData ifd1 = mExifData.getIfdData(IfdId.TYPE_IFD_1);

//comment
if (mExifData.hasCompressedThumbnail()) {

if (ifd1 == null) {
ifd1 = new IfdData(IfdId.TYPE_IFD_1);
mExifData.addIfdData(ifd1);
}

ExifTag offsetTag = mInterface
.buildUninitializedTag(ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT);
if (offsetTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT);
}

ifd1.setTag(offsetTag);
ExifTag lengthTag = mInterface
.buildUninitializedTag(ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT_LENGTH);
if (lengthTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT_LENGTH);
}

lengthTag.setValue(mExifData.getCompressedThumbnail().length);
ifd1.setTag(lengthTag);

//comment
ifd1.removeTag(ExifInterface.getTrueTagKey(ExifInterface.TAG_STRIP_OFFSETS));
ifd1.removeTag(ExifInterface.getTrueTagKey(ExifInterface.TAG_STRIP_BYTE_COUNTS));
} else if (mExifData.hasUncompressedStrip()) {
if (ifd1 == null) {
ifd1 = new IfdData(IfdId.TYPE_IFD_1);
mExifData.addIfdData(ifd1);
}
int stripCount = mExifData.getStripCount();
ExifTag offsetTag = mInterface.buildUninitializedTag(ExifInterface.TAG_STRIP_OFFSETS);
if (offsetTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_STRIP_OFFSETS);
}
ExifTag lengthTag = mInterface
.buildUninitializedTag(ExifInterface.TAG_STRIP_BYTE_COUNTS);
if (lengthTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_STRIP_BYTE_COUNTS);
}
long[] lengths = new long[stripCount];
for (int i = 0; i < mExifData.getStripCount(); i++) {
lengths[i] = mExifData.getStrip(i).length;
}
lengthTag.setValue(lengths);
ifd1.setTag(offsetTag);
ifd1.setTag(lengthTag);
//comment
<start>ifd1.removeTag(ExifInterface.getTrueTagKey(ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT));
ifd1.removeTag(ExifInterface
.getTrueTagKey(ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT_LENGTH));<end>
} else if (ifd1 != null) {
//comment
ifd1.removeTag(ExifInterface.getTrueTagKey(ExifInterface.TAG_STRIP_OFFSETS));
ifd1.removeTag(ExifInterface.getTrueTagKey(ExifInterface.TAG_STRIP_BYTE_COUNTS));
ifd1.removeTag(ExifInterface.getTrueTagKey(ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT));
ifd1.removeTag(ExifInterface
.getTrueTagKey(ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT_LENGTH));
}
}"
2489,"private void createRequiredIfdAndTag() throws IOException {
//comment
IfdData ifd0 = mExifData.getIfdData(IfdId.TYPE_IFD_0);
if (ifd0 == null) {
ifd0 = new IfdData(IfdId.TYPE_IFD_0);
mExifData.addIfdData(ifd0);
}
ExifTag exifOffsetTag = mInterface.buildUninitializedTag(ExifInterface.TAG_EXIF_IFD);
if (exifOffsetTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_EXIF_IFD);
}
ifd0.setTag(exifOffsetTag);

//comment
IfdData exifIfd = mExifData.getIfdData(IfdId.TYPE_IFD_EXIF);
if (exifIfd == null) {
exifIfd = new IfdData(IfdId.TYPE_IFD_EXIF);
mExifData.addIfdData(exifIfd);
}

//comment
IfdData gpsIfd = mExifData.getIfdData(IfdId.TYPE_IFD_GPS);
if (gpsIfd != null) {
ExifTag gpsOffsetTag = mInterface.buildUninitializedTag(ExifInterface.TAG_GPS_IFD);
if (gpsOffsetTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_GPS_IFD);
}
ifd0.setTag(gpsOffsetTag);
}

//comment
IfdData interIfd = mExifData.getIfdData(IfdId.TYPE_IFD_INTEROPERABILITY);
if (interIfd != null) {
ExifTag interOffsetTag = mInterface
.buildUninitializedTag(ExifInterface.TAG_INTEROPERABILITY_IFD);
if (interOffsetTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_INTEROPERABILITY_IFD);
}
exifIfd.setTag(interOffsetTag);
}

IfdData ifd1 = mExifData.getIfdData(IfdId.TYPE_IFD_1);

//comment
if (mExifData.hasCompressedThumbnail()) {

if (ifd1 == null) {
ifd1 = new IfdData(IfdId.TYPE_IFD_1);
mExifData.addIfdData(ifd1);
}

ExifTag offsetTag = mInterface
.buildUninitializedTag(ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT);
if (offsetTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT);
}

ifd1.setTag(offsetTag);
ExifTag lengthTag = mInterface
.buildUninitializedTag(ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT_LENGTH);
if (lengthTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT_LENGTH);
}

lengthTag.setValue(mExifData.getCompressedThumbnail().length);
ifd1.setTag(lengthTag);

//comment
ifd1.removeTag(ExifInterface.getTrueTagKey(ExifInterface.TAG_STRIP_OFFSETS));
ifd1.removeTag(ExifInterface.getTrueTagKey(ExifInterface.TAG_STRIP_BYTE_COUNTS));
} else if (mExifData.hasUncompressedStrip()) {
if (ifd1 == null) {
ifd1 = new IfdData(IfdId.TYPE_IFD_1);
mExifData.addIfdData(ifd1);
}
int stripCount = mExifData.getStripCount();
ExifTag offsetTag = mInterface.buildUninitializedTag(ExifInterface.TAG_STRIP_OFFSETS);
if (offsetTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_STRIP_OFFSETS);
}
ExifTag lengthTag = mInterface
.buildUninitializedTag(ExifInterface.TAG_STRIP_BYTE_COUNTS);
if (lengthTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_STRIP_BYTE_COUNTS);
}
long[] lengths = new long[stripCount];
for (int i = 0; i < mExifData.getStripCount(); i++) {
lengths[i] = mExifData.getStrip(i).length;
}
lengthTag.setValue(lengths);
<start>ifd1.setTag(offsetTag);<end>
ifd1.setTag(lengthTag);
//comment
<start>ifd1.removeTag(ExifInterface.getTrueTagKey(ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT));<end>
ifd1.removeTag(ExifInterface
.getTrueTagKey(ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT_LENGTH));
} else if (ifd1 != null) {
//comment
<start>ifd1.removeTag(ExifInterface.getTrueTagKey(ExifInterface.TAG_STRIP_OFFSETS));
ifd1.removeTag(ExifInterface.getTrueTagKey(ExifInterface.TAG_STRIP_BYTE_COUNTS));
ifd1.removeTag(ExifInterface.getTrueTagKey(ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT));<end>
ifd1.removeTag(ExifInterface
.getTrueTagKey(ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT_LENGTH));
}
}","private void createRequiredIfdAndTag() throws IOException {
//comment
IfdData ifd0 = mExifData.getIfdData(IfdId.TYPE_IFD_0);
if (ifd0 == null) {
ifd0 = new IfdData(IfdId.TYPE_IFD_0);
mExifData.addIfdData(ifd0);
}
ExifTag exifOffsetTag = mInterface.buildUninitializedTag(ExifInterface.TAG_EXIF_IFD);
if (exifOffsetTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_EXIF_IFD);
}
ifd0.setTag(exifOffsetTag);

//comment
IfdData exifIfd = mExifData.getIfdData(IfdId.TYPE_IFD_EXIF);
if (exifIfd == null) {
exifIfd = new IfdData(IfdId.TYPE_IFD_EXIF);
mExifData.addIfdData(exifIfd);
}

//comment
IfdData gpsIfd = mExifData.getIfdData(IfdId.TYPE_IFD_GPS);
if (gpsIfd != null) {
ExifTag gpsOffsetTag = mInterface.buildUninitializedTag(ExifInterface.TAG_GPS_IFD);
if (gpsOffsetTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_GPS_IFD);
}
ifd0.setTag(gpsOffsetTag);
}

//comment
IfdData interIfd = mExifData.getIfdData(IfdId.TYPE_IFD_INTEROPERABILITY);
if (interIfd != null) {
ExifTag interOffsetTag = mInterface
.buildUninitializedTag(ExifInterface.TAG_INTEROPERABILITY_IFD);
if (interOffsetTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_INTEROPERABILITY_IFD);
}
exifIfd.setTag(interOffsetTag);
}

IfdData ifd1 = mExifData.getIfdData(IfdId.TYPE_IFD_1);

//comment
if (mExifData.hasCompressedThumbnail()) {

if (ifd1 == null) {
ifd1 = new IfdData(IfdId.TYPE_IFD_1);
mExifData.addIfdData(ifd1);
}

ExifTag offsetTag = mInterface
.buildUninitializedTag(ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT);
if (offsetTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT);
}

ifd1.setTag(offsetTag);
ExifTag lengthTag = mInterface
.buildUninitializedTag(ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT_LENGTH);
if (lengthTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT_LENGTH);
}

lengthTag.setValue(mExifData.getCompressedThumbnail().length);
ifd1.setTag(lengthTag);

//comment
ifd1.removeTag(ExifInterface.getTrueTagKey(ExifInterface.TAG_STRIP_OFFSETS));
ifd1.removeTag(ExifInterface.getTrueTagKey(ExifInterface.TAG_STRIP_BYTE_COUNTS));
} else if (mExifData.hasUncompressedStrip()) {
if (ifd1 == null) {
ifd1 = new IfdData(IfdId.TYPE_IFD_1);
mExifData.addIfdData(ifd1);
}
int stripCount = mExifData.getStripCount();
ExifTag offsetTag = mInterface.buildUninitializedTag(ExifInterface.TAG_STRIP_OFFSETS);
if (offsetTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_STRIP_OFFSETS);
}
ExifTag lengthTag = mInterface
.buildUninitializedTag(ExifInterface.TAG_STRIP_BYTE_COUNTS);
if (lengthTag == null) {
throw new IOException(""No definition for crucial exif tag: ""
+ ExifInterface.TAG_STRIP_BYTE_COUNTS);
}
long[] lengths = new long[stripCount];
for (int i = 0; i < mExifData.getStripCount(); i++) {
lengths[i] = mExifData.getStrip(i).length;
}
lengthTag.setValue(lengths);
ifd1.setTag(offsetTag);
ifd1.setTag(lengthTag);
//comment
ifd1.removeTag(ExifInterface.getTrueTagKey(ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT));
ifd1.removeTag(ExifInterface
.getTrueTagKey(ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT_LENGTH));
} else if (ifd1 != null) {
//comment
<start>ifd1.removeTag(ExifInterface.getTrueTagKey(ExifInterface.TAG_STRIP_OFFSETS));
ifd1.removeTag(ExifInterface.getTrueTagKey(ExifInterface.TAG_STRIP_BYTE_COUNTS));
ifd1.removeTag(ExifInterface.getTrueTagKey(ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT));
ifd1.removeTag(ExifInterface
.getTrueTagKey(ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT_LENGTH));<end>
}
}"
3221,"private void onCreateTinyPlanet() {
//comment
//comment
synchronized (mRendering) {
<start>mRenderOneMore = false;<end>
}

final String savingTinyPlanet = getActivity().getResources().getString(
R.string.saving_tiny_planet);
(new AsyncTask<Void, Void, TinyPlanetImage>() {
@Override
protected void onPreExecute() {
mDialog = ProgressDialog.show(getActivity(), null, savingTinyPlanet, true, false);
}

@Override
protected TinyPlanetImage doInBackground(Void... params) {
return createTinyPlanet();
}

@Override
protected void onPostExecute(TinyPlanetImage image) {
//comment
final CameraActivity activity = (CameraActivity) getActivity();
MediaSaveService mediaSaveService = activity.getMediaSaveService();
OnMediaSavedListener doneListener =
new OnMediaSavedListener() {
@Override
public void onMediaSaved(Uri uri) {
//comment
//comment
activity.notifyNewMedia(uri);
mDialog.dismiss();
TinyPlanetFragment.this.dismiss();
}
};
String tinyPlanetTitle = FILENAME_PREFIX + mOriginalTitle;
mediaSaveService.addImage(image.mJpegData, tinyPlanetTitle, (new Date()).getTime(),
null,
image.mSize, image.mSize, 0, null, doneListener, getActivity()
.getContentResolver(),PhotoModule.PIXEL_FORMAT_JPEG);
}
}).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
}","private void onCreateTinyPlanet() {
//comment
//comment
<start>synchronized (mRendering) {
mRenderOneMore = false;
}<end>

final String savingTinyPlanet = getActivity().getResources().getString(
R.string.saving_tiny_planet);
(new AsyncTask<Void, Void, TinyPlanetImage>() {
@Override
protected void onPreExecute() {
mDialog = ProgressDialog.show(getActivity(), null, savingTinyPlanet, true, false);
}

@Override
protected TinyPlanetImage doInBackground(Void... params) {
return createTinyPlanet();
}

@Override
protected void onPostExecute(TinyPlanetImage image) {
//comment
final CameraActivity activity = (CameraActivity) getActivity();
MediaSaveService mediaSaveService = activity.getMediaSaveService();
OnMediaSavedListener doneListener =
new OnMediaSavedListener() {
@Override
public void onMediaSaved(Uri uri) {
//comment
//comment
activity.notifyNewMedia(uri);
mDialog.dismiss();
TinyPlanetFragment.this.dismiss();
}
};
String tinyPlanetTitle = FILENAME_PREFIX + mOriginalTitle;
mediaSaveService.addImage(image.mJpegData, tinyPlanetTitle, (new Date()).getTime(),
null,
image.mSize, image.mSize, 0, null, doneListener, getActivity()
.getContentResolver(),PhotoModule.PIXEL_FORMAT_JPEG);
}
}).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
}"
3222,"private void onCreateTinyPlanet() {
//comment
//comment
synchronized (mRendering) {
mRenderOneMore = false;
}

final String savingTinyPlanet = getActivity().getResources().getString(
R.string.saving_tiny_planet);
(new AsyncTask<Void, Void, TinyPlanetImage>() {
@Override
protected void onPreExecute() {
mDialog = ProgressDialog.show(getActivity(), null, savingTinyPlanet, true, false);
}

@Override
protected TinyPlanetImage doInBackground(Void... params) {
return createTinyPlanet();
}

@Override
protected void onPostExecute(TinyPlanetImage image) {
//comment
final CameraActivity activity = (CameraActivity) getActivity();
MediaSaveService mediaSaveService = activity.getMediaSaveService();
OnMediaSavedListener doneListener =
new OnMediaSavedListener() {
@Override
public void onMediaSaved(Uri uri) {
//comment
//comment
activity.notifyNewMedia(uri);
mDialog.dismiss();
TinyPlanetFragment.this.dismiss();
}
};
String tinyPlanetTitle = FILENAME_PREFIX + mOriginalTitle;
mediaSaveService.addImage(image.mJpegData, tinyPlanetTitle, (new Date()).getTime(),
null,
image.mSize, image.mSize, 0, null, doneListener, getActivity()
.getContentResolver(),PhotoModule.PIXEL_FORMAT_JPEG);
}
}).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
}","private void onCreateTinyPlanet() {
//comment
//comment
synchronized (mRendering) {
mRenderOneMore = false;
}

final String savingTinyPlanet = getActivity().getResources().getString(
R.string.saving_tiny_planet);
(new AsyncTask<Void, Void, TinyPlanetImage>() {
@Override
protected void onPreExecute() {
mDialog = ProgressDialog.show(getActivity(), null, savingTinyPlanet, true, false);
}

@Override
protected TinyPlanetImage doInBackground(Void... params) {
return createTinyPlanet();
}

@Override
protected void onPostExecute(TinyPlanetImage image) {
//comment
final CameraActivity activity = (CameraActivity) getActivity();
MediaSaveService mediaSaveService = activity.getMediaSaveService();
OnMediaSavedListener doneListener =
new OnMediaSavedListener() {
@Override
public void onMediaSaved(Uri uri) {
//comment
//comment
<start>activity.notifyNewMedia(uri);
mDialog.dismiss();
TinyPlanetFragment.this.dismiss();<end>
}
};
String tinyPlanetTitle = FILENAME_PREFIX + mOriginalTitle;
mediaSaveService.addImage(image.mJpegData, tinyPlanetTitle, (new Date()).getTime(),
null,
image.mSize, image.mSize, 0, null, doneListener, getActivity()
.getContentResolver(),PhotoModule.PIXEL_FORMAT_JPEG);
}
}).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
}"
4888,"@Override
public void onLayout(boolean changed, int l, int t, int r, int b) {
int orientation = getResources().getConfiguration().orientation;
int size = getResources().getDimensionPixelSize(R.dimen.camera_controls_size);
int rotation = getUnifiedRotation();
adjustBackground();
//comment
//comment
<start>r = r - l;
b = b - t;<end>
l = 0;
t = 0;
for (int i = 0; i < getChildCount(); i++) {
View v = getChildAt(i);
v.layout(l, t, r, b);
}
Rect shutter = new Rect();
center(mShutter, l, t, r, b, orientation, rotation, shutter, SHUTTER_INDEX);
mSize = (int) (Math.max(shutter.right - shutter.left, shutter.bottom - shutter.top) * 1.2f);
center(mBackgroundView, l, t, r, b, orientation, rotation, new Rect(), -1);
mBackgroundView.setVisibility(View.GONE);
setLocation(r - l, b - t);

View retake = findViewById(R.id.btn_retake);
if (retake != null) {
mReviewRetakeButton = retake;
mReviewCancelButton = findViewById(R.id.btn_cancel);
mReviewDoneButton = findViewById(R.id.done_button);

center(mReviewRetakeButton, shutter, rotation);
toLeft(mReviewCancelButton, shutter, rotation);
toRight(mReviewDoneButton, shutter, rotation);
} else {
mReviewRetakeButton = null;
mReviewCancelButton = null;
mReviewDoneButton = null;
}
layoutRemaingPhotos();
}","@Override
public void onLayout(boolean changed, int l, int t, int r, int b) {
int orientation = getResources().getConfiguration().orientation;
int size = getResources().getDimensionPixelSize(R.dimen.camera_controls_size);
int rotation = getUnifiedRotation();
adjustBackground();
//comment
//comment
<start>r = r - l;
b = b - t;
l = 0;
t = 0;
for (int i = 0; i < getChildCount(); i++) {
View v = getChildAt(i);
v.layout(l, t, r, b);
}<end>
Rect shutter = new Rect();
center(mShutter, l, t, r, b, orientation, rotation, shutter, SHUTTER_INDEX);
mSize = (int) (Math.max(shutter.right - shutter.left, shutter.bottom - shutter.top) * 1.2f);
center(mBackgroundView, l, t, r, b, orientation, rotation, new Rect(), -1);
mBackgroundView.setVisibility(View.GONE);
setLocation(r - l, b - t);

View retake = findViewById(R.id.btn_retake);
if (retake != null) {
mReviewRetakeButton = retake;
mReviewCancelButton = findViewById(R.id.btn_cancel);
mReviewDoneButton = findViewById(R.id.done_button);

center(mReviewRetakeButton, shutter, rotation);
toLeft(mReviewCancelButton, shutter, rotation);
toRight(mReviewDoneButton, shutter, rotation);
} else {
mReviewRetakeButton = null;
mReviewCancelButton = null;
mReviewDoneButton = null;
}
layoutRemaingPhotos();
}"
4889,"private void center(View v, int l, int t, int r, int b, int orientation, int rotation,
Rect result, int idx) {
FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) v.getLayoutParams();
int tw = lp.leftMargin + v.getMeasuredWidth() + lp.rightMargin;
int th = lp.topMargin + v.getMeasuredHeight() + lp.bottomMargin;
switch (rotation) {
case 0:
//comment
result.left = (r + l) / 2 - tw / 2 + lp.leftMargin;
<start>result.right = (r + l) / 2 + tw / 2 - lp.rightMargin;<end>
result.bottom = b - lp.bottomMargin;
<start>result.top = b - th + lp.topMargin;<end>
break;
case 90:
//comment
result.right = r - lp.rightMargin;
result.left = r - tw + lp.leftMargin;
result.top = (b + t) / 2 - th / 2 + lp.topMargin;
result.bottom = (b + t) / 2 + th / 2 - lp.bottomMargin;
break;
case 180:
//comment
result.left = (r + l) / 2 - tw / 2 + lp.leftMargin;
result.right = (r + l) / 2 + tw / 2 - lp.rightMargin;
result.top = t + lp.topMargin;
result.bottom = t + th - lp.bottomMargin;
break;
case 270:
//comment
result.left = l + lp.leftMargin;
result.right = l + tw - lp.rightMargin;
result.top = (b + t) / 2 - th / 2 + lp.topMargin;
result.bottom = (b + t) / 2 + th / 2 - lp.bottomMargin;
break;
}
v.layout(result.left, result.top, result.right, result.bottom);
if (idx != -1) {
int idx1 = rotation / 90;
int idx2 = idx;
mLocX[idx1][idx2] = result.left;
mLocY[idx1][idx2] = result.top;
}
}","private void center(View v, int l, int t, int r, int b, int orientation, int rotation,
Rect result, int idx) {
FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) v.getLayoutParams();
int tw = lp.leftMargin + v.getMeasuredWidth() + lp.rightMargin;
int th = lp.topMargin + v.getMeasuredHeight() + lp.bottomMargin;
<start>switch (rotation) {
case 0:
//comment
result.left = (r + l) / 2 - tw / 2 + lp.leftMargin;
result.right = (r + l) / 2 + tw / 2 - lp.rightMargin;
result.bottom = b - lp.bottomMargin;
result.top = b - th + lp.topMargin;
break;<end>
case 90:
//comment
result.right = r - lp.rightMargin;
result.left = r - tw + lp.leftMargin;
result.top = (b + t) / 2 - th / 2 + lp.topMargin;
result.bottom = (b + t) / 2 + th / 2 - lp.bottomMargin;
break;
case 180:
//comment
result.left = (r + l) / 2 - tw / 2 + lp.leftMargin;
result.right = (r + l) / 2 + tw / 2 - lp.rightMargin;
result.top = t + lp.topMargin;
result.bottom = t + th - lp.bottomMargin;
break;
case 270:
//comment
result.left = l + lp.leftMargin;
result.right = l + tw - lp.rightMargin;
result.top = (b + t) / 2 - th / 2 + lp.topMargin;
result.bottom = (b + t) / 2 + th / 2 - lp.bottomMargin;
break;
<start>}<end>
v.layout(result.left, result.top, result.right, result.bottom);
if (idx != -1) {
int idx1 = rotation / 90;
int idx2 = idx;
mLocX[idx1][idx2] = result.left;
mLocY[idx1][idx2] = result.top;
}
}"
4890,"private void center(View v, int l, int t, int r, int b, int orientation, int rotation,
Rect result, int idx) {
FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) v.getLayoutParams();
int tw = lp.leftMargin + v.getMeasuredWidth() + lp.rightMargin;
int th = lp.topMargin + v.getMeasuredHeight() + lp.bottomMargin;
switch (rotation) {
case 0:
//comment
result.left = (r + l) / 2 - tw / 2 + lp.leftMargin;
result.right = (r + l) / 2 + tw / 2 - lp.rightMargin;
result.bottom = b - lp.bottomMargin;
result.top = b - th + lp.topMargin;
break;
case 90:
//comment
result.right = r - lp.rightMargin;
<start>result.left = r - tw + lp.leftMargin;<end>
result.top = (b + t) / 2 - th / 2 + lp.topMargin;
<start>result.bottom = (b + t) / 2 + th / 2 - lp.bottomMargin;<end>
break;
case 180:
//comment
result.left = (r + l) / 2 - tw / 2 + lp.leftMargin;
result.right = (r + l) / 2 + tw / 2 - lp.rightMargin;
result.top = t + lp.topMargin;
result.bottom = t + th - lp.bottomMargin;
break;
case 270:
//comment
result.left = l + lp.leftMargin;
result.right = l + tw - lp.rightMargin;
result.top = (b + t) / 2 - th / 2 + lp.topMargin;
result.bottom = (b + t) / 2 + th / 2 - lp.bottomMargin;
break;
}
v.layout(result.left, result.top, result.right, result.bottom);
if (idx != -1) {
int idx1 = rotation / 90;
int idx2 = idx;
mLocX[idx1][idx2] = result.left;
mLocY[idx1][idx2] = result.top;
}
}","private void center(View v, int l, int t, int r, int b, int orientation, int rotation,
Rect result, int idx) {
FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) v.getLayoutParams();
int tw = lp.leftMargin + v.getMeasuredWidth() + lp.rightMargin;
int th = lp.topMargin + v.getMeasuredHeight() + lp.bottomMargin;
<start>switch (rotation) {<end>
case 0:
//comment
result.left = (r + l) / 2 - tw / 2 + lp.leftMargin;
result.right = (r + l) / 2 + tw / 2 - lp.rightMargin;
result.bottom = b - lp.bottomMargin;
result.top = b - th + lp.topMargin;
break;
<start>case 90:
//comment
result.right = r - lp.rightMargin;
result.left = r - tw + lp.leftMargin;
result.top = (b + t) / 2 - th / 2 + lp.topMargin;
result.bottom = (b + t) / 2 + th / 2 - lp.bottomMargin;
break;<end>
case 180:
//comment
result.left = (r + l) / 2 - tw / 2 + lp.leftMargin;
result.right = (r + l) / 2 + tw / 2 - lp.rightMargin;
result.top = t + lp.topMargin;
result.bottom = t + th - lp.bottomMargin;
break;
case 270:
//comment
result.left = l + lp.leftMargin;
result.right = l + tw - lp.rightMargin;
result.top = (b + t) / 2 - th / 2 + lp.topMargin;
result.bottom = (b + t) / 2 + th / 2 - lp.bottomMargin;
break;
<start>}<end>
v.layout(result.left, result.top, result.right, result.bottom);
if (idx != -1) {
int idx1 = rotation / 90;
int idx2 = idx;
mLocX[idx1][idx2] = result.left;
mLocY[idx1][idx2] = result.top;
}
}"
4891,"private void center(View v, int l, int t, int r, int b, int orientation, int rotation,
Rect result, int idx) {
FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) v.getLayoutParams();
int tw = lp.leftMargin + v.getMeasuredWidth() + lp.rightMargin;
int th = lp.topMargin + v.getMeasuredHeight() + lp.bottomMargin;
switch (rotation) {
case 0:
//comment
result.left = (r + l) / 2 - tw / 2 + lp.leftMargin;
result.right = (r + l) / 2 + tw / 2 - lp.rightMargin;
result.bottom = b - lp.bottomMargin;
result.top = b - th + lp.topMargin;
<start>break;<end>
case 90:
//comment
result.right = r - lp.rightMargin;
result.left = r - tw + lp.leftMargin;
result.top = (b + t) / 2 - th / 2 + lp.topMargin;
result.bottom = (b + t) / 2 + th / 2 - lp.bottomMargin;
break;
case 180:
//comment
result.left = (r + l) / 2 - tw / 2 + lp.leftMargin;
<start>result.right = (r + l) / 2 + tw / 2 - lp.rightMargin;
result.top = t + lp.topMargin;
result.bottom = t + th - lp.bottomMargin;<end>
break;
case 270:
//comment
result.left = l + lp.leftMargin;
result.right = l + tw - lp.rightMargin;
result.top = (b + t) / 2 - th / 2 + lp.topMargin;
<start>result.bottom = (b + t) / 2 + th / 2 - lp.bottomMargin;<end>
break;
}
v.layout(result.left, result.top, result.right, result.bottom);
if (idx != -1) {
int idx1 = rotation / 90;
int idx2 = idx;
mLocX[idx1][idx2] = result.left;
mLocY[idx1][idx2] = result.top;
}
}","private void center(View v, int l, int t, int r, int b, int orientation, int rotation,
Rect result, int idx) {
FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) v.getLayoutParams();
int tw = lp.leftMargin + v.getMeasuredWidth() + lp.rightMargin;
int th = lp.topMargin + v.getMeasuredHeight() + lp.bottomMargin;
<start>switch (rotation) {<end>
case 0:
//comment
result.left = (r + l) / 2 - tw / 2 + lp.leftMargin;
result.right = (r + l) / 2 + tw / 2 - lp.rightMargin;
result.bottom = b - lp.bottomMargin;
result.top = b - th + lp.topMargin;
break;
case 90:
//comment
result.right = r - lp.rightMargin;
result.left = r - tw + lp.leftMargin;
result.top = (b + t) / 2 - th / 2 + lp.topMargin;
result.bottom = (b + t) / 2 + th / 2 - lp.bottomMargin;
break;
<start>case 180:
//comment
result.left = (r + l) / 2 - tw / 2 + lp.leftMargin;
result.right = (r + l) / 2 + tw / 2 - lp.rightMargin;
result.top = t + lp.topMargin;
result.bottom = t + th - lp.bottomMargin;
break;<end>
case 270:
//comment
result.left = l + lp.leftMargin;
result.right = l + tw - lp.rightMargin;
result.top = (b + t) / 2 - th / 2 + lp.topMargin;
result.bottom = (b + t) / 2 + th / 2 - lp.bottomMargin;
break;
<start>}<end>
v.layout(result.left, result.top, result.right, result.bottom);
if (idx != -1) {
int idx1 = rotation / 90;
int idx2 = idx;
mLocX[idx1][idx2] = result.left;
mLocY[idx1][idx2] = result.top;
}
}"
4892,"private void center(View v, int l, int t, int r, int b, int orientation, int rotation,
Rect result, int idx) {
FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) v.getLayoutParams();
int tw = lp.leftMargin + v.getMeasuredWidth() + lp.rightMargin;
int th = lp.topMargin + v.getMeasuredHeight() + lp.bottomMargin;
switch (rotation) {
case 0:
//comment
result.left = (r + l) / 2 - tw / 2 + lp.leftMargin;
result.right = (r + l) / 2 + tw / 2 - lp.rightMargin;
result.bottom = b - lp.bottomMargin;
result.top = b - th + lp.topMargin;
break;
case 90:
//comment
result.right = r - lp.rightMargin;
result.left = r - tw + lp.leftMargin;
result.top = (b + t) / 2 - th / 2 + lp.topMargin;
result.bottom = (b + t) / 2 + th / 2 - lp.bottomMargin;
<start>break;<end>
case 180:
//comment
result.left = (r + l) / 2 - tw / 2 + lp.leftMargin;
result.right = (r + l) / 2 + tw / 2 - lp.rightMargin;
result.top = t + lp.topMargin;
result.bottom = t + th - lp.bottomMargin;
break;
case 270:
//comment
result.left = l + lp.leftMargin;
result.right = l + tw - lp.rightMargin;
<start>result.top = (b + t) / 2 - th / 2 + lp.topMargin;<end>
result.bottom = (b + t) / 2 + th / 2 - lp.bottomMargin;
<start>break;<end>
}
v.layout(result.left, result.top, result.right, result.bottom);
if (idx != -1) {
int idx1 = rotation / 90;
int idx2 = idx;
mLocX[idx1][idx2] = result.left;
mLocY[idx1][idx2] = result.top;
}
}","private void center(View v, int l, int t, int r, int b, int orientation, int rotation,
Rect result, int idx) {
FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) v.getLayoutParams();
int tw = lp.leftMargin + v.getMeasuredWidth() + lp.rightMargin;
int th = lp.topMargin + v.getMeasuredHeight() + lp.bottomMargin;
<start>switch (rotation) {<end>
case 0:
//comment
result.left = (r + l) / 2 - tw / 2 + lp.leftMargin;
result.right = (r + l) / 2 + tw / 2 - lp.rightMargin;
result.bottom = b - lp.bottomMargin;
result.top = b - th + lp.topMargin;
break;
case 90:
//comment
result.right = r - lp.rightMargin;
result.left = r - tw + lp.leftMargin;
result.top = (b + t) / 2 - th / 2 + lp.topMargin;
result.bottom = (b + t) / 2 + th / 2 - lp.bottomMargin;
break;
case 180:
//comment
result.left = (r + l) / 2 - tw / 2 + lp.leftMargin;
result.right = (r + l) / 2 + tw / 2 - lp.rightMargin;
result.top = t + lp.topMargin;
result.bottom = t + th - lp.bottomMargin;
break;
<start>case 270:
//comment
result.left = l + lp.leftMargin;
result.right = l + tw - lp.rightMargin;
result.top = (b + t) / 2 - th / 2 + lp.topMargin;
result.bottom = (b + t) / 2 + th / 2 - lp.bottomMargin;
break;
}<end>
v.layout(result.left, result.top, result.right, result.bottom);
if (idx != -1) {
int idx1 = rotation / 90;
int idx2 = idx;
mLocX[idx1][idx2] = result.left;
mLocY[idx1][idx2] = result.top;
}
}"
4893,"private void adjustBackground() {
<start>int rotation = getUnifiedRotation();<end>
//comment
mBackgroundView.setBackgroundDrawable(null);
mBackgroundView.setRotationX(0);
mBackgroundView.setRotationY(0);
//comment
//comment
//comment
switch (rotation) {
case 180:
mBackgroundView.setRotationX(180);
break;
case 270:
mBackgroundView.setRotationY(180);
break;
default:
break;
}
mBackgroundView.setBackgroundResource(R.drawable.switcher_bg);
}","private void adjustBackground() {
int rotation = getUnifiedRotation();
//comment
<start>mBackgroundView.setBackgroundDrawable(null);
mBackgroundView.setRotationX(0);
mBackgroundView.setRotationY(0);<end>
//comment
//comment
//comment
switch (rotation) {
case 180:
mBackgroundView.setRotationX(180);
break;
case 270:
mBackgroundView.setRotationY(180);
break;
default:
break;
}
mBackgroundView.setBackgroundResource(R.drawable.switcher_bg);
}"
4894,"private void adjustBackground() {
int rotation = getUnifiedRotation();
//comment
mBackgroundView.setBackgroundDrawable(null);
mBackgroundView.setRotationX(0);
<start>mBackgroundView.setRotationY(0);<end>
//comment
//comment
//comment
switch (rotation) {
<start>case 180:
mBackgroundView.setRotationX(180);
break;<end>
case 270:
mBackgroundView.setRotationY(180);
break;
default:
break;
}
mBackgroundView.setBackgroundResource(R.drawable.switcher_bg);
}","private void adjustBackground() {
int rotation = getUnifiedRotation();
//comment
mBackgroundView.setBackgroundDrawable(null);
mBackgroundView.setRotationX(0);
mBackgroundView.setRotationY(0);
//comment
//comment
//comment
<start>switch (rotation) {
case 180:
mBackgroundView.setRotationX(180);
break;
case 270:
mBackgroundView.setRotationY(180);
break;
default:
break;
}<end>
mBackgroundView.setBackgroundResource(R.drawable.switcher_bg);
}"
238,"public void initialize(ListPreference timer, ListPreference beep) {
mTimer = timer;
<start>mBeep = beep;
//comment
mTitle.setText(mTimer.getTitle());<end>

//comment
CharSequence[] entries = mTimer.getEntryValues();
mDurations = new String[entries.length];
Locale locale = getResources().getConfiguration().locale;
mDurations[0] = getResources().getString(R.string.setting_off);
for (int i = 1; i < entries.length; i++)
mDurations[i] =  String.format(locale, ""%d"", Integer.parseInt(entries[i].toString()));
int durationCount = mDurations.length;
mNumberSpinner = (NumberPicker) findViewById(R.id.duration);
mNumberSpinner.setMinValue(0);
mNumberSpinner.setMaxValue(durationCount - 1);
mNumberSpinner.setDisplayedValues(mDurations);
mNumberSpinner.setWrapSelectorWheel(false);
mNumberSpinner.setOnValueChangedListener(new OnValueChangeListener() {
@Override
public void onValueChange(NumberPicker picker, int oldValue, int newValue) {
setTimeSelectionEnabled(newValue != 0);
}
});
mConfirmButton = (Button) findViewById(R.id.timer_set_button);
mPickerTitle = findViewById(R.id.set_time_interval_title);

//comment
mNumberSpinner.setDescendantFocusability(NumberPicker.FOCUS_BLOCK_DESCENDANTS);

mConfirmButton.setOnClickListener(new View.OnClickListener() {
public void onClick(View v) {
updateInputState();
}
});
mTimerSound = (CheckBox) findViewById(R.id.sound_check_box);
mSoundTitle = findViewById(R.id.beep_title);
}","public void initialize(ListPreference timer, ListPreference beep) {
mTimer = timer;
mBeep = beep;
//comment
<start>mTitle.setText(mTimer.getTitle());<end>

//comment
CharSequence[] entries = mTimer.getEntryValues();
mDurations = new String[entries.length];
Locale locale = getResources().getConfiguration().locale;
mDurations[0] = getResources().getString(R.string.setting_off);
for (int i = 1; i < entries.length; i++)
mDurations[i] =  String.format(locale, ""%d"", Integer.parseInt(entries[i].toString()));
int durationCount = mDurations.length;
mNumberSpinner = (NumberPicker) findViewById(R.id.duration);
mNumberSpinner.setMinValue(0);
mNumberSpinner.setMaxValue(durationCount - 1);
mNumberSpinner.setDisplayedValues(mDurations);
mNumberSpinner.setWrapSelectorWheel(false);
mNumberSpinner.setOnValueChangedListener(new OnValueChangeListener() {
@Override
public void onValueChange(NumberPicker picker, int oldValue, int newValue) {
setTimeSelectionEnabled(newValue != 0);
}
});
mConfirmButton = (Button) findViewById(R.id.timer_set_button);
mPickerTitle = findViewById(R.id.set_time_interval_title);

//comment
mNumberSpinner.setDescendantFocusability(NumberPicker.FOCUS_BLOCK_DESCENDANTS);

mConfirmButton.setOnClickListener(new View.OnClickListener() {
public void onClick(View v) {
updateInputState();
}
});
mTimerSound = (CheckBox) findViewById(R.id.sound_check_box);
mSoundTitle = findViewById(R.id.beep_title);
}"
239,"public void initialize(ListPreference timer, ListPreference beep) {
mTimer = timer;
mBeep = beep;
//comment
mTitle.setText(mTimer.getTitle());

//comment
CharSequence[] entries = mTimer.getEntryValues();
mDurations = new String[entries.length];
Locale locale = getResources().getConfiguration().locale;
mDurations[0] = getResources().getString(R.string.setting_off);
for (int i = 1; i < entries.length; i++)
mDurations[i] =  String.format(locale, ""%d"", Integer.parseInt(entries[i].toString()));
int durationCount = mDurations.length;
mNumberSpinner = (NumberPicker) findViewById(R.id.duration);
mNumberSpinner.setMinValue(0);
mNumberSpinner.setMaxValue(durationCount - 1);
mNumberSpinner.setDisplayedValues(mDurations);
mNumberSpinner.setWrapSelectorWheel(false);
mNumberSpinner.setOnValueChangedListener(new OnValueChangeListener() {
@Override
public void onValueChange(NumberPicker picker, int oldValue, int newValue) {
setTimeSelectionEnabled(newValue != 0);
}
});
mConfirmButton = (Button) findViewById(R.id.timer_set_button);
mPickerTitle = findViewById(R.id.set_time_interval_title);

//comment
<start>mNumberSpinner.setDescendantFocusability(NumberPicker.FOCUS_BLOCK_DESCENDANTS);<end>

mConfirmButton.setOnClickListener(new View.OnClickListener() {
public void onClick(View v) {
updateInputState();
}
});
mTimerSound = (CheckBox) findViewById(R.id.sound_check_box);
mSoundTitle = findViewById(R.id.beep_title);
}","public void initialize(ListPreference timer, ListPreference beep) {
mTimer = timer;
mBeep = beep;
//comment
mTitle.setText(mTimer.getTitle());

//comment
CharSequence[] entries = mTimer.getEntryValues();
mDurations = new String[entries.length];
Locale locale = getResources().getConfiguration().locale;
mDurations[0] = getResources().getString(R.string.setting_off);
for (int i = 1; i < entries.length; i++)
mDurations[i] =  String.format(locale, ""%d"", Integer.parseInt(entries[i].toString()));
int durationCount = mDurations.length;
mNumberSpinner = (NumberPicker) findViewById(R.id.duration);
mNumberSpinner.setMinValue(0);
mNumberSpinner.setMaxValue(durationCount - 1);
mNumberSpinner.setDisplayedValues(mDurations);
mNumberSpinner.setWrapSelectorWheel(false);
mNumberSpinner.setOnValueChangedListener(new OnValueChangeListener() {
@Override
public void onValueChange(NumberPicker picker, int oldValue, int newValue) {
setTimeSelectionEnabled(newValue != 0);
}
});
mConfirmButton = (Button) findViewById(R.id.timer_set_button);
mPickerTitle = findViewById(R.id.set_time_interval_title);

//comment
<start>mNumberSpinner.setDescendantFocusability(NumberPicker.FOCUS_BLOCK_DESCENDANTS);<end>

mConfirmButton.setOnClickListener(new View.OnClickListener() {
public void onClick(View v) {
updateInputState();
}
});
mTimerSound = (CheckBox) findViewById(R.id.sound_check_box);
mSoundTitle = findViewById(R.id.beep_title);
}"
4895,"private void setDetails(Context context, MediaDetails details) {
boolean resolutionIsValid = true;
String path = null;
for (Entry<Integer, Object> detail : details) {
String value;
switch (detail.getKey()) {
case MediaDetails.INDEX_SIZE: {
value = Formatter.formatFileSize(
context, (Long) detail.getValue());
break;
}
case MediaDetails.INDEX_WHITE_BALANCE: {
value = ""1"".equals(detail.getValue())
? context.getString(R.string.manual)
: context.getString(R.string.auto);
break;
}
case MediaDetails.INDEX_FLASH: {
MediaDetails.FlashState flash =
(MediaDetails.FlashState) detail.getValue();
//comment
//comment
if (flash.isFlashFired()) {
value = context.getString(R.string.flash_on);
} else {
value = context.getString(R.string.flash_off);
}
break;
}
case MediaDetails.INDEX_EXPOSURE_TIME: {
value = (String) detail.getValue();
double time = Double.valueOf(value);
if (time < 1.0f) {
value = String.format(mDefaultLocale, ""%d/%d"", 1,
(int) (0.5f + 1 / time));
} else {
int integer = (int) time;
time -= integer;
value = String.valueOf(integer) + ""''"";
if (time > 0.0001) {
value += String.format(mDefaultLocale, "" %d/%d"", 1,
(int) (0.5f + 1 / time));
}
}
break;
}
case MediaDetails.INDEX_WIDTH:
mWidthIndex = mItems.size();
if (detail.getValue().toString().equalsIgnoreCase(""0"")) {
value = context.getString(R.string.unknown);
resolutionIsValid = false;
} else {
value = toLocalInteger(detail.getValue());
}
break;
case MediaDetails.INDEX_HEIGHT: {
mHeightIndex = mItems.size();
if (detail.getValue().toString().equalsIgnoreCase(""0"")) {
value = context.getString(R.string.unknown);
resolutionIsValid = false;
} else {
value = toLocalInteger(detail.getValue());
}
break;
}
case MediaDetails.INDEX_PATH:
//comment
//comment
//comment
//comment
//comment
value = ""\n"" + detail.getValue().toString();
path = detail.getValue().toString();
break;
case MediaDetails.INDEX_ORIENTATION:
value = toLocalInteger(detail.getValue());
break;
case MediaDetails.INDEX_ISO:
value = toLocalNumber(Integer.parseInt((String) detail.getValue()));
break;
case MediaDetails.INDEX_FOCAL_LENGTH:
double focalLength = Double.parseDouble(detail.getValue().toString());
value = toLocalNumber(focalLength);
break;
default: {
Object valueObj = detail.getValue();
//comment
//comment
if (valueObj == null) {
fail(""%s's value is Null"",
getDetailsName(context,
detail.getKey()));
}
value = valueObj.toString();
}
}
int key = detail.getKey();
if (details.hasUnit(key)) {
value = String.format(""%s: %s %s"", getDetailsName(
context, key), value, context.getString(details.getUnit(key)));
} else {
value = String.format(""%s: %s"", getDetailsName(
context, key), value);
}
mItems.add(value);
}
if (!resolutionIsValid) {
resolveResolution(path);
}
}","private void setDetails(Context context, MediaDetails details) {
boolean resolutionIsValid = true;
String path = null;
for (Entry<Integer, Object> detail : details) {
String value;
switch (detail.getKey()) {
case MediaDetails.INDEX_SIZE: {
value = Formatter.formatFileSize(
context, (Long) detail.getValue());
break;
}
case MediaDetails.INDEX_WHITE_BALANCE: {
value = ""1"".equals(detail.getValue())
? context.getString(R.string.manual)
: context.getString(R.string.auto);
break;
}
case MediaDetails.INDEX_FLASH: {
MediaDetails.FlashState flash =
(MediaDetails.FlashState) detail.getValue();
//comment
//comment
if (flash.isFlashFired()) {
value = context.getString(R.string.flash_on);
} else {
value = context.getString(R.string.flash_off);
}
break;
}
case MediaDetails.INDEX_EXPOSURE_TIME: {
value = (String) detail.getValue();
double time = Double.valueOf(value);
if (time < 1.0f) {
value = String.format(mDefaultLocale, ""%d/%d"", 1,
(int) (0.5f + 1 / time));
} else {
int integer = (int) time;
time -= integer;
value = String.valueOf(integer) + ""''"";
if (time > 0.0001) {
value += String.format(mDefaultLocale, "" %d/%d"", 1,
(int) (0.5f + 1 / time));
}
}
break;
}
case MediaDetails.INDEX_WIDTH:
mWidthIndex = mItems.size();
if (detail.getValue().toString().equalsIgnoreCase(""0"")) {
value = context.getString(R.string.unknown);
resolutionIsValid = false;
} else {
value = toLocalInteger(detail.getValue());
}
break;
case MediaDetails.INDEX_HEIGHT: {
mHeightIndex = mItems.size();
if (detail.getValue().toString().equalsIgnoreCase(""0"")) {
value = context.getString(R.string.unknown);
resolutionIsValid = false;
} else {
value = toLocalInteger(detail.getValue());
}
break;
}
case MediaDetails.INDEX_PATH:
//comment
//comment
//comment
//comment
//comment
value = ""\n"" + detail.getValue().toString();
path = detail.getValue().toString();
break;
case MediaDetails.INDEX_ORIENTATION:
value = toLocalInteger(detail.getValue());
break;
case MediaDetails.INDEX_ISO:
value = toLocalNumber(Integer.parseInt((String) detail.getValue()));
break;
case MediaDetails.INDEX_FOCAL_LENGTH:
double focalLength = Double.parseDouble(detail.getValue().toString());
value = toLocalNumber(focalLength);
break;
default: {
Object valueObj = detail.getValue();
//comment
//comment
<start>if (valueObj == null) {
fail(""%s's value is Null"",
getDetailsName(context,
detail.getKey()));
}<end>
value = valueObj.toString();
}
}
int key = detail.getKey();
if (details.hasUnit(key)) {
value = String.format(""%s: %s %s"", getDetailsName(
context, key), value, context.getString(details.getUnit(key)));
} else {
value = String.format(""%s: %s"", getDetailsName(
context, key), value);
}
mItems.add(value);
}
if (!resolutionIsValid) {
resolveResolution(path);
}
}"
4896,"public void onResolutionAvailable(int width, int height) {
if (width == 0 || height == 0)
return;
//comment
<start>String widthString = String.format(mDefaultLocale, ""%s: %d"",
getDetailsName(
mContext, MediaDetails.INDEX_WIDTH), width);<end>
String heightString = String.format(mDefaultLocale, ""%s: %d"",
getDetailsName(
mContext, MediaDetails.INDEX_HEIGHT), height);
mItems.set(mWidthIndex, String.valueOf(widthString));
mItems.set(mHeightIndex, String.valueOf(heightString));
notifyDataSetChanged();
}","public void onResolutionAvailable(int width, int height) {
if (width == 0 || height == 0)
return;
//comment
<start>String widthString = String.format(mDefaultLocale, ""%s: %d"",
getDetailsName(
mContext, MediaDetails.INDEX_WIDTH), width);
String heightString = String.format(mDefaultLocale, ""%s: %d"",
getDetailsName(
mContext, MediaDetails.INDEX_HEIGHT), height);
mItems.set(mWidthIndex, String.valueOf(widthString));
mItems.set(mHeightIndex, String.valueOf(heightString));<end>
notifyDataSetChanged();
}"
4901,"public void initializeDrawables(Context context) {
int numDrawIds = DRAW_IDS.length;

if (!PhotoSphereHelper.hasLightCycleCapture(context)) {
--numDrawIds;
}

//comment
<start>--numDrawIds;<end>

int[] drawids = new int[numDrawIds];
int[] moduleids = new int[numDrawIds];
int ix = 0;
for (int i = 0; i < DRAW_IDS.length; i++) {
if (i == LIGHTCYCLE_MODULE_INDEX && !PhotoSphereHelper.hasLightCycleCapture(context)) {
continue;
}
if (i == GCAM_MODULE_INDEX) {
continue;
}
moduleids[ix] = i;
drawids[ix++] = DRAW_IDS[i];
}
setIds(moduleids, drawids);
}","public void initializeDrawables(Context context) {
int numDrawIds = DRAW_IDS.length;

if (!PhotoSphereHelper.hasLightCycleCapture(context)) {
--numDrawIds;
}

//comment
<start>--numDrawIds;<end>

int[] drawids = new int[numDrawIds];
int[] moduleids = new int[numDrawIds];
int ix = 0;
for (int i = 0; i < DRAW_IDS.length; i++) {
if (i == LIGHTCYCLE_MODULE_INDEX && !PhotoSphereHelper.hasLightCycleCapture(context)) {
continue;
}
if (i == GCAM_MODULE_INDEX) {
continue;
}
moduleids[ix] = i;
drawids[ix++] = DRAW_IDS[i];
}
setIds(moduleids, drawids);
}"
4902,"public void initializeDrawables(Context context) {
int numDrawIds = DRAW_IDS.length;

if (!PhotoSphereHelper.hasLightCycleCapture(context)) {
--numDrawIds;
}

//comment
--numDrawIds;

int[] drawids = new int[numDrawIds];
int[] moduleids = new int[numDrawIds];
int ix = 0;
for (int i = 0; i < DRAW_IDS.length; i++) {
if (i == LIGHTCYCLE_MODULE_INDEX && !PhotoSphereHelper.hasLightCycleCapture(context)) {
continue;
}
if (i == GCAM_MODULE_INDEX) {
continue;
}
moduleids[ix] = i;
drawids[ix++] = DRAW_IDS[i];
}
setIds(moduleids, drawids);
}","public void initializeDrawables(Context context) {
int numDrawIds = DRAW_IDS.length;

if (!PhotoSphereHelper.hasLightCycleCapture(context)) {
--numDrawIds;
}

//comment
--numDrawIds;

int[] drawids = new int[numDrawIds];
int[] moduleids = new int[numDrawIds];
int ix = 0;
for (int i = 0; i < DRAW_IDS.length; i++) {
<start>if (i == LIGHTCYCLE_MODULE_INDEX && !PhotoSphereHelper.hasLightCycleCapture(context)) {
continue;
}<end>
if (i == GCAM_MODULE_INDEX) {
continue;
}
moduleids[ix] = i;
drawids[ix++] = DRAW_IDS[i];
}
setIds(moduleids, drawids);
}"
4903,"public void initializeDrawables(Context context) {
int numDrawIds = DRAW_IDS.length;

if (!PhotoSphereHelper.hasLightCycleCapture(context)) {
--numDrawIds;
}

//comment
--numDrawIds;

int[] drawids = new int[numDrawIds];
int[] moduleids = new int[numDrawIds];
int ix = 0;
for (int i = 0; i < DRAW_IDS.length; i++) {
if (i == LIGHTCYCLE_MODULE_INDEX && !PhotoSphereHelper.hasLightCycleCapture(context)) {
continue;
}
if (i == GCAM_MODULE_INDEX) {
continue;
}
moduleids[ix] = i;
drawids[ix++] = DRAW_IDS[i];
}
setIds(moduleids, drawids);
}","public void initializeDrawables(Context context) {
int numDrawIds = DRAW_IDS.length;

if (!PhotoSphereHelper.hasLightCycleCapture(context)) {
--numDrawIds;
}

//comment
--numDrawIds;

int[] drawids = new int[numDrawIds];
int[] moduleids = new int[numDrawIds];
int ix = 0;
for (int i = 0; i < DRAW_IDS.length; i++) {
if (i == LIGHTCYCLE_MODULE_INDEX && !PhotoSphereHelper.hasLightCycleCapture(context)) {
continue;
}
<start>if (i == GCAM_MODULE_INDEX) {
continue;
}<end>
moduleids[ix] = i;
drawids[ix++] = DRAW_IDS[i];
}
setIds(moduleids, drawids);
}"
4904,"private void initPopup() {
mParent = LayoutInflater.from(getContext()).inflate(R.layout.switcher_popup,
(ViewGroup) getParent());
LinearLayout content = (LinearLayout) mParent.findViewById(R.id.content);
<start>mPopup = content;
//comment
//comment
//comment
LayoutParams lp = ((LayoutParams) mPopup.getLayoutParams());
lp.gravity = ((LayoutParams) mParent.findViewById(R.id.camera_switcher)
.getLayoutParams()).gravity;
mPopup.setLayoutParams(lp);<end>

mPopup.setVisibility(View.INVISIBLE);
mNeedsAnimationSetup = true;
for (int i = mDrawIds.length - 1; i >= 0; i--) {
RotateImageView item = new RotateImageView(getContext());
item.setImageResource(mDrawIds[i]);
item.setScaleType(ImageView.ScaleType.CENTER);
item.setBackgroundResource(R.drawable.bg_pressed);
final int index = i;
item.setOnClickListener(new OnClickListener() {
@Override
public void onClick(View v) {
if (showsPopup()) {
onModuleSelected(index);
}
}
});
switch (mDrawIds[i]) {
case R.drawable.ic_switch_camera:
item.setContentDescription(getContext().getResources().getString(
R.string.accessibility_switch_to_camera));
break;
case R.drawable.ic_switch_video:
item.setContentDescription(getContext().getResources().getString(
R.string.accessibility_switch_to_video));
break;
case R.drawable.ic_switch_pan:
item.setContentDescription(getContext().getResources().getString(
R.string.accessibility_switch_to_panorama));
break;
case R.drawable.ic_switch_photosphere:
item.setContentDescription(getContext().getResources().getString(
R.string.accessibility_switch_to_photo_sphere));
break;
case R.drawable.ic_switch_gcam:
item.setContentDescription(getContext().getResources().getString(
R.string.accessibility_switch_to_gcam));
break;
default:
break;
}
content.addView(item, new LinearLayout.LayoutParams(mItemSize, mItemSize));
}
mPopup.measure(MeasureSpec.makeMeasureSpec(mParent.getWidth(), MeasureSpec.AT_MOST),
MeasureSpec.makeMeasureSpec(mParent.getHeight(), MeasureSpec.AT_MOST));
}","private void initPopup() {
mParent = LayoutInflater.from(getContext()).inflate(R.layout.switcher_popup,
(ViewGroup) getParent());
LinearLayout content = (LinearLayout) mParent.findViewById(R.id.content);
mPopup = content;
//comment
//comment
//comment
<start>LayoutParams lp = ((LayoutParams) mPopup.getLayoutParams());
lp.gravity = ((LayoutParams) mParent.findViewById(R.id.camera_switcher)
.getLayoutParams()).gravity;
mPopup.setLayoutParams(lp);<end>

mPopup.setVisibility(View.INVISIBLE);
mNeedsAnimationSetup = true;
for (int i = mDrawIds.length - 1; i >= 0; i--) {
RotateImageView item = new RotateImageView(getContext());
item.setImageResource(mDrawIds[i]);
item.setScaleType(ImageView.ScaleType.CENTER);
item.setBackgroundResource(R.drawable.bg_pressed);
final int index = i;
item.setOnClickListener(new OnClickListener() {
@Override
public void onClick(View v) {
if (showsPopup()) {
onModuleSelected(index);
}
}
});
switch (mDrawIds[i]) {
case R.drawable.ic_switch_camera:
item.setContentDescription(getContext().getResources().getString(
R.string.accessibility_switch_to_camera));
break;
case R.drawable.ic_switch_video:
item.setContentDescription(getContext().getResources().getString(
R.string.accessibility_switch_to_video));
break;
case R.drawable.ic_switch_pan:
item.setContentDescription(getContext().getResources().getString(
R.string.accessibility_switch_to_panorama));
break;
case R.drawable.ic_switch_photosphere:
item.setContentDescription(getContext().getResources().getString(
R.string.accessibility_switch_to_photo_sphere));
break;
case R.drawable.ic_switch_gcam:
item.setContentDescription(getContext().getResources().getString(
R.string.accessibility_switch_to_gcam));
break;
default:
break;
}
content.addView(item, new LinearLayout.LayoutParams(mItemSize, mItemSize));
}
mPopup.measure(MeasureSpec.makeMeasureSpec(mParent.getWidth(), MeasureSpec.AT_MOST),
MeasureSpec.makeMeasureSpec(mParent.getHeight(), MeasureSpec.AT_MOST));
}"
4905,"private boolean animateHidePopup() {
if (mHideAnimationListener == null) {
mHideAnimationListener = new AnimatorListenerAdapter() {
@Override
public void onAnimationEnd(Animator animation) {
//comment
if (!showsPopup() && mPopup != null) {
mPopup.setVisibility(View.INVISIBLE);
((ViewGroup) mParent).removeView(mPopup);
mPopup = null;
}
}
};
}
mPopup.animate()
.alpha(0f)
.scaleX(0.3f).scaleY(0.3f)
.translationX(mTranslationX)
.translationY(mTranslationY)
.setDuration(SWITCHER_POPUP_ANIM_DURATION)
.setListener(mHideAnimationListener);
animate().alpha(1f).setDuration(SWITCHER_POPUP_ANIM_DURATION)
.setListener(null);
return true;
}","private boolean animateHidePopup() {
if (mHideAnimationListener == null) {
mHideAnimationListener = new AnimatorListenerAdapter() {
@Override
public void onAnimationEnd(Animator animation) {
//comment
<start>if (!showsPopup() && mPopup != null) {<end>
mPopup.setVisibility(View.INVISIBLE);
((ViewGroup) mParent).removeView(mPopup);
mPopup = null;
}
}
};
}
mPopup.animate()
.alpha(0f)
.scaleX(0.3f).scaleY(0.3f)
.translationX(mTranslationX)
.translationY(mTranslationY)
.setDuration(SWITCHER_POPUP_ANIM_DURATION)
.setListener(mHideAnimationListener);
animate().alpha(1f).setDuration(SWITCHER_POPUP_ANIM_DURATION)
.setListener(null);
return true;
}"
4906,"private boolean animateShowPopup() {
if (mNeedsAnimationSetup) {
popupAnimationSetup();
}
if (mShowAnimationListener == null) {
mShowAnimationListener = new AnimatorListenerAdapter() {
@Override
public void onAnimationEnd(Animator animation) {
//comment
if (showsPopup()) {
setVisibility(View.INVISIBLE);
//comment
//comment
mPopup.requestLayout();
}
}
};
}
mPopup.animate()
.alpha(1f)
.scaleX(1f).scaleY(1f)
.translationX(0)
.translationY(0)
.setDuration(SWITCHER_POPUP_ANIM_DURATION)
.setListener(null);
animate().alpha(0f).setDuration(SWITCHER_POPUP_ANIM_DURATION)
.setListener(mShowAnimationListener);
return true;
}","private boolean animateShowPopup() {
if (mNeedsAnimationSetup) {
popupAnimationSetup();
}
if (mShowAnimationListener == null) {
mShowAnimationListener = new AnimatorListenerAdapter() {
@Override
public void onAnimationEnd(Animator animation) {
//comment
<start>if (showsPopup()) {<end>
setVisibility(View.INVISIBLE);
//comment
//comment
mPopup.requestLayout();
}
}
};
}
mPopup.animate()
.alpha(1f)
.scaleX(1f).scaleY(1f)
.translationX(0)
.translationY(0)
.setDuration(SWITCHER_POPUP_ANIM_DURATION)
.setListener(null);
animate().alpha(0f).setDuration(SWITCHER_POPUP_ANIM_DURATION)
.setListener(mShowAnimationListener);
return true;
}"
4907,"private boolean animateShowPopup() {
if (mNeedsAnimationSetup) {
popupAnimationSetup();
}
if (mShowAnimationListener == null) {
mShowAnimationListener = new AnimatorListenerAdapter() {
@Override
public void onAnimationEnd(Animator animation) {
//comment
<start>if (showsPopup()) {
setVisibility(View.INVISIBLE);
//comment
//comment
mPopup.requestLayout();
}<end>
}
};
}
mPopup.animate()
.alpha(1f)
.scaleX(1f).scaleY(1f)
.translationX(0)
.translationY(0)
.setDuration(SWITCHER_POPUP_ANIM_DURATION)
.setListener(null);
animate().alpha(0f).setDuration(SWITCHER_POPUP_ANIM_DURATION)
.setListener(mShowAnimationListener);
return true;
}","private boolean animateShowPopup() {
if (mNeedsAnimationSetup) {
popupAnimationSetup();
}
if (mShowAnimationListener == null) {
mShowAnimationListener = new AnimatorListenerAdapter() {
@Override
public void onAnimationEnd(Animator animation) {
//comment
if (showsPopup()) {
setVisibility(View.INVISIBLE);
//comment
//comment
<start>mPopup.requestLayout();<end>
}
}
};
}
mPopup.animate()
.alpha(1f)
.scaleX(1f).scaleY(1f)
.translationX(0)
.translationY(0)
.setDuration(SWITCHER_POPUP_ANIM_DURATION)
.setListener(null);
animate().alpha(0f).setDuration(SWITCHER_POPUP_ANIM_DURATION)
.setListener(mShowAnimationListener);
return true;
}"
4908,"@Override
protected void onDraw(Canvas canvas) {
if (mOrientation == 0 || mOrientation == 180) {
rectF.left = canvas.getWidth() / 2 - mPreviewThumbWidth;
rectF.right = canvas.getWidth() / 2 + mPreviewThumbWidth;
rectF.top = canvas.getHeight() / 2 - mPreviewThumbHeight;
rectF.bottom = canvas.getHeight() / 2 + mPreviewThumbHeight;
} else {
rectF.left = canvas.getWidth() / 2 - mPreviewThumbHeight;
rectF.right = canvas.getWidth() / 2 + mPreviewThumbHeight;
rectF.top = canvas.getHeight() / 2 - mPreviewThumbWidth;
rectF.bottom = canvas.getHeight() / 2 + mPreviewThumbWidth;
}

if(mPanoStatus != PANO_STATUS.INACTIVE) {
canvas.rotate(-mOrientation, canvas.getWidth() / 2, canvas.getHeight() / 2);

if(!mProgressSentence.equals("""")) {
int textWidth = (int) mCompleteSentencePaint.measureText(mProgressSentence);
<start>canvas.drawText(mProgressSentence, rectF.centerX() - textWidth / 2, canvas.getHeight()*4/5, mCompleteSentencePaint);<end>
}

if(mPanoStatus == PANO_STATUS.COMPLETING) {
int textWidth = (int) mCompleteSentencePaint.measureText(mCompleteSentence);
canvas.drawText(mCompleteSentence, rectF.centerX() - textWidth / 2, rectF.centerY(), mCompleteSentencePaint);
} else {
//comment
<start>canvas.drawRect(rectF, mCenterRectPaint);<end>

//comment
if(mGuidePicture != null) {
canvas.save();
mGuidePicture.drawGuideInAir(canvas);
canvas.restore();
}

//comment
synchronized (mPreviewBitmapLock) {
if (mPreviewPicture != null) {
mPreviewPicture.drawMasterPanoPreview(canvas);
}
}
}
} else {
canvas.rotate(-mPendingOrientation, canvas.getWidth()/2, canvas.getHeight()/2);
int textWidth = (int) mCompleteSentencePaint.measureText(mIntroSentence);
canvas.drawText(mIntroSentence, rectF.centerX() - textWidth / 2, canvas.getHeight()*4/5, mCompleteSentencePaint);
}
}","@Override
protected void onDraw(Canvas canvas) {
if (mOrientation == 0 || mOrientation == 180) {
rectF.left = canvas.getWidth() / 2 - mPreviewThumbWidth;
rectF.right = canvas.getWidth() / 2 + mPreviewThumbWidth;
rectF.top = canvas.getHeight() / 2 - mPreviewThumbHeight;
rectF.bottom = canvas.getHeight() / 2 + mPreviewThumbHeight;
} else {
rectF.left = canvas.getWidth() / 2 - mPreviewThumbHeight;
rectF.right = canvas.getWidth() / 2 + mPreviewThumbHeight;
rectF.top = canvas.getHeight() / 2 - mPreviewThumbWidth;
rectF.bottom = canvas.getHeight() / 2 + mPreviewThumbWidth;
}

if(mPanoStatus != PANO_STATUS.INACTIVE) {
canvas.rotate(-mOrientation, canvas.getWidth() / 2, canvas.getHeight() / 2);

if(!mProgressSentence.equals("""")) {
int textWidth = (int) mCompleteSentencePaint.measureText(mProgressSentence);
canvas.drawText(mProgressSentence, rectF.centerX() - textWidth / 2, canvas.getHeight()*4/5, mCompleteSentencePaint);
}

if(mPanoStatus == PANO_STATUS.COMPLETING) {
int textWidth = (int) mCompleteSentencePaint.measureText(mCompleteSentence);
canvas.drawText(mCompleteSentence, rectF.centerX() - textWidth / 2, rectF.centerY(), mCompleteSentencePaint);
} else {
//comment
<start>canvas.drawRect(rectF, mCenterRectPaint);<end>

//comment
if(mGuidePicture != null) {
canvas.save();
mGuidePicture.drawGuideInAir(canvas);
canvas.restore();
}

//comment
synchronized (mPreviewBitmapLock) {
if (mPreviewPicture != null) {
mPreviewPicture.drawMasterPanoPreview(canvas);
}
}
}
} else {
canvas.rotate(-mPendingOrientation, canvas.getWidth()/2, canvas.getHeight()/2);
int textWidth = (int) mCompleteSentencePaint.measureText(mIntroSentence);
canvas.drawText(mIntroSentence, rectF.centerX() - textWidth / 2, canvas.getHeight()*4/5, mCompleteSentencePaint);
}
}"
4909,"@Override
protected void onDraw(Canvas canvas) {
if (mOrientation == 0 || mOrientation == 180) {
rectF.left = canvas.getWidth() / 2 - mPreviewThumbWidth;
rectF.right = canvas.getWidth() / 2 + mPreviewThumbWidth;
rectF.top = canvas.getHeight() / 2 - mPreviewThumbHeight;
rectF.bottom = canvas.getHeight() / 2 + mPreviewThumbHeight;
} else {
rectF.left = canvas.getWidth() / 2 - mPreviewThumbHeight;
rectF.right = canvas.getWidth() / 2 + mPreviewThumbHeight;
rectF.top = canvas.getHeight() / 2 - mPreviewThumbWidth;
rectF.bottom = canvas.getHeight() / 2 + mPreviewThumbWidth;
}

if(mPanoStatus != PANO_STATUS.INACTIVE) {
canvas.rotate(-mOrientation, canvas.getWidth() / 2, canvas.getHeight() / 2);

if(!mProgressSentence.equals("""")) {
int textWidth = (int) mCompleteSentencePaint.measureText(mProgressSentence);
canvas.drawText(mProgressSentence, rectF.centerX() - textWidth / 2, canvas.getHeight()*4/5, mCompleteSentencePaint);
}

if(mPanoStatus == PANO_STATUS.COMPLETING) {
int textWidth = (int) mCompleteSentencePaint.measureText(mCompleteSentence);
canvas.drawText(mCompleteSentence, rectF.centerX() - textWidth / 2, rectF.centerY(), mCompleteSentencePaint);
} else {
//comment
canvas.drawRect(rectF, mCenterRectPaint);

//comment
if(mGuidePicture != null) {
canvas.save();
mGuidePicture.drawGuideInAir(canvas);
canvas.restore();
}

//comment
synchronized (mPreviewBitmapLock) {
if (mPreviewPicture != null) {
mPreviewPicture.drawMasterPanoPreview(canvas);
}
}
}
} else {
canvas.rotate(-mPendingOrientation, canvas.getWidth()/2, canvas.getHeight()/2);
int textWidth = (int) mCompleteSentencePaint.measureText(mIntroSentence);
canvas.drawText(mIntroSentence, rectF.centerX() - textWidth / 2, canvas.getHeight()*4/5, mCompleteSentencePaint);
}
}","@Override
protected void onDraw(Canvas canvas) {
if (mOrientation == 0 || mOrientation == 180) {
rectF.left = canvas.getWidth() / 2 - mPreviewThumbWidth;
rectF.right = canvas.getWidth() / 2 + mPreviewThumbWidth;
rectF.top = canvas.getHeight() / 2 - mPreviewThumbHeight;
rectF.bottom = canvas.getHeight() / 2 + mPreviewThumbHeight;
} else {
rectF.left = canvas.getWidth() / 2 - mPreviewThumbHeight;
rectF.right = canvas.getWidth() / 2 + mPreviewThumbHeight;
rectF.top = canvas.getHeight() / 2 - mPreviewThumbWidth;
rectF.bottom = canvas.getHeight() / 2 + mPreviewThumbWidth;
}

if(mPanoStatus != PANO_STATUS.INACTIVE) {
canvas.rotate(-mOrientation, canvas.getWidth() / 2, canvas.getHeight() / 2);

if(!mProgressSentence.equals("""")) {
int textWidth = (int) mCompleteSentencePaint.measureText(mProgressSentence);
canvas.drawText(mProgressSentence, rectF.centerX() - textWidth / 2, canvas.getHeight()*4/5, mCompleteSentencePaint);
}

if(mPanoStatus == PANO_STATUS.COMPLETING) {
int textWidth = (int) mCompleteSentencePaint.measureText(mCompleteSentence);
canvas.drawText(mCompleteSentence, rectF.centerX() - textWidth / 2, rectF.centerY(), mCompleteSentencePaint);
} else {
//comment
canvas.drawRect(rectF, mCenterRectPaint);

//comment
<start>if(mGuidePicture != null) {
canvas.save();
mGuidePicture.drawGuideInAir(canvas);
canvas.restore();
}<end>

//comment
synchronized (mPreviewBitmapLock) {
if (mPreviewPicture != null) {
mPreviewPicture.drawMasterPanoPreview(canvas);
}
}
}
} else {
canvas.rotate(-mPendingOrientation, canvas.getWidth()/2, canvas.getHeight()/2);
int textWidth = (int) mCompleteSentencePaint.measureText(mIntroSentence);
canvas.drawText(mIntroSentence, rectF.centerX() - textWidth / 2, canvas.getHeight()*4/5, mCompleteSentencePaint);
}
}"
104,"private long launchVideo() {
long startupTime = 0;

try {
Intent intent = new Intent(MediaStore.INTENT_ACTION_VIDEO_CAMERA);
intent.setClass(getInstrumentation().getTargetContext(), CameraActivity.class);
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
long beforeStart = System.currentTimeMillis();
Instrumentation inst = getInstrumentation();
Activity recorderActivity = inst.startActivitySync(intent);
long cameraStarted = System.currentTimeMillis();
Thread.sleep(WAIT_TIME_FOR_PREVIEW);
recorderActivity.finish();
startupTime = cameraStarted - beforeStart;
Log.v(TAG, ""Video Startup Time = "" + startupTime);
//comment
<start>Thread.sleep(2 * 1000);
Log.v(TAG, ""video startup time: "" + startupTime);<end>
} catch (Exception e) {
<start>Log.v(TAG, ""Got exception"", e);<end>
fail(""Fails to launch video output file"");
}
return startupTime;
}","private long launchVideo() {
long startupTime = 0;

try {
Intent intent = new Intent(MediaStore.INTENT_ACTION_VIDEO_CAMERA);
intent.setClass(getInstrumentation().getTargetContext(), CameraActivity.class);
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
long beforeStart = System.currentTimeMillis();
Instrumentation inst = getInstrumentation();
Activity recorderActivity = inst.startActivitySync(intent);
long cameraStarted = System.currentTimeMillis();
Thread.sleep(WAIT_TIME_FOR_PREVIEW);
recorderActivity.finish();
startupTime = cameraStarted - beforeStart;
Log.v(TAG, ""Video Startup Time = "" + startupTime);
//comment
<start>Thread.sleep(2 * 1000);<end>
Log.v(TAG, ""video startup time: "" + startupTime);
} catch (Exception e) {
Log.v(TAG, ""Got exception"", e);
fail(""Fails to launch video output file"");
}
return startupTime;
}"
105,"public void testLaunchVideo() throws Exception {
String individualStartupTime;
individualStartupTime = ""Individual Video Startup Time = "";
long totalStartupTime = 0;
long startupTime = 0;
for (int i = 0; i < TOTAL_NUMBER_OF_STARTUP; i++) {
if (i == 0) {
//comment
<start>long firstStartUpTime = launchVideo();
writeToOutputFile(firstStartUpTime, ""na"", true, ""Video"");<end>
} else {
<start>startupTime = launchVideo();
totalStartupTime += startupTime;<end>
individualStartupTime += startupTime + "" ,"";
}
}
Log.v(TAG, ""totalStartupTime ="" + totalStartupTime);
writeToOutputFile(totalStartupTime, individualStartupTime, false, ""Video"");
}","public void testLaunchVideo() throws Exception {
String individualStartupTime;
individualStartupTime = ""Individual Video Startup Time = "";
long totalStartupTime = 0;
long startupTime = 0;
for (int i = 0; i < TOTAL_NUMBER_OF_STARTUP; i++) {
<start>if (i == 0) {
//comment
long firstStartUpTime = launchVideo();
writeToOutputFile(firstStartUpTime, ""na"", true, ""Video"");
} else {<end>
startupTime = launchVideo();
totalStartupTime += startupTime;
individualStartupTime += startupTime + "" ,"";
}
}
Log.v(TAG, ""totalStartupTime ="" + totalStartupTime);
writeToOutputFile(totalStartupTime, individualStartupTime, false, ""Video"");
}"
106,"public void testLaunchCamera() throws Exception {
String individualStartupTime;
individualStartupTime = ""Individual Camera Startup Time = "";
long totalStartupTime = 0;
long startupTime = 0;
for (int i = 0; i < TOTAL_NUMBER_OF_STARTUP; i++) {
if (i == 0) {
//comment
<start>long firstStartUpTime = launchCamera();
writeToOutputFile(firstStartUpTime, ""na"", true, ""Camera"");<end>
} else {
<start>startupTime = launchCamera();
totalStartupTime += startupTime;<end>
individualStartupTime += startupTime + "" ,"";
}
}
Log.v(TAG, ""totalStartupTime ="" + totalStartupTime);
writeToOutputFile(totalStartupTime,
individualStartupTime, false, ""Camera"");
}","public void testLaunchCamera() throws Exception {
String individualStartupTime;
individualStartupTime = ""Individual Camera Startup Time = "";
long totalStartupTime = 0;
long startupTime = 0;
for (int i = 0; i < TOTAL_NUMBER_OF_STARTUP; i++) {
<start>if (i == 0) {
//comment
long firstStartUpTime = launchCamera();
writeToOutputFile(firstStartUpTime, ""na"", true, ""Camera"");
} else {<end>
startupTime = launchCamera();
totalStartupTime += startupTime;
individualStartupTime += startupTime + "" ,"";
}
}
Log.v(TAG, ""totalStartupTime ="" + totalStartupTime);
writeToOutputFile(totalStartupTime,
individualStartupTime, false, ""Camera"");
}"
1141,"public void testBackImageCapture() throws Exception {
Instrumentation inst = getInstrumentation();
Intent intent = new Intent();

intent.setClass(getInstrumentation().getTargetContext(), CameraActivity.class);
intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
intent.putExtra(EXTRAS_CAMERA_FACING,
android.hardware.Camera.CameraInfo.CAMERA_FACING_BACK);
Activity act = inst.startActivitySync(intent);
Thread.sleep(WAIT_FOR_SWITCH_CAMERA);
captureImages(""Back Camera Image Capture\n"", inst);
act.finish();
//comment
<start>Thread.sleep(2 * 1000);<end>

}","public void testBackImageCapture() throws Exception {
Instrumentation inst = getInstrumentation();
Intent intent = new Intent();

intent.setClass(getInstrumentation().getTargetContext(), CameraActivity.class);
intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
intent.putExtra(EXTRAS_CAMERA_FACING,
android.hardware.Camera.CameraInfo.CAMERA_FACING_BACK);
Activity act = inst.startActivitySync(intent);
Thread.sleep(WAIT_FOR_SWITCH_CAMERA);
captureImages(""Back Camera Image Capture\n"", inst);
act.finish();
//comment
<start>Thread.sleep(2 * 1000);<end>

}"
1142,"public void testFrontImageCapture() throws Exception {
Instrumentation inst = getInstrumentation();
Intent intent = new Intent();

intent.setClass(getInstrumentation().getTargetContext(), CameraActivity.class);
intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
intent.putExtra(EXTRAS_CAMERA_FACING,
android.hardware.Camera.CameraInfo.CAMERA_FACING_FRONT);
Activity act = inst.startActivitySync(intent);
Thread.sleep(WAIT_FOR_SWITCH_CAMERA);
captureImages(""Front Camera Image Capture\n"", inst);
act.finish();
//comment
<start>Thread.sleep(2 * 1000);<end>
}","public void testFrontImageCapture() throws Exception {
Instrumentation inst = getInstrumentation();
Intent intent = new Intent();

intent.setClass(getInstrumentation().getTargetContext(), CameraActivity.class);
intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
intent.putExtra(EXTRAS_CAMERA_FACING,
android.hardware.Camera.CameraInfo.CAMERA_FACING_FRONT);
Activity act = inst.startActivitySync(intent);
Thread.sleep(WAIT_FOR_SWITCH_CAMERA);
captureImages(""Front Camera Image Capture\n"", inst);
act.finish();
//comment
<start>Thread.sleep(2 * 1000);<end>
}"
2784,"@Override
public void onCreate(Bundle state) {
super.onCreate(state);
mActivity = this;
Intent intent = getIntent();
String action = intent.getAction();
if (INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE.equals(action)
|| ACTION_IMAGE_CAPTURE_SECURE.equals(action)) {
mSecureCamera = true;
} else {
mSecureCamera = intent.getBooleanExtra(SECURE_CAMERA_EXTRA, false);
}

if (mSecureCamera) {
//comment
<start>Window win = getWindow();
WindowManager.LayoutParams params = win.getAttributes();
params.flags |= WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED;<end>
win.setAttributes(params);
}
mFilesPath = getFilesDir()+""/Bestpicture"";
setContentView(R.layout.bestpicture_editor);
Display display = getWindowManager().getDefaultDisplay();
Point size = new Point();
display.getSize(size);
mWidth = size.x/4;
mHeight = size.y/4;
mNamedImages = new PhotoModule.NamedImages();

mImageItems = new ImageItems(mActivity);
mDotsView = (DotsView) findViewById(R.id.dots_view);
mDotsView.setItems(mImageItems);
mPlaceHolderUri = getIntent().getData();

mImagePager = (ViewPager) findViewById(R.id.bestpicture_pager);
mImagePagerAdapter = new ImagePagerAdapter(getFragmentManager());
mImagePager.setAdapter(mImagePagerAdapter);
mImagePager.setOnPageChangeListener(new ViewPager.SimpleOnPageChangeListener() {
@Override
public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
mDotsView.update(position, positionOffset);
}

@Override
public void onPageSelected(int position) {
}
});
findViewById(R.id.bestpicture_done).setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(final View v) {
int choosenCount = 0;
for (int i = 0; i < mImageItems.mChosen.length; i++) {
if (mImageItems.mChosen[i]) {
choosenCount++;
}
}
boolean showSaveDialog = CameraUtil.loadDialogShowConfig(BestpictureActivity
.this,CameraUtil.KEY_SAVE);
if (showSaveDialog) {
//comment
initSaveDialog(CameraUtil.MODE_TWO_BT, choosenCount);
mDialog.show();
setDialogLayoutPararms();
} else {
saveImages(choosenCount, false);
}
}
});
findViewById(R.id.delete_best).setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(final View v) {
boolean showDeleteDialog = CameraUtil.loadDialogShowConfig(BestpictureActivity.this
,CameraUtil.KEY_DELETE);
if (showDeleteDialog) {
initDeleteDialog(CameraUtil.MODE_TWO_BT);
mDialog.show();
setDialogLayoutPararms();
} else {
backToViewfinder();
}
}
});
RotateImageView moreView = (RotateImageView) findViewById(R.id.best_more);
Bitmap mMoreBp = BitmapFactory.decodeResource(getResources(), R.drawable.more_options);
mMoreBp = CameraUtil.adjustPhotoRotation(mMoreBp, 90);
moreView.setImageBitmap(mMoreBp);
moreView.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(final View v) {
initOverFlow(v);
}
});
}","@Override
public void onCreate(Bundle state) {
super.onCreate(state);
mActivity = this;
Intent intent = getIntent();
String action = intent.getAction();
if (INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE.equals(action)
|| ACTION_IMAGE_CAPTURE_SECURE.equals(action)) {
mSecureCamera = true;
} else {
mSecureCamera = intent.getBooleanExtra(SECURE_CAMERA_EXTRA, false);
}

if (mSecureCamera) {
//comment
<start>Window win = getWindow();
WindowManager.LayoutParams params = win.getAttributes();
params.flags |= WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED;
win.setAttributes(params);<end>
}
mFilesPath = getFilesDir()+""/Bestpicture"";
setContentView(R.layout.bestpicture_editor);
Display display = getWindowManager().getDefaultDisplay();
Point size = new Point();
display.getSize(size);
mWidth = size.x/4;
mHeight = size.y/4;
mNamedImages = new PhotoModule.NamedImages();

mImageItems = new ImageItems(mActivity);
mDotsView = (DotsView) findViewById(R.id.dots_view);
mDotsView.setItems(mImageItems);
mPlaceHolderUri = getIntent().getData();

mImagePager = (ViewPager) findViewById(R.id.bestpicture_pager);
mImagePagerAdapter = new ImagePagerAdapter(getFragmentManager());
mImagePager.setAdapter(mImagePagerAdapter);
mImagePager.setOnPageChangeListener(new ViewPager.SimpleOnPageChangeListener() {
@Override
public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
mDotsView.update(position, positionOffset);
}

@Override
public void onPageSelected(int position) {
}
});
findViewById(R.id.bestpicture_done).setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(final View v) {
int choosenCount = 0;
for (int i = 0; i < mImageItems.mChosen.length; i++) {
if (mImageItems.mChosen[i]) {
choosenCount++;
}
}
boolean showSaveDialog = CameraUtil.loadDialogShowConfig(BestpictureActivity
.this,CameraUtil.KEY_SAVE);
if (showSaveDialog) {
//comment
initSaveDialog(CameraUtil.MODE_TWO_BT, choosenCount);
mDialog.show();
setDialogLayoutPararms();
} else {
saveImages(choosenCount, false);
}
}
});
findViewById(R.id.delete_best).setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(final View v) {
boolean showDeleteDialog = CameraUtil.loadDialogShowConfig(BestpictureActivity.this
,CameraUtil.KEY_DELETE);
if (showDeleteDialog) {
initDeleteDialog(CameraUtil.MODE_TWO_BT);
mDialog.show();
setDialogLayoutPararms();
} else {
backToViewfinder();
}
}
});
RotateImageView moreView = (RotateImageView) findViewById(R.id.best_more);
Bitmap mMoreBp = BitmapFactory.decodeResource(getResources(), R.drawable.more_options);
mMoreBp = CameraUtil.adjustPhotoRotation(mMoreBp, 90);
moreView.setImageBitmap(mMoreBp);
moreView.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(final View v) {
initOverFlow(v);
}
});
}"
2785,"private void setDialogLayoutPararms() {
//comment
<start>int width = CameraUtil.dip2px(BestpictureActivity.this, 320);
int height = CameraUtil.dip2px(BestpictureActivity.this, 250);
mDialog.getWindow().setLayout(width, height);<end>
}","private void setDialogLayoutPararms() {
//comment
<start>int width = CameraUtil.dip2px(BestpictureActivity.this, 320);
int height = CameraUtil.dip2px(BestpictureActivity.this, 250);
mDialog.getWindow().setLayout(width, height);<end>
}"
1335,"@Override
public void onReceive(Context context, Intent intent) {
//comment
<start>boolean needCameraActivity = CHECK_BACK_CAMERA_ONLY
? hasBackCamera()
: hasCamera();<end>

if (!needCameraActivity) {
Log.i(TAG, ""disable all camera activities"");
for (int i = 0; i < ACTIVITIES.length; i++) {
disableComponent(context, ACTIVITIES[i]);
}
}

//comment
disableComponent(context, ""com.android.camera.DisableCameraReceiver"");
}","@Override
public void onReceive(Context context, Intent intent) {
//comment
<start>boolean needCameraActivity = CHECK_BACK_CAMERA_ONLY
? hasBackCamera()
: hasCamera();<end>

<start>if (!needCameraActivity) {
Log.i(TAG, ""disable all camera activities"");
for (int i = 0; i < ACTIVITIES.length; i++) {
disableComponent(context, ACTIVITIES[i]);
}
}<end>

//comment
disableComponent(context, ""com.android.camera.DisableCameraReceiver"");
}"
1336,"@Override
public void onReceive(Context context, Intent intent) {
//comment
boolean needCameraActivity = CHECK_BACK_CAMERA_ONLY
? hasBackCamera()
: hasCamera();

if (!needCameraActivity) {
Log.i(TAG, ""disable all camera activities"");
for (int i = 0; i < ACTIVITIES.length; i++) {
disableComponent(context, ACTIVITIES[i]);
}
}

//comment
<start>disableComponent(context, ""com.android.camera.DisableCameraReceiver"");<end>
}","@Override
public void onReceive(Context context, Intent intent) {
//comment
boolean needCameraActivity = CHECK_BACK_CAMERA_ONLY
? hasBackCamera()
: hasCamera();

if (!needCameraActivity) {
Log.i(TAG, ""disable all camera activities"");
for (int i = 0; i < ACTIVITIES.length; i++) {
disableComponent(context, ACTIVITIES[i]);
}
}

//comment
<start>disableComponent(context, ""com.android.camera.DisableCameraReceiver"");<end>
}"
1263,"public void addImage(final byte[] data, String title, long date, Location loc,
int orientation, ExifInterface exif,
OnMediaSavedListener l, ContentResolver resolver) {
//comment
//comment
addImage(data, title, date, loc, 0, 0, orientation, exif, l, resolver,
PhotoModule.PIXEL_FORMAT_JPEG);
}","public void addImage(final byte[] data, String title, long date, Location loc,
int orientation, ExifInterface exif,
OnMediaSavedListener l, ContentResolver resolver) {
//comment
//comment
<start>addImage(data, title, date, loc, 0, 0, orientation, exif, l, resolver,
PhotoModule.PIXEL_FORMAT_JPEG);<end>
}"
1264,"        @Override
protected Uri doInBackground(Void... v) {
//comment
MpoData mpo = new MpoData();
MpoImageData bayer = new MpoImageData(bayerImage,
ByteOrder.BIG_ENDIAN);

MpoImageData mono = new MpoImageData(monoImage,
ByteOrder.BIG_ENDIAN);

if (csImage == null) {
mpo.addAuxiliaryMpoImage(mono);
mpo.setPrimaryMpoImage(bayer);
} else {
MpoImageData cs = new MpoImageData(csImage,
ByteOrder.BIG_ENDIAN);

mpo.addAuxiliaryMpoImage(bayer);
mpo.addAuxiliaryMpoImage(mono);
mpo.setPrimaryMpoImage(cs);
}

//comment
String path = Storage.generateFilepath(title, pictureFormat);
int size = MpoInterface.writeMpo(mpo, path);
//comment
File f = new File(path);
if (f.exists() && f.isFile()) {
size = (int) f.length();
}
return Storage.addImage(resolver, title, date, loc, orientation,
size, path, width, height, pictureFormat);
}","        @Override
protected Uri doInBackground(Void... v) {
//comment
<start>MpoData mpo = new MpoData();
MpoImageData bayer = new MpoImageData(bayerImage,
ByteOrder.BIG_ENDIAN);

MpoImageData mono = new MpoImageData(monoImage,
ByteOrder.BIG_ENDIAN);

if (csImage == null) {
mpo.addAuxiliaryMpoImage(mono);
mpo.setPrimaryMpoImage(bayer);
} else {
MpoImageData cs = new MpoImageData(csImage,
ByteOrder.BIG_ENDIAN);

mpo.addAuxiliaryMpoImage(bayer);
mpo.addAuxiliaryMpoImage(mono);
mpo.setPrimaryMpoImage(cs);
}<end>

//comment
String path = Storage.generateFilepath(title, pictureFormat);
int size = MpoInterface.writeMpo(mpo, path);
//comment
File f = new File(path);
if (f.exists() && f.isFile()) {
size = (int) f.length();
}
return Storage.addImage(resolver, title, date, loc, orientation,
size, path, width, height, pictureFormat);
}"
1265,"        @Override
protected Uri doInBackground(Void... v) {
//comment
MpoData mpo = new MpoData();
MpoImageData bayer = new MpoImageData(bayerImage,
ByteOrder.BIG_ENDIAN);

MpoImageData mono = new MpoImageData(monoImage,
ByteOrder.BIG_ENDIAN);

if (csImage == null) {
mpo.addAuxiliaryMpoImage(mono);
mpo.setPrimaryMpoImage(bayer);
} else {
MpoImageData cs = new MpoImageData(csImage,
ByteOrder.BIG_ENDIAN);

mpo.addAuxiliaryMpoImage(bayer);
mpo.addAuxiliaryMpoImage(mono);
mpo.setPrimaryMpoImage(cs);
}

//comment
<start>String path = Storage.generateFilepath(title, pictureFormat);<end>
int size = MpoInterface.writeMpo(mpo, path);
//comment
File f = new File(path);
if (f.exists() && f.isFile()) {
size = (int) f.length();
}
return Storage.addImage(resolver, title, date, loc, orientation,
size, path, width, height, pictureFormat);
}","        @Override
protected Uri doInBackground(Void... v) {
//comment
MpoData mpo = new MpoData();
MpoImageData bayer = new MpoImageData(bayerImage,
ByteOrder.BIG_ENDIAN);

MpoImageData mono = new MpoImageData(monoImage,
ByteOrder.BIG_ENDIAN);

if (csImage == null) {
mpo.addAuxiliaryMpoImage(mono);
mpo.setPrimaryMpoImage(bayer);
} else {
MpoImageData cs = new MpoImageData(csImage,
ByteOrder.BIG_ENDIAN);

mpo.addAuxiliaryMpoImage(bayer);
mpo.addAuxiliaryMpoImage(mono);
mpo.setPrimaryMpoImage(cs);
}

//comment
<start>String path = Storage.generateFilepath(title, pictureFormat);
int size = MpoInterface.writeMpo(mpo, path);<end>
//comment
File f = new File(path);
if (f.exists() && f.isFile()) {
size = (int) f.length();
}
return Storage.addImage(resolver, title, date, loc, orientation,
size, path, width, height, pictureFormat);
}"
1266,"        @Override
protected Uri doInBackground(Void... v) {
//comment
MpoData mpo = new MpoData();
MpoImageData bayer = new MpoImageData(bayerImage,
ByteOrder.BIG_ENDIAN);

MpoImageData mono = new MpoImageData(monoImage,
ByteOrder.BIG_ENDIAN);

if (csImage == null) {
mpo.addAuxiliaryMpoImage(mono);
mpo.setPrimaryMpoImage(bayer);
} else {
MpoImageData cs = new MpoImageData(csImage,
ByteOrder.BIG_ENDIAN);

mpo.addAuxiliaryMpoImage(bayer);
mpo.addAuxiliaryMpoImage(mono);
mpo.setPrimaryMpoImage(cs);
}

//comment
String path = Storage.generateFilepath(title, pictureFormat);
<start>int size = MpoInterface.writeMpo(mpo, path);
//comment
File f = new File(path);<end>
if (f.exists() && f.isFile()) {
size = (int) f.length();
}
return Storage.addImage(resolver, title, date, loc, orientation,
size, path, width, height, pictureFormat);
}","        @Override
protected Uri doInBackground(Void... v) {
//comment
MpoData mpo = new MpoData();
MpoImageData bayer = new MpoImageData(bayerImage,
ByteOrder.BIG_ENDIAN);

MpoImageData mono = new MpoImageData(monoImage,
ByteOrder.BIG_ENDIAN);

if (csImage == null) {
mpo.addAuxiliaryMpoImage(mono);
mpo.setPrimaryMpoImage(bayer);
} else {
MpoImageData cs = new MpoImageData(csImage,
ByteOrder.BIG_ENDIAN);

mpo.addAuxiliaryMpoImage(bayer);
mpo.addAuxiliaryMpoImage(mono);
mpo.setPrimaryMpoImage(cs);
}

//comment
String path = Storage.generateFilepath(title, pictureFormat);
int size = MpoInterface.writeMpo(mpo, path);
//comment
<start>File f = new File(path);
if (f.exists() && f.isFile()) {
size = (int) f.length();
}<end>
return Storage.addImage(resolver, title, date, loc, orientation,
size, path, width, height, pictureFormat);
}"
1267,"        @Override
protected Uri doInBackground(Void... v) {
values.put(Video.Media.SIZE, new File(path).length());
values.put(Video.Media.DURATION, duration);
Uri uri = null;
try {
<start>Uri videoTable = Uri.parse(VIDEO_BASE_URI);<end>
uri = resolver.insert(videoTable, values);

//comment
//comment
//comment
<start>String finalName = values.getAsString(
Video.Media.DATA);<end>
if (new File(path).renameTo(new File(finalName))) {
path = finalName;
}

resolver.update(uri, values, null, null);
} catch (Exception e) {
//comment
//comment
Log.e(TAG, ""failed to add video to media store"", e);
uri = null;
} finally {
Log.v(TAG, ""Current video URI: "" + uri);
}
return uri;
}","        @Override
protected Uri doInBackground(Void... v) {
values.put(Video.Media.SIZE, new File(path).length());
values.put(Video.Media.DURATION, duration);
Uri uri = null;
try {
Uri videoTable = Uri.parse(VIDEO_BASE_URI);
uri = resolver.insert(videoTable, values);

//comment
//comment
//comment
<start>String finalName = values.getAsString(
Video.Media.DATA);
if (new File(path).renameTo(new File(finalName))) {
path = finalName;
}

resolver.update(uri, values, null, null);<end>
} catch (Exception e) {
//comment
//comment
Log.e(TAG, ""failed to add video to media store"", e);
uri = null;
} finally {
Log.v(TAG, ""Current video URI: "" + uri);
}
return uri;
}"
492,"    public static DatabaseDialect findBestFor(
final String jdbcUrl,
final JdbcConfig config
) throws ConnectException {
final JdbcUrlInfo info = extractJdbcUrlInfo(jdbcUrl);
LOG.debug(""Finding best dialect for {}"", info);
int bestScore = DatabaseDialectProvider.NO_MATCH_SCORE;

//comment
<start>DatabaseDialectProvider bestMatch = null;<end>
for (final DatabaseDialectProvider provider : REGISTRY.values()) {
<start>final int score = provider.score(info);<end>
LOG.debug(""Dialect {} scored {} against {}"", provider, score, info);
<start>if (score > bestScore) {
bestMatch = provider;
bestScore = score;
}<end>
}
LOG.debug(""Using dialect {} with score {} against {}"", bestMatch, bestScore, info);
return bestMatch.create(config);
}","    public static DatabaseDialect findBestFor(
final String jdbcUrl,
final JdbcConfig config
) throws ConnectException {
final JdbcUrlInfo info = extractJdbcUrlInfo(jdbcUrl);
LOG.debug(""Finding best dialect for {}"", info);
int bestScore = DatabaseDialectProvider.NO_MATCH_SCORE;

//comment
<start>DatabaseDialectProvider bestMatch = null;
for (final DatabaseDialectProvider provider : REGISTRY.values()) {
final int score = provider.score(info);
LOG.debug(""Dialect {} scored {} against {}"", provider, score, info);
if (score > bestScore) {
bestMatch = provider;
bestScore = score;
}
}<end>
LOG.debug(""Using dialect {} with score {} against {}"", bestMatch, bestScore, info);
return bestMatch.create(config);
}"
5723,"@Override
public void setup(){
String dataDir = OS.env(""MINDUSTRY_DATA_DIR"");
if(dataDir != null){
Core.settings.setDataDirectory(files.absolute(dataDir));
}

checkLaunch();
loadLogger();

loader = new LoadRenderer();
Events.fire(new ClientCreateEvent());

loadFileLogger();
platform = this;
maxTextureSize = Gl.getInt(Gl.maxTextureSize);
beginTime = Time.millis();

//comment
Log.info(""[GL] Version: @"", graphics.getGLVersion());
Log.info(""[GL] Max texture size: @"", maxTextureSize);
Log.info(""[GL] Using @ context."", gl30 != null ? ""OpenGL 3"" : ""OpenGL 2"");
if(maxTextureSize < 4096) Log.warn(""[GL] Your maximum texture size is below the recommended minimum of 4096. This will cause severe performance issues."");
Log.info(""[JAVA] Version: @"", OS.javaVersion);
long ram = Runtime.getRuntime().maxMemory();
boolean gb = ram >= 1024 * 1024 * 1024;
Log.info(""[RAM] Available: @ @"", Strings.fixed(gb ? ram / 1024f / 1024 / 1024f : ram / 1024f / 1024f, 1), gb ? ""GB"" : ""MB"");

Time.setDeltaProvider(() -> {
float result = Core.graphics.getDeltaTime() * 60f;
return (Float.isNaN(result) || Float.isInfinite(result)) ? 1f : Mathf.clamp(result, 0.0001f, 60f / 10f);
});

batch = new SortedSpriteBatch();
assets = new AssetManager();
assets.setLoader(Texture.class, ""."" + mapExtension, new MapPreviewLoader());

tree = new FileTree();
assets.setLoader(Sound.class, new SoundLoader(tree));
assets.setLoader(Music.class, new MusicLoader(tree));

assets.load(""sprites/error.png"", Texture.class);
atlas = TextureAtlas.blankAtlas();
Vars.net = new Net(platform.getNet());
mods = new Mods();
schematics = new Schematics();

Fonts.loadSystemCursors();

assets.load(new Vars());

Fonts.loadDefaultFont();

//comment
<start>assets.load(new AssetDescriptor<>(maxTextureSize >= 4096 ? ""sprites/sprites.aatls"" : ""sprites/fallback/sprites.aatls"", TextureAtlas.class)).loaded = t -> atlas = t;<end>
assets.loadRun(""maps"", Map.class, () -> maps.loadPreviews());

Musics.load();
Sounds.load();

assets.loadRun(""contentcreate"", Content.class, () -> {
content.createBaseContent();
content.loadColors();
}, () -> {
mods.loadScripts();
content.createModContent();
});

assets.load(mods);
assets.loadRun(""mergeUI"", PixmapPacker.class, () -> {}, () -> Fonts.mergeFontAtlas(atlas));

add(logic = new Logic());
add(control = new Control());
add(renderer = new Renderer());
add(ui = new UI());
add(netServer = new NetServer());
add(netClient = new NetClient());

assets.load(schematics);

assets.loadRun(""contentinit"", ContentLoader.class, () -> content.init(), () -> content.load());
assets.loadRun(""baseparts"", BaseRegistry.class, () -> {}, () -> bases.load());
}","@Override
public void setup(){
String dataDir = OS.env(""MINDUSTRY_DATA_DIR"");
if(dataDir != null){
Core.settings.setDataDirectory(files.absolute(dataDir));
}

checkLaunch();
loadLogger();

loader = new LoadRenderer();
Events.fire(new ClientCreateEvent());

loadFileLogger();
platform = this;
maxTextureSize = Gl.getInt(Gl.maxTextureSize);
beginTime = Time.millis();

//comment
Log.info(""[GL] Version: @"", graphics.getGLVersion());
Log.info(""[GL] Max texture size: @"", maxTextureSize);
Log.info(""[GL] Using @ context."", gl30 != null ? ""OpenGL 3"" : ""OpenGL 2"");
if(maxTextureSize < 4096) Log.warn(""[GL] Your maximum texture size is below the recommended minimum of 4096. This will cause severe performance issues."");
Log.info(""[JAVA] Version: @"", OS.javaVersion);
long ram = Runtime.getRuntime().maxMemory();
boolean gb = ram >= 1024 * 1024 * 1024;
Log.info(""[RAM] Available: @ @"", Strings.fixed(gb ? ram / 1024f / 1024 / 1024f : ram / 1024f / 1024f, 1), gb ? ""GB"" : ""MB"");

Time.setDeltaProvider(() -> {
float result = Core.graphics.getDeltaTime() * 60f;
return (Float.isNaN(result) || Float.isInfinite(result)) ? 1f : Mathf.clamp(result, 0.0001f, 60f / 10f);
});

batch = new SortedSpriteBatch();
assets = new AssetManager();
assets.setLoader(Texture.class, ""."" + mapExtension, new MapPreviewLoader());

tree = new FileTree();
assets.setLoader(Sound.class, new SoundLoader(tree));
assets.setLoader(Music.class, new MusicLoader(tree));

assets.load(""sprites/error.png"", Texture.class);
atlas = TextureAtlas.blankAtlas();
Vars.net = new Net(platform.getNet());
mods = new Mods();
schematics = new Schematics();

Fonts.loadSystemCursors();

assets.load(new Vars());

Fonts.loadDefaultFont();

//comment
<start>assets.load(new AssetDescriptor<>(maxTextureSize >= 4096 ? ""sprites/sprites.aatls"" : ""sprites/fallback/sprites.aatls"", TextureAtlas.class)).loaded = t -> atlas = t;
assets.loadRun(""maps"", Map.class, () -> maps.loadPreviews());<end>

Musics.load();
Sounds.load();

assets.loadRun(""contentcreate"", Content.class, () -> {
content.createBaseContent();
content.loadColors();
}, () -> {
mods.loadScripts();
content.createModContent();
});

assets.load(mods);
assets.loadRun(""mergeUI"", PixmapPacker.class, () -> {}, () -> Fonts.mergeFontAtlas(atlas));

add(logic = new Logic());
add(control = new Control());
add(renderer = new Renderer());
add(ui = new UI());
add(netServer = new NetServer());
add(netClient = new NetClient());

assets.load(schematics);

assets.loadRun(""contentinit"", ContentLoader.class, () -> content.init(), () -> content.load());
assets.loadRun(""baseparts"", BaseRegistry.class, () -> {}, () -> bases.load());
}"
1748,"<start>public void setupRequirements(ItemStack[] requirements){
this.requirements = requirements;<end>
this.finishedRequirements = new ItemStack[requirements.length];

//comment
<start>for(int i = 0; i < requirements.length; i++){
finishedRequirements[i] = new ItemStack(requirements[i].item, Core.settings == null ? 0 : Core.settings.getInt(""req-"" + content.name + ""-"" + requirements[i].item.name));
}<end>
}","public void setupRequirements(ItemStack[] requirements){
this.requirements = requirements;
this.finishedRequirements = new ItemStack[requirements.length];

//comment
<start>for(int i = 0; i < requirements.length; i++){
finishedRequirements[i] = new ItemStack(requirements[i].item, Core.settings == null ? 0 : Core.settings.getInt(""req-"" + content.name + ""-"" + requirements[i].item.name));
}<end>
}"
1749,"<start>        public void save(){<end>

//comment
<start>for(ItemStack stack : finishedRequirements){
Core.settings.put(""req-"" + content.name + ""-"" + stack.item.name, stack.amount);
}<end>
}","        public void save(){

//comment
<start>for(ItemStack stack : finishedRequirements){
Core.settings.put(""req-"" + content.name + ""-"" + stack.item.name, stack.amount);
}<end>
}"
1290,"    public void removeByID(int id){
if(map == null) throw new RuntimeException(""Mapping is not enabled for group "" + id + ""!"");
T t = map.get(id);
if(t != null){
<start>t.remove();<end>
}
}","    public void removeByID(int id){
if(map == null) throw new RuntimeException(""Mapping is not enabled for group "" + id + ""!"");
<start>T t = map.get(id);
if(t != null){
t.remove();
}<end>
}"
1291,"    public void intersect(float x, float y, float width, float height, Cons<? super T> out){
//comment
if(isEmpty()) return;
tree.intersect(x, y, width, height, out);
}","    public void intersect(float x, float y, float width, float height, Cons<? super T> out){
//comment
<start>if(isEmpty()) return;<end>
tree.intersect(x, y, width, height, out);
}"
1292,"    public Seq<T> intersect(float x, float y, float width, float height){
intersectArray.clear();
//comment
<start>if(isEmpty()) return intersectArray;
tree.intersect(intersectRect.set(x, y, width, height), intersectArray);<end>
return intersectArray;
}","    public Seq<T> intersect(float x, float y, float width, float height){
<start>intersectArray.clear();
//comment
if(isEmpty()) return intersectArray;<end>
tree.intersect(intersectRect.set(x, y, width, height), intersectArray);
return intersectArray;
}"
5690,"    public void registerCore(CoreBuild core){
<start>TeamData data = get(core.team);
//comment
if(!data.cores.contains(core)){
data.cores.add(core);
}<end>

//comment
if(data.active() && !active.contains(data)){
active.add(data);
updateEnemies();
}
}","    public void registerCore(CoreBuild core){
TeamData data = get(core.team);
//comment
<start>if(!data.cores.contains(core)){
data.cores.add(core);
}<end>

//comment
if(data.active() && !active.contains(data)){
active.add(data);
updateEnemies();
}
}"
5691,"<start>    public boolean isActive(Team team){
//comment
return get(team).active();<end>
}","    public boolean isActive(Team team){
//comment
<start>return get(team).active();<end>
}"
5692,"    public void registerCore(CoreBuild core){
TeamData data = get(core.team);
//comment
if(!data.cores.contains(core)){
data.cores.add(core);
}

//comment
<start>if(data.active() && !active.contains(data)){
active.add(data);
updateEnemies();
}<end>
}","    public void registerCore(CoreBuild core){
TeamData data = get(core.team);
//comment
if(!data.cores.contains(core)){
data.cores.add(core);
}

//comment
<start>if(data.active() && !active.contains(data)){
active.add(data);
updateEnemies();
}<end>
}"
5693,"public void updateTeamStats(){
present.clear();
bosses.clear();

for(Team team : Team.all){
TeamData data = team.data();

data.presentFlag = false;
data.unitCount = 0;
data.units.clear();
if(data.tree != null){
data.tree.clear();
}

if(data.typeCounts != null){
Arrays.fill(data.typeCounts, 0);
}

//comment
if(data.unitsByType != null){
for(int i = 0; i < data.unitsByType.length; i++){
if(data.unitsByType[i] != null){
data.unitsByType[i].clear();
}
}
}
}

//comment
Groups.build.each(b -> b.team.data().presentFlag = true);

for(Unit unit : Groups.unit){
if(unit.type == null) continue;
TeamData data = unit.team.data();
data.tree().insert(unit);
data.units.add(unit);
data.presentFlag = true;

if(unit.team == state.rules.waveTeam && unit.isBoss()){
bosses.add(unit);
}

if(data.unitsByType == null || data.unitsByType.length <= unit.type.id){
data.unitsByType = new Seq[content.units().size];
}

if(data.unitsByType[unit.type.id] == null){
data.unitsByType[unit.type.id] = new Seq<>();
}

data.unitsByType[unit.type.id].add(unit);

count(unit);
}

//comment
for(Team team : Team.all){
TeamData data = team.data();

if(data.presentFlag || data.active()){
present.add(data);
}
}
}","public void updateTeamStats(){
present.clear();
bosses.clear();

for(Team team : Team.all){
TeamData data = team.data();

data.presentFlag = false;
data.unitCount = 0;
data.units.clear();
if(data.tree != null){
data.tree.clear();
}

if(data.typeCounts != null){
Arrays.fill(data.typeCounts, 0);
}

//comment
<start>if(data.unitsByType != null){
for(int i = 0; i < data.unitsByType.length; i++){
if(data.unitsByType[i] != null){
data.unitsByType[i].clear();
}
}
}<end>
}

//comment
Groups.build.each(b -> b.team.data().presentFlag = true);

for(Unit unit : Groups.unit){
if(unit.type == null) continue;
TeamData data = unit.team.data();
data.tree().insert(unit);
data.units.add(unit);
data.presentFlag = true;

if(unit.team == state.rules.waveTeam && unit.isBoss()){
bosses.add(unit);
}

if(data.unitsByType == null || data.unitsByType.length <= unit.type.id){
data.unitsByType = new Seq[content.units().size];
}

if(data.unitsByType[unit.type.id] == null){
data.unitsByType[unit.type.id] = new Seq<>();
}

data.unitsByType[unit.type.id].add(unit);

count(unit);
}

//comment
for(Team team : Team.all){
TeamData data = team.data();

if(data.presentFlag || data.active()){
present.add(data);
}
}
}"
5694,"public void updateTeamStats(){
present.clear();
bosses.clear();

for(Team team : Team.all){
TeamData data = team.data();

data.presentFlag = false;
data.unitCount = 0;
data.units.clear();
if(data.tree != null){
data.tree.clear();
}

if(data.typeCounts != null){
Arrays.fill(data.typeCounts, 0);
}

//comment
if(data.unitsByType != null){
for(int i = 0; i < data.unitsByType.length; i++){
if(data.unitsByType[i] != null){
data.unitsByType[i].clear();
}
}
}
}

//comment
<start>Groups.build.each(b -> b.team.data().presentFlag = true);<end>

for(Unit unit : Groups.unit){
if(unit.type == null) continue;
TeamData data = unit.team.data();
data.tree().insert(unit);
data.units.add(unit);
data.presentFlag = true;

if(unit.team == state.rules.waveTeam && unit.isBoss()){
bosses.add(unit);
}

if(data.unitsByType == null || data.unitsByType.length <= unit.type.id){
data.unitsByType = new Seq[content.units().size];
}

if(data.unitsByType[unit.type.id] == null){
data.unitsByType[unit.type.id] = new Seq<>();
}

data.unitsByType[unit.type.id].add(unit);

count(unit);
}

//comment
for(Team team : Team.all){
TeamData data = team.data();

if(data.presentFlag || data.active()){
present.add(data);
}
}
}","public void updateTeamStats(){
present.clear();
bosses.clear();

for(Team team : Team.all){
TeamData data = team.data();

data.presentFlag = false;
data.unitCount = 0;
data.units.clear();
if(data.tree != null){
data.tree.clear();
}

if(data.typeCounts != null){
Arrays.fill(data.typeCounts, 0);
}

//comment
if(data.unitsByType != null){
for(int i = 0; i < data.unitsByType.length; i++){
if(data.unitsByType[i] != null){
data.unitsByType[i].clear();
}
}
}
}

//comment
<start>Groups.build.each(b -> b.team.data().presentFlag = true);<end>

for(Unit unit : Groups.unit){
if(unit.type == null) continue;
TeamData data = unit.team.data();
data.tree().insert(unit);
data.units.add(unit);
data.presentFlag = true;

if(unit.team == state.rules.waveTeam && unit.isBoss()){
bosses.add(unit);
}

if(data.unitsByType == null || data.unitsByType.length <= unit.type.id){
data.unitsByType = new Seq[content.units().size];
}

if(data.unitsByType[unit.type.id] == null){
data.unitsByType[unit.type.id] = new Seq<>();
}

data.unitsByType[unit.type.id].add(unit);

count(unit);
}

//comment
for(Team team : Team.all){
TeamData data = team.data();

if(data.presentFlag || data.active()){
present.add(data);
}
}
}"
5695,"public void updateTeamStats(){
present.clear();
bosses.clear();

for(Team team : Team.all){
TeamData data = team.data();

data.presentFlag = false;
data.unitCount = 0;
data.units.clear();
if(data.tree != null){
data.tree.clear();
}

if(data.typeCounts != null){
Arrays.fill(data.typeCounts, 0);
}

//comment
if(data.unitsByType != null){
for(int i = 0; i < data.unitsByType.length; i++){
if(data.unitsByType[i] != null){
data.unitsByType[i].clear();
}
}
}
}

//comment
Groups.build.each(b -> b.team.data().presentFlag = true);

for(Unit unit : Groups.unit){
if(unit.type == null) continue;
TeamData data = unit.team.data();
data.tree().insert(unit);
data.units.add(unit);
data.presentFlag = true;

if(unit.team == state.rules.waveTeam && unit.isBoss()){
bosses.add(unit);
}

if(data.unitsByType == null || data.unitsByType.length <= unit.type.id){
data.unitsByType = new Seq[content.units().size];
}

if(data.unitsByType[unit.type.id] == null){
data.unitsByType[unit.type.id] = new Seq<>();
}

data.unitsByType[unit.type.id].add(unit);

count(unit);
}

//comment
for(Team team : Team.all){
TeamData data = team.data();

if(data.presentFlag || data.active()){
present.add(data);
}
}
}","public void updateTeamStats(){
present.clear();
bosses.clear();

for(Team team : Team.all){
TeamData data = team.data();

data.presentFlag = false;
data.unitCount = 0;
data.units.clear();
if(data.tree != null){
data.tree.clear();
}

if(data.typeCounts != null){
Arrays.fill(data.typeCounts, 0);
}

//comment
if(data.unitsByType != null){
for(int i = 0; i < data.unitsByType.length; i++){
if(data.unitsByType[i] != null){
data.unitsByType[i].clear();
}
}
}
}

//comment
Groups.build.each(b -> b.team.data().presentFlag = true);

for(Unit unit : Groups.unit){
if(unit.type == null) continue;
TeamData data = unit.team.data();
data.tree().insert(unit);
data.units.add(unit);
data.presentFlag = true;

if(unit.team == state.rules.waveTeam && unit.isBoss()){
bosses.add(unit);
}

if(data.unitsByType == null || data.unitsByType.length <= unit.type.id){
data.unitsByType = new Seq[content.units().size];
}

if(data.unitsByType[unit.type.id] == null){
data.unitsByType[unit.type.id] = new Seq<>();
}

data.unitsByType[unit.type.id].add(unit);

count(unit);
}

//comment
<start>for(Team team : Team.all){
TeamData data = team.data();

if(data.presentFlag || data.active()){
present.add(data);
}
}<end>
}"
2912,"@Override
public void layout(){
invalidated = true;
float cy = 0;
seq.clear();

float totalHeight = getChildren().sumf(e -> e.getHeight() + space);

height = prefHeight = totalHeight;
width = prefWidth = Scl.scl(targetWidth);

//comment
for(int i = 0; i < getChildren().size; i++){
Element e = getChildren().get(i);

//comment
<start>if(dragging == e) continue;<end>

e.setSize(width, e.getPrefHeight());
e.setPosition(0, height - cy, Align.topLeft);
((StatementElem)e).updateAddress(i);

cy += e.getPrefHeight() + space;
seq.add(e);
}

//comment
if(dragging != null){
//comment
float realY = dragging.getY(Align.top) + dragging.translation.y;

insertPosition = 0;

for(int i = 0; i < seq.size; i++){
Element cur = seq.get(i);
//comment
if(realY < cur.y && (i == seq.size - 1 || realY > seq.get(i + 1).y)){
insertPosition = i + 1;
break;
}
}

float shiftAmount = dragging.getHeight() + space;

//comment
for(int i = insertPosition; i < seq.size; i++){
seq.get(i).y -= shiftAmount;
}
}

invalidateHierarchy();

if(parent != null && parent instanceof Table){
setCullingArea(parent.getCullingArea());
}
}","@Override
public void layout(){
invalidated = true;
float cy = 0;
seq.clear();

float totalHeight = getChildren().sumf(e -> e.getHeight() + space);

height = prefHeight = totalHeight;
width = prefWidth = Scl.scl(targetWidth);

//comment
for(int i = 0; i < getChildren().size; i++){
Element e = getChildren().get(i);

//comment
<start>if(dragging == e) continue;<end>

e.setSize(width, e.getPrefHeight());
e.setPosition(0, height - cy, Align.topLeft);
((StatementElem)e).updateAddress(i);

cy += e.getPrefHeight() + space;
seq.add(e);
}

//comment
if(dragging != null){
//comment
float realY = dragging.getY(Align.top) + dragging.translation.y;

insertPosition = 0;

for(int i = 0; i < seq.size; i++){
Element cur = seq.get(i);
//comment
if(realY < cur.y && (i == seq.size - 1 || realY > seq.get(i + 1).y)){
insertPosition = i + 1;
break;
}
}

float shiftAmount = dragging.getHeight() + space;

//comment
for(int i = insertPosition; i < seq.size; i++){
seq.get(i).y -= shiftAmount;
}
}

invalidateHierarchy();

if(parent != null && parent instanceof Table){
setCullingArea(parent.getCullingArea());
}
}"
2913,"@Override
public void layout(){
invalidated = true;
float cy = 0;
seq.clear();

float totalHeight = getChildren().sumf(e -> e.getHeight() + space);

height = prefHeight = totalHeight;
width = prefWidth = Scl.scl(targetWidth);

//comment
for(int i = 0; i < getChildren().size; i++){
Element e = getChildren().get(i);

//comment
if(dragging == e) continue;

e.setSize(width, e.getPrefHeight());
e.setPosition(0, height - cy, Align.topLeft);
((StatementElem)e).updateAddress(i);

cy += e.getPrefHeight() + space;
seq.add(e);
}

//comment
if(dragging != null){
//comment
float realY = dragging.getY(Align.top) + dragging.translation.y;

insertPosition = 0;

for(int i = 0; i < seq.size; i++){
Element cur = seq.get(i);
//comment
if(realY < cur.y && (i == seq.size - 1 || realY > seq.get(i + 1).y)){
insertPosition = i + 1;
break;
}
}

float shiftAmount = dragging.getHeight() + space;

//comment
for(int i = insertPosition; i < seq.size; i++){
seq.get(i).y -= shiftAmount;
}
}

invalidateHierarchy();

if(parent != null && parent instanceof Table){
setCullingArea(parent.getCullingArea());
}
}","@Override
public void layout(){
invalidated = true;
float cy = 0;
seq.clear();

float totalHeight = getChildren().sumf(e -> e.getHeight() + space);

height = prefHeight = totalHeight;
width = prefWidth = Scl.scl(targetWidth);

//comment
for(int i = 0; i < getChildren().size; i++){
Element e = getChildren().get(i);

//comment
if(dragging == e) continue;

e.setSize(width, e.getPrefHeight());
e.setPosition(0, height - cy, Align.topLeft);
((StatementElem)e).updateAddress(i);

cy += e.getPrefHeight() + space;
seq.add(e);
}

//comment
<start>if(dragging != null){
//comment
float realY = dragging.getY(Align.top) + dragging.translation.y;

insertPosition = 0;

for(int i = 0; i < seq.size; i++){
Element cur = seq.get(i);
//comment
if(realY < cur.y && (i == seq.size - 1 || realY > seq.get(i + 1).y)){
insertPosition = i + 1;
break;
}
}

float shiftAmount = dragging.getHeight() + space;

//comment
for(int i = insertPosition; i < seq.size; i++){
seq.get(i).y -= shiftAmount;
}
}<end>

invalidateHierarchy();

if(parent != null && parent instanceof Table){
setCullingArea(parent.getCullingArea());
}
}"
2914,"@Override
public void layout(){
invalidated = true;
float cy = 0;
seq.clear();

float totalHeight = getChildren().sumf(e -> e.getHeight() + space);

height = prefHeight = totalHeight;
width = prefWidth = Scl.scl(targetWidth);

//comment
for(int i = 0; i < getChildren().size; i++){
Element e = getChildren().get(i);

//comment
if(dragging == e) continue;

e.setSize(width, e.getPrefHeight());
e.setPosition(0, height - cy, Align.topLeft);
((StatementElem)e).updateAddress(i);

cy += e.getPrefHeight() + space;
seq.add(e);
}

//comment
if(dragging != null){
//comment
<start>float realY = dragging.getY(Align.top) + dragging.translation.y;<end>

insertPosition = 0;

for(int i = 0; i < seq.size; i++){
Element cur = seq.get(i);
//comment
if(realY < cur.y && (i == seq.size - 1 || realY > seq.get(i + 1).y)){
insertPosition = i + 1;
break;
}
}

float shiftAmount = dragging.getHeight() + space;

//comment
for(int i = insertPosition; i < seq.size; i++){
seq.get(i).y -= shiftAmount;
}
}

invalidateHierarchy();

if(parent != null && parent instanceof Table){
setCullingArea(parent.getCullingArea());
}
}","@Override
public void layout(){
invalidated = true;
float cy = 0;
seq.clear();

float totalHeight = getChildren().sumf(e -> e.getHeight() + space);

height = prefHeight = totalHeight;
width = prefWidth = Scl.scl(targetWidth);

//comment
for(int i = 0; i < getChildren().size; i++){
Element e = getChildren().get(i);

//comment
if(dragging == e) continue;

e.setSize(width, e.getPrefHeight());
e.setPosition(0, height - cy, Align.topLeft);
((StatementElem)e).updateAddress(i);

cy += e.getPrefHeight() + space;
seq.add(e);
}

//comment
if(dragging != null){
//comment
<start>float realY = dragging.getY(Align.top) + dragging.translation.y;<end>

insertPosition = 0;

for(int i = 0; i < seq.size; i++){
Element cur = seq.get(i);
//comment
if(realY < cur.y && (i == seq.size - 1 || realY > seq.get(i + 1).y)){
insertPosition = i + 1;
break;
}
}

float shiftAmount = dragging.getHeight() + space;

//comment
for(int i = insertPosition; i < seq.size; i++){
seq.get(i).y -= shiftAmount;
}
}

invalidateHierarchy();

if(parent != null && parent instanceof Table){
setCullingArea(parent.getCullingArea());
}
}"
2915,"@Override
public void layout(){
invalidated = true;
float cy = 0;
seq.clear();

float totalHeight = getChildren().sumf(e -> e.getHeight() + space);

height = prefHeight = totalHeight;
width = prefWidth = Scl.scl(targetWidth);

//comment
for(int i = 0; i < getChildren().size; i++){
Element e = getChildren().get(i);

//comment
if(dragging == e) continue;

e.setSize(width, e.getPrefHeight());
e.setPosition(0, height - cy, Align.topLeft);
((StatementElem)e).updateAddress(i);

cy += e.getPrefHeight() + space;
seq.add(e);
}

//comment
if(dragging != null){
//comment
float realY = dragging.getY(Align.top) + dragging.translation.y;

insertPosition = 0;

for(int i = 0; i < seq.size; i++){
<start>Element cur = seq.get(i);<end>
//comment
if(realY < cur.y && (i == seq.size - 1 || realY > seq.get(i + 1).y)){
insertPosition = i + 1;
<start>break;<end>
}
}

float shiftAmount = dragging.getHeight() + space;

//comment
for(int i = insertPosition; i < seq.size; i++){
seq.get(i).y -= shiftAmount;
}
}

invalidateHierarchy();

if(parent != null && parent instanceof Table){
setCullingArea(parent.getCullingArea());
}
}","@Override
public void layout(){
invalidated = true;
float cy = 0;
seq.clear();

float totalHeight = getChildren().sumf(e -> e.getHeight() + space);

height = prefHeight = totalHeight;
width = prefWidth = Scl.scl(targetWidth);

//comment
for(int i = 0; i < getChildren().size; i++){
Element e = getChildren().get(i);

//comment
if(dragging == e) continue;

e.setSize(width, e.getPrefHeight());
e.setPosition(0, height - cy, Align.topLeft);
((StatementElem)e).updateAddress(i);

cy += e.getPrefHeight() + space;
seq.add(e);
}

//comment
if(dragging != null){
//comment
float realY = dragging.getY(Align.top) + dragging.translation.y;

insertPosition = 0;

for(int i = 0; i < seq.size; i++){
Element cur = seq.get(i);
//comment
<start>if(realY < cur.y && (i == seq.size - 1 || realY > seq.get(i + 1).y)){
insertPosition = i + 1;
break;
}<end>
}

float shiftAmount = dragging.getHeight() + space;

//comment
for(int i = insertPosition; i < seq.size; i++){
seq.get(i).y -= shiftAmount;
}
}

invalidateHierarchy();

if(parent != null && parent instanceof Table){
setCullingArea(parent.getCullingArea());
}
}"
2916,"@Override
public void layout(){
invalidated = true;
float cy = 0;
seq.clear();

float totalHeight = getChildren().sumf(e -> e.getHeight() + space);

height = prefHeight = totalHeight;
width = prefWidth = Scl.scl(targetWidth);

//comment
for(int i = 0; i < getChildren().size; i++){
Element e = getChildren().get(i);

//comment
if(dragging == e) continue;

e.setSize(width, e.getPrefHeight());
e.setPosition(0, height - cy, Align.topLeft);
((StatementElem)e).updateAddress(i);

cy += e.getPrefHeight() + space;
seq.add(e);
}

//comment
if(dragging != null){
//comment
float realY = dragging.getY(Align.top) + dragging.translation.y;

insertPosition = 0;

for(int i = 0; i < seq.size; i++){
Element cur = seq.get(i);
//comment
if(realY < cur.y && (i == seq.size - 1 || realY > seq.get(i + 1).y)){
insertPosition = i + 1;
break;
}
}

float shiftAmount = dragging.getHeight() + space;

//comment
<start>for(int i = insertPosition; i < seq.size; i++){
seq.get(i).y -= shiftAmount;
}<end>
}

invalidateHierarchy();

if(parent != null && parent instanceof Table){
setCullingArea(parent.getCullingArea());
}
}","@Override
public void layout(){
invalidated = true;
float cy = 0;
seq.clear();

float totalHeight = getChildren().sumf(e -> e.getHeight() + space);

height = prefHeight = totalHeight;
width = prefWidth = Scl.scl(targetWidth);

//comment
for(int i = 0; i < getChildren().size; i++){
Element e = getChildren().get(i);

//comment
if(dragging == e) continue;

e.setSize(width, e.getPrefHeight());
e.setPosition(0, height - cy, Align.topLeft);
((StatementElem)e).updateAddress(i);

cy += e.getPrefHeight() + space;
seq.add(e);
}

//comment
if(dragging != null){
//comment
float realY = dragging.getY(Align.top) + dragging.translation.y;

insertPosition = 0;

for(int i = 0; i < seq.size; i++){
Element cur = seq.get(i);
//comment
if(realY < cur.y && (i == seq.size - 1 || realY > seq.get(i + 1).y)){
insertPosition = i + 1;
break;
}
}

float shiftAmount = dragging.getHeight() + space;

//comment
<start>for(int i = insertPosition; i < seq.size; i++){
seq.get(i).y -= shiftAmount;
}<end>
}

invalidateHierarchy();

if(parent != null && parent instanceof Table){
setCullingArea(parent.getCullingArea());
}
}"
2917,"@Override
public void draw(){
Draw.alpha(parentAlpha);

//comment
if(dragging != null && insertPosition <= seq.size){
<start>float shiftAmount = dragging.getHeight();<end>
float lastX = x;
float lastY = insertPosition == 0 ? height + y : seq.get(insertPosition - 1).y + y - space;

Tex.pane.draw(lastX, lastY - shiftAmount, width, dragging.getHeight());
}

if(invalidated){
children.each(c -> c.cullable = false);
}

super.draw();

if(invalidated){
children.each(c -> c.cullable = true);
invalidated = false;
}
}","@Override
public void draw(){
Draw.alpha(parentAlpha);

//comment
<start>if(dragging != null && insertPosition <= seq.size){
float shiftAmount = dragging.getHeight();
float lastX = x;
float lastY = insertPosition == 0 ? height + y : seq.get(insertPosition - 1).y + y - space;

Tex.pane.draw(lastX, lastY - shiftAmount, width, dragging.getHeight());
}<end>

if(invalidated){
children.each(c -> c.cullable = false);
}

super.draw();

if(invalidated){
children.each(c -> c.cullable = true);
invalidated = false;
}
}"
5724,"@Override
public Color getColor(Vec3 position){
Block block = getBlock(position);
//comment
if(block == Blocks.salt) return Blocks.sand.mapColor;
return Tmp.c1.set(block.mapColor).a(1f - block.albedo);
}","@Override
public Color getColor(Vec3 position){
Block block = getBlock(position);
//comment
<start>if(block == Blocks.salt) return Blocks.sand.mapColor;<end>
return Tmp.c1.set(block.mapColor).a(1f - block.albedo);
}"
5731,"public LoadedMod importMod(Fi file) throws IOException{
//comment
String baseName = file.nameWithoutExtension().replace(':', '_').replace(' ', '_');
String finalName = baseName;
//comment
int count = 1;
while(modDirectory.child(finalName + "".zip"").exists()){
finalName = baseName + """" + count++;
}

Fi dest = modDirectory.child(finalName + "".zip"");

file.copyTo(dest);
try{
var loaded = loadMod(dest, true);
mods.add(loaded);
requiresReload = true;
//comment
<start>Core.settings.put(""mod-"" + loaded.name + ""-enabled"", true);<end>
sortMods();
//comment
Core.app.post(() -> loadIcon(loaded));
return loaded;
}catch(IOException e){
dest.delete();
throw e;
}catch(Throwable t){
dest.delete();
throw new IOException(t);
}
}","public LoadedMod importMod(Fi file) throws IOException{
//comment
String baseName = file.nameWithoutExtension().replace(':', '_').replace(' ', '_');
String finalName = baseName;
//comment
int count = 1;
while(modDirectory.child(finalName + "".zip"").exists()){
finalName = baseName + """" + count++;
}

Fi dest = modDirectory.child(finalName + "".zip"");

file.copyTo(dest);
try{
var loaded = loadMod(dest, true);
mods.add(loaded);
requiresReload = true;
//comment
<start>Core.settings.put(""mod-"" + loaded.name + ""-enabled"", true);<end>
sortMods();
//comment
Core.app.post(() -> loadIcon(loaded));
return loaded;
}catch(IOException e){
dest.delete();
throw e;
}catch(Throwable t){
dest.delete();
throw new IOException(t);
}
}"
5732,"public LoadedMod importMod(Fi file) throws IOException{
//comment
String baseName = file.nameWithoutExtension().replace(':', '_').replace(' ', '_');
String finalName = baseName;
//comment
int count = 1;
while(modDirectory.child(finalName + "".zip"").exists()){
finalName = baseName + """" + count++;
}

Fi dest = modDirectory.child(finalName + "".zip"");

file.copyTo(dest);
try{
var loaded = loadMod(dest, true);
mods.add(loaded);
requiresReload = true;
//comment
Core.settings.put(""mod-"" + loaded.name + ""-enabled"", true);
sortMods();
//comment
<start>Core.app.post(() -> loadIcon(loaded));<end>
return loaded;
}catch(IOException e){
<start>dest.delete();<end>
throw e;
}catch(Throwable t){
dest.delete();
throw new IOException(t);
}
}","public LoadedMod importMod(Fi file) throws IOException{
//comment
String baseName = file.nameWithoutExtension().replace(':', '_').replace(' ', '_');
String finalName = baseName;
//comment
int count = 1;
while(modDirectory.child(finalName + "".zip"").exists()){
finalName = baseName + """" + count++;
}

Fi dest = modDirectory.child(finalName + "".zip"");

file.copyTo(dest);
try{
var loaded = loadMod(dest, true);
mods.add(loaded);
requiresReload = true;
//comment
Core.settings.put(""mod-"" + loaded.name + ""-enabled"", true);
sortMods();
//comment
<start>Core.app.post(() -> loadIcon(loaded));<end>
return loaded;
}catch(IOException e){
dest.delete();
throw e;
}catch(Throwable t){
dest.delete();
throw new IOException(t);
}
}"
5733,"<start>    @Override
public void loadAsync(){<end>
if(!mods.contains(LoadedMod::enabled)) return;
Time.mark();

packer = new MultiPacker();
//comment
var tasks = new Seq<AsyncResult<Runnable>>();

eachEnabled(mod -> {
Seq<Fi> sprites = mod.root.child(""sprites"").findAll(f -> f.extension().equals(""png""));
Seq<Fi> overrides = mod.root.child(""sprites-override"").findAll(f -> f.extension().equals(""png""));

packSprites(sprites, mod, true, tasks);
packSprites(overrides, mod, false, tasks);

Log.debug(""Packed @ images for mod '@'."", sprites.size + overrides.size, mod.meta.name);
totalSprites += sprites.size + overrides.size;
});

for(var result : tasks){
try{
var packRun = result.get();
if(packRun != null){
try{
//comment
<start>packRun.run();<end>
}catch(Exception e){
<start>Log.err(""Failed to fit image into the spritesheet, skipping."");<end>
Log.err(e);
}
}
}catch(Exception e){
Log.err(e);
}
}

Log.debug(""Time to pack textures: @"", Time.elapsed());
}","    @Override
public void loadAsync(){
if(!mods.contains(LoadedMod::enabled)) return;
Time.mark();

packer = new MultiPacker();
//comment
var tasks = new Seq<AsyncResult<Runnable>>();

eachEnabled(mod -> {
Seq<Fi> sprites = mod.root.child(""sprites"").findAll(f -> f.extension().equals(""png""));
Seq<Fi> overrides = mod.root.child(""sprites-override"").findAll(f -> f.extension().equals(""png""));

packSprites(sprites, mod, true, tasks);
packSprites(overrides, mod, false, tasks);

Log.debug(""Packed @ images for mod '@'."", sprites.size + overrides.size, mod.meta.name);
totalSprites += sprites.size + overrides.size;
});

for(var result : tasks){
try{
var packRun = result.get();
if(packRun != null){
try{
//comment
<start>packRun.run();<end>
}catch(Exception e){
Log.err(""Failed to fit image into the spritesheet, skipping."");
Log.err(e);
}
}
}catch(Exception e){
Log.err(e);
}
}

Log.debug(""Time to pack textures: @"", Time.elapsed());
}"
5734,"<start>    private void loadIcon(LoadedMod mod){<end>
//comment
if(mod.root.child(""icon.png"").exists() && !headless){
<start>try{
mod.iconTexture = new Texture(mod.root.child(""icon.png""));
mod.iconTexture.setFilter(TextureFilter.linear);
}catch(Throwable t){
Log.err(""Failed to load icon for mod '"" + mod.name + ""'."", t);
}<end>
}
}","    private void loadIcon(LoadedMod mod){
//comment
<start>if(mod.root.child(""icon.png"").exists() && !headless){
try{
mod.iconTexture = new Texture(mod.root.child(""icon.png""));
mod.iconTexture.setFilter(TextureFilter.linear);
}catch(Throwable t){
Log.err(""Failed to load icon for mod '"" + mod.name + ""'."", t);
}
}<end>
}"
5735,"private void packSprites(Seq<Fi> sprites, LoadedMod mod, boolean prefix, Seq<AsyncResult<Runnable>> tasks){
boolean linear = Core.settings.getBool(""linear"", true);

for(Fi file : sprites){
//comment
<start>tasks.add(async.submit(() -> {<end>
try{
Pixmap pix = new Pixmap(file.readBytes());
//comment
if(linear){
Pixmaps.bleed(pix, 2);
}
//comment
return () -> {
packer.add(getPage(file), (prefix ? mod.name + ""-"" : """") + file.nameWithoutExtension(), new PixmapRegion(pix));
pix.dispose();
};
}catch(Exception e){
//comment
throw new Exception(""Failed to load image "" + file + "" for mod "" + mod.name, e);
}
}));
}
}","private void packSprites(Seq<Fi> sprites, LoadedMod mod, boolean prefix, Seq<AsyncResult<Runnable>> tasks){
boolean linear = Core.settings.getBool(""linear"", true);

for(Fi file : sprites){
//comment
<start>tasks.add(async.submit(() -> {
try{
Pixmap pix = new Pixmap(file.readBytes());
//comment
if(linear){
Pixmaps.bleed(pix, 2);
}
//comment
return () -> {
packer.add(getPage(file), (prefix ? mod.name + ""-"" : """") + file.nameWithoutExtension(), new PixmapRegion(pix));
pix.dispose();
};
}catch(Exception e){
//comment
throw new Exception(""Failed to load image "" + file + "" for mod "" + mod.name, e);
}
}));<end>
}
}"
5736,"private void packSprites(Seq<Fi> sprites, LoadedMod mod, boolean prefix, Seq<AsyncResult<Runnable>> tasks){
boolean linear = Core.settings.getBool(""linear"", true);

for(Fi file : sprites){
//comment
tasks.add(async.submit(() -> {
try{
Pixmap pix = new Pixmap(file.readBytes());
//comment
<start>if(linear){
Pixmaps.bleed(pix, 2);
}<end>
//comment
return () -> {
packer.add(getPage(file), (prefix ? mod.name + ""-"" : """") + file.nameWithoutExtension(), new PixmapRegion(pix));
pix.dispose();
};
}catch(Exception e){
//comment
throw new Exception(""Failed to load image "" + file + "" for mod "" + mod.name, e);
}
}));
}
}","private void packSprites(Seq<Fi> sprites, LoadedMod mod, boolean prefix, Seq<AsyncResult<Runnable>> tasks){
boolean linear = Core.settings.getBool(""linear"", true);

for(Fi file : sprites){
//comment
tasks.add(async.submit(() -> {
try{
Pixmap pix = new Pixmap(file.readBytes());
//comment
<start>if(linear){
Pixmaps.bleed(pix, 2);
}<end>
//comment
return () -> {
packer.add(getPage(file), (prefix ? mod.name + ""-"" : """") + file.nameWithoutExtension(), new PixmapRegion(pix));
pix.dispose();
};
}catch(Exception e){
//comment
throw new Exception(""Failed to load image "" + file + "" for mod "" + mod.name, e);
}
}));
}
}"
5737,"private void packSprites(Seq<Fi> sprites, LoadedMod mod, boolean prefix, Seq<AsyncResult<Runnable>> tasks){
boolean linear = Core.settings.getBool(""linear"", true);

for(Fi file : sprites){
//comment
tasks.add(async.submit(() -> {
try{
Pixmap pix = new Pixmap(file.readBytes());
//comment
if(linear){
Pixmaps.bleed(pix, 2);
}
//comment
return () -> {
packer.add(getPage(file), (prefix ? mod.name + ""-"" : """") + file.nameWithoutExtension(), new PixmapRegion(pix));
pix.dispose();
};
<start>}catch(Exception e){
//comment
throw new Exception(""Failed to load image "" + file + "" for mod "" + mod.name, e);<end>
}
}));
}
}","private void packSprites(Seq<Fi> sprites, LoadedMod mod, boolean prefix, Seq<AsyncResult<Runnable>> tasks){
boolean linear = Core.settings.getBool(""linear"", true);

for(Fi file : sprites){
//comment
tasks.add(async.submit(() -> {
try{
Pixmap pix = new Pixmap(file.readBytes());
//comment
if(linear){
Pixmaps.bleed(pix, 2);
}
//comment
return () -> {
packer.add(getPage(file), (prefix ? mod.name + ""-"" : """") + file.nameWithoutExtension(), new PixmapRegion(pix));
pix.dispose();
};
}catch(Exception e){
//comment
<start>throw new Exception(""Failed to load image "" + file + "" for mod "" + mod.name, e);<end>
}
}));
}
}"
5740,"<start>    private void sortMods(){<end>
//comment
mods.sort(Structs.comps(Structs.comparingInt(m -> m.state.ordinal()), Structs.comparing(m -> m.name)));
}","    private void sortMods(){
//comment
<start>mods.sort(Structs.comps(Structs.comparingInt(m -> m.state.ordinal()), Structs.comparing(m -> m.name)));<end>
}"
5741,"private void buildFiles(){
for(LoadedMod mod : orderedMods()){
boolean zipFolder = !mod.file.isDirectory() && mod.root.parent() != null;
String parentName = zipFolder ? mod.root.name() : null;
for(Fi file : mod.root.list()){
//comment
if(file.isDirectory() && !specialFolders.contains(file.name())){
file.walk(f -> tree.addFile(mod.file.isDirectory() ? f.path().substring(1 + mod.file.path().length()) :
zipFolder ? f.path().substring(parentName.length() + 1) : f.path(), f));
}
}

//comment
Fi folder = mod.root.child(""bundles"");
if(folder.exists()){
for(Fi file : folder.list()){
if(file.name().startsWith(""bundle"") && file.extension().equals(""properties"")){
String name = file.nameWithoutExtension();
bundles.get(name, Seq::new).add(file);
}
}
}
}
Events.fire(new FileTreeInitEvent());

//comment
I18NBundle bundle = Core.bundle;
while(bundle != null){
String str = bundle.getLocale().toString();
String locale = ""bundle"" + (str.isEmpty() ? """" : ""_"" + str);
for(Fi file : bundles.get(locale, Seq::new)){
try{
PropertiesUtils.load(bundle.getProperties(), file.reader());
}catch(Throwable e){
Log.err(""Error loading bundle: "" + file + ""/"" + locale, e);
}
}
bundle = bundle.getParent();
}
}","private void buildFiles(){
for(LoadedMod mod : orderedMods()){
boolean zipFolder = !mod.file.isDirectory() && mod.root.parent() != null;
String parentName = zipFolder ? mod.root.name() : null;
for(Fi file : mod.root.list()){
//comment
<start>if(file.isDirectory() && !specialFolders.contains(file.name())){
file.walk(f -> tree.addFile(mod.file.isDirectory() ? f.path().substring(1 + mod.file.path().length()) :
zipFolder ? f.path().substring(parentName.length() + 1) : f.path(), f));
}<end>
}

//comment
Fi folder = mod.root.child(""bundles"");
if(folder.exists()){
for(Fi file : folder.list()){
if(file.name().startsWith(""bundle"") && file.extension().equals(""properties"")){
String name = file.nameWithoutExtension();
bundles.get(name, Seq::new).add(file);
}
}
}
}
Events.fire(new FileTreeInitEvent());

//comment
I18NBundle bundle = Core.bundle;
while(bundle != null){
String str = bundle.getLocale().toString();
String locale = ""bundle"" + (str.isEmpty() ? """" : ""_"" + str);
for(Fi file : bundles.get(locale, Seq::new)){
try{
PropertiesUtils.load(bundle.getProperties(), file.reader());
}catch(Throwable e){
Log.err(""Error loading bundle: "" + file + ""/"" + locale, e);
}
}
bundle = bundle.getParent();
}
}"
5742,"private void buildFiles(){
for(LoadedMod mod : orderedMods()){
boolean zipFolder = !mod.file.isDirectory() && mod.root.parent() != null;
String parentName = zipFolder ? mod.root.name() : null;
for(Fi file : mod.root.list()){
//comment
if(file.isDirectory() && !specialFolders.contains(file.name())){
file.walk(f -> tree.addFile(mod.file.isDirectory() ? f.path().substring(1 + mod.file.path().length()) :
zipFolder ? f.path().substring(parentName.length() + 1) : f.path(), f));
}
}

//comment
<start>Fi folder = mod.root.child(""bundles"");<end>
if(folder.exists()){
for(Fi file : folder.list()){
if(file.name().startsWith(""bundle"") && file.extension().equals(""properties"")){
String name = file.nameWithoutExtension();
bundles.get(name, Seq::new).add(file);
}
}
}
}
Events.fire(new FileTreeInitEvent());

//comment
I18NBundle bundle = Core.bundle;
while(bundle != null){
String str = bundle.getLocale().toString();
String locale = ""bundle"" + (str.isEmpty() ? """" : ""_"" + str);
for(Fi file : bundles.get(locale, Seq::new)){
try{
PropertiesUtils.load(bundle.getProperties(), file.reader());
}catch(Throwable e){
Log.err(""Error loading bundle: "" + file + ""/"" + locale, e);
}
}
bundle = bundle.getParent();
}
}","private void buildFiles(){
for(LoadedMod mod : orderedMods()){
boolean zipFolder = !mod.file.isDirectory() && mod.root.parent() != null;
String parentName = zipFolder ? mod.root.name() : null;
for(Fi file : mod.root.list()){
//comment
if(file.isDirectory() && !specialFolders.contains(file.name())){
file.walk(f -> tree.addFile(mod.file.isDirectory() ? f.path().substring(1 + mod.file.path().length()) :
zipFolder ? f.path().substring(parentName.length() + 1) : f.path(), f));
}
}

//comment
<start>Fi folder = mod.root.child(""bundles"");
if(folder.exists()){
for(Fi file : folder.list()){
if(file.name().startsWith(""bundle"") && file.extension().equals(""properties"")){
String name = file.nameWithoutExtension();
bundles.get(name, Seq::new).add(file);
}
}
}<end>
}
Events.fire(new FileTreeInitEvent());

//comment
I18NBundle bundle = Core.bundle;
while(bundle != null){
String str = bundle.getLocale().toString();
String locale = ""bundle"" + (str.isEmpty() ? """" : ""_"" + str);
for(Fi file : bundles.get(locale, Seq::new)){
try{
PropertiesUtils.load(bundle.getProperties(), file.reader());
}catch(Throwable e){
Log.err(""Error loading bundle: "" + file + ""/"" + locale, e);
}
}
bundle = bundle.getParent();
}
}"
5743,"private void buildFiles(){
for(LoadedMod mod : orderedMods()){
boolean zipFolder = !mod.file.isDirectory() && mod.root.parent() != null;
String parentName = zipFolder ? mod.root.name() : null;
for(Fi file : mod.root.list()){
//comment
if(file.isDirectory() && !specialFolders.contains(file.name())){
file.walk(f -> tree.addFile(mod.file.isDirectory() ? f.path().substring(1 + mod.file.path().length()) :
zipFolder ? f.path().substring(parentName.length() + 1) : f.path(), f));
}
}

//comment
Fi folder = mod.root.child(""bundles"");
if(folder.exists()){
for(Fi file : folder.list()){
if(file.name().startsWith(""bundle"") && file.extension().equals(""properties"")){
String name = file.nameWithoutExtension();
bundles.get(name, Seq::new).add(file);
}
}
}
}
Events.fire(new FileTreeInitEvent());

//comment
<start>I18NBundle bundle = Core.bundle;<end>
while(bundle != null){
String str = bundle.getLocale().toString();
String locale = ""bundle"" + (str.isEmpty() ? """" : ""_"" + str);
for(Fi file : bundles.get(locale, Seq::new)){
try{
PropertiesUtils.load(bundle.getProperties(), file.reader());
}catch(Throwable e){
Log.err(""Error loading bundle: "" + file + ""/"" + locale, e);
}
}
bundle = bundle.getParent();
}
}","private void buildFiles(){
for(LoadedMod mod : orderedMods()){
boolean zipFolder = !mod.file.isDirectory() && mod.root.parent() != null;
String parentName = zipFolder ? mod.root.name() : null;
for(Fi file : mod.root.list()){
//comment
if(file.isDirectory() && !specialFolders.contains(file.name())){
file.walk(f -> tree.addFile(mod.file.isDirectory() ? f.path().substring(1 + mod.file.path().length()) :
zipFolder ? f.path().substring(parentName.length() + 1) : f.path(), f));
}
}

//comment
Fi folder = mod.root.child(""bundles"");
if(folder.exists()){
for(Fi file : folder.list()){
if(file.name().startsWith(""bundle"") && file.extension().equals(""properties"")){
String name = file.nameWithoutExtension();
bundles.get(name, Seq::new).add(file);
}
}
}
}
Events.fire(new FileTreeInitEvent());

//comment
<start>I18NBundle bundle = Core.bundle;
while(bundle != null){
String str = bundle.getLocale().toString();
String locale = ""bundle"" + (str.isEmpty() ? """" : ""_"" + str);
for(Fi file : bundles.get(locale, Seq::new)){
try{
PropertiesUtils.load(bundle.getProperties(), file.reader());
}catch(Throwable e){
Log.err(""Error loading bundle: "" + file + ""/"" + locale, e);
}
}
bundle = bundle.getParent();
}<end>
}"
5746,"private void selectFile(boolean open, String purpose, String ext, Cons<Fi> cons){
<start>purpose = purpose.startsWith(""@"") ? Core.bundle.get(purpose.substring(1)) : purpose;
//comment
String title = Core.bundle.get(open ? ""open"" : ""save"") + "" - "" + purpose + "" (."" + ext + "")"";
Vars.platform.showFileChooser(open, title, ext, fi -> {<end>
try{
cons.get(fi);
<start>}catch(Exception e){<end>
Log.err(""Failed to select file '@' for a mod"", fi);
Log.err(e);
}
});
}","private void selectFile(boolean open, String purpose, String ext, Cons<Fi> cons){
purpose = purpose.startsWith(""@"") ? Core.bundle.get(purpose.substring(1)) : purpose;
//comment
<start>String title = Core.bundle.get(open ? ""open"" : ""save"") + "" - "" + purpose + "" (."" + ext + "")"";<end>
Vars.platform.showFileChooser(open, title, ext, fi -> {
try{
cons.get(fi);
}catch(Exception e){
Log.err(""Failed to select file '@' for a mod"", fi);
Log.err(e);
}
});
}"
5747,"private boolean run(String script, String file, boolean wrap){
try{
if(currentMod != null){
//comment
context.evaluateString(scope, ""modName = \"""" + currentMod.name + ""\""\nscriptName = \"""" + file + ""\"""", ""initscript.js"", 1);
}
<start>context.evaluateString(scope,
wrap ? ""(function(){'use strict';\n"" + script + ""\n})();"" : script,
file, 0);<end>
return true;
}catch(Throwable t){
if(currentMod != null){
file = currentMod.name + ""/"" + file;
}
log(LogLevel.err, file, """" + getError(t, true));
return false;
}
}","private boolean run(String script, String file, boolean wrap){
try{
if(currentMod != null){
//comment
<start>context.evaluateString(scope, ""modName = \"""" + currentMod.name + ""\""\nscriptName = \"""" + file + ""\"""", ""initscript.js"", 1);<end>
}
context.evaluateString(scope,
wrap ? ""(function(){'use strict';\n"" + script + ""\n})();"" : script,
file, 0);
return true;
}catch(Throwable t){
if(currentMod != null){
file = currentMod.name + ""/"" + file;
}
log(LogLevel.err, file, """" + getError(t, true));
return false;
}
}"
5748,"@Override
public void sendStream(Streamable stream){
connection.addListener(new InputStreamSender(stream.stream, 512){
int id;

@Override
protected void start(){
//comment
StreamBegin begin = new StreamBegin();
begin.total = stream.stream.available();
begin.type = Net.getPacketId(stream);
connection.sendTCP(begin);
id = begin.id;
}

@Override
protected Object next(byte[] bytes){
StreamChunk chunk = new StreamChunk();
chunk.id = id;
chunk.data = bytes;
<start>return chunk;<end>
}
});
}","@Override
public void sendStream(Streamable stream){
connection.addListener(new InputStreamSender(stream.stream, 512){
int id;

@Override
protected void start(){
//comment
StreamBegin begin = new StreamBegin();
begin.total = stream.stream.available();
begin.type = Net.getPacketId(stream);
connection.sendTCP(begin);
id = begin.id;
}

@Override
protected Object next(byte[] bytes){
<start>StreamChunk chunk = new StreamChunk();
chunk.id = id;
chunk.data = bytes;
return chunk;<end>
}
});
}"
5749,"@Override
public Object read(ByteBuffer byteBuffer){
if(debug){
if(Time.timeSinceMillis(lastDownload) >= 1000){
lastDownload = Time.millis();
download.add(downloadAccum);
downloadAccum = 0;
Log.info(""Download: @ b/s"", download.mean());
}
downloadAccum += byteBuffer.remaining();
}

byte id = byteBuffer.get();
if(id == -2){
return readFramework(byteBuffer);
<start>}else{<end>
//comment
Packet packet = Net.newPacket(id);
var buffer = decompressBuffer.get();
int length = byteBuffer.getShort() & 0xffff;
byte compression = byteBuffer.get();

//comment
if(compression == 0){
<start>buffer.position(0).limit(length);
buffer.put(byteBuffer.array(), byteBuffer.position(), length);<end>
buffer.position(0);
packet.read(reads.get(), length);
//comment
<start>byteBuffer.position(byteBuffer.position() + buffer.position());<end>
}else{
//comment
int read = decompressor.decompress(byteBuffer, byteBuffer.position(), buffer, 0, length);

buffer.position(0);
buffer.limit(length);
<start>packet.read(reads.get(), length);<end>
//comment
byteBuffer.position(byteBuffer.position() + read);
}

return packet;
}
}","@Override
public Object read(ByteBuffer byteBuffer){
if(debug){
if(Time.timeSinceMillis(lastDownload) >= 1000){
lastDownload = Time.millis();
download.add(downloadAccum);
downloadAccum = 0;
Log.info(""Download: @ b/s"", download.mean());
}
downloadAccum += byteBuffer.remaining();
}

byte id = byteBuffer.get();
if(id == -2){
return readFramework(byteBuffer);
}else{
//comment
Packet packet = Net.newPacket(id);
var buffer = decompressBuffer.get();
int length = byteBuffer.getShort() & 0xffff;
byte compression = byteBuffer.get();

//comment
<start>if(compression == 0){
buffer.position(0).limit(length);
buffer.put(byteBuffer.array(), byteBuffer.position(), length);
buffer.position(0);
packet.read(reads.get(), length);
//comment
byteBuffer.position(byteBuffer.position() + buffer.position());
}else{<end>
//comment
int read = decompressor.decompress(byteBuffer, byteBuffer.position(), buffer, 0, length);

buffer.position(0);
buffer.limit(length);
packet.read(reads.get(), length);
//comment
byteBuffer.position(byteBuffer.position() + read);
}

return packet;
}
}"
5750,"@Override
public Object read(ByteBuffer byteBuffer){
if(debug){
if(Time.timeSinceMillis(lastDownload) >= 1000){
lastDownload = Time.millis();
download.add(downloadAccum);
downloadAccum = 0;
Log.info(""Download: @ b/s"", download.mean());
}
downloadAccum += byteBuffer.remaining();
}

byte id = byteBuffer.get();
if(id == -2){
return readFramework(byteBuffer);
}else{
//comment
Packet packet = Net.newPacket(id);
var buffer = decompressBuffer.get();
int length = byteBuffer.getShort() & 0xffff;
byte compression = byteBuffer.get();

//comment
if(compression == 0){
buffer.position(0).limit(length);
buffer.put(byteBuffer.array(), byteBuffer.position(), length);
buffer.position(0);
<start>packet.read(reads.get(), length);<end>
//comment
byteBuffer.position(byteBuffer.position() + buffer.position());
<start>}else{<end>
//comment
int read = decompressor.decompress(byteBuffer, byteBuffer.position(), buffer, 0, length);

buffer.position(0);
buffer.limit(length);
packet.read(reads.get(), length);
//comment
byteBuffer.position(byteBuffer.position() + read);
}

return packet;
}
}","@Override
public Object read(ByteBuffer byteBuffer){
if(debug){
if(Time.timeSinceMillis(lastDownload) >= 1000){
lastDownload = Time.millis();
download.add(downloadAccum);
downloadAccum = 0;
Log.info(""Download: @ b/s"", download.mean());
}
downloadAccum += byteBuffer.remaining();
}

byte id = byteBuffer.get();
if(id == -2){
return readFramework(byteBuffer);
}else{
//comment
Packet packet = Net.newPacket(id);
var buffer = decompressBuffer.get();
int length = byteBuffer.getShort() & 0xffff;
byte compression = byteBuffer.get();

//comment
if(compression == 0){
buffer.position(0).limit(length);
buffer.put(byteBuffer.array(), byteBuffer.position(), length);
buffer.position(0);
packet.read(reads.get(), length);
//comment
<start>byteBuffer.position(byteBuffer.position() + buffer.position());<end>
}else{
//comment
int read = decompressor.decompress(byteBuffer, byteBuffer.position(), buffer, 0, length);

buffer.position(0);
buffer.limit(length);
packet.read(reads.get(), length);
//comment
byteBuffer.position(byteBuffer.position() + read);
}

return packet;
}
}"
5751,"@Override
public Object read(ByteBuffer byteBuffer){
if(debug){
if(Time.timeSinceMillis(lastDownload) >= 1000){
lastDownload = Time.millis();
download.add(downloadAccum);
downloadAccum = 0;
Log.info(""Download: @ b/s"", download.mean());
}
downloadAccum += byteBuffer.remaining();
}

byte id = byteBuffer.get();
if(id == -2){
return readFramework(byteBuffer);
}else{
//comment
Packet packet = Net.newPacket(id);
var buffer = decompressBuffer.get();
int length = byteBuffer.getShort() & 0xffff;
byte compression = byteBuffer.get();

//comment
if(compression == 0){
buffer.position(0).limit(length);
buffer.put(byteBuffer.array(), byteBuffer.position(), length);
buffer.position(0);
packet.read(reads.get(), length);
//comment
byteBuffer.position(byteBuffer.position() + buffer.position());
}else{
//comment
<start>int read = decompressor.decompress(byteBuffer, byteBuffer.position(), buffer, 0, length);<end>

buffer.position(0);
buffer.limit(length);
packet.read(reads.get(), length);
//comment
byteBuffer.position(byteBuffer.position() + read);
}

return packet;
}
}","@Override
public Object read(ByteBuffer byteBuffer){
if(debug){
if(Time.timeSinceMillis(lastDownload) >= 1000){
lastDownload = Time.millis();
download.add(downloadAccum);
downloadAccum = 0;
Log.info(""Download: @ b/s"", download.mean());
}
downloadAccum += byteBuffer.remaining();
}

byte id = byteBuffer.get();
if(id == -2){
return readFramework(byteBuffer);
}else{
//comment
Packet packet = Net.newPacket(id);
var buffer = decompressBuffer.get();
int length = byteBuffer.getShort() & 0xffff;
byte compression = byteBuffer.get();

//comment
<start>if(compression == 0){<end>
buffer.position(0).limit(length);
buffer.put(byteBuffer.array(), byteBuffer.position(), length);
buffer.position(0);
packet.read(reads.get(), length);
//comment
byteBuffer.position(byteBuffer.position() + buffer.position());
<start>}else{
//comment
int read = decompressor.decompress(byteBuffer, byteBuffer.position(), buffer, 0, length);

buffer.position(0);
buffer.limit(length);
packet.read(reads.get(), length);<end>
//comment
byteBuffer.position(byteBuffer.position() + read);
<start>}<end>

return packet;
}
}"
5752,"@Override
public Object read(ByteBuffer byteBuffer){
if(debug){
if(Time.timeSinceMillis(lastDownload) >= 1000){
lastDownload = Time.millis();
download.add(downloadAccum);
downloadAccum = 0;
Log.info(""Download: @ b/s"", download.mean());
}
downloadAccum += byteBuffer.remaining();
}

byte id = byteBuffer.get();
if(id == -2){
return readFramework(byteBuffer);
}else{
//comment
Packet packet = Net.newPacket(id);
var buffer = decompressBuffer.get();
int length = byteBuffer.getShort() & 0xffff;
byte compression = byteBuffer.get();

//comment
if(compression == 0){
buffer.position(0).limit(length);
buffer.put(byteBuffer.array(), byteBuffer.position(), length);
buffer.position(0);
packet.read(reads.get(), length);
//comment
byteBuffer.position(byteBuffer.position() + buffer.position());
}else{
//comment
int read = decompressor.decompress(byteBuffer, byteBuffer.position(), buffer, 0, length);

buffer.position(0);
buffer.limit(length);
packet.read(reads.get(), length);
//comment
<start>byteBuffer.position(byteBuffer.position() + read);<end>
}

return packet;
}
}","@Override
public Object read(ByteBuffer byteBuffer){
if(debug){
if(Time.timeSinceMillis(lastDownload) >= 1000){
lastDownload = Time.millis();
download.add(downloadAccum);
downloadAccum = 0;
Log.info(""Download: @ b/s"", download.mean());
}
downloadAccum += byteBuffer.remaining();
}

byte id = byteBuffer.get();
if(id == -2){
return readFramework(byteBuffer);
}else{
//comment
Packet packet = Net.newPacket(id);
var buffer = decompressBuffer.get();
int length = byteBuffer.getShort() & 0xffff;
byte compression = byteBuffer.get();

//comment
if(compression == 0){
buffer.position(0).limit(length);
buffer.put(byteBuffer.array(), byteBuffer.position(), length);
buffer.position(0);
packet.read(reads.get(), length);
//comment
byteBuffer.position(byteBuffer.position() + buffer.position());
}else{
//comment
int read = decompressor.decompress(byteBuffer, byteBuffer.position(), buffer, 0, length);

buffer.position(0);
buffer.limit(length);
packet.read(reads.get(), length);
//comment
<start>byteBuffer.position(byteBuffer.position() + read);<end>
}

return packet;
}
}"
5758,"protected TextureRegion[] icons(){
//comment
<start>TextureRegion r = variants > 0 ? Core.atlas.find(name + ""1"") : region;<end>
return teamRegion.found() && minfo.mod == null ? new TextureRegion[]{r, teamRegions[Team.sharded.id]} : new TextureRegion[]{r};
}","protected TextureRegion[] icons(){
//comment
<start>TextureRegion r = variants > 0 ? Core.atlas.find(name + ""1"") : region;
return teamRegion.found() && minfo.mod == null ? new TextureRegion[]{r, teamRegions[Team.sharded.id]} : new TextureRegion[]{r};
}<end>"
5759,"    protected void initBuilding(){
//comment
try{
Class<?> current = getClass();

if(current.isAnonymousClass()){
current = current.getSuperclass();
}

subclass = current;

while(buildType == null && Block.class.isAssignableFrom(current)){
//comment
Class<?> type = Structs.find(current.getDeclaredClasses(), t -> Building.class.isAssignableFrom(t) && !t.isInterface());
if(type != null){
//comment
Constructor<? extends Building> cons = (Constructor<? extends Building>)type.getDeclaredConstructor(type.getDeclaringClass());
buildType = () -> {
try{
return cons.newInstance(this);
}catch(Exception e){
throw new RuntimeException(e);
}
};
}

//comment
current = current.getSuperclass();
}

}catch(Throwable ignored){
}

if(buildType == null){
//comment
buildType = Building::create;
}
}","    protected void initBuilding(){
//comment
<start>try{
Class<?> current = getClass();

if(current.isAnonymousClass()){
current = current.getSuperclass();
}

subclass = current;<end>

while(buildType == null && Block.class.isAssignableFrom(current)){
//comment
Class<?> type = Structs.find(current.getDeclaredClasses(), t -> Building.class.isAssignableFrom(t) && !t.isInterface());
if(type != null){
//comment
Constructor<? extends Building> cons = (Constructor<? extends Building>)type.getDeclaredConstructor(type.getDeclaringClass());
buildType = () -> {
try{
return cons.newInstance(this);
}catch(Exception e){
throw new RuntimeException(e);
}
};
}

//comment
current = current.getSuperclass();
}

}catch(Throwable ignored){
}

if(buildType == null){
//comment
buildType = Building::create;
}
}"
5760,"    protected void initBuilding(){
//comment
try{
Class<?> current = getClass();

if(current.isAnonymousClass()){
current = current.getSuperclass();
}

subclass = current;

while(buildType == null && Block.class.isAssignableFrom(current)){
//comment
<start>Class<?> type = Structs.find(current.getDeclaredClasses(), t -> Building.class.isAssignableFrom(t) && !t.isInterface());<end>
if(type != null){
//comment
Constructor<? extends Building> cons = (Constructor<? extends Building>)type.getDeclaredConstructor(type.getDeclaringClass());
buildType = () -> {
try{
return cons.newInstance(this);
}catch(Exception e){
throw new RuntimeException(e);
}
};
}

//comment
current = current.getSuperclass();
}

}catch(Throwable ignored){
}

if(buildType == null){
//comment
buildType = Building::create;
}
}","    protected void initBuilding(){
//comment
try{
Class<?> current = getClass();

if(current.isAnonymousClass()){
current = current.getSuperclass();
}

subclass = current;

while(buildType == null && Block.class.isAssignableFrom(current)){
//comment
<start>Class<?> type = Structs.find(current.getDeclaredClasses(), t -> Building.class.isAssignableFrom(t) && !t.isInterface());<end>
if(type != null){
//comment
Constructor<? extends Building> cons = (Constructor<? extends Building>)type.getDeclaredConstructor(type.getDeclaringClass());
buildType = () -> {
try{
return cons.newInstance(this);
}catch(Exception e){
throw new RuntimeException(e);
}
};
}

//comment
current = current.getSuperclass();
}

}catch(Throwable ignored){
}

if(buildType == null){
//comment
buildType = Building::create;
}
}"
5761,"@Override
@CallSuper
public void init(){
//comment
<start>if(health == -1){
health = size * size * 40;
}<end>

clipSize = Math.max(clipSize, size * tilesize);

//comment
if(expanded){
clipSize += tilesize * 10f;
}

if(emitLight){
clipSize = Math.max(clipSize, lightRadius * 2f);
}

if(group == BlockGroup.transportation || consumes.has(ConsumeType.item) || category == Category.distribution){
acceptsItems = true;
}

offset = ((size + 1) % 2) * tilesize / 2f;

if(requirements.length > 0){
buildCost = 0f;
for(ItemStack stack : requirements){
buildCost += stack.amount * stack.item.cost;
}
}

buildCost *= buildCostMultiplier;

if(consumes.has(ConsumeType.power)) hasPower = true;
if(consumes.has(ConsumeType.item)) hasItems = true;
if(consumes.has(ConsumeType.liquid)) hasLiquids = true;

setBars();

stats.useCategories = true;

consumes.init();

if(!logicConfigurable){
configurations.each((key, val) -> {
if(UnlockableContent.class.isAssignableFrom(key)){
logicConfigurable = true;
}
});
}

if(!outputsPower && consumes.hasPower() && consumes.getPower().buffered){
Log.warn(""Consumer using buffered power: @. Disabling buffered power."", name);
consumes.getPower().buffered = false;
}

if(buildVisibility == BuildVisibility.sandboxOnly){
hideDetails = false;
}
}","@Override
@CallSuper
public void init(){
//comment
<start>if(health == -1){
health = size * size * 40;
}<end>

clipSize = Math.max(clipSize, size * tilesize);

//comment
if(expanded){
clipSize += tilesize * 10f;
}

if(emitLight){
clipSize = Math.max(clipSize, lightRadius * 2f);
}

if(group == BlockGroup.transportation || consumes.has(ConsumeType.item) || category == Category.distribution){
acceptsItems = true;
}

offset = ((size + 1) % 2) * tilesize / 2f;

if(requirements.length > 0){
buildCost = 0f;
for(ItemStack stack : requirements){
buildCost += stack.amount * stack.item.cost;
}
}

buildCost *= buildCostMultiplier;

if(consumes.has(ConsumeType.power)) hasPower = true;
if(consumes.has(ConsumeType.item)) hasItems = true;
if(consumes.has(ConsumeType.liquid)) hasLiquids = true;

setBars();

stats.useCategories = true;

consumes.init();

if(!logicConfigurable){
configurations.each((key, val) -> {
if(UnlockableContent.class.isAssignableFrom(key)){
logicConfigurable = true;
}
});
}

if(!outputsPower && consumes.hasPower() && consumes.getPower().buffered){
Log.warn(""Consumer using buffered power: @. Disabling buffered power."", name);
consumes.getPower().buffered = false;
}

if(buildVisibility == BuildVisibility.sandboxOnly){
hideDetails = false;
}
}"
5763,"    protected void initBuilding(){
//comment
try{
Class<?> current = getClass();

if(current.isAnonymousClass()){
current = current.getSuperclass();
}

subclass = current;

while(buildType == null && Block.class.isAssignableFrom(current)){
//comment
Class<?> type = Structs.find(current.getDeclaredClasses(), t -> Building.class.isAssignableFrom(t) && !t.isInterface());
if(type != null){
//comment
Constructor<? extends Building> cons = (Constructor<? extends Building>)type.getDeclaredConstructor(type.getDeclaringClass());
buildType = () -> {
try{
return cons.newInstance(this);
}catch(Exception e){
throw new RuntimeException(e);
}
};
}

//comment
<start>current = current.getSuperclass();<end>
}

}catch(Throwable ignored){
}

if(buildType == null){
//comment
buildType = Building::create;
}
}","    protected void initBuilding(){
//comment
try{
Class<?> current = getClass();

if(current.isAnonymousClass()){
current = current.getSuperclass();
}

subclass = current;

while(buildType == null && Block.class.isAssignableFrom(current)){
//comment
Class<?> type = Structs.find(current.getDeclaredClasses(), t -> Building.class.isAssignableFrom(t) && !t.isInterface());
if(type != null){
//comment
Constructor<? extends Building> cons = (Constructor<? extends Building>)type.getDeclaredConstructor(type.getDeclaringClass());
buildType = () -> {
try{
return cons.newInstance(this);
}catch(Exception e){
throw new RuntimeException(e);
}
};
}

//comment
<start>current = current.getSuperclass();<end>
}

}catch(Throwable ignored){
}

if(buildType == null){
//comment
buildType = Building::create;
}
}"
5764,"    protected void initBuilding(){
//comment
try{
Class<?> current = getClass();

if(current.isAnonymousClass()){
current = current.getSuperclass();
}

subclass = current;

while(buildType == null && Block.class.isAssignableFrom(current)){
//comment
Class<?> type = Structs.find(current.getDeclaredClasses(), t -> Building.class.isAssignableFrom(t) && !t.isInterface());
if(type != null){
//comment
Constructor<? extends Building> cons = (Constructor<? extends Building>)type.getDeclaredConstructor(type.getDeclaringClass());
buildType = () -> {
try{
return cons.newInstance(this);
}catch(Exception e){
throw new RuntimeException(e);
}
};
}

//comment
current = current.getSuperclass();
}

}catch(Throwable ignored){
}

<start>if(buildType == null){
//comment
buildType = Building::create;
}<end>
}","    protected void initBuilding(){
//comment
try{
Class<?> current = getClass();

if(current.isAnonymousClass()){
current = current.getSuperclass();
}

subclass = current;

while(buildType == null && Block.class.isAssignableFrom(current)){
//comment
Class<?> type = Structs.find(current.getDeclaredClasses(), t -> Building.class.isAssignableFrom(t) && !t.isInterface());
if(type != null){
//comment
Constructor<? extends Building> cons = (Constructor<? extends Building>)type.getDeclaredConstructor(type.getDeclaringClass());
buildType = () -> {
try{
return cons.newInstance(this);
}catch(Exception e){
throw new RuntimeException(e);
}
};
}

//comment
current = current.getSuperclass();
}

}catch(Throwable ignored){
}

<start>if(buildType == null){
//comment
buildType = Building::create;
}<end>
}"
1394,"@Override
public void updateTile(){
if(!state.isCampaign()) return;

//comment
if((launchCounter += edelta()) >= launchTime && edelta() >= 0.001f && items.total() >= itemCapacity){
<start>launchSound.at(x, y);<end>
LaunchPayload entity = LaunchPayload.create();
<start>items.each((item, amount) -> entity.stacks.add(new ItemStack(item, amount)));<end>
entity.set(this);
entity.lifetime(120f);
entity.team(team);
entity.add();
Fx.launchPod.at(this);
items.clear();
Effect.shake(3f, 3f, this);
launchCounter = 0f;
}
}","@Override
public void updateTile(){
if(!state.isCampaign()) return;

//comment
<start>if((launchCounter += edelta()) >= launchTime && edelta() >= 0.001f && items.total() >= itemCapacity){
launchSound.at(x, y);<end>
LaunchPayload entity = LaunchPayload.create();
items.each((item, amount) -> entity.stacks.add(new ItemStack(item, amount)));
entity.set(this);
entity.lifetime(120f);
entity.team(team);
entity.add();
Fx.launchPod.at(this);
items.clear();
Effect.shake(3f, 3f, this);
launchCounter = 0f;
<start>}<end>
}"
1395,"        @Override
public void remove(){
if(!state.isCampaign()) return;

Sector destsec = state.rules.sector.info.getRealDestination();

//comment
if(team() == state.rules.defaultTeam){
if(destsec != null && (destsec != state.rules.sector || net.client())){
ItemSeq dest = new ItemSeq();

for(ItemStack stack : stacks){
dest.add(stack);

//comment
state.rules.sector.info.handleItemExport(stack);
Events.fire(new LaunchItemEvent(stack));
}

if(!net.client()){
destsec.addItems(dest);
}
}
}
}","        @Override
public void remove(){
if(!state.isCampaign()) return;

Sector destsec = state.rules.sector.info.getRealDestination();

//comment
if(team() == state.rules.defaultTeam){
if(destsec != null && (destsec != state.rules.sector || net.client())){
ItemSeq dest = new ItemSeq();

<start>for(ItemStack stack : stacks){<end>
dest.add(stack);

//comment
state.rules.sector.info.handleItemExport(stack);
<start>Events.fire(new LaunchItemEvent(stack));
}<end>

if(!net.client()){
destsec.addItems(dest);
}
}
}
}"
1396,"        @Override
public void remove(){
if(!state.isCampaign()) return;

Sector destsec = state.rules.sector.info.getRealDestination();

//comment
if(team() == state.rules.defaultTeam){
if(destsec != null && (destsec != state.rules.sector || net.client())){
ItemSeq dest = new ItemSeq();

for(ItemStack stack : stacks){
dest.add(stack);

//comment
<start>state.rules.sector.info.handleItemExport(stack);
Events.fire(new LaunchItemEvent(stack));<end>
}

if(!net.client()){
destsec.addItems(dest);
}
}
}
}","        @Override
public void remove(){
if(!state.isCampaign()) return;

Sector destsec = state.rules.sector.info.getRealDestination();

//comment
if(team() == state.rules.defaultTeam){
if(destsec != null && (destsec != state.rules.sector || net.client())){
ItemSeq dest = new ItemSeq();

for(ItemStack stack : stacks){
dest.add(stack);

//comment
<start>state.rules.sector.info.handleItemExport(stack);<end>
Events.fire(new LaunchItemEvent(stack));
}

if(!net.client()){
destsec.addItems(dest);
}
}
}
}"
5765,"@Override
public void init(){
super.init();

//comment
<start>clipSize = Math.max(clipSize, size * tilesize * 2.1f);<end>
}","@Override
public void init(){
super.init();

//comment
<start>clipSize = Math.max(clipSize, size * tilesize * 2.1f);<end>
}"
5766,"@Override
public void onProximityUpdate(){
super.onProximityUpdate();

<start>Building accept = nearby(Geometry.d4(rotation).x * (size/2+1), Geometry.d4(rotation).y * (size/2+1));<end>
//comment
if(accept != null && (
//comment
(accept.block.size == size && tileX() + Geometry.d4(rotation).x * size == accept.tileX() && tileY() + Geometry.d4(rotation).y * size == accept.tileY()) ||

//comment
(accept.block.size > size &&
(rotation % 2 == 0 ?
Math.abs(accept.y - y) <= (accept.block.size * tilesize - size * tilesize)/2f :
Math.abs(accept.x - x) <= (accept.block.size * tilesize - size * tilesize)/2f
)))){
next = accept;
}else{
next = null;
}

int ntrns = 1 + size/2;
Tile next = tile.nearby(Geometry.d4(rotation).x * ntrns, Geometry.d4(rotation).y * ntrns);
blocked = (next != null && next.solid() && !(next.block().outputsPayload || next.block().acceptsPayload)) || (this.next != null && this.next.payloadCheck(rotation));
}","@Override
public void onProximityUpdate(){
super.onProximityUpdate();

Building accept = nearby(Geometry.d4(rotation).x * (size/2+1), Geometry.d4(rotation).y * (size/2+1));
//comment
<start>if(accept != null && (
//comment
(accept.block.size == size && tileX() + Geometry.d4(rotation).x * size == accept.tileX() && tileY() + Geometry.d4(rotation).y * size == accept.tileY()) ||<end>

//comment
<start>(accept.block.size > size &&
(rotation % 2 == 0 ?
Math.abs(accept.y - y) <= (accept.block.size * tilesize - size * tilesize)/2f :
Math.abs(accept.x - x) <= (accept.block.size * tilesize - size * tilesize)/2f
)))){<end>
next = accept;
}else{
next = null;
}

int ntrns = 1 + size/2;
Tile next = tile.nearby(Geometry.d4(rotation).x * ntrns, Geometry.d4(rotation).y * ntrns);
blocked = (next != null && next.solid() && !(next.block().outputsPayload || next.block().acceptsPayload)) || (this.next != null && this.next.payloadCheck(rotation));
}"
5767,"@Override
public void updateTile(){
if(!enabled) return;

if(item != null){
item.update(false);
}

lastInterp = curInterp;
curInterp = fract();
//comment
if(lastInterp > curInterp) lastInterp = 0f;
progress = time() % moveTime;

updatePayload();
if(item != null && next == null){
PayloadBlock.pushOutput(item, progress / moveTime);
}

//comment
int curStep = curStep();
if(curStep > step){
boolean valid = step != -1;
step = curStep;
boolean had = item != null;

if(valid && stepAccepted != curStep && item != null){
if(next != null){
//comment
<start>next.updateTile();<end>

//comment
if(next.acceptPayload(this, item)){
//comment
next.handlePayload(this, item);
item = null;
moved();
}
}else if(!blocked){
//comment
if(item.dump()){
item = null;
moved();
}
}
}

if(had && item != null){
moveFailed();
}
}
}","@Override
public void updateTile(){
if(!enabled) return;

if(item != null){
item.update(false);
}

lastInterp = curInterp;
curInterp = fract();
//comment
if(lastInterp > curInterp) lastInterp = 0f;
progress = time() % moveTime;

updatePayload();
if(item != null && next == null){
PayloadBlock.pushOutput(item, progress / moveTime);
}

//comment
int curStep = curStep();
if(curStep > step){
boolean valid = step != -1;
step = curStep;
boolean had = item != null;

if(valid && stepAccepted != curStep && item != null){
if(next != null){
//comment
<start>next.updateTile();<end>

//comment
if(next.acceptPayload(this, item)){
//comment
next.handlePayload(this, item);
item = null;
moved();
}
}else if(!blocked){
//comment
if(item.dump()){
item = null;
moved();
}
}
}

if(had && item != null){
moveFailed();
}
}
}"
5768,"@Override
public void updateTile(){
if(!enabled) return;

if(item != null){
item.update(false);
}

lastInterp = curInterp;
curInterp = fract();
//comment
if(lastInterp > curInterp) lastInterp = 0f;
progress = time() % moveTime;

updatePayload();
if(item != null && next == null){
PayloadBlock.pushOutput(item, progress / moveTime);
}

//comment
int curStep = curStep();
if(curStep > step){
boolean valid = step != -1;
step = curStep;
boolean had = item != null;

if(valid && stepAccepted != curStep && item != null){
if(next != null){
//comment
next.updateTile();

//comment
if(next.acceptPayload(this, item)){
//comment
next.handlePayload(this, item);
<start>item = null;<end>
moved();
}
}else if(!blocked){
//comment
if(item.dump()){
<start>item = null;<end>
moved();
}
}
}

if(had && item != null){
moveFailed();
}
}
}","@Override
public void updateTile(){
if(!enabled) return;

if(item != null){
item.update(false);
}

lastInterp = curInterp;
curInterp = fract();
//comment
if(lastInterp > curInterp) lastInterp = 0f;
progress = time() % moveTime;

updatePayload();
if(item != null && next == null){
PayloadBlock.pushOutput(item, progress / moveTime);
}

//comment
int curStep = curStep();
if(curStep > step){
boolean valid = step != -1;
step = curStep;
boolean had = item != null;

if(valid && stepAccepted != curStep && item != null){
if(next != null){
//comment
next.updateTile();

//comment
if(next.acceptPayload(this, item)){
//comment
next.handlePayload(this, item);
item = null;
moved();
}
}else if(!blocked){
//comment
<start>if(item.dump()){
item = null;
moved();
}<end>
}
}

if(had && item != null){
moveFailed();
}
}
}"
5769,"@Override
public void unitOn(Unit unit){
//comment
float delta = (curInterp - lastInterp) * size * tilesize;
Tmp.v1.trns(rotdeg(), delta * moveForce).scl(1f / Math.max(unit.mass(), 201f));
unit.move(Tmp.v1.x, Tmp.v1.y);
}","@Override
public void unitOn(Unit unit){
//comment
<start>float delta = (curInterp - lastInterp) * size * tilesize;
Tmp.v1.trns(rotdeg(), delta * moveForce).scl(1f / Math.max(unit.mass(), 201f));
unit.move(Tmp.v1.x, Tmp.v1.y);<end>
}"
617,"@Override
protected String getSqlType(final SinkRecordField field) {
if (field.schemaName() != null) {
switch (field.schemaName()) {
case Decimal.LOGICAL_NAME:
case Date.LOGICAL_NAME:
case Time.LOGICAL_NAME:
case Timestamp.LOGICAL_NAME:
return ""NUMERIC"";
default:
//comment
}
}
switch (field.schemaType()) {
case BOOLEAN:
case INT8:
case INT16:
case INT32:
case INT64:
return ""INTEGER"";
case FLOAT32:
case FLOAT64:
return ""REAL"";
case STRING:
return ""TEXT"";
case BYTES:
return ""BLOB"";
default:
return super.getSqlType(field);
}
}","@Override
protected String getSqlType(final SinkRecordField field) {
if (field.schemaName() != null) {
<start>switch (field.schemaName()) {<end>
case Decimal.LOGICAL_NAME:
case Date.LOGICAL_NAME:
case Time.LOGICAL_NAME:
case Timestamp.LOGICAL_NAME:
return ""NUMERIC"";
<start>default:<end>
//comment
}
}
switch (field.schemaType()) {
case BOOLEAN:
case INT8:
case INT16:
case INT32:
case INT64:
return ""INTEGER"";
case FLOAT32:
case FLOAT64:
return ""REAL"";
case STRING:
return ""TEXT"";
case BYTES:
return ""BLOB"";
default:
return super.getSqlType(field);
}
}"
2484,"    public boolean createOrAmendIfNecessary(
final JdbcSinkConfig config,
final Connection connection,
final TableId tableId,
final FieldsMetadata fieldsMetadata
) throws SQLException {
if (tableDefns.get(connection, tableId) == null) {
//comment
try {
<start>create(config, connection, tableId, fieldsMetadata);<end>
} catch (final SQLException sqle) {
<start>log.warn(""Create failed, will attempt amend if table already exists"", sqle);<end>
try {
final TableDefinition newDefn = tableDefns.refresh(connection, tableId);
if (newDefn == null) {
throw sqle;
}
} catch (final SQLException e) {
throw sqle;
}
}
}
return amendIfNecessary(config, connection, tableId, fieldsMetadata, config.maxRetries);
}","    public boolean createOrAmendIfNecessary(
final JdbcSinkConfig config,
final Connection connection,
final TableId tableId,
final FieldsMetadata fieldsMetadata
) throws SQLException {
if (tableDefns.get(connection, tableId) == null) {
//comment
<start>try {
create(config, connection, tableId, fieldsMetadata);
} catch (final SQLException sqle) {<end>
log.warn(""Create failed, will attempt amend if table already exists"", sqle);
try {
final TableDefinition newDefn = tableDefns.refresh(connection, tableId);
if (newDefn == null) {
throw sqle;
}
} catch (final SQLException e) {
throw sqle;
}
}
}
return amendIfNecessary(config, connection, tableId, fieldsMetadata, config.maxRetries);
}"
2485,"Set<SinkRecordField> missingFields(
final Collection<SinkRecordField> fields,
final Set<String> dbColumnNames
) {
final Set<SinkRecordField> missingFields = new HashSet<>();
for (final SinkRecordField field : fields) {
if (!dbColumnNames.contains(field.name())) {
log.debug(""Found missing field: {}"", field);
missingFields.add(field);
}
}

if (missingFields.isEmpty()) {
return missingFields;
}

//comment
<start>final Set<String> columnNamesLowerCase = new HashSet<>();<end>
for (final String columnName : dbColumnNames) {
columnNamesLowerCase.add(columnName.toLowerCase());
}

if (columnNamesLowerCase.size() != dbColumnNames.size()) {
log.warn(
""Table has column names that differ only by case. Original columns={}"",
dbColumnNames
);
}

final Set<SinkRecordField> missingFieldsIgnoreCase = new HashSet<>();
for (final SinkRecordField missing : missingFields) {
if (!columnNamesLowerCase.contains(missing.name().toLowerCase())) {
missingFieldsIgnoreCase.add(missing);
}
}

if (missingFieldsIgnoreCase.size() > 0) {
log.info(
""Unable to find fields {} among column names {}"",
missingFieldsIgnoreCase,
dbColumnNames
);
}

return missingFieldsIgnoreCase;
}","Set<SinkRecordField> missingFields(
final Collection<SinkRecordField> fields,
final Set<String> dbColumnNames
) {
final Set<SinkRecordField> missingFields = new HashSet<>();
for (final SinkRecordField field : fields) {
if (!dbColumnNames.contains(field.name())) {
log.debug(""Found missing field: {}"", field);
missingFields.add(field);
}
}

if (missingFields.isEmpty()) {
return missingFields;
}

//comment
<start>final Set<String> columnNamesLowerCase = new HashSet<>();
for (final String columnName : dbColumnNames) {
columnNamesLowerCase.add(columnName.toLowerCase());
}<end>

if (columnNamesLowerCase.size() != dbColumnNames.size()) {
log.warn(
""Table has column names that differ only by case. Original columns={}"",
dbColumnNames
);
}

final Set<SinkRecordField> missingFieldsIgnoreCase = new HashSet<>();
for (final SinkRecordField missing : missingFields) {
if (!columnNamesLowerCase.contains(missing.name().toLowerCase())) {
missingFieldsIgnoreCase.add(missing);
}
}

if (missingFieldsIgnoreCase.size() > 0) {
log.info(
""Unable to find fields {} among column names {}"",
missingFieldsIgnoreCase,
dbColumnNames
);
}

return missingFieldsIgnoreCase;
}"
2322,"@Override
protected String getSqlType(final SinkRecordField field) {
if (field.schemaName() != null) {
switch (field.schemaName()) {
case Decimal.LOGICAL_NAME:
return ""decimal(38,"" + field.schemaParameters().get(Decimal.SCALE_FIELD) + "")"";
case Date.LOGICAL_NAME:
return ""date"";
case Time.LOGICAL_NAME:
return ""time"";
case Timestamp.LOGICAL_NAME:
return ""datetime"";
default:
//comment
}
}
switch (field.schemaType()) {
case INT8:
//comment
return ""smallint"";
case INT16:
return ""smallint"";
case INT32:
return ""int"";
case INT64:
return ""bigint"";
case FLOAT32:
return ""real"";
case FLOAT64:
return ""float"";
case BOOLEAN:
if (field.isOptional()) {
return ""tinyint"";
} else {
return ""bit"";
}
case STRING:
if (field.isPrimaryKey()) {
//comment
//comment
//comment
<start>return ""varchar(512)"";
} else {<end>
return ""text"";
}
case BYTES:
return ""image"";
default:
return super.getSqlType(field);
}
}","@Override
protected String getSqlType(final SinkRecordField field) {
if (field.schemaName() != null) {
switch (field.schemaName()) {
case Decimal.LOGICAL_NAME:
return ""decimal(38,"" + field.schemaParameters().get(Decimal.SCALE_FIELD) + "")"";
case Date.LOGICAL_NAME:
return ""date"";
case Time.LOGICAL_NAME:
return ""time"";
case Timestamp.LOGICAL_NAME:
return ""datetime"";
default:
//comment
}
}
switch (field.schemaType()) {
case INT8:
//comment
return ""smallint"";
case INT16:
return ""smallint"";
case INT32:
return ""int"";
case INT64:
return ""bigint"";
case FLOAT32:
return ""real"";
case FLOAT64:
return ""float"";
case BOOLEAN:
if (field.isOptional()) {
return ""tinyint"";
} else {
return ""bit"";
}
case STRING:
<start>if (field.isPrimaryKey()) {
//comment
//comment
//comment
return ""varchar(512)"";
} else {<end>
return ""text"";
}
case BYTES:
return ""image"";
default:
return super.getSqlType(field);
}
}"
1111,"@Override
public List<SourceRecord> poll() throws InterruptedException {
log.trace(""Polling for new data"");

while (running.get()) {
final TableQuerier querier = tableQueue.peek();

if (!querier.querying()) {
//comment
<start>final long nextUpdate = querier.getLastUpdate()
+ config.getInt(JdbcSourceTaskConfig.POLL_INTERVAL_MS_CONFIG);
final long untilNext = nextUpdate - time.milliseconds();<end>
final long sleepMs = Math.min(untilNext, 100);
if (sleepMs > 0) {
log.trace(""Waiting {} ms to poll {} next ({} ms total left to wait)"",
sleepMs, querier.toString(), untilNext);
<start>time.sleep(sleepMs);<end>
continue;
}
}

final List<SourceRecord> results = new ArrayList<>();
try {
log.debug(""Checking for next block of results from {}"", querier.toString());
querier.maybeStartQuery(cachedConnectionProvider.getConnection());

final int batchMaxRows = config.getInt(JdbcSourceTaskConfig.BATCH_MAX_ROWS_CONFIG);
boolean hadNext = true;
while (results.size() < batchMaxRows && (hadNext = querier.next())) {
results.add(querier.extractRecord());
}

if (!hadNext) {
//comment
//comment
resetAndRequeueHead(querier);
}

if (results.isEmpty()) {
log.trace(""No updates for {}"", querier.toString());
continue;
}

log.debug(""Returning {} records for {}"", results.size(), querier.toString());
return results;
} catch (final SQLException sqle) {
log.error(""Failed to run query for table {}: {}"", querier.toString(), sqle);
resetAndRequeueHead(querier);
return null;
} catch (final Throwable t) {
resetAndRequeueHead(querier);
//comment
closeResources();
throw t;
}
}

//comment
final TableQuerier querier = tableQueue.peek();
if (querier != null) {
resetAndRequeueHead(querier);
}
closeResources();
return null;
}","@Override
public List<SourceRecord> poll() throws InterruptedException {
log.trace(""Polling for new data"");

while (running.get()) {
final TableQuerier querier = tableQueue.peek();

<start>if (!querier.querying()) {
//comment
final long nextUpdate = querier.getLastUpdate()
+ config.getInt(JdbcSourceTaskConfig.POLL_INTERVAL_MS_CONFIG);
final long untilNext = nextUpdate - time.milliseconds();
final long sleepMs = Math.min(untilNext, 100);
if (sleepMs > 0) {
log.trace(""Waiting {} ms to poll {} next ({} ms total left to wait)"",
sleepMs, querier.toString(), untilNext);
time.sleep(sleepMs);
continue;
}
}<end>

final List<SourceRecord> results = new ArrayList<>();
try {
log.debug(""Checking for next block of results from {}"", querier.toString());
querier.maybeStartQuery(cachedConnectionProvider.getConnection());

final int batchMaxRows = config.getInt(JdbcSourceTaskConfig.BATCH_MAX_ROWS_CONFIG);
boolean hadNext = true;
while (results.size() < batchMaxRows && (hadNext = querier.next())) {
results.add(querier.extractRecord());
}

if (!hadNext) {
//comment
//comment
resetAndRequeueHead(querier);
}

if (results.isEmpty()) {
log.trace(""No updates for {}"", querier.toString());
continue;
}

log.debug(""Returning {} records for {}"", results.size(), querier.toString());
return results;
} catch (final SQLException sqle) {
log.error(""Failed to run query for table {}: {}"", querier.toString(), sqle);
resetAndRequeueHead(querier);
return null;
} catch (final Throwable t) {
resetAndRequeueHead(querier);
//comment
closeResources();
throw t;
}
}

//comment
final TableQuerier querier = tableQueue.peek();
if (querier != null) {
resetAndRequeueHead(querier);
}
closeResources();
return null;
}"
1112,"@Override
public List<SourceRecord> poll() throws InterruptedException {
log.trace(""Polling for new data"");

while (running.get()) {
final TableQuerier querier = tableQueue.peek();

if (!querier.querying()) {
//comment
final long nextUpdate = querier.getLastUpdate()
+ config.getInt(JdbcSourceTaskConfig.POLL_INTERVAL_MS_CONFIG);
final long untilNext = nextUpdate - time.milliseconds();
final long sleepMs = Math.min(untilNext, 100);
if (sleepMs > 0) {
log.trace(""Waiting {} ms to poll {} next ({} ms total left to wait)"",
sleepMs, querier.toString(), untilNext);
time.sleep(sleepMs);
continue;
}
}

final List<SourceRecord> results = new ArrayList<>();
try {
log.debug(""Checking for next block of results from {}"", querier.toString());
querier.maybeStartQuery(cachedConnectionProvider.getConnection());

final int batchMaxRows = config.getInt(JdbcSourceTaskConfig.BATCH_MAX_ROWS_CONFIG);
boolean hadNext = true;
while (results.size() < batchMaxRows && (hadNext = querier.next())) {
results.add(querier.extractRecord());
}

<start>if (!hadNext) {
//comment
//comment
resetAndRequeueHead(querier);
}<end>

if (results.isEmpty()) {
log.trace(""No updates for {}"", querier.toString());
continue;
}

log.debug(""Returning {} records for {}"", results.size(), querier.toString());
return results;
} catch (final SQLException sqle) {
log.error(""Failed to run query for table {}: {}"", querier.toString(), sqle);
resetAndRequeueHead(querier);
return null;
} catch (final Throwable t) {
resetAndRequeueHead(querier);
//comment
closeResources();
throw t;
}
}

//comment
final TableQuerier querier = tableQueue.peek();
if (querier != null) {
resetAndRequeueHead(querier);
}
closeResources();
return null;
}","@Override
public List<SourceRecord> poll() throws InterruptedException {
log.trace(""Polling for new data"");

while (running.get()) {
final TableQuerier querier = tableQueue.peek();

if (!querier.querying()) {
//comment
final long nextUpdate = querier.getLastUpdate()
+ config.getInt(JdbcSourceTaskConfig.POLL_INTERVAL_MS_CONFIG);
final long untilNext = nextUpdate - time.milliseconds();
final long sleepMs = Math.min(untilNext, 100);
if (sleepMs > 0) {
log.trace(""Waiting {} ms to poll {} next ({} ms total left to wait)"",
sleepMs, querier.toString(), untilNext);
time.sleep(sleepMs);
continue;
}
}

final List<SourceRecord> results = new ArrayList<>();
try {
log.debug(""Checking for next block of results from {}"", querier.toString());
querier.maybeStartQuery(cachedConnectionProvider.getConnection());

final int batchMaxRows = config.getInt(JdbcSourceTaskConfig.BATCH_MAX_ROWS_CONFIG);
boolean hadNext = true;
while (results.size() < batchMaxRows && (hadNext = querier.next())) {
results.add(querier.extractRecord());
}

<start>if (!hadNext) {
//comment
//comment
resetAndRequeueHead(querier);
}<end>

if (results.isEmpty()) {
log.trace(""No updates for {}"", querier.toString());
continue;
}

log.debug(""Returning {} records for {}"", results.size(), querier.toString());
return results;
} catch (final SQLException sqle) {
log.error(""Failed to run query for table {}: {}"", querier.toString(), sqle);
resetAndRequeueHead(querier);
return null;
} catch (final Throwable t) {
resetAndRequeueHead(querier);
//comment
closeResources();
throw t;
}
}

//comment
final TableQuerier querier = tableQueue.peek();
if (querier != null) {
resetAndRequeueHead(querier);
}
closeResources();
return null;
}"
1113,"@Override
public List<SourceRecord> poll() throws InterruptedException {
log.trace(""Polling for new data"");

while (running.get()) {
final TableQuerier querier = tableQueue.peek();

if (!querier.querying()) {
//comment
final long nextUpdate = querier.getLastUpdate()
+ config.getInt(JdbcSourceTaskConfig.POLL_INTERVAL_MS_CONFIG);
final long untilNext = nextUpdate - time.milliseconds();
final long sleepMs = Math.min(untilNext, 100);
if (sleepMs > 0) {
log.trace(""Waiting {} ms to poll {} next ({} ms total left to wait)"",
sleepMs, querier.toString(), untilNext);
time.sleep(sleepMs);
continue;
}
}

final List<SourceRecord> results = new ArrayList<>();
try {
log.debug(""Checking for next block of results from {}"", querier.toString());
querier.maybeStartQuery(cachedConnectionProvider.getConnection());

final int batchMaxRows = config.getInt(JdbcSourceTaskConfig.BATCH_MAX_ROWS_CONFIG);
boolean hadNext = true;
while (results.size() < batchMaxRows && (hadNext = querier.next())) {
results.add(querier.extractRecord());
}

if (!hadNext) {
//comment
//comment
resetAndRequeueHead(querier);
}

if (results.isEmpty()) {
log.trace(""No updates for {}"", querier.toString());
continue;
}

log.debug(""Returning {} records for {}"", results.size(), querier.toString());
return results;
} catch (final SQLException sqle) {
log.error(""Failed to run query for table {}: {}"", querier.toString(), sqle);
resetAndRequeueHead(querier);
return null;
} catch (final Throwable t) {
resetAndRequeueHead(querier);
//comment
<start>closeResources();<end>
throw t;
}
}

//comment
final TableQuerier querier = tableQueue.peek();
if (querier != null) {
resetAndRequeueHead(querier);
}
closeResources();
return null;
}","@Override
public List<SourceRecord> poll() throws InterruptedException {
log.trace(""Polling for new data"");

while (running.get()) {
final TableQuerier querier = tableQueue.peek();

if (!querier.querying()) {
//comment
final long nextUpdate = querier.getLastUpdate()
+ config.getInt(JdbcSourceTaskConfig.POLL_INTERVAL_MS_CONFIG);
final long untilNext = nextUpdate - time.milliseconds();
final long sleepMs = Math.min(untilNext, 100);
if (sleepMs > 0) {
log.trace(""Waiting {} ms to poll {} next ({} ms total left to wait)"",
sleepMs, querier.toString(), untilNext);
time.sleep(sleepMs);
continue;
}
}

final List<SourceRecord> results = new ArrayList<>();
try {
log.debug(""Checking for next block of results from {}"", querier.toString());
querier.maybeStartQuery(cachedConnectionProvider.getConnection());

final int batchMaxRows = config.getInt(JdbcSourceTaskConfig.BATCH_MAX_ROWS_CONFIG);
boolean hadNext = true;
while (results.size() < batchMaxRows && (hadNext = querier.next())) {
results.add(querier.extractRecord());
}

if (!hadNext) {
//comment
//comment
resetAndRequeueHead(querier);
}

if (results.isEmpty()) {
log.trace(""No updates for {}"", querier.toString());
continue;
}

log.debug(""Returning {} records for {}"", results.size(), querier.toString());
return results;
} catch (final SQLException sqle) {
log.error(""Failed to run query for table {}: {}"", querier.toString(), sqle);
resetAndRequeueHead(querier);
return null;
<start>} catch (final Throwable t) {
resetAndRequeueHead(querier);
//comment
closeResources();
throw t;
}<end>
}

//comment
final TableQuerier querier = tableQueue.peek();
if (querier != null) {
resetAndRequeueHead(querier);
}
closeResources();
return null;
}"
2927,"<start>@Override
public int compareTo(@NonNull Card other) {<end>

//comment
if (this.mNumber != null && other.mNumber != null && this.mNumber.length() > 0 && other.mNumber.length() > 0) {

int this_num = this.getNumberInteger();
int other_num = other.getNumberInteger();
if (this_num > other_num) {
return 1;
} else if (this_num < other_num) {
return -1;
} else {
return Character.compare(this.getNumberChar(), other.getNumberChar());
}
}

//comment
if (this.mExpansion.equals(""BR"")) {
if (this.mType.contains(""Basic Land"") && !other.mType.contains(""Basic Land"")) {
return 1;
}
if (!this.mType.contains(""Basic Land"") && other.mType.contains(""Basic Land"")) {
return -1;
}
return this.mName.compareTo(other.mName);
}

//comment
//comment
//comment
//comment
if (this.getNumFromColor() > other.getNumFromColor()) {
return 1;
} else if (this.getNumFromColor() < other.getNumFromColor()) {
return -1;
}

//comment
return this.mName.compareTo(other.mName);
}","@Override
public int compareTo(@NonNull Card other) {

//comment
<start>if (this.mNumber != null && other.mNumber != null && this.mNumber.length() > 0 && other.mNumber.length() > 0) {

int this_num = this.getNumberInteger();
int other_num = other.getNumberInteger();
if (this_num > other_num) {
return 1;
} else if (this_num < other_num) {
return -1;
} else {
return Character.compare(this.getNumberChar(), other.getNumberChar());
}
}<end>

//comment
if (this.mExpansion.equals(""BR"")) {
if (this.mType.contains(""Basic Land"") && !other.mType.contains(""Basic Land"")) {
return 1;
}
if (!this.mType.contains(""Basic Land"") && other.mType.contains(""Basic Land"")) {
return -1;
}
return this.mName.compareTo(other.mName);
}

//comment
//comment
//comment
//comment
if (this.getNumFromColor() > other.getNumFromColor()) {
return 1;
} else if (this.getNumFromColor() < other.getNumFromColor()) {
return -1;
}

//comment
return this.mName.compareTo(other.mName);
}"
2929,"@Override
public int compareTo(@NonNull Card other) {

//comment
if (this.mNumber != null && other.mNumber != null && this.mNumber.length() > 0 && other.mNumber.length() > 0) {

int this_num = this.getNumberInteger();
int other_num = other.getNumberInteger();
if (this_num > other_num) {
return 1;
} else if (this_num < other_num) {
return -1;
} else {
return Character.compare(this.getNumberChar(), other.getNumberChar());
}
}

//comment
if (this.mExpansion.equals(""BR"")) {
if (this.mType.contains(""Basic Land"") && !other.mType.contains(""Basic Land"")) {
return 1;
}
if (!this.mType.contains(""Basic Land"") && other.mType.contains(""Basic Land"")) {
return -1;
}
return this.mName.compareTo(other.mName);
}

//comment
//comment
//comment
//comment
if (this.getNumFromColor() > other.getNumFromColor()) {
return 1;
} else if (this.getNumFromColor() < other.getNumFromColor()) {
return -1;
}

//comment
<start>return this.mName.compareTo(other.mName);<end>
}","@Override
public int compareTo(@NonNull Card other) {

//comment
if (this.mNumber != null && other.mNumber != null && this.mNumber.length() > 0 && other.mNumber.length() > 0) {

int this_num = this.getNumberInteger();
int other_num = other.getNumberInteger();
if (this_num > other_num) {
return 1;
} else if (this_num < other_num) {
return -1;
} else {
return Character.compare(this.getNumberChar(), other.getNumberChar());
}
}

//comment
if (this.mExpansion.equals(""BR"")) {
if (this.mType.contains(""Basic Land"") && !other.mType.contains(""Basic Land"")) {
return 1;
}
if (!this.mType.contains(""Basic Land"") && other.mType.contains(""Basic Land"")) {
return -1;
}
return this.mName.compareTo(other.mName);
}

//comment
//comment
//comment
//comment
if (this.getNumFromColor() > other.getNumFromColor()) {
return 1;
} else if (this.getNumFromColor() < other.getNumFromColor()) {
return -1;
}

//comment
<start>return this.mName.compareTo(other.mName);
}<end>"
6059,"    @Override
public void onPause() {
super.onPause();
StringBuilder playerData = new StringBuilder();
for (LcPlayer player : mPlayers) {
player.onPause();
playerData.append(player.toString());
}
PreferenceAdapter.setPlayerData(getContext(), playerData.toString());
mGridLayout.removeAllViews();
mPlayers.clear();

//comment
<start>requireActivity().getWindow().clearFlags(android.view.WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);<end>
onUserActive();
}","    @Override
public void onPause() {
super.onPause();
StringBuilder playerData = new StringBuilder();
for (LcPlayer player : mPlayers) {
player.onPause();
playerData.append(player.toString());
}
PreferenceAdapter.setPlayerData(getContext(), playerData.toString());
mGridLayout.removeAllViews();
mPlayers.clear();

//comment
<start>requireActivity().getWindow().clearFlags(android.view.WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);<end>
onUserActive();
}"
6060,"@Override
public boolean onOptionsItemSelected(MenuItem item) {
//comment
if (item.getItemId() == R.id.add_player) {
<start>addPlayer();
setCommanderInfo(-1);
addPlayerView(mPlayers.get(mPlayers.size() - 1));<end>
return true;
} else if (item.getItemId() == R.id.remove_player) {
showDialog(LifeCounterDialogFragment.DIALOG_REMOVE_PLAYER);
return true;
<start>} else if (item.getItemId() == R.id.announce_life) {<end>
announceLifeTotals();
return true;
} else if (item.getItemId() == R.id.edit_gatherings) {
GatheringsFragment rlFrag = new GatheringsFragment();
startNewFragment(rlFrag, null);
return true;
} else if (item.getItemId() == R.id.set_gathering) {
showDialog(LifeCounterDialogFragment.DIALOG_SET_GATHERING);
return true;
} else if (item.getItemId() == R.id.display_mode) {
showDialog(LifeCounterDialogFragment.DIALOG_CHANGE_DISPLAY);
return true;
} else {
return super.onOptionsItemSelected(item);
}
}","@Override
public boolean onOptionsItemSelected(MenuItem item) {
//comment
if (item.getItemId() == R.id.add_player) {
addPlayer();
setCommanderInfo(-1);
<start>addPlayerView(mPlayers.get(mPlayers.size() - 1));<end>
return true;
} else if (item.getItemId() == R.id.remove_player) {
showDialog(LifeCounterDialogFragment.DIALOG_REMOVE_PLAYER);
return true;
} else if (item.getItemId() == R.id.announce_life) {
announceLifeTotals();
return true;
} else if (item.getItemId() == R.id.edit_gatherings) {
GatheringsFragment rlFrag = new GatheringsFragment();
startNewFragment(rlFrag, null);
return true;
} else if (item.getItemId() == R.id.set_gathering) {
showDialog(LifeCounterDialogFragment.DIALOG_SET_GATHERING);
return true;
} else if (item.getItemId() == R.id.display_mode) {
showDialog(LifeCounterDialogFragment.DIALOG_CHANGE_DISPLAY);
return true;
} else {
return super.onOptionsItemSelected(item);
}
}"
6061,"@Override
public boolean onOptionsItemSelected(MenuItem item) {
//comment
if (item.getItemId() == R.id.add_player) {
addPlayer();
setCommanderInfo(-1);
addPlayerView(mPlayers.get(mPlayers.size() - 1));
return true;
<start>} else if (item.getItemId() == R.id.remove_player) {
showDialog(LifeCounterDialogFragment.DIALOG_REMOVE_PLAYER);<end>
return true;
} else if (item.getItemId() == R.id.announce_life) {
announceLifeTotals();
return true;
} else if (item.getItemId() == R.id.edit_gatherings) {
GatheringsFragment rlFrag = new GatheringsFragment();
startNewFragment(rlFrag, null);
return true;
} else if (item.getItemId() == R.id.set_gathering) {
showDialog(LifeCounterDialogFragment.DIALOG_SET_GATHERING);
return true;
} else if (item.getItemId() == R.id.display_mode) {
showDialog(LifeCounterDialogFragment.DIALOG_CHANGE_DISPLAY);
return true;
} else {
return super.onOptionsItemSelected(item);
}
}","@Override
public boolean onOptionsItemSelected(MenuItem item) {
//comment
if (item.getItemId() == R.id.add_player) {
addPlayer();
setCommanderInfo(-1);
addPlayerView(mPlayers.get(mPlayers.size() - 1));
return true;
} else if (item.getItemId() == R.id.remove_player) {
<start>showDialog(LifeCounterDialogFragment.DIALOG_REMOVE_PLAYER);<end>
return true;
} else if (item.getItemId() == R.id.announce_life) {
announceLifeTotals();
return true;
} else if (item.getItemId() == R.id.edit_gatherings) {
GatheringsFragment rlFrag = new GatheringsFragment();
startNewFragment(rlFrag, null);
return true;
} else if (item.getItemId() == R.id.set_gathering) {
showDialog(LifeCounterDialogFragment.DIALOG_SET_GATHERING);
return true;
} else if (item.getItemId() == R.id.display_mode) {
showDialog(LifeCounterDialogFragment.DIALOG_CHANGE_DISPLAY);
return true;
} else {
return super.onOptionsItemSelected(item);
}
}"
6062,"@Override
public boolean onOptionsItemSelected(MenuItem item) {
//comment
if (item.getItemId() == R.id.add_player) {
addPlayer();
setCommanderInfo(-1);
addPlayerView(mPlayers.get(mPlayers.size() - 1));
return true;
} else if (item.getItemId() == R.id.remove_player) {
showDialog(LifeCounterDialogFragment.DIALOG_REMOVE_PLAYER);
return true;
<start>} else if (item.getItemId() == R.id.announce_life) {
announceLifeTotals();
return true;<end>
} else if (item.getItemId() == R.id.edit_gatherings) {
GatheringsFragment rlFrag = new GatheringsFragment();
startNewFragment(rlFrag, null);
return true;
} else if (item.getItemId() == R.id.set_gathering) {
showDialog(LifeCounterDialogFragment.DIALOG_SET_GATHERING);
return true;
} else if (item.getItemId() == R.id.display_mode) {
showDialog(LifeCounterDialogFragment.DIALOG_CHANGE_DISPLAY);
return true;
} else {
return super.onOptionsItemSelected(item);
}
}","@Override
public boolean onOptionsItemSelected(MenuItem item) {
//comment
if (item.getItemId() == R.id.add_player) {
addPlayer();
setCommanderInfo(-1);
addPlayerView(mPlayers.get(mPlayers.size() - 1));
return true;
} else if (item.getItemId() == R.id.remove_player) {
showDialog(LifeCounterDialogFragment.DIALOG_REMOVE_PLAYER);
return true;
} else if (item.getItemId() == R.id.announce_life) {
<start>announceLifeTotals();<end>
return true;
} else if (item.getItemId() == R.id.edit_gatherings) {
GatheringsFragment rlFrag = new GatheringsFragment();
startNewFragment(rlFrag, null);
return true;
} else if (item.getItemId() == R.id.set_gathering) {
showDialog(LifeCounterDialogFragment.DIALOG_SET_GATHERING);
return true;
} else if (item.getItemId() == R.id.display_mode) {
showDialog(LifeCounterDialogFragment.DIALOG_CHANGE_DISPLAY);
return true;
} else {
return super.onOptionsItemSelected(item);
}
}"
6063,"@Override
public boolean onOptionsItemSelected(MenuItem item) {
//comment
if (item.getItemId() == R.id.add_player) {
addPlayer();
setCommanderInfo(-1);
addPlayerView(mPlayers.get(mPlayers.size() - 1));
return true;
} else if (item.getItemId() == R.id.remove_player) {
showDialog(LifeCounterDialogFragment.DIALOG_REMOVE_PLAYER);
return true;
} else if (item.getItemId() == R.id.announce_life) {
announceLifeTotals();
return true;
<start>} else if (item.getItemId() == R.id.edit_gatherings) {
GatheringsFragment rlFrag = new GatheringsFragment();
startNewFragment(rlFrag, null);
return true;<end>
} else if (item.getItemId() == R.id.set_gathering) {
showDialog(LifeCounterDialogFragment.DIALOG_SET_GATHERING);
return true;
} else if (item.getItemId() == R.id.display_mode) {
showDialog(LifeCounterDialogFragment.DIALOG_CHANGE_DISPLAY);
return true;
} else {
return super.onOptionsItemSelected(item);
}
}","@Override
public boolean onOptionsItemSelected(MenuItem item) {
//comment
if (item.getItemId() == R.id.add_player) {
addPlayer();
setCommanderInfo(-1);
addPlayerView(mPlayers.get(mPlayers.size() - 1));
return true;
} else if (item.getItemId() == R.id.remove_player) {
showDialog(LifeCounterDialogFragment.DIALOG_REMOVE_PLAYER);
return true;
} else if (item.getItemId() == R.id.announce_life) {
announceLifeTotals();
return true;
} else if (item.getItemId() == R.id.edit_gatherings) {
<start>GatheringsFragment rlFrag = new GatheringsFragment();
startNewFragment(rlFrag, null);<end>
return true;
} else if (item.getItemId() == R.id.set_gathering) {
showDialog(LifeCounterDialogFragment.DIALOG_SET_GATHERING);
return true;
} else if (item.getItemId() == R.id.display_mode) {
showDialog(LifeCounterDialogFragment.DIALOG_CHANGE_DISPLAY);
return true;
} else {
return super.onOptionsItemSelected(item);
}
}"
6064,"@Override
public boolean onOptionsItemSelected(MenuItem item) {
//comment
if (item.getItemId() == R.id.add_player) {
addPlayer();
setCommanderInfo(-1);
addPlayerView(mPlayers.get(mPlayers.size() - 1));
return true;
} else if (item.getItemId() == R.id.remove_player) {
showDialog(LifeCounterDialogFragment.DIALOG_REMOVE_PLAYER);
return true;
} else if (item.getItemId() == R.id.announce_life) {
announceLifeTotals();
return true;
} else if (item.getItemId() == R.id.edit_gatherings) {
GatheringsFragment rlFrag = new GatheringsFragment();
startNewFragment(rlFrag, null);
return true;
<start>} else if (item.getItemId() == R.id.set_gathering) {
showDialog(LifeCounterDialogFragment.DIALOG_SET_GATHERING);
return true;<end>
} else if (item.getItemId() == R.id.display_mode) {
showDialog(LifeCounterDialogFragment.DIALOG_CHANGE_DISPLAY);
return true;
} else {
return super.onOptionsItemSelected(item);
}
}","@Override
public boolean onOptionsItemSelected(MenuItem item) {
//comment
if (item.getItemId() == R.id.add_player) {
addPlayer();
setCommanderInfo(-1);
addPlayerView(mPlayers.get(mPlayers.size() - 1));
return true;
} else if (item.getItemId() == R.id.remove_player) {
showDialog(LifeCounterDialogFragment.DIALOG_REMOVE_PLAYER);
return true;
} else if (item.getItemId() == R.id.announce_life) {
announceLifeTotals();
return true;
} else if (item.getItemId() == R.id.edit_gatherings) {
GatheringsFragment rlFrag = new GatheringsFragment();
startNewFragment(rlFrag, null);
return true;
} else if (item.getItemId() == R.id.set_gathering) {
<start>showDialog(LifeCounterDialogFragment.DIALOG_SET_GATHERING);<end>
return true;
} else if (item.getItemId() == R.id.display_mode) {
showDialog(LifeCounterDialogFragment.DIALOG_CHANGE_DISPLAY);
return true;
} else {
return super.onOptionsItemSelected(item);
}
}"
6065,"@Override
public boolean onOptionsItemSelected(MenuItem item) {
//comment
if (item.getItemId() == R.id.add_player) {
addPlayer();
setCommanderInfo(-1);
addPlayerView(mPlayers.get(mPlayers.size() - 1));
return true;
} else if (item.getItemId() == R.id.remove_player) {
showDialog(LifeCounterDialogFragment.DIALOG_REMOVE_PLAYER);
return true;
} else if (item.getItemId() == R.id.announce_life) {
announceLifeTotals();
return true;
} else if (item.getItemId() == R.id.edit_gatherings) {
GatheringsFragment rlFrag = new GatheringsFragment();
startNewFragment(rlFrag, null);
return true;
} else if (item.getItemId() == R.id.set_gathering) {
showDialog(LifeCounterDialogFragment.DIALOG_SET_GATHERING);
return true;
} else if (item.getItemId() == R.id.display_mode) {
<start>showDialog(LifeCounterDialogFragment.DIALOG_CHANGE_DISPLAY);
return true;<end>
} else {
return super.onOptionsItemSelected(item);
}
}","@Override
public boolean onOptionsItemSelected(MenuItem item) {
//comment
if (item.getItemId() == R.id.add_player) {
addPlayer();
setCommanderInfo(-1);
addPlayerView(mPlayers.get(mPlayers.size() - 1));
return true;
} else if (item.getItemId() == R.id.remove_player) {
showDialog(LifeCounterDialogFragment.DIALOG_REMOVE_PLAYER);
return true;
} else if (item.getItemId() == R.id.announce_life) {
announceLifeTotals();
return true;
} else if (item.getItemId() == R.id.edit_gatherings) {
GatheringsFragment rlFrag = new GatheringsFragment();
startNewFragment(rlFrag, null);
return true;
} else if (item.getItemId() == R.id.set_gathering) {
showDialog(LifeCounterDialogFragment.DIALOG_SET_GATHERING);
return true;
} else if (item.getItemId() == R.id.display_mode) {
<start>showDialog(LifeCounterDialogFragment.DIALOG_CHANGE_DISPLAY);<end>
return true;
} else {
return super.onOptionsItemSelected(item);
}
}"
6066,"    private void showDialog(final int id) throws IllegalStateException {
//comment
//comment

//comment
<start>if (!this.isVisible()) {
return;
}<end>

removeDialog(getParentFragmentManager());

//comment
LifeCounterDialogFragment newFragment = new LifeCounterDialogFragment();
Bundle arguments = new Bundle();
arguments.putInt(FamiliarDialogFragment.ID_KEY, id);
newFragment.setArguments(arguments);
newFragment.show(getParentFragmentManager(), FamiliarActivity.DIALOG_TAG);
}","    private void showDialog(final int id) throws IllegalStateException {
//comment
//comment

//comment
<start>if (!this.isVisible()) {
return;
}<end>

removeDialog(getParentFragmentManager());

//comment
LifeCounterDialogFragment newFragment = new LifeCounterDialogFragment();
Bundle arguments = new Bundle();
arguments.putInt(FamiliarDialogFragment.ID_KEY, id);
newFragment.setArguments(arguments);
newFragment.show(getParentFragmentManager(), FamiliarActivity.DIALOG_TAG);
}"
6067,"    private void showDialog(final int id) throws IllegalStateException {
//comment
//comment

//comment
if (!this.isVisible()) {
return;
}

removeDialog(getParentFragmentManager());

//comment
<start>LifeCounterDialogFragment newFragment = new LifeCounterDialogFragment();<end>
Bundle arguments = new Bundle();
<start>arguments.putInt(FamiliarDialogFragment.ID_KEY, id);<end>
newFragment.setArguments(arguments);
newFragment.show(getParentFragmentManager(), FamiliarActivity.DIALOG_TAG);
}","    private void showDialog(final int id) throws IllegalStateException {
//comment
//comment

//comment
if (!this.isVisible()) {
return;
}

removeDialog(getParentFragmentManager());

//comment
<start>LifeCounterDialogFragment newFragment = new LifeCounterDialogFragment();
Bundle arguments = new Bundle();
arguments.putInt(FamiliarDialogFragment.ID_KEY, id);
newFragment.setArguments(arguments);
newFragment.show(getParentFragmentManager(), FamiliarActivity.DIALOG_TAG);<end>
}"
6068,"public void setCommanderInfo(int toBeRemoved) {
for (LcPlayer player1 : mPlayers) {
if (toBeRemoved != -1) {
player1.mCommanderDamage.remove(toBeRemoved);
} else {
for (int i = 0; i < mPlayers.size(); i++) {
//comment
if (player1.mCommanderDamage.size() > i) {
<start>player1.mCommanderDamage.get(i).mName = mPlayers.get(i).mName;<end>
}
//comment
else {
CommanderEntry ce = new CommanderEntry();
ce.mName = mPlayers.get(i).mName;
ce.mLife = 0;
player1.mCommanderDamage.add(ce);
}
}
}
//comment
if (player1.mCommanderDamageAdapter != null) {
player1.mCommanderDamageAdapter.notifyDataSetChanged();
}
}
}","public void setCommanderInfo(int toBeRemoved) {
for (LcPlayer player1 : mPlayers) {
if (toBeRemoved != -1) {
player1.mCommanderDamage.remove(toBeRemoved);
} else {
for (int i = 0; i < mPlayers.size(); i++) {
//comment
<start>if (player1.mCommanderDamage.size() > i) {
player1.mCommanderDamage.get(i).mName = mPlayers.get(i).mName;
}<end>
//comment
else {
CommanderEntry ce = new CommanderEntry();
ce.mName = mPlayers.get(i).mName;
ce.mLife = 0;
player1.mCommanderDamage.add(ce);
}
}
}
//comment
if (player1.mCommanderDamageAdapter != null) {
player1.mCommanderDamageAdapter.notifyDataSetChanged();
}
}
}"
6069,"public void setCommanderInfo(int toBeRemoved) {
for (LcPlayer player1 : mPlayers) {
if (toBeRemoved != -1) {
player1.mCommanderDamage.remove(toBeRemoved);
} else {
for (int i = 0; i < mPlayers.size(); i++) {
//comment
if (player1.mCommanderDamage.size() > i) {
<start>player1.mCommanderDamage.get(i).mName = mPlayers.get(i).mName;<end>
}
//comment
else {
<start>CommanderEntry ce = new CommanderEntry();<end>
ce.mName = mPlayers.get(i).mName;
ce.mLife = 0;
player1.mCommanderDamage.add(ce);
}
}
}
//comment
if (player1.mCommanderDamageAdapter != null) {
player1.mCommanderDamageAdapter.notifyDataSetChanged();
}
}
}","public void setCommanderInfo(int toBeRemoved) {
for (LcPlayer player1 : mPlayers) {
if (toBeRemoved != -1) {
player1.mCommanderDamage.remove(toBeRemoved);
} else {
for (int i = 0; i < mPlayers.size(); i++) {
//comment
<start>if (player1.mCommanderDamage.size() > i) {<end>
player1.mCommanderDamage.get(i).mName = mPlayers.get(i).mName;
<start>}
//comment
else {
CommanderEntry ce = new CommanderEntry();
ce.mName = mPlayers.get(i).mName;
ce.mLife = 0;
player1.mCommanderDamage.add(ce);
}<end>
}
}
//comment
if (player1.mCommanderDamageAdapter != null) {
player1.mCommanderDamageAdapter.notifyDataSetChanged();
}
}
}"
6070,"public void changeDisplayMode(boolean shouldDefaultLives) {
//comment
<start>PreferenceAdapter.setDisplayMode(getContext(), String.valueOf(mDisplayMode));<end>

mGridLayout.removeAllViews();

if (requireActivity().getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT) {
switch (mDisplayMode) {
case DISPLAY_NORMAL:
mGridLayout.setOrientation(GridLayout.HORIZONTAL);
mGridLayout.setColumnCount(1);
mGridLayout.setRowCount(GridLayout.UNDEFINED);
break;
case DISPLAY_COMPACT:
mGridLayout.setOrientation(GridLayout.HORIZONTAL);
mGridLayout.setColumnCount(mNumCols);
mGridLayout.setRowCount(GridLayout.UNDEFINED);
break;
case DISPLAY_COMMANDER:
mGridLayout.setOrientation(GridLayout.HORIZONTAL);
mGridLayout.setColumnCount(2);
mGridLayout.setRowCount(GridLayout.UNDEFINED);
break;
}
} else {
switch (mDisplayMode) {
case DISPLAY_NORMAL:
mGridLayout.setOrientation(GridLayout.VERTICAL);
mGridLayout.setColumnCount(GridLayout.UNDEFINED);
mGridLayout.setRowCount(1);
break;
case DISPLAY_COMPACT:
mGridLayout.setOrientation(GridLayout.VERTICAL);
mGridLayout.setColumnCount(GridLayout.UNDEFINED);
mGridLayout.setRowCount(mNumRows);
break;
case DISPLAY_COMMANDER:
mGridLayout.setOrientation(GridLayout.VERTICAL);
mGridLayout.setColumnCount(GridLayout.UNDEFINED);
if (mListSizeHeight != -1) {
float height = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 48,
getActivity().getResources().getDisplayMetrics());
mGridLayout.setRowCount((int) (mListSizeHeight / height));
} else {
mGridLayout.setRowCount(GridLayout.UNDEFINED);
}
break;
}
}

boolean areLivesDefault = true;
for (LcPlayer player : mPlayers) {
//comment
//comment
if (!(player.mLifeHistory.size() == 0
&& player.mPoisonHistory.size() == 0
&& player.mLife == player.mDefaultLifeTotal
&& (player.mDefaultLifeTotal == DEFAULT_LIFE || player.mDefaultLifeTotal == DEFAULT_LIFE_COMMANDER))) {
areLivesDefault = false;
}
}

if (areLivesDefault && shouldDefaultLives) {
for (LcPlayer player : mPlayers) {
player.mDefaultLifeTotal = getDefaultLife();
player.mLife = player.mDefaultLifeTotal;
}
}

for (LcPlayer player : mPlayers) {
//comment
addPlayerView(player);
}

if (mDisplayMode == DISPLAY_COMMANDER) {
mCommanderButton.setVisibility(View.VISIBLE);
mCommanderPlayerView.setVisibility(View.VISIBLE);
mCommanderPlayerView.removeAllViews();
if (mPlayers.size() > 0 && null != mPlayers.get(0).mView) {
mCommanderPlayerView.addView(mPlayers.get(0).mView);
mPlayers.get(0).setSize(mListSizeWidth, mListSizeHeight, mNumRows, mNumCols, mDisplayMode, getActivity().getResources()
.getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT,
mPlayers.size() == 1);
}
} else {
mCommanderPlayerView.setVisibility(View.GONE);
mCommanderButton.setVisibility(View.GONE);
if (mStatDisplaying == STAT_COMMANDER) {
setStatDisplaying(STAT_LIFE);
}
}
}","public void changeDisplayMode(boolean shouldDefaultLives) {
//comment
<start>PreferenceAdapter.setDisplayMode(getContext(), String.valueOf(mDisplayMode));

mGridLayout.removeAllViews();

if (requireActivity().getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT) {
switch (mDisplayMode) {
case DISPLAY_NORMAL:
mGridLayout.setOrientation(GridLayout.HORIZONTAL);
mGridLayout.setColumnCount(1);
mGridLayout.setRowCount(GridLayout.UNDEFINED);
break;
case DISPLAY_COMPACT:
mGridLayout.setOrientation(GridLayout.HORIZONTAL);
mGridLayout.setColumnCount(mNumCols);
mGridLayout.setRowCount(GridLayout.UNDEFINED);
break;
case DISPLAY_COMMANDER:
mGridLayout.setOrientation(GridLayout.HORIZONTAL);
mGridLayout.setColumnCount(2);
mGridLayout.setRowCount(GridLayout.UNDEFINED);
break;
}
} else {
switch (mDisplayMode) {
case DISPLAY_NORMAL:
mGridLayout.setOrientation(GridLayout.VERTICAL);
mGridLayout.setColumnCount(GridLayout.UNDEFINED);
mGridLayout.setRowCount(1);
break;
case DISPLAY_COMPACT:
mGridLayout.setOrientation(GridLayout.VERTICAL);
mGridLayout.setColumnCount(GridLayout.UNDEFINED);
mGridLayout.setRowCount(mNumRows);
break;
case DISPLAY_COMMANDER:
mGridLayout.setOrientation(GridLayout.VERTICAL);
mGridLayout.setColumnCount(GridLayout.UNDEFINED);
if (mListSizeHeight != -1) {
float height = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 48,
getActivity().getResources().getDisplayMetrics());
mGridLayout.setRowCount((int) (mListSizeHeight / height));
} else {
mGridLayout.setRowCount(GridLayout.UNDEFINED);
}
break;
}<end>
}

boolean areLivesDefault = true;
for (LcPlayer player : mPlayers) {
//comment
//comment
if (!(player.mLifeHistory.size() == 0
&& player.mPoisonHistory.size() == 0
&& player.mLife == player.mDefaultLifeTotal
&& (player.mDefaultLifeTotal == DEFAULT_LIFE || player.mDefaultLifeTotal == DEFAULT_LIFE_COMMANDER))) {
areLivesDefault = false;
}
}

if (areLivesDefault && shouldDefaultLives) {
for (LcPlayer player : mPlayers) {
player.mDefaultLifeTotal = getDefaultLife();
player.mLife = player.mDefaultLifeTotal;
}
}

for (LcPlayer player : mPlayers) {
//comment
addPlayerView(player);
}

if (mDisplayMode == DISPLAY_COMMANDER) {
mCommanderButton.setVisibility(View.VISIBLE);
mCommanderPlayerView.setVisibility(View.VISIBLE);
mCommanderPlayerView.removeAllViews();
if (mPlayers.size() > 0 && null != mPlayers.get(0).mView) {
mCommanderPlayerView.addView(mPlayers.get(0).mView);
mPlayers.get(0).setSize(mListSizeWidth, mListSizeHeight, mNumRows, mNumCols, mDisplayMode, getActivity().getResources()
.getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT,
mPlayers.size() == 1);
}
} else {
mCommanderPlayerView.setVisibility(View.GONE);
mCommanderButton.setVisibility(View.GONE);
if (mStatDisplaying == STAT_COMMANDER) {
setStatDisplaying(STAT_LIFE);
}
}
}"
6071,"private void addPlayerView(final LcPlayer player) {
try {
<start>mGridLayout.addView(player.newView(mDisplayMode, mStatDisplaying, mGridLayout, mCommanderPlayerView));<end>
} catch (IllegalArgumentException e) {
<start>return;<end>
}
if (mDisplayMode == DISPLAY_COMMANDER) {
<start>player.mCommanderRowView.setOnClickListener(view -> {
//comment
mCommanderPlayerView.removeAllViews();
mCommanderPlayerView.addView(player.mView);<end>
player.setSize(mListSizeWidth, mListSizeHeight, mNumRows, mNumCols, mDisplayMode,
requireActivity().getResources().getConfiguration().orientation
== Configuration.ORIENTATION_PORTRAIT, mPlayers.size() == 1
);
});

if (mPlayers.size() == 1) {
mCommanderPlayerView.addView(mPlayers.get(0).mView);
}
}

//comment
resizeAllPlayers();
}","private void addPlayerView(final LcPlayer player) {
try {
mGridLayout.addView(player.newView(mDisplayMode, mStatDisplaying, mGridLayout, mCommanderPlayerView));
} catch (IllegalArgumentException e) {
return;
}
if (mDisplayMode == DISPLAY_COMMANDER) {
<start>player.mCommanderRowView.setOnClickListener(view -> {
//comment
mCommanderPlayerView.removeAllViews();
mCommanderPlayerView.addView(player.mView);
player.setSize(mListSizeWidth, mListSizeHeight, mNumRows, mNumCols, mDisplayMode,
requireActivity().getResources().getConfiguration().orientation
== Configuration.ORIENTATION_PORTRAIT, mPlayers.size() == 1
);
});<end>

if (mPlayers.size() == 1) {
mCommanderPlayerView.addView(mPlayers.get(0).mView);
}
}

//comment
resizeAllPlayers();
}"
6072,"    public void addPlayer() {
<start>final LcPlayer player = new LcPlayer(this);<end>

//comment
<start>mLargestPlayerNumber++;
player.mName = getString(R.string.life_counter_default_name) + "" "" + mLargestPlayerNumber;
player.mDefaultLifeTotal = getDefaultLife();
player.mLife = player.mDefaultLifeTotal;<end>

resizeAllPlayers();

mPlayers.add(player);
}","    public void addPlayer() {
final LcPlayer player = new LcPlayer(this);

//comment
<start>mLargestPlayerNumber++;<end>
player.mName = getString(R.string.life_counter_default_name) + "" "" + mLargestPlayerNumber;
player.mDefaultLifeTotal = getDefaultLife();
player.mLife = player.mDefaultLifeTotal;

resizeAllPlayers();

mPlayers.add(player);
}"
6073,"public void addPlayer(String name, int startingLife) {
LcPlayer player = new LcPlayer(this);
<start>player.mName = name;
player.mDefaultLifeTotal = startingLife;<end>
player.mLife = startingLife;

//comment
//comment
<start>try {
String[] nameParts = player.mName.split("" "");
int number = Integer.parseInt(nameParts[nameParts.length - 1]);
if (number > mLargestPlayerNumber) {
mLargestPlayerNumber = number;
}
} catch (NumberFormatException e) {
//comment
}<end>

mPlayers.add(player);
}","public void addPlayer(String name, int startingLife) {
LcPlayer player = new LcPlayer(this);
player.mName = name;
player.mDefaultLifeTotal = startingLife;
player.mLife = startingLife;

//comment
//comment
try {
String[] nameParts = player.mName.split("" "");
int number = Integer.parseInt(nameParts[nameParts.length - 1]);
<start>if (number > mLargestPlayerNumber) {
mLargestPlayerNumber = number;
}<end>
} catch (NumberFormatException e) {
//comment
}

mPlayers.add(player);
}"
6074,"private void addPlayer(String line) {
try {
LcPlayer player = new LcPlayer(this);

String[] data = line.split("";"");

try {
player.mName = data[0];
} catch (Exception e) {
player.mName = getResources().getString(R.string.life_counter_default_name);
}

//comment
//comment
<start>try {
String[] nameParts = player.mName.split("" "");
int number = Integer.parseInt(nameParts[nameParts.length - 1]);
if (number > mLargestPlayerNumber) {
mLargestPlayerNumber = number;
}
} catch (NumberFormatException e) {
//comment
}<end>

try {
player.mLife = Integer.parseInt(data[1]);
} catch (Exception e) {
player.mLife = getDefaultLife();
}

try {
player.mDefaultLifeTotal = Integer.parseInt(data[5]);
} catch (Exception e) {
player.mDefaultLifeTotal = getDefaultLife();
}

try {
String[] lifeHistory = data[2].split("","");
player.mLifeHistory = new ArrayList<>(lifeHistory.length);
HistoryEntry entry;
for (int i = lifeHistory.length - 1; i >= 0; i--) {
entry = new HistoryEntry();
entry.mAbsolute = Integer.parseInt(lifeHistory[i]);
if (i != lifeHistory.length - 1) {
entry.mDelta = entry.mAbsolute - player.mLifeHistory.get(0).mAbsolute;
} else {
entry.mDelta = entry.mAbsolute - player.mDefaultLifeTotal;
}
player.mLifeHistory.add(0, entry);
}
} catch (NumberFormatException | ArrayIndexOutOfBoundsException e) {
player.mLifeHistory = new ArrayList<>();
}

try {
player.mPoison = Integer.parseInt(data[3]);
} catch (Exception e) {
player.mPoison = getDefaultLife();
}

try {
String[] poisonHistory = data[4].split("","");
player.mPoisonHistory = new ArrayList<>(poisonHistory.length);
HistoryEntry entry;
for (int i = poisonHistory.length - 1; i >= 0; i--) {
entry = new HistoryEntry();
entry.mAbsolute = Integer.parseInt(poisonHistory[i]);
if (i != poisonHistory.length - 1) {
entry.mDelta = entry.mAbsolute - player.mPoisonHistory.get(0).mAbsolute;
} else {
entry.mDelta = entry.mAbsolute;
}
player.mPoisonHistory.add(0, entry);
}

} catch (NumberFormatException | ArrayIndexOutOfBoundsException e) {
player.mPoisonHistory = new ArrayList<>();
}

try {
String[] commanderLifeString = data[6].split("","");
player.mCommanderDamage = new ArrayList<>(commanderLifeString.length);
CommanderEntry entry;
for (String aCommanderLifeString : commanderLifeString) {
entry = new CommanderEntry();
entry.mLife = Integer.parseInt(aCommanderLifeString);
player.mCommanderDamage.add(entry);
}
} catch (NumberFormatException | ArrayIndexOutOfBoundsException e) {
player.mCommanderDamage = new ArrayList<>();
}

try {
player.mCommanderCasting = Integer.parseInt(data[7]);
} catch (Exception e) {
player.mCommanderCasting = 0;
}

try {
player.mCommanderExperienceCounter = Integer.parseInt(data[8]);
} catch (Exception e) {
player.mCommanderExperienceCounter = 0;
}

mPlayers.add(player);
} catch (ArrayIndexOutOfBoundsException e) {
//comment
}
}","private void addPlayer(String line) {
try {
LcPlayer player = new LcPlayer(this);

String[] data = line.split("";"");

try {
player.mName = data[0];
} catch (Exception e) {
player.mName = getResources().getString(R.string.life_counter_default_name);
}

//comment
//comment
try {
String[] nameParts = player.mName.split("" "");
int number = Integer.parseInt(nameParts[nameParts.length - 1]);
<start>if (number > mLargestPlayerNumber) {
mLargestPlayerNumber = number;
}<end>
} catch (NumberFormatException e) {
//comment
}

try {
player.mLife = Integer.parseInt(data[1]);
} catch (Exception e) {
player.mLife = getDefaultLife();
}

try {
player.mDefaultLifeTotal = Integer.parseInt(data[5]);
} catch (Exception e) {
player.mDefaultLifeTotal = getDefaultLife();
}

try {
String[] lifeHistory = data[2].split("","");
player.mLifeHistory = new ArrayList<>(lifeHistory.length);
HistoryEntry entry;
for (int i = lifeHistory.length - 1; i >= 0; i--) {
entry = new HistoryEntry();
entry.mAbsolute = Integer.parseInt(lifeHistory[i]);
if (i != lifeHistory.length - 1) {
entry.mDelta = entry.mAbsolute - player.mLifeHistory.get(0).mAbsolute;
} else {
entry.mDelta = entry.mAbsolute - player.mDefaultLifeTotal;
}
player.mLifeHistory.add(0, entry);
}
} catch (NumberFormatException | ArrayIndexOutOfBoundsException e) {
player.mLifeHistory = new ArrayList<>();
}

try {
player.mPoison = Integer.parseInt(data[3]);
} catch (Exception e) {
player.mPoison = getDefaultLife();
}

try {
String[] poisonHistory = data[4].split("","");
player.mPoisonHistory = new ArrayList<>(poisonHistory.length);
HistoryEntry entry;
for (int i = poisonHistory.length - 1; i >= 0; i--) {
entry = new HistoryEntry();
entry.mAbsolute = Integer.parseInt(poisonHistory[i]);
if (i != poisonHistory.length - 1) {
entry.mDelta = entry.mAbsolute - player.mPoisonHistory.get(0).mAbsolute;
} else {
entry.mDelta = entry.mAbsolute;
}
player.mPoisonHistory.add(0, entry);
}

} catch (NumberFormatException | ArrayIndexOutOfBoundsException e) {
player.mPoisonHistory = new ArrayList<>();
}

try {
String[] commanderLifeString = data[6].split("","");
player.mCommanderDamage = new ArrayList<>(commanderLifeString.length);
CommanderEntry entry;
for (String aCommanderLifeString : commanderLifeString) {
entry = new CommanderEntry();
entry.mLife = Integer.parseInt(aCommanderLifeString);
player.mCommanderDamage.add(entry);
}
} catch (NumberFormatException | ArrayIndexOutOfBoundsException e) {
player.mCommanderDamage = new ArrayList<>();
}

try {
player.mCommanderCasting = Integer.parseInt(data[7]);
} catch (Exception e) {
player.mCommanderCasting = 0;
}

try {
player.mCommanderExperienceCounter = Integer.parseInt(data[8]);
} catch (Exception e) {
player.mCommanderExperienceCounter = 0;
}

mPlayers.add(player);
} catch (ArrayIndexOutOfBoundsException e) {
//comment
}
}"
120,"<start>    public static void checkOverrideSystemLanguage(Context context) {<end>

//comment
<start>String defaultLocale = context.getResources().getConfiguration().locale.getLanguage();<end>
boolean overrideSystemLanguage = !defaultLocale.equals(PreferenceAdapter.getLanguage(context));

if (overrideSystemLanguage) {
String localeString = PreferenceAdapter.getLanguage(context);

//comment
Locale locale = new Locale(localeString);
Locale.setDefault(locale);
Configuration config = new Configuration();
config.locale = locale;
context.getResources().updateConfiguration(config,
context.getResources().getDisplayMetrics());
}
}","    public static void checkOverrideSystemLanguage(Context context) {

//comment
<start>String defaultLocale = context.getResources().getConfiguration().locale.getLanguage();
boolean overrideSystemLanguage = !defaultLocale.equals(PreferenceAdapter.getLanguage(context));

if (overrideSystemLanguage) {<end>
String localeString = PreferenceAdapter.getLanguage(context);

//comment
Locale locale = new Locale(localeString);
Locale.setDefault(locale);
Configuration config = new Configuration();
config.locale = locale;
context.getResources().updateConfiguration(config,
context.getResources().getDisplayMetrics());
}
}"
121,"    public static void checkOverrideSystemLanguage(Context context) {

//comment
String defaultLocale = context.getResources().getConfiguration().locale.getLanguage();
boolean overrideSystemLanguage = !defaultLocale.equals(PreferenceAdapter.getLanguage(context));

if (overrideSystemLanguage) {
<start>String localeString = PreferenceAdapter.getLanguage(context);<end>

//comment
<start>Locale locale = new Locale(localeString);
Locale.setDefault(locale);<end>
Configuration config = new Configuration();
config.locale = locale;
context.getResources().updateConfiguration(config,
context.getResources().getDisplayMetrics());
}
}","    public static void checkOverrideSystemLanguage(Context context) {

//comment
String defaultLocale = context.getResources().getConfiguration().locale.getLanguage();
boolean overrideSystemLanguage = !defaultLocale.equals(PreferenceAdapter.getLanguage(context));

if (overrideSystemLanguage) {
String localeString = PreferenceAdapter.getLanguage(context);

//comment
<start>Locale locale = new Locale(localeString);
Locale.setDefault(locale);
Configuration config = new Configuration();
config.locale = locale;
context.getResources().updateConfiguration(config,
context.getResources().getDisplayMetrics());<end>
}
}"
122,"    @Override
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);

<start>mOldCacheVal = PreferenceAdapter.getImageCacheSize(getContext());
//comment
addPreferencesFromResource(R.xml.preferences);<end>
}","    @Override
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);

mOldCacheVal = PreferenceAdapter.getImageCacheSize(getContext());
//comment
<start>addPreferencesFromResource(R.xml.preferences);<end>
}"
123,"    @Override
public void onDestroy() {
super.onDestroy();

//comment
<start>if (PreferenceAdapter.getImageCacheSize(getContext()) != mOldCacheVal && null != getActivity()) {
getActivity().finish();
startActivity(new Intent(getContext(), FamiliarActivity.class).setAction(Intent.ACTION_MAIN));
}<end>
}","    @Override
public void onDestroy() {
super.onDestroy();

//comment
<start>if (PreferenceAdapter.getImageCacheSize(getContext()) != mOldCacheVal && null != getActivity()) {
getActivity().finish();
startActivity(new Intent(getContext(), FamiliarActivity.class).setAction(Intent.ACTION_MAIN));
}<end>
}"
2719,"    @NonNull
@Override
public Dialog onCreateDialog(Bundle savedInstanceState) {
if (!canCreateDialog()) {
return DontShowDialog();
}

mDialogId = requireArguments().getInt(ID_KEY);

if (null == getParentSearchViewFragment()) {
return DontShowDialog();
}

try {
//comment
//comment
<start>switch (mDialogId) {
case FORMAT_LIST: {
getParentSearchViewFragment().mFormatDialog = new MaterialDialog.Builder(this.requireActivity())<end>
.title(R.string.search_formats)
.items((CharSequence[]) getParentSearchViewFragment().mFormatNames)
.itemsCallbackSingleChoice(getParentSearchViewFragment().mSelectedFormat, (dialog, itemView, which, text) -> {
getParentSearchViewFragment().mSelectedFormat = which;
return true;
})
.positiveText(R.string.dialog_ok)
<start>.build();<end>
if (null != getParentSearchViewFragment()) {
return getParentSearchViewFragment().mFormatDialog;
}
return DontShowDialog();
}
case RARITY_LIST: {
getParentSearchViewFragment().mRarityDialog = new MaterialDialog.Builder(this.requireActivity())
.title(R.string.search_rarities)
.positiveText(R.string.dialog_ok)
.items((CharSequence[]) getParentSearchViewFragment().mRarityNames)
.alwaysCallMultiChoiceCallback()
.itemsCallbackMultiChoice(toIntegerArray(getParentSearchViewFragment().mRarityCheckedIndices), (dialog, which, text) -> {
getParentSearchViewFragment().mRarityCheckedIndices = toIntArray(which);
return true;
})
.build();
if (null != getParentSearchViewFragment()) {
return getParentSearchViewFragment().mRarityDialog;
}
return DontShowDialog();
}
default: {
savedInstanceState.putInt(""id"", mDialogId);
return super.onCreateDialog(savedInstanceState);
}
}
} catch (NullPointerException e) {
//comment
if (null != getParentSearchViewFragment()) {
getParentSearchViewFragment().handleFamiliarDbException(false);
}
return DontShowDialog();
}
}","    @NonNull
@Override
public Dialog onCreateDialog(Bundle savedInstanceState) {
if (!canCreateDialog()) {
return DontShowDialog();
}

mDialogId = requireArguments().getInt(ID_KEY);

if (null == getParentSearchViewFragment()) {
return DontShowDialog();
}

try {
//comment
//comment
<start>switch (mDialogId) {
case FORMAT_LIST: {
getParentSearchViewFragment().mFormatDialog = new MaterialDialog.Builder(this.requireActivity())
.title(R.string.search_formats)
.items((CharSequence[]) getParentSearchViewFragment().mFormatNames)
.itemsCallbackSingleChoice(getParentSearchViewFragment().mSelectedFormat, (dialog, itemView, which, text) -> {
getParentSearchViewFragment().mSelectedFormat = which;
return true;
})
.positiveText(R.string.dialog_ok)
.build();
if (null != getParentSearchViewFragment()) {
return getParentSearchViewFragment().mFormatDialog;
}
return DontShowDialog();
}
case RARITY_LIST: {
getParentSearchViewFragment().mRarityDialog = new MaterialDialog.Builder(this.requireActivity())
.title(R.string.search_rarities)
.positiveText(R.string.dialog_ok)
.items((CharSequence[]) getParentSearchViewFragment().mRarityNames)
.alwaysCallMultiChoiceCallback()
.itemsCallbackMultiChoice(toIntegerArray(getParentSearchViewFragment().mRarityCheckedIndices), (dialog, which, text) -> {
getParentSearchViewFragment().mRarityCheckedIndices = toIntArray(which);
return true;
})
.build();
if (null != getParentSearchViewFragment()) {
return getParentSearchViewFragment().mRarityDialog;
}
return DontShowDialog();
}
default: {
savedInstanceState.putInt(""id"", mDialogId);
return super.onCreateDialog(savedInstanceState);
}
}<end>
} catch (NullPointerException e) {
//comment
if (null != getParentSearchViewFragment()) {
getParentSearchViewFragment().handleFamiliarDbException(false);
}
return DontShowDialog();
}
}"
768,"    @NonNull
@Override
public Loader<Cursor> onCreateLoader(int id, Bundle args) {
//comment
//comment
String select = ""("" + CardDbAdapter.KEY_NAME + "")"";
<start>return new CursorLoader(mFragment.requireActivity(), SEARCH_URI, CARD_NAME_PROJECTION, select, mAutocompleteFilter,
CardDbAdapter.KEY_NAME + "" COLLATE LOCALIZED ASC"");<end>
}","    @NonNull
@Override
public Loader<Cursor> onCreateLoader(int id, Bundle args) {
//comment
//comment
<start>String select = ""("" + CardDbAdapter.KEY_NAME + "")"";
return new CursorLoader(mFragment.requireActivity(), SEARCH_URI, CARD_NAME_PROJECTION, select, mAutocompleteFilter,
CardDbAdapter.KEY_NAME + "" COLLATE LOCALIZED ASC"");<end>
}"
769,"    @Override
public CharSequence convertToString(@NonNull Cursor cursor) {
try {
return CardDbAdapter.getStringFromCursor(cursor, CardDbAdapter.KEY_NAME);
<start>} catch (Exception e) {
//comment
return """";<end>
}
}","    @Override
public CharSequence convertToString(@NonNull Cursor cursor) {
try {
return CardDbAdapter.getStringFromCursor(cursor, CardDbAdapter.KEY_NAME);
<start>} catch (Exception e) {
//comment
return """";
}<end>
}"
2828,"    public static void WriteDecklist(
Activity activity,
ArrayList<MtgCard> lDecklist,
String fileName) {

try {
fileName = sanitizeFilename(fileName);
FileOutputStream fos = activity.openFileOutput(fileName, Context.MODE_PRIVATE);
for (MtgCard m : lDecklist) {
String cardString = m.toWishlistString();
//comment
if (m.isSideboard()) {
<start>cardString = ""SB:"" + cardString;<end>
}
<start>fos.write(cardString.getBytes());<end>
}
fos.close();
} catch (IOException | IllegalArgumentException ioe) {
SnackbarWrapper.makeAndShowText(activity, ioe.getLocalizedMessage(), SnackbarWrapper.LENGTH_LONG);
}

}","    public static void WriteDecklist(
Activity activity,
ArrayList<MtgCard> lDecklist,
String fileName) {

try {
fileName = sanitizeFilename(fileName);
FileOutputStream fos = activity.openFileOutput(fileName, Context.MODE_PRIVATE);
for (MtgCard m : lDecklist) {
String cardString = m.toWishlistString();
//comment
<start>if (m.isSideboard()) {
cardString = ""SB:"" + cardString;
}
fos.write(cardString.getBytes());<end>
}
fos.close();
} catch (IOException | IllegalArgumentException ioe) {
SnackbarWrapper.makeAndShowText(activity, ioe.getLocalizedMessage(), SnackbarWrapper.LENGTH_LONG);
}

}"
2829,"    public static void WriteCompressedDecklist(
Activity activity,
List<CompressedDecklistInfo> compressedDecklist,
String fileName) {

if (null == activity) {
return;
}
try {

final String newFileName = sanitizeFilename(fileName);
FileOutputStream fos = activity.openFileOutput(newFileName, Context.MODE_PRIVATE);

//comment
for (CompressedDecklistInfo cdi : compressedDecklist) {
if (cdi.getName() != null && !cdi.getName().isEmpty()) {
for (CardHelpers.IndividualSetInfo isi : cdi.mInfo) {
<start>cdi.applyIndividualInfo(isi);<end>
String cardString = cdi.toWishlistString();
//comment
if (cdi.isSideboard()) {
<start>cardString = ""SB:"" + cardString;<end>
}
fos.write(cardString.getBytes());
}
}
}
fos.close();
} catch (IOException ioe) {
SnackbarWrapper.makeAndShowText(activity, ioe.getLocalizedMessage(), SnackbarWrapper.LENGTH_LONG);
}

}","    public static void WriteCompressedDecklist(
Activity activity,
List<CompressedDecklistInfo> compressedDecklist,
String fileName) {

if (null == activity) {
return;
}
try {

final String newFileName = sanitizeFilename(fileName);
FileOutputStream fos = activity.openFileOutput(newFileName, Context.MODE_PRIVATE);

//comment
<start>for (CompressedDecklistInfo cdi : compressedDecklist) {
if (cdi.getName() != null && !cdi.getName().isEmpty()) {
for (CardHelpers.IndividualSetInfo isi : cdi.mInfo) {
cdi.applyIndividualInfo(isi);
String cardString = cdi.toWishlistString();
//comment
if (cdi.isSideboard()) {
cardString = ""SB:"" + cardString;
}
fos.write(cardString.getBytes());
}
}
}<end>
fos.close();
} catch (IOException ioe) {
SnackbarWrapper.makeAndShowText(activity, ioe.getLocalizedMessage(), SnackbarWrapper.LENGTH_LONG);
}

}"
2830,"    public static void WriteCompressedDecklist(
Activity activity,
List<CompressedDecklistInfo> compressedDecklist,
String fileName) {

if (null == activity) {
return;
}
try {

final String newFileName = sanitizeFilename(fileName);
FileOutputStream fos = activity.openFileOutput(newFileName, Context.MODE_PRIVATE);

//comment
for (CompressedDecklistInfo cdi : compressedDecklist) {
if (cdi.getName() != null && !cdi.getName().isEmpty()) {
for (CardHelpers.IndividualSetInfo isi : cdi.mInfo) {
cdi.applyIndividualInfo(isi);
<start>String cardString = cdi.toWishlistString();
//comment
if (cdi.isSideboard()) {
cardString = ""SB:"" + cardString;
}<end>
fos.write(cardString.getBytes());
}
}
}
fos.close();
} catch (IOException ioe) {
SnackbarWrapper.makeAndShowText(activity, ioe.getLocalizedMessage(), SnackbarWrapper.LENGTH_LONG);
}

}","    public static void WriteCompressedDecklist(
Activity activity,
List<CompressedDecklistInfo> compressedDecklist,
String fileName) {

if (null == activity) {
return;
}
try {

final String newFileName = sanitizeFilename(fileName);
FileOutputStream fos = activity.openFileOutput(newFileName, Context.MODE_PRIVATE);

//comment
for (CompressedDecklistInfo cdi : compressedDecklist) {
if (cdi.getName() != null && !cdi.getName().isEmpty()) {
for (CardHelpers.IndividualSetInfo isi : cdi.mInfo) {
cdi.applyIndividualInfo(isi);
String cardString = cdi.toWishlistString();
//comment
<start>if (cdi.isSideboard()) {
cardString = ""SB:"" + cardString;
}<end>
fos.write(cardString.getBytes());
}
}
}
fos.close();
} catch (IOException ioe) {
SnackbarWrapper.makeAndShowText(activity, ioe.getLocalizedMessage(), SnackbarWrapper.LENGTH_LONG);
}

}"
2831,"public static ArrayList<MtgCard> ReadDecklist(Activity activity, String deckName, boolean loadFullData) throws FamiliarDbException {

ArrayList<MtgCard> lDecklist = new ArrayList<>();

try {
String line;
//comment
deckName = sanitizeFilename(deckName);
try (BufferedReader br = new BufferedReader(new InputStreamReader(activity.openFileInput(deckName)))) {
boolean isSideboard;
//comment
while ((line = br.readLine()) != null) {
isSideboard = false;
String sideboard = line.substring(0, 3);
//comment
//comment
if (sideboard.equals(""SB:"")) {
isSideboard = true;
line = line.substring(3);
}
MtgCard card = MtgCard.fromWishlistString(line, isSideboard, activity);
if (null != card) {
lDecklist.add(card);
}
}
}
} catch (NumberFormatException nfe) {
SnackbarWrapper.makeAndShowText(activity, nfe.getLocalizedMessage(), SnackbarWrapper.LENGTH_LONG);
} catch (IOException ioe) {
//comment
}

if (loadFullData && !lDecklist.isEmpty()) {
MtgCard.initCardListFromDb(activity, lDecklist);
}
return lDecklist;

}","public static ArrayList<MtgCard> ReadDecklist(Activity activity, String deckName, boolean loadFullData) throws FamiliarDbException {

ArrayList<MtgCard> lDecklist = new ArrayList<>();

try {
String line;
//comment
<start>deckName = sanitizeFilename(deckName);<end>
try (BufferedReader br = new BufferedReader(new InputStreamReader(activity.openFileInput(deckName)))) {
boolean isSideboard;
//comment
while ((line = br.readLine()) != null) {
isSideboard = false;
String sideboard = line.substring(0, 3);
//comment
//comment
if (sideboard.equals(""SB:"")) {
isSideboard = true;
line = line.substring(3);
}
MtgCard card = MtgCard.fromWishlistString(line, isSideboard, activity);
if (null != card) {
lDecklist.add(card);
}
}
}
} catch (NumberFormatException nfe) {
SnackbarWrapper.makeAndShowText(activity, nfe.getLocalizedMessage(), SnackbarWrapper.LENGTH_LONG);
} catch (IOException ioe) {
//comment
}

if (loadFullData && !lDecklist.isEmpty()) {
MtgCard.initCardListFromDb(activity, lDecklist);
}
return lDecklist;

}"
2832,"public static ArrayList<MtgCard> ReadDecklist(Activity activity, String deckName, boolean loadFullData) throws FamiliarDbException {

ArrayList<MtgCard> lDecklist = new ArrayList<>();

try {
String line;
//comment
deckName = sanitizeFilename(deckName);
try (BufferedReader br = new BufferedReader(new InputStreamReader(activity.openFileInput(deckName)))) {
boolean isSideboard;
//comment
while ((line = br.readLine()) != null) {
isSideboard = false;
String sideboard = line.substring(0, 3);
//comment
//comment
if (sideboard.equals(""SB:"")) {
isSideboard = true;
line = line.substring(3);
}
MtgCard card = MtgCard.fromWishlistString(line, isSideboard, activity);
if (null != card) {
lDecklist.add(card);
}
}
}
} catch (NumberFormatException nfe) {
SnackbarWrapper.makeAndShowText(activity, nfe.getLocalizedMessage(), SnackbarWrapper.LENGTH_LONG);
} catch (IOException ioe) {
//comment
}

if (loadFullData && !lDecklist.isEmpty()) {
MtgCard.initCardListFromDb(activity, lDecklist);
}
return lDecklist;

}","public static ArrayList<MtgCard> ReadDecklist(Activity activity, String deckName, boolean loadFullData) throws FamiliarDbException {

ArrayList<MtgCard> lDecklist = new ArrayList<>();

try {
String line;
//comment
deckName = sanitizeFilename(deckName);
try (BufferedReader br = new BufferedReader(new InputStreamReader(activity.openFileInput(deckName)))) {
boolean isSideboard;
//comment
<start>while ((line = br.readLine()) != null) {<end>
isSideboard = false;
String sideboard = line.substring(0, 3);
//comment
//comment
if (sideboard.equals(""SB:"")) {
isSideboard = true;
line = line.substring(3);
}
MtgCard card = MtgCard.fromWishlistString(line, isSideboard, activity);
if (null != card) {
<start>lDecklist.add(card);<end>
}
<start>}<end>
}
} catch (NumberFormatException nfe) {
SnackbarWrapper.makeAndShowText(activity, nfe.getLocalizedMessage(), SnackbarWrapper.LENGTH_LONG);
} catch (IOException ioe) {
//comment
}

if (loadFullData && !lDecklist.isEmpty()) {
MtgCard.initCardListFromDb(activity, lDecklist);
}
return lDecklist;

}"
2833,"public static ArrayList<MtgCard> ReadDecklist(Activity activity, String deckName, boolean loadFullData) throws FamiliarDbException {

ArrayList<MtgCard> lDecklist = new ArrayList<>();

try {
String line;
//comment
deckName = sanitizeFilename(deckName);
try (BufferedReader br = new BufferedReader(new InputStreamReader(activity.openFileInput(deckName)))) {
boolean isSideboard;
//comment
while ((line = br.readLine()) != null) {
isSideboard = false;
String sideboard = line.substring(0, 3);
//comment
//comment
if (sideboard.equals(""SB:"")) {
<start>isSideboard = true;<end>
line = line.substring(3);
}
MtgCard card = MtgCard.fromWishlistString(line, isSideboard, activity);
if (null != card) {
lDecklist.add(card);
}
}
}
} catch (NumberFormatException nfe) {
SnackbarWrapper.makeAndShowText(activity, nfe.getLocalizedMessage(), SnackbarWrapper.LENGTH_LONG);
} catch (IOException ioe) {
//comment
}

if (loadFullData && !lDecklist.isEmpty()) {
MtgCard.initCardListFromDb(activity, lDecklist);
}
return lDecklist;

}","public static ArrayList<MtgCard> ReadDecklist(Activity activity, String deckName, boolean loadFullData) throws FamiliarDbException {

ArrayList<MtgCard> lDecklist = new ArrayList<>();

try {
String line;
//comment
deckName = sanitizeFilename(deckName);
try (BufferedReader br = new BufferedReader(new InputStreamReader(activity.openFileInput(deckName)))) {
boolean isSideboard;
//comment
while ((line = br.readLine()) != null) {
isSideboard = false;
String sideboard = line.substring(0, 3);
//comment
//comment
<start>if (sideboard.equals(""SB:"")) {
isSideboard = true;
line = line.substring(3);
}<end>
MtgCard card = MtgCard.fromWishlistString(line, isSideboard, activity);
if (null != card) {
lDecklist.add(card);
}
}
}
} catch (NumberFormatException nfe) {
SnackbarWrapper.makeAndShowText(activity, nfe.getLocalizedMessage(), SnackbarWrapper.LENGTH_LONG);
} catch (IOException ioe) {
//comment
}

if (loadFullData && !lDecklist.isEmpty()) {
MtgCard.initCardListFromDb(activity, lDecklist);
}
return lDecklist;

}"
6224,"    public static void appendToLogFile(StringBuilder sb, String methodName) {
//comment
if (mLoggingEnabled && null != mExternalFileDirPath &&
Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) {

//comment
File logFile = new File(mExternalFileDirPath, DB_LOG_FILE_NAME);
if (!logFile.exists()) {
try {
logFile.createNewFile();
logDeviceInfo();
} catch (IOException e) {
e.printStackTrace();
}
}

//comment
try (FileWriter logWriter = new FileWriter(logFile, true)) {
//comment
logWriter.write(""Date : "" + (new Date()).toString() + '\n');
logWriter.write(""From : "" + methodName + '\n');
logWriter.write(sb.toString() + ""\n\n"");
} catch (IOException e) {
//comment
}
}
}","    public static void appendToLogFile(StringBuilder sb, String methodName) {
//comment
<start>if (mLoggingEnabled && null != mExternalFileDirPath &&
Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) {

//comment
File logFile = new File(mExternalFileDirPath, DB_LOG_FILE_NAME);
if (!logFile.exists()) {
try {
logFile.createNewFile();
logDeviceInfo();
} catch (IOException e) {
e.printStackTrace();
}
}

//comment
try (FileWriter logWriter = new FileWriter(logFile, true)) {
//comment
logWriter.write(""Date : "" + (new Date()).toString() + '\n');
logWriter.write(""From : "" + methodName + '\n');
logWriter.write(sb.toString() + ""\n\n"");
} catch (IOException e) {
//comment
}
}<end>
}"
6225,"    public static void appendToLogFile(StringBuilder sb, String methodName) {
//comment
if (mLoggingEnabled && null != mExternalFileDirPath &&
Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) {

//comment
<start>File logFile = new File(mExternalFileDirPath, DB_LOG_FILE_NAME);<end>
if (!logFile.exists()) {
try {
logFile.createNewFile();
logDeviceInfo();
} catch (IOException e) {
e.printStackTrace();
}
}

//comment
try (FileWriter logWriter = new FileWriter(logFile, true)) {
//comment
logWriter.write(""Date : "" + (new Date()).toString() + '\n');
logWriter.write(""From : "" + methodName + '\n');
logWriter.write(sb.toString() + ""\n\n"");
} catch (IOException e) {
//comment
}
}
}","    public static void appendToLogFile(StringBuilder sb, String methodName) {
//comment
if (mLoggingEnabled && null != mExternalFileDirPath &&
Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) {

//comment
<start>File logFile = new File(mExternalFileDirPath, DB_LOG_FILE_NAME);
if (!logFile.exists()) {
try {
logFile.createNewFile();
logDeviceInfo();
} catch (IOException e) {
e.printStackTrace();
}
}<end>

//comment
try (FileWriter logWriter = new FileWriter(logFile, true)) {
//comment
logWriter.write(""Date : "" + (new Date()).toString() + '\n');
logWriter.write(""From : "" + methodName + '\n');
logWriter.write(sb.toString() + ""\n\n"");
} catch (IOException e) {
//comment
}
}
}"
6226,"    public static void appendToLogFile(StringBuilder sb, String methodName) {
//comment
if (mLoggingEnabled && null != mExternalFileDirPath &&
Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) {

//comment
File logFile = new File(mExternalFileDirPath, DB_LOG_FILE_NAME);
if (!logFile.exists()) {
try {
logFile.createNewFile();
logDeviceInfo();
} catch (IOException e) {
e.printStackTrace();
}
}

//comment
try (FileWriter logWriter = new FileWriter(logFile, true)) {
//comment
<start>logWriter.write(""Date : "" + (new Date()).toString() + '\n');
logWriter.write(""From : "" + methodName + '\n');
logWriter.write(sb.toString() + ""\n\n"");<end>
} catch (IOException e) {
//comment
}
}
}","    public static void appendToLogFile(StringBuilder sb, String methodName) {
//comment
if (mLoggingEnabled && null != mExternalFileDirPath &&
Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) {

//comment
File logFile = new File(mExternalFileDirPath, DB_LOG_FILE_NAME);
if (!logFile.exists()) {
try {
logFile.createNewFile();
logDeviceInfo();
} catch (IOException e) {
e.printStackTrace();
}
}

//comment
<start>try (FileWriter logWriter = new FileWriter(logFile, true)) {
//comment
logWriter.write(""Date : "" + (new Date()).toString() + '\n');
logWriter.write(""From : "" + methodName + '\n');
logWriter.write(sb.toString() + ""\n\n"");
} catch (IOException e) {<end>
//comment
}
}
}"
6227,"    public static void appendToLogFile(StringBuilder sb, String methodName) {
//comment
if (mLoggingEnabled && null != mExternalFileDirPath &&
Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) {

//comment
File logFile = new File(mExternalFileDirPath, DB_LOG_FILE_NAME);
if (!logFile.exists()) {
try {
logFile.createNewFile();
logDeviceInfo();
} catch (IOException e) {
e.printStackTrace();
}
}

//comment
try (FileWriter logWriter = new FileWriter(logFile, true)) {
//comment
logWriter.write(""Date : "" + (new Date()).toString() + '\n');
<start>logWriter.write(""From : "" + methodName + '\n');<end>
logWriter.write(sb.toString() + ""\n\n"");
} catch (IOException e) {
//comment
}
}
}","    public static void appendToLogFile(StringBuilder sb, String methodName) {
//comment
if (mLoggingEnabled && null != mExternalFileDirPath &&
Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) {

//comment
File logFile = new File(mExternalFileDirPath, DB_LOG_FILE_NAME);
if (!logFile.exists()) {
try {
logFile.createNewFile();
logDeviceInfo();
} catch (IOException e) {
e.printStackTrace();
}
}

//comment
try (FileWriter logWriter = new FileWriter(logFile, true)) {
//comment
<start>logWriter.write(""Date : "" + (new Date()).toString() + '\n');<end>
logWriter.write(""From : "" + methodName + '\n');
logWriter.write(sb.toString() + ""\n\n"");
} catch (IOException e) {
//comment
}
}
}"
6228,"<start>    private static void logDeviceInfo() {
//comment
appendToLogFile(new StringBuilder(""Android SDK: "").append(Build.VERSION.SDK_INT)
.append("", Manufacturer: "").append(Build.MANUFACTURER)<end>
.append("", Model: "").append(Build.MODEL), ""SYS Info"");

//comment
try (BufferedReader br = new BufferedReader(new InputStreamReader(
new ProcessBuilder(""/system/bin/cat"", ""/proc/cpuinfo"").start().getInputStream()))) {
String line;
StringBuilder sb = new StringBuilder(""/proc/cpuinfo\n"");
while (null != (line = br.readLine())) {
sb.append(line).append('\n');
}
appendToLogFile(sb, ""CPU Info"");
} catch (IOException e) {
//comment
}

//comment
try (BufferedReader br = new BufferedReader(new InputStreamReader(
new ProcessBuilder(""/system/bin/cat"", ""/proc/meminfo"").start().getInputStream()))) {
String line;
StringBuilder sb = new StringBuilder(""/proc/meminfo\n"");
while (null != (line = br.readLine())) {
sb.append(line).append('\n');
}
appendToLogFile(sb, ""MEM Info"");
} catch (IOException e) {
//comment
}
}","    private static void logDeviceInfo() {
//comment
<start>appendToLogFile(new StringBuilder(""Android SDK: "").append(Build.VERSION.SDK_INT)
.append("", Manufacturer: "").append(Build.MANUFACTURER)
.append("", Model: "").append(Build.MODEL), ""SYS Info"");<end>

//comment
try (BufferedReader br = new BufferedReader(new InputStreamReader(
new ProcessBuilder(""/system/bin/cat"", ""/proc/cpuinfo"").start().getInputStream()))) {
String line;
StringBuilder sb = new StringBuilder(""/proc/cpuinfo\n"");
while (null != (line = br.readLine())) {
sb.append(line).append('\n');
}
appendToLogFile(sb, ""CPU Info"");
} catch (IOException e) {
//comment
}

//comment
try (BufferedReader br = new BufferedReader(new InputStreamReader(
new ProcessBuilder(""/system/bin/cat"", ""/proc/meminfo"").start().getInputStream()))) {
String line;
StringBuilder sb = new StringBuilder(""/proc/meminfo\n"");
while (null != (line = br.readLine())) {
sb.append(line).append('\n');
}
appendToLogFile(sb, ""MEM Info"");
} catch (IOException e) {
//comment
}
}"
6229,"    private static void logDeviceInfo() {
//comment
<start>appendToLogFile(new StringBuilder(""Android SDK: "").append(Build.VERSION.SDK_INT)<end>
.append("", Manufacturer: "").append(Build.MANUFACTURER)
.append("", Model: "").append(Build.MODEL), ""SYS Info"");

//comment
try (BufferedReader br = new BufferedReader(new InputStreamReader(
<start>new ProcessBuilder(""/system/bin/cat"", ""/proc/cpuinfo"").start().getInputStream()))) {<end>
String line;
StringBuilder sb = new StringBuilder(""/proc/cpuinfo\n"");
while (null != (line = br.readLine())) {
sb.append(line).append('\n');
}
<start>appendToLogFile(sb, ""CPU Info"");<end>
} catch (IOException e) {
//comment
}

//comment
try (BufferedReader br = new BufferedReader(new InputStreamReader(
new ProcessBuilder(""/system/bin/cat"", ""/proc/meminfo"").start().getInputStream()))) {
String line;
StringBuilder sb = new StringBuilder(""/proc/meminfo\n"");
while (null != (line = br.readLine())) {
sb.append(line).append('\n');
}
appendToLogFile(sb, ""MEM Info"");
} catch (IOException e) {
//comment
}
}","    private static void logDeviceInfo() {
//comment
appendToLogFile(new StringBuilder(""Android SDK: "").append(Build.VERSION.SDK_INT)
.append("", Manufacturer: "").append(Build.MANUFACTURER)
.append("", Model: "").append(Build.MODEL), ""SYS Info"");

//comment
<start>try (BufferedReader br = new BufferedReader(new InputStreamReader(
new ProcessBuilder(""/system/bin/cat"", ""/proc/cpuinfo"").start().getInputStream()))) {
String line;
StringBuilder sb = new StringBuilder(""/proc/cpuinfo\n"");
while (null != (line = br.readLine())) {
sb.append(line).append('\n');
}
appendToLogFile(sb, ""CPU Info"");
} catch (IOException e) {<end>
//comment
}

//comment
try (BufferedReader br = new BufferedReader(new InputStreamReader(
new ProcessBuilder(""/system/bin/cat"", ""/proc/meminfo"").start().getInputStream()))) {
String line;
StringBuilder sb = new StringBuilder(""/proc/meminfo\n"");
while (null != (line = br.readLine())) {
sb.append(line).append('\n');
}
appendToLogFile(sb, ""MEM Info"");
} catch (IOException e) {
//comment
}
}"
6230,"    private static void logDeviceInfo() {
//comment
appendToLogFile(new StringBuilder(""Android SDK: "").append(Build.VERSION.SDK_INT)
.append("", Manufacturer: "").append(Build.MANUFACTURER)
.append("", Model: "").append(Build.MODEL), ""SYS Info"");

//comment
try (BufferedReader br = new BufferedReader(new InputStreamReader(
new ProcessBuilder(""/system/bin/cat"", ""/proc/cpuinfo"").start().getInputStream()))) {
String line;
StringBuilder sb = new StringBuilder(""/proc/cpuinfo\n"");
while (null != (line = br.readLine())) {
sb.append(line).append('\n');
}
appendToLogFile(sb, ""CPU Info"");
} catch (IOException e) {
//comment
}

//comment
try (BufferedReader br = new BufferedReader(new InputStreamReader(
new ProcessBuilder(""/system/bin/cat"", ""/proc/meminfo"").start().getInputStream()))) {
String line;
StringBuilder sb = new StringBuilder(""/proc/meminfo\n"");
while (null != (line = br.readLine())) {
sb.append(line).append('\n');
}
appendToLogFile(sb, ""MEM Info"");
} catch (IOException e) {
//comment
}
}","    private static void logDeviceInfo() {
//comment
appendToLogFile(new StringBuilder(""Android SDK: "").append(Build.VERSION.SDK_INT)
.append("", Manufacturer: "").append(Build.MANUFACTURER)
.append("", Model: "").append(Build.MODEL), ""SYS Info"");

//comment
try (BufferedReader br = new BufferedReader(new InputStreamReader(
new ProcessBuilder(""/system/bin/cat"", ""/proc/cpuinfo"").start().getInputStream()))) {
String line;
StringBuilder sb = new StringBuilder(""/proc/cpuinfo\n"");
while (null != (line = br.readLine())) {
sb.append(line).append('\n');
}
appendToLogFile(sb, ""CPU Info"");
} catch (IOException e) {
//comment
}

//comment
<start>try (BufferedReader br = new BufferedReader(new InputStreamReader(
new ProcessBuilder(""/system/bin/cat"", ""/proc/meminfo"").start().getInputStream()))) {
String line;
StringBuilder sb = new StringBuilder(""/proc/meminfo\n"");
while (null != (line = br.readLine())) {
sb.append(line).append('\n');
}
appendToLogFile(sb, ""MEM Info"");
} catch (IOException e) {<end>
//comment
}
}"
6231,"private static void shareLog(FamiliarActivity activity) {
try (BufferedReader br = new BufferedReader(new FileReader(
<start>new File(activity.getExternalFilesDir(null), DB_LOG_FILE_NAME)))) {
//comment
StringBuilder sb = new StringBuilder();
String line;<end>
while (null != (line = br.readLine())) {
sb.append(line).append('\n');
}

//comment
ShareCompat.IntentBuilder.from(activity)
.setType(""message/rfc822"")
.addEmailTo(""mtg.familiar@gmail.com"")
.setSubject(activity.getString(R.string.logging_database_log))
.setText(sb.toString())
.setChooserTitle(activity.getString(R.string.logging_send_database_log))
.startChooser();
} catch (IOException e) {
//comment
}
}","private static void shareLog(FamiliarActivity activity) {
try (BufferedReader br = new BufferedReader(new FileReader(
new File(activity.getExternalFilesDir(null), DB_LOG_FILE_NAME)))) {
//comment
<start>StringBuilder sb = new StringBuilder();
String line;
while (null != (line = br.readLine())) {
sb.append(line).append('\n');<end>
}

//comment
ShareCompat.IntentBuilder.from(activity)
.setType(""message/rfc822"")
.addEmailTo(""mtg.familiar@gmail.com"")
.setSubject(activity.getString(R.string.logging_database_log))
.setText(sb.toString())
.setChooserTitle(activity.getString(R.string.logging_send_database_log))
.startChooser();
} catch (IOException e) {
//comment
}
}"
6232,"private static void shareLog(FamiliarActivity activity) {
try (BufferedReader br = new BufferedReader(new FileReader(
new File(activity.getExternalFilesDir(null), DB_LOG_FILE_NAME)))) {
//comment
StringBuilder sb = new StringBuilder();
String line;
while (null != (line = br.readLine())) {
sb.append(line).append('\n');
}

//comment
<start>ShareCompat.IntentBuilder.from(activity)<end>
.setType(""message/rfc822"")
.addEmailTo(""mtg.familiar@gmail.com"")
<start>.setSubject(activity.getString(R.string.logging_database_log))<end>
.setText(sb.toString())
.setChooserTitle(activity.getString(R.string.logging_send_database_log))
.startChooser();
} catch (IOException e) {
//comment
}
}","private static void shareLog(FamiliarActivity activity) {
try (BufferedReader br = new BufferedReader(new FileReader(
new File(activity.getExternalFilesDir(null), DB_LOG_FILE_NAME)))) {
//comment
StringBuilder sb = new StringBuilder();
String line;
while (null != (line = br.readLine())) {
sb.append(line).append('\n');
}

//comment
<start>ShareCompat.IntentBuilder.from(activity)
.setType(""message/rfc822"")
.addEmailTo(""mtg.familiar@gmail.com"")
.setSubject(activity.getString(R.string.logging_database_log))
.setText(sb.toString())
.setChooserTitle(activity.getString(R.string.logging_send_database_log))
.startChooser();<end>
} catch (IOException e) {
//comment
}
}"
6233,"    public static Dialog createDialog(FamiliarActivity familiarActivity, MaterialDialog.Builder builder) {
builder.title(R.string.logging_title);
builder.positiveText(R.string.dialog_ok);

//comment
LayoutInflater inflater = familiarActivity.getLayoutInflater();
@SuppressLint(""InflateParams"") View dialogLayout = inflater.inflate(R.layout.activity_dialog_logging, null, false);
assert dialogLayout != null;
((SwitchCompat) dialogLayout.findViewById(R.id.logging_switch)).setChecked(PreferenceAdapter.getLoggingPref(familiarActivity));
((SwitchCompat) dialogLayout.findViewById(R.id.logging_switch)).setOnCheckedChangeListener((buttonView, isChecked) -> {
//comment
if (!isChecked) {
<start>new File(mExternalFileDirPath, DB_LOG_FILE_NAME).delete();<end>
}
//comment
<start>PreferenceAdapter.setLoggingPref(familiarActivity, isChecked);<end>
mLoggingEnabled = isChecked;
});
dialogLayout.findViewById(R.id.export_db).setOnClickListener(v -> {
familiarActivity.removeDialogFragment(familiarActivity.getSupportFragmentManager());
FamiliarLogger.exportDatabase(familiarActivity);
});
dialogLayout.findViewById(R.id.share_log).setOnClickListener(v -> {
familiarActivity.removeDialogFragment(familiarActivity.getSupportFragmentManager());
FamiliarLogger.shareLog(familiarActivity);
});
builder.customView(dialogLayout, false);
return builder.build();
}","    public static Dialog createDialog(FamiliarActivity familiarActivity, MaterialDialog.Builder builder) {
builder.title(R.string.logging_title);
builder.positiveText(R.string.dialog_ok);

//comment
LayoutInflater inflater = familiarActivity.getLayoutInflater();
@SuppressLint(""InflateParams"") View dialogLayout = inflater.inflate(R.layout.activity_dialog_logging, null, false);
assert dialogLayout != null;
((SwitchCompat) dialogLayout.findViewById(R.id.logging_switch)).setChecked(PreferenceAdapter.getLoggingPref(familiarActivity));
((SwitchCompat) dialogLayout.findViewById(R.id.logging_switch)).setOnCheckedChangeListener((buttonView, isChecked) -> {
//comment
<start>if (!isChecked) {
new File(mExternalFileDirPath, DB_LOG_FILE_NAME).delete();
}<end>
//comment
PreferenceAdapter.setLoggingPref(familiarActivity, isChecked);
mLoggingEnabled = isChecked;
});
dialogLayout.findViewById(R.id.export_db).setOnClickListener(v -> {
familiarActivity.removeDialogFragment(familiarActivity.getSupportFragmentManager());
FamiliarLogger.exportDatabase(familiarActivity);
});
dialogLayout.findViewById(R.id.share_log).setOnClickListener(v -> {
familiarActivity.removeDialogFragment(familiarActivity.getSupportFragmentManager());
FamiliarLogger.shareLog(familiarActivity);
});
builder.customView(dialogLayout, false);
return builder.build();
}"
6234,"    public static Dialog createDialog(FamiliarActivity familiarActivity, MaterialDialog.Builder builder) {
builder.title(R.string.logging_title);
builder.positiveText(R.string.dialog_ok);

//comment
LayoutInflater inflater = familiarActivity.getLayoutInflater();
@SuppressLint(""InflateParams"") View dialogLayout = inflater.inflate(R.layout.activity_dialog_logging, null, false);
assert dialogLayout != null;
<start>((SwitchCompat) dialogLayout.findViewById(R.id.logging_switch)).setChecked(PreferenceAdapter.getLoggingPref(familiarActivity));
((SwitchCompat) dialogLayout.findViewById(R.id.logging_switch)).setOnCheckedChangeListener((buttonView, isChecked) -> {<end>
//comment
if (!isChecked) {
new File(mExternalFileDirPath, DB_LOG_FILE_NAME).delete();
}
//comment
<start>PreferenceAdapter.setLoggingPref(familiarActivity, isChecked);<end>
mLoggingEnabled = isChecked;
});
dialogLayout.findViewById(R.id.export_db).setOnClickListener(v -> {
familiarActivity.removeDialogFragment(familiarActivity.getSupportFragmentManager());
FamiliarLogger.exportDatabase(familiarActivity);
});
dialogLayout.findViewById(R.id.share_log).setOnClickListener(v -> {
familiarActivity.removeDialogFragment(familiarActivity.getSupportFragmentManager());
FamiliarLogger.shareLog(familiarActivity);
});
builder.customView(dialogLayout, false);
return builder.build();
}","    public static Dialog createDialog(FamiliarActivity familiarActivity, MaterialDialog.Builder builder) {
builder.title(R.string.logging_title);
builder.positiveText(R.string.dialog_ok);

//comment
LayoutInflater inflater = familiarActivity.getLayoutInflater();
@SuppressLint(""InflateParams"") View dialogLayout = inflater.inflate(R.layout.activity_dialog_logging, null, false);
assert dialogLayout != null;
((SwitchCompat) dialogLayout.findViewById(R.id.logging_switch)).setChecked(PreferenceAdapter.getLoggingPref(familiarActivity));
((SwitchCompat) dialogLayout.findViewById(R.id.logging_switch)).setOnCheckedChangeListener((buttonView, isChecked) -> {
//comment
if (!isChecked) {
new File(mExternalFileDirPath, DB_LOG_FILE_NAME).delete();
}
//comment
<start>PreferenceAdapter.setLoggingPref(familiarActivity, isChecked);<end>
mLoggingEnabled = isChecked;
});
dialogLayout.findViewById(R.id.export_db).setOnClickListener(v -> {
familiarActivity.removeDialogFragment(familiarActivity.getSupportFragmentManager());
FamiliarLogger.exportDatabase(familiarActivity);
});
dialogLayout.findViewById(R.id.share_log).setOnClickListener(v -> {
familiarActivity.removeDialogFragment(familiarActivity.getSupportFragmentManager());
FamiliarLogger.shareLog(familiarActivity);
});
builder.customView(dialogLayout, false);
return builder.build();
}"
10,"<start>    public static Spanned formatStringWithGlyphs(String source, ImageGetter imageGetter) {
//comment
if (source == null) {
return new SpannedString("""");
}<end>
source = source.replace(""{"", ""<img src=\"""").replace(""}"", ""\""/>"");
return Html.fromHtml(source, imageGetter, null);
}","    public static Spanned formatStringWithGlyphs(String source, ImageGetter imageGetter) {
//comment
<start>if (source == null) {
return new SpannedString("""");
}<end>
source = source.replace(""{"", ""<img src=\"""").replace(""}"", ""\""/>"");
return Html.fromHtml(source, imageGetter, null);
}"
11,"    public static Spanned formatHtmlString(String source) {
//comment
<start>if (source == null) {
return new SpannedString("""");
}<end>
return Html.fromHtml(source);
}","    public static Spanned formatHtmlString(String source) {
//comment
<start>if (source == null) {
return new SpannedString("""");
}<end>
return Html.fromHtml(source);
}"
1972,"public AccessToken getAccessToken(String publicKey, String privateKey, String accessToken)
throws IOException {

//comment
if (null == mAccessToken) {
//comment
<start>HttpURLConnection conn = (HttpURLConnection)
new URL(""https://api.tcgplayer.com/token"").openConnection();<end>
setDefaultOptions(conn, HttpMethod.POST);

//comment
conn.setRequestProperty(""Content-Type"", ""application/json"");
conn.setRequestProperty(""Accept"", ""application/json"");
conn.setRequestProperty(""X-Tcg-Access-Token"", accessToken);

//comment
String payload = ""grant_type=client_credentials&client_id="" + publicKey +
""&client_secret="" + privateKey;
conn.getOutputStream().write(payload.getBytes(StandardCharsets.UTF_8));

//comment
InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
return new AccessToken();
}
}

//comment
GsonBuilder builder = new GsonBuilder();
AccessToken.setDateFormat(builder);
AccessToken token = builder.create()
.fromJson(new InputStreamReader(inStream), AccessToken.class);
this.mAccessToken = token.access_token;

//comment
inStream.close();
conn.disconnect();

return token;
}

//comment
return null;
}","public AccessToken getAccessToken(String publicKey, String privateKey, String accessToken)
throws IOException {

//comment
<start>if (null == mAccessToken) {<end>
//comment
HttpURLConnection conn = (HttpURLConnection)
new URL(""https://api.tcgplayer.com/token"").openConnection();
setDefaultOptions(conn, HttpMethod.POST);

//comment
conn.setRequestProperty(""Content-Type"", ""application/json"");
conn.setRequestProperty(""Accept"", ""application/json"");
conn.setRequestProperty(""X-Tcg-Access-Token"", accessToken);

//comment
String payload = ""grant_type=client_credentials&client_id="" + publicKey +
""&client_secret="" + privateKey;
conn.getOutputStream().write(payload.getBytes(StandardCharsets.UTF_8));

//comment
InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
return new AccessToken();
}
}

//comment
GsonBuilder builder = new GsonBuilder();
AccessToken.setDateFormat(builder);
AccessToken token = builder.create()
.fromJson(new InputStreamReader(inStream), AccessToken.class);
this.mAccessToken = token.access_token;

//comment
inStream.close();
conn.disconnect();

return token;
}

//comment
return null;
}"
1973,"public AccessToken getAccessToken(String publicKey, String privateKey, String accessToken)
throws IOException {

//comment
if (null == mAccessToken) {
//comment
HttpURLConnection conn = (HttpURLConnection)
new URL(""https://api.tcgplayer.com/token"").openConnection();
setDefaultOptions(conn, HttpMethod.POST);

//comment
conn.setRequestProperty(""Content-Type"", ""application/json"");
conn.setRequestProperty(""Accept"", ""application/json"");
conn.setRequestProperty(""X-Tcg-Access-Token"", accessToken);

//comment
String payload = ""grant_type=client_credentials&client_id="" + publicKey +
""&client_secret="" + privateKey;
conn.getOutputStream().write(payload.getBytes(StandardCharsets.UTF_8));

//comment
InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
return new AccessToken();
}
}

//comment
GsonBuilder builder = new GsonBuilder();
AccessToken.setDateFormat(builder);
AccessToken token = builder.create()
.fromJson(new InputStreamReader(inStream), AccessToken.class);
this.mAccessToken = token.access_token;

//comment
inStream.close();
conn.disconnect();

return token;
}

//comment
return null;
}","public AccessToken getAccessToken(String publicKey, String privateKey, String accessToken)
throws IOException {

//comment
if (null == mAccessToken) {
//comment
<start>HttpURLConnection conn = (HttpURLConnection)
new URL(""https://api.tcgplayer.com/token"").openConnection();
setDefaultOptions(conn, HttpMethod.POST);<end>

//comment
conn.setRequestProperty(""Content-Type"", ""application/json"");
conn.setRequestProperty(""Accept"", ""application/json"");
conn.setRequestProperty(""X-Tcg-Access-Token"", accessToken);

//comment
String payload = ""grant_type=client_credentials&client_id="" + publicKey +
""&client_secret="" + privateKey;
conn.getOutputStream().write(payload.getBytes(StandardCharsets.UTF_8));

//comment
InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
return new AccessToken();
}
}

//comment
GsonBuilder builder = new GsonBuilder();
AccessToken.setDateFormat(builder);
AccessToken token = builder.create()
.fromJson(new InputStreamReader(inStream), AccessToken.class);
this.mAccessToken = token.access_token;

//comment
inStream.close();
conn.disconnect();

return token;
}

//comment
return null;
}"
1974,"<start>public AccessToken getAccessToken(String publicKey, String privateKey, String accessToken)<end>
throws IOException {

//comment
if (null == mAccessToken) {
//comment
HttpURLConnection conn = (HttpURLConnection)
new URL(""https://api.tcgplayer.com/token"").openConnection();
setDefaultOptions(conn, HttpMethod.POST);

//comment
<start>conn.setRequestProperty(""Content-Type"", ""application/json"");
conn.setRequestProperty(""Accept"", ""application/json"");
conn.setRequestProperty(""X-Tcg-Access-Token"", accessToken);<end>

//comment
String payload = ""grant_type=client_credentials&client_id="" + publicKey +
""&client_secret="" + privateKey;
conn.getOutputStream().write(payload.getBytes(StandardCharsets.UTF_8));

//comment
InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
return new AccessToken();
}
}

//comment
GsonBuilder builder = new GsonBuilder();
AccessToken.setDateFormat(builder);
AccessToken token = builder.create()
.fromJson(new InputStreamReader(inStream), AccessToken.class);
this.mAccessToken = token.access_token;

//comment
inStream.close();
conn.disconnect();

return token;
}

//comment
return null;
}","public AccessToken getAccessToken(String publicKey, String privateKey, String accessToken)
throws IOException {

//comment
if (null == mAccessToken) {
//comment
HttpURLConnection conn = (HttpURLConnection)
new URL(""https://api.tcgplayer.com/token"").openConnection();
setDefaultOptions(conn, HttpMethod.POST);

//comment
<start>conn.setRequestProperty(""Content-Type"", ""application/json"");
conn.setRequestProperty(""Accept"", ""application/json"");
conn.setRequestProperty(""X-Tcg-Access-Token"", accessToken);<end>

//comment
String payload = ""grant_type=client_credentials&client_id="" + publicKey +
""&client_secret="" + privateKey;
conn.getOutputStream().write(payload.getBytes(StandardCharsets.UTF_8));

//comment
InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
return new AccessToken();
}
}

//comment
GsonBuilder builder = new GsonBuilder();
AccessToken.setDateFormat(builder);
AccessToken token = builder.create()
.fromJson(new InputStreamReader(inStream), AccessToken.class);
this.mAccessToken = token.access_token;

//comment
inStream.close();
conn.disconnect();

return token;
}

//comment
return null;
}"
1975,"public AccessToken getAccessToken(String publicKey, String privateKey, String accessToken)
throws IOException {

//comment
if (null == mAccessToken) {
//comment
HttpURLConnection conn = (HttpURLConnection)
new URL(""https://api.tcgplayer.com/token"").openConnection();
setDefaultOptions(conn, HttpMethod.POST);

//comment
conn.setRequestProperty(""Content-Type"", ""application/json"");
<start>conn.setRequestProperty(""Accept"", ""application/json"");<end>
conn.setRequestProperty(""X-Tcg-Access-Token"", accessToken);

//comment
<start>String payload = ""grant_type=client_credentials&client_id="" + publicKey +
""&client_secret="" + privateKey;<end>
conn.getOutputStream().write(payload.getBytes(StandardCharsets.UTF_8));

//comment
InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
return new AccessToken();
}
}

//comment
GsonBuilder builder = new GsonBuilder();
AccessToken.setDateFormat(builder);
AccessToken token = builder.create()
.fromJson(new InputStreamReader(inStream), AccessToken.class);
this.mAccessToken = token.access_token;

//comment
inStream.close();
conn.disconnect();

return token;
}

//comment
return null;
}","public AccessToken getAccessToken(String publicKey, String privateKey, String accessToken)
throws IOException {

//comment
if (null == mAccessToken) {
//comment
HttpURLConnection conn = (HttpURLConnection)
new URL(""https://api.tcgplayer.com/token"").openConnection();
setDefaultOptions(conn, HttpMethod.POST);

//comment
conn.setRequestProperty(""Content-Type"", ""application/json"");
conn.setRequestProperty(""Accept"", ""application/json"");
conn.setRequestProperty(""X-Tcg-Access-Token"", accessToken);

//comment
<start>String payload = ""grant_type=client_credentials&client_id="" + publicKey +
""&client_secret="" + privateKey;
conn.getOutputStream().write(payload.getBytes(StandardCharsets.UTF_8));<end>

//comment
InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
return new AccessToken();
}
}

//comment
GsonBuilder builder = new GsonBuilder();
AccessToken.setDateFormat(builder);
AccessToken token = builder.create()
.fromJson(new InputStreamReader(inStream), AccessToken.class);
this.mAccessToken = token.access_token;

//comment
inStream.close();
conn.disconnect();

return token;
}

//comment
return null;
}"
1976,"public AccessToken getAccessToken(String publicKey, String privateKey, String accessToken)
throws IOException {

//comment
if (null == mAccessToken) {
//comment
HttpURLConnection conn = (HttpURLConnection)
new URL(""https://api.tcgplayer.com/token"").openConnection();
setDefaultOptions(conn, HttpMethod.POST);

//comment
conn.setRequestProperty(""Content-Type"", ""application/json"");
conn.setRequestProperty(""Accept"", ""application/json"");
conn.setRequestProperty(""X-Tcg-Access-Token"", accessToken);

//comment
String payload = ""grant_type=client_credentials&client_id="" + publicKey +
""&client_secret="" + privateKey;
<start>conn.getOutputStream().write(payload.getBytes(StandardCharsets.UTF_8));<end>

//comment
<start>InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
return new AccessToken();
}
}<end>

//comment
GsonBuilder builder = new GsonBuilder();
AccessToken.setDateFormat(builder);
AccessToken token = builder.create()
.fromJson(new InputStreamReader(inStream), AccessToken.class);
this.mAccessToken = token.access_token;

//comment
inStream.close();
conn.disconnect();

return token;
}

//comment
return null;
}","public AccessToken getAccessToken(String publicKey, String privateKey, String accessToken)
throws IOException {

//comment
if (null == mAccessToken) {
//comment
HttpURLConnection conn = (HttpURLConnection)
new URL(""https://api.tcgplayer.com/token"").openConnection();
setDefaultOptions(conn, HttpMethod.POST);

//comment
conn.setRequestProperty(""Content-Type"", ""application/json"");
conn.setRequestProperty(""Accept"", ""application/json"");
conn.setRequestProperty(""X-Tcg-Access-Token"", accessToken);

//comment
String payload = ""grant_type=client_credentials&client_id="" + publicKey +
""&client_secret="" + privateKey;
conn.getOutputStream().write(payload.getBytes(StandardCharsets.UTF_8));

//comment
<start>InputStream inStream;<end>
try {
<start>inStream = conn.getInputStream();<end>
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
return new AccessToken();
}
}

//comment
GsonBuilder builder = new GsonBuilder();
AccessToken.setDateFormat(builder);
AccessToken token = builder.create()
.fromJson(new InputStreamReader(inStream), AccessToken.class);
this.mAccessToken = token.access_token;

//comment
inStream.close();
conn.disconnect();

return token;
}

//comment
return null;
}"
1977,"public AccessToken getAccessToken(String publicKey, String privateKey, String accessToken)
throws IOException {

//comment
if (null == mAccessToken) {
//comment
HttpURLConnection conn = (HttpURLConnection)
new URL(""https://api.tcgplayer.com/token"").openConnection();
setDefaultOptions(conn, HttpMethod.POST);

//comment
conn.setRequestProperty(""Content-Type"", ""application/json"");
conn.setRequestProperty(""Accept"", ""application/json"");
conn.setRequestProperty(""X-Tcg-Access-Token"", accessToken);

//comment
String payload = ""grant_type=client_credentials&client_id="" + publicKey +
""&client_secret="" + privateKey;
conn.getOutputStream().write(payload.getBytes(StandardCharsets.UTF_8));

//comment
InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
<start>return new AccessToken();<end>
}
}

//comment
GsonBuilder builder = new GsonBuilder();
AccessToken.setDateFormat(builder);
AccessToken token = builder.create()
.fromJson(new InputStreamReader(inStream), AccessToken.class);
this.mAccessToken = token.access_token;

//comment
inStream.close();
conn.disconnect();

return token;
}

//comment
return null;
}","public AccessToken getAccessToken(String publicKey, String privateKey, String accessToken)
throws IOException {

//comment
if (null == mAccessToken) {
//comment
HttpURLConnection conn = (HttpURLConnection)
new URL(""https://api.tcgplayer.com/token"").openConnection();
setDefaultOptions(conn, HttpMethod.POST);

//comment
conn.setRequestProperty(""Content-Type"", ""application/json"");
conn.setRequestProperty(""Accept"", ""application/json"");
conn.setRequestProperty(""X-Tcg-Access-Token"", accessToken);

//comment
String payload = ""grant_type=client_credentials&client_id="" + publicKey +
""&client_secret="" + privateKey;
conn.getOutputStream().write(payload.getBytes(StandardCharsets.UTF_8));

//comment
InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
<start>return new AccessToken();<end>
}
}

//comment
GsonBuilder builder = new GsonBuilder();
AccessToken.setDateFormat(builder);
AccessToken token = builder.create()
.fromJson(new InputStreamReader(inStream), AccessToken.class);
this.mAccessToken = token.access_token;

//comment
inStream.close();
conn.disconnect();

return token;
}

//comment
return null;
}"
1978,"public AccessToken getAccessToken(String publicKey, String privateKey, String accessToken)
throws IOException {

//comment
if (null == mAccessToken) {
//comment
HttpURLConnection conn = (HttpURLConnection)
new URL(""https://api.tcgplayer.com/token"").openConnection();
setDefaultOptions(conn, HttpMethod.POST);

//comment
conn.setRequestProperty(""Content-Type"", ""application/json"");
conn.setRequestProperty(""Accept"", ""application/json"");
conn.setRequestProperty(""X-Tcg-Access-Token"", accessToken);

//comment
String payload = ""grant_type=client_credentials&client_id="" + publicKey +
""&client_secret="" + privateKey;
conn.getOutputStream().write(payload.getBytes(StandardCharsets.UTF_8));

//comment
InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
return new AccessToken();
}
}

//comment
<start>GsonBuilder builder = new GsonBuilder();<end>
AccessToken.setDateFormat(builder);
AccessToken token = builder.create()
.fromJson(new InputStreamReader(inStream), AccessToken.class);
this.mAccessToken = token.access_token;

//comment
inStream.close();
conn.disconnect();

return token;
}

//comment
return null;
}","public AccessToken getAccessToken(String publicKey, String privateKey, String accessToken)
throws IOException {

//comment
if (null == mAccessToken) {
//comment
HttpURLConnection conn = (HttpURLConnection)
new URL(""https://api.tcgplayer.com/token"").openConnection();
setDefaultOptions(conn, HttpMethod.POST);

//comment
conn.setRequestProperty(""Content-Type"", ""application/json"");
conn.setRequestProperty(""Accept"", ""application/json"");
conn.setRequestProperty(""X-Tcg-Access-Token"", accessToken);

//comment
String payload = ""grant_type=client_credentials&client_id="" + publicKey +
""&client_secret="" + privateKey;
conn.getOutputStream().write(payload.getBytes(StandardCharsets.UTF_8));

//comment
InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
return new AccessToken();
}
}

//comment
<start>GsonBuilder builder = new GsonBuilder();
AccessToken.setDateFormat(builder);
AccessToken token = builder.create()
.fromJson(new InputStreamReader(inStream), AccessToken.class);
this.mAccessToken = token.access_token;<end>

//comment
inStream.close();
conn.disconnect();

return token;
}

//comment
return null;
}"
1979,"public AccessToken getAccessToken(String publicKey, String privateKey, String accessToken)
throws IOException {

//comment
if (null == mAccessToken) {
//comment
HttpURLConnection conn = (HttpURLConnection)
new URL(""https://api.tcgplayer.com/token"").openConnection();
setDefaultOptions(conn, HttpMethod.POST);

//comment
conn.setRequestProperty(""Content-Type"", ""application/json"");
conn.setRequestProperty(""Accept"", ""application/json"");
conn.setRequestProperty(""X-Tcg-Access-Token"", accessToken);

//comment
String payload = ""grant_type=client_credentials&client_id="" + publicKey +
""&client_secret="" + privateKey;
conn.getOutputStream().write(payload.getBytes(StandardCharsets.UTF_8));

//comment
InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
return new AccessToken();
}
}

//comment
GsonBuilder builder = new GsonBuilder();
AccessToken.setDateFormat(builder);
AccessToken token = builder.create()
.fromJson(new InputStreamReader(inStream), AccessToken.class);
this.mAccessToken = token.access_token;

//comment
<start>inStream.close();
conn.disconnect();<end>

return token;
}

//comment
return null;
}","public AccessToken getAccessToken(String publicKey, String privateKey, String accessToken)
throws IOException {

//comment
if (null == mAccessToken) {
//comment
HttpURLConnection conn = (HttpURLConnection)
new URL(""https://api.tcgplayer.com/token"").openConnection();
setDefaultOptions(conn, HttpMethod.POST);

//comment
conn.setRequestProperty(""Content-Type"", ""application/json"");
conn.setRequestProperty(""Accept"", ""application/json"");
conn.setRequestProperty(""X-Tcg-Access-Token"", accessToken);

//comment
String payload = ""grant_type=client_credentials&client_id="" + publicKey +
""&client_secret="" + privateKey;
conn.getOutputStream().write(payload.getBytes(StandardCharsets.UTF_8));

//comment
InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
return new AccessToken();
}
}

//comment
GsonBuilder builder = new GsonBuilder();
AccessToken.setDateFormat(builder);
AccessToken token = builder.create()
.fromJson(new InputStreamReader(inStream), AccessToken.class);
this.mAccessToken = token.access_token;

//comment
<start>inStream.close();
conn.disconnect();<end>

return token;
}

//comment
return null;
}"
1980,"public ProductMarketPrice getProductMarketPrice(long[] productIds) throws IOException {
//comment
if (null != mAccessToken) {

//comment
StringBuilder stringIds = new StringBuilder();
for (long id : productIds) {
if (stringIds.length() > 0) {
stringIds.append(',');
}
stringIds.append(id);
}

//comment
HttpURLConnection conn = (HttpURLConnection) new URL(
""https://api.tcgplayer.com/"" + TCGP_VERSION + ""/pricing/product/"" +
stringIds.toString()).openConnection();
setDefaultOptions(conn, HttpMethod.GET);
addHeaders(conn);

//comment
InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
return new ProductMarketPrice();
}
}

//comment
ProductMarketPrice price = new Gson()
.fromJson(new InputStreamReader(inStream), ProductMarketPrice.class);

//comment
inStream.close();
conn.disconnect();
return price;
}
//comment
return null;
}","public ProductMarketPrice getProductMarketPrice(long[] productIds) throws IOException {
//comment
<start>if (null != mAccessToken) {<end>

//comment
StringBuilder stringIds = new StringBuilder();
for (long id : productIds) {
if (stringIds.length() > 0) {
stringIds.append(',');
}
stringIds.append(id);
}

//comment
HttpURLConnection conn = (HttpURLConnection) new URL(
""https://api.tcgplayer.com/"" + TCGP_VERSION + ""/pricing/product/"" +
stringIds.toString()).openConnection();
setDefaultOptions(conn, HttpMethod.GET);
addHeaders(conn);

//comment
InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
return new ProductMarketPrice();
}
}

//comment
ProductMarketPrice price = new Gson()
.fromJson(new InputStreamReader(inStream), ProductMarketPrice.class);

//comment
inStream.close();
conn.disconnect();
return price;
}
//comment
return null;
}"
1981,"public ProductMarketPrice getProductMarketPrice(long[] productIds) throws IOException {
//comment
if (null != mAccessToken) {

//comment
<start>StringBuilder stringIds = new StringBuilder();<end>
for (long id : productIds) {
if (stringIds.length() > 0) {
stringIds.append(',');
}
stringIds.append(id);
}

//comment
HttpURLConnection conn = (HttpURLConnection) new URL(
""https://api.tcgplayer.com/"" + TCGP_VERSION + ""/pricing/product/"" +
stringIds.toString()).openConnection();
setDefaultOptions(conn, HttpMethod.GET);
addHeaders(conn);

//comment
InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
return new ProductMarketPrice();
}
}

//comment
ProductMarketPrice price = new Gson()
.fromJson(new InputStreamReader(inStream), ProductMarketPrice.class);

//comment
inStream.close();
conn.disconnect();
return price;
}
//comment
return null;
}","public ProductMarketPrice getProductMarketPrice(long[] productIds) throws IOException {
//comment
if (null != mAccessToken) {

//comment
<start>StringBuilder stringIds = new StringBuilder();
for (long id : productIds) {
if (stringIds.length() > 0) {
stringIds.append(',');
}
stringIds.append(id);
}<end>

//comment
HttpURLConnection conn = (HttpURLConnection) new URL(
""https://api.tcgplayer.com/"" + TCGP_VERSION + ""/pricing/product/"" +
stringIds.toString()).openConnection();
setDefaultOptions(conn, HttpMethod.GET);
addHeaders(conn);

//comment
InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
return new ProductMarketPrice();
}
}

//comment
ProductMarketPrice price = new Gson()
.fromJson(new InputStreamReader(inStream), ProductMarketPrice.class);

//comment
inStream.close();
conn.disconnect();
return price;
}
//comment
return null;
}"
1982,"public ProductMarketPrice getProductMarketPrice(long[] productIds) throws IOException {
//comment
if (null != mAccessToken) {

//comment
StringBuilder stringIds = new StringBuilder();
for (long id : productIds) {
if (stringIds.length() > 0) {
stringIds.append(',');
}
stringIds.append(id);
}

//comment
<start>HttpURLConnection conn = (HttpURLConnection) new URL(
""https://api.tcgplayer.com/"" + TCGP_VERSION + ""/pricing/product/"" +
stringIds.toString()).openConnection();<end>
setDefaultOptions(conn, HttpMethod.GET);
addHeaders(conn);

//comment
InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
return new ProductMarketPrice();
}
}

//comment
ProductMarketPrice price = new Gson()
.fromJson(new InputStreamReader(inStream), ProductMarketPrice.class);

//comment
inStream.close();
conn.disconnect();
return price;
}
//comment
return null;
}","public ProductMarketPrice getProductMarketPrice(long[] productIds) throws IOException {
//comment
if (null != mAccessToken) {

//comment
StringBuilder stringIds = new StringBuilder();
for (long id : productIds) {
if (stringIds.length() > 0) {
stringIds.append(',');
}
stringIds.append(id);
}

//comment
<start>HttpURLConnection conn = (HttpURLConnection) new URL(
""https://api.tcgplayer.com/"" + TCGP_VERSION + ""/pricing/product/"" +
stringIds.toString()).openConnection();
setDefaultOptions(conn, HttpMethod.GET);
addHeaders(conn);<end>

//comment
InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
return new ProductMarketPrice();
}
}

//comment
ProductMarketPrice price = new Gson()
.fromJson(new InputStreamReader(inStream), ProductMarketPrice.class);

//comment
inStream.close();
conn.disconnect();
return price;
}
//comment
return null;
}"
1983,"public ProductMarketPrice getProductMarketPrice(long[] productIds) throws IOException {
//comment
if (null != mAccessToken) {

//comment
StringBuilder stringIds = new StringBuilder();
for (long id : productIds) {
if (stringIds.length() > 0) {
stringIds.append(',');
}
stringIds.append(id);
}

//comment
HttpURLConnection conn = (HttpURLConnection) new URL(
""https://api.tcgplayer.com/"" + TCGP_VERSION + ""/pricing/product/"" +
stringIds.toString()).openConnection();
setDefaultOptions(conn, HttpMethod.GET);
addHeaders(conn);

//comment
<start>InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
return new ProductMarketPrice();
}
}<end>

//comment
ProductMarketPrice price = new Gson()
.fromJson(new InputStreamReader(inStream), ProductMarketPrice.class);

//comment
inStream.close();
conn.disconnect();
return price;
}
//comment
return null;
}","public ProductMarketPrice getProductMarketPrice(long[] productIds) throws IOException {
//comment
if (null != mAccessToken) {

//comment
StringBuilder stringIds = new StringBuilder();
for (long id : productIds) {
if (stringIds.length() > 0) {
stringIds.append(',');
}
stringIds.append(id);
}

//comment
HttpURLConnection conn = (HttpURLConnection) new URL(
""https://api.tcgplayer.com/"" + TCGP_VERSION + ""/pricing/product/"" +
stringIds.toString()).openConnection();
setDefaultOptions(conn, HttpMethod.GET);
addHeaders(conn);

//comment
<start>InputStream inStream;<end>
try {
<start>inStream = conn.getInputStream();<end>
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
return new ProductMarketPrice();
}
}

//comment
ProductMarketPrice price = new Gson()
.fromJson(new InputStreamReader(inStream), ProductMarketPrice.class);

//comment
inStream.close();
conn.disconnect();
return price;
}
//comment
return null;
}"
1984,"public ProductMarketPrice getProductMarketPrice(long[] productIds) throws IOException {
//comment
if (null != mAccessToken) {

//comment
StringBuilder stringIds = new StringBuilder();
for (long id : productIds) {
if (stringIds.length() > 0) {
stringIds.append(',');
}
stringIds.append(id);
}

//comment
HttpURLConnection conn = (HttpURLConnection) new URL(
""https://api.tcgplayer.com/"" + TCGP_VERSION + ""/pricing/product/"" +
stringIds.toString()).openConnection();
setDefaultOptions(conn, HttpMethod.GET);
addHeaders(conn);

//comment
InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
<start>return new ProductMarketPrice();<end>
}
}

//comment
ProductMarketPrice price = new Gson()
.fromJson(new InputStreamReader(inStream), ProductMarketPrice.class);

//comment
inStream.close();
conn.disconnect();
return price;
}
//comment
return null;
}","public ProductMarketPrice getProductMarketPrice(long[] productIds) throws IOException {
//comment
if (null != mAccessToken) {

//comment
StringBuilder stringIds = new StringBuilder();
for (long id : productIds) {
if (stringIds.length() > 0) {
stringIds.append(',');
}
stringIds.append(id);
}

//comment
HttpURLConnection conn = (HttpURLConnection) new URL(
""https://api.tcgplayer.com/"" + TCGP_VERSION + ""/pricing/product/"" +
stringIds.toString()).openConnection();
setDefaultOptions(conn, HttpMethod.GET);
addHeaders(conn);

//comment
InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
<start>return new ProductMarketPrice();<end>
}
}

//comment
ProductMarketPrice price = new Gson()
.fromJson(new InputStreamReader(inStream), ProductMarketPrice.class);

//comment
inStream.close();
conn.disconnect();
return price;
}
//comment
return null;
}"
1985,"public ProductMarketPrice getProductMarketPrice(long[] productIds) throws IOException {
//comment
if (null != mAccessToken) {

//comment
StringBuilder stringIds = new StringBuilder();
for (long id : productIds) {
if (stringIds.length() > 0) {
stringIds.append(',');
}
stringIds.append(id);
}

//comment
HttpURLConnection conn = (HttpURLConnection) new URL(
""https://api.tcgplayer.com/"" + TCGP_VERSION + ""/pricing/product/"" +
stringIds.toString()).openConnection();
setDefaultOptions(conn, HttpMethod.GET);
addHeaders(conn);

//comment
InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
return new ProductMarketPrice();
}
}

//comment
<start>ProductMarketPrice price = new Gson()
.fromJson(new InputStreamReader(inStream), ProductMarketPrice.class);<end>

//comment
inStream.close();
conn.disconnect();
return price;
}
//comment
return null;
}","public ProductMarketPrice getProductMarketPrice(long[] productIds) throws IOException {
//comment
if (null != mAccessToken) {

//comment
StringBuilder stringIds = new StringBuilder();
for (long id : productIds) {
if (stringIds.length() > 0) {
stringIds.append(',');
}
stringIds.append(id);
}

//comment
HttpURLConnection conn = (HttpURLConnection) new URL(
""https://api.tcgplayer.com/"" + TCGP_VERSION + ""/pricing/product/"" +
stringIds.toString()).openConnection();
setDefaultOptions(conn, HttpMethod.GET);
addHeaders(conn);

//comment
InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
return new ProductMarketPrice();
}
}

//comment
<start>ProductMarketPrice price = new Gson()
.fromJson(new InputStreamReader(inStream), ProductMarketPrice.class);<end>

//comment
inStream.close();
conn.disconnect();
return price;
}
//comment
return null;
}"
1986,"public ProductMarketPrice getProductMarketPrice(long[] productIds) throws IOException {
//comment
if (null != mAccessToken) {

//comment
StringBuilder stringIds = new StringBuilder();
for (long id : productIds) {
if (stringIds.length() > 0) {
stringIds.append(',');
}
stringIds.append(id);
}

//comment
HttpURLConnection conn = (HttpURLConnection) new URL(
""https://api.tcgplayer.com/"" + TCGP_VERSION + ""/pricing/product/"" +
stringIds.toString()).openConnection();
setDefaultOptions(conn, HttpMethod.GET);
addHeaders(conn);

//comment
InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
return new ProductMarketPrice();
}
}

//comment
ProductMarketPrice price = new Gson()
.fromJson(new InputStreamReader(inStream), ProductMarketPrice.class);

//comment
<start>inStream.close();<end>
conn.disconnect();
return price;
}
//comment
return null;
}","public ProductMarketPrice getProductMarketPrice(long[] productIds) throws IOException {
//comment
if (null != mAccessToken) {

//comment
StringBuilder stringIds = new StringBuilder();
for (long id : productIds) {
if (stringIds.length() > 0) {
stringIds.append(',');
}
stringIds.append(id);
}

//comment
HttpURLConnection conn = (HttpURLConnection) new URL(
""https://api.tcgplayer.com/"" + TCGP_VERSION + ""/pricing/product/"" +
stringIds.toString()).openConnection();
setDefaultOptions(conn, HttpMethod.GET);
addHeaders(conn);

//comment
InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
return new ProductMarketPrice();
}
}

//comment
ProductMarketPrice price = new Gson()
.fromJson(new InputStreamReader(inStream), ProductMarketPrice.class);

//comment
<start>inStream.close();
conn.disconnect();<end>
return price;
}
//comment
return null;
}"
1987,"public ProductDetails getProductDetails(long[] productIds) throws IOException {
//comment
if (null != mAccessToken) {

//comment
StringBuilder stringIds = new StringBuilder();
for (long id : productIds) {
if (stringIds.length() > 0) {
stringIds.append(',');
}
stringIds.append(id);
}

//comment
HttpURLConnection conn = (HttpURLConnection) new URL(""https://api.tcgplayer.com/"" +
TCGP_VERSION + ""/catalog/products/"" + stringIds.toString()).openConnection();
setDefaultOptions(conn, HttpMethod.GET);
addHeaders(conn);

//comment
InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
return new ProductDetails();
}
}

//comment
GsonBuilder builder = new GsonBuilder();
CatalogData.CatalogDataItem.setDateFormat(builder);
ProductDetails details = builder.create()
.fromJson(new InputStreamReader(inStream), ProductDetails.class);

//comment
inStream.close();
conn.disconnect();
return details;
}
//comment
return null;
}","public ProductDetails getProductDetails(long[] productIds) throws IOException {
//comment
<start>if (null != mAccessToken) {<end>

//comment
StringBuilder stringIds = new StringBuilder();
for (long id : productIds) {
if (stringIds.length() > 0) {
stringIds.append(',');
}
stringIds.append(id);
}

//comment
HttpURLConnection conn = (HttpURLConnection) new URL(""https://api.tcgplayer.com/"" +
TCGP_VERSION + ""/catalog/products/"" + stringIds.toString()).openConnection();
setDefaultOptions(conn, HttpMethod.GET);
addHeaders(conn);

//comment
InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
return new ProductDetails();
}
}

//comment
GsonBuilder builder = new GsonBuilder();
CatalogData.CatalogDataItem.setDateFormat(builder);
ProductDetails details = builder.create()
.fromJson(new InputStreamReader(inStream), ProductDetails.class);

//comment
inStream.close();
conn.disconnect();
return details;
}
//comment
return null;
}"
1988,"public ProductDetails getProductDetails(long[] productIds) throws IOException {
//comment
if (null != mAccessToken) {

//comment
<start>StringBuilder stringIds = new StringBuilder();<end>
for (long id : productIds) {
if (stringIds.length() > 0) {
stringIds.append(',');
}
stringIds.append(id);
}

//comment
HttpURLConnection conn = (HttpURLConnection) new URL(""https://api.tcgplayer.com/"" +
TCGP_VERSION + ""/catalog/products/"" + stringIds.toString()).openConnection();
setDefaultOptions(conn, HttpMethod.GET);
addHeaders(conn);

//comment
InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
return new ProductDetails();
}
}

//comment
GsonBuilder builder = new GsonBuilder();
CatalogData.CatalogDataItem.setDateFormat(builder);
ProductDetails details = builder.create()
.fromJson(new InputStreamReader(inStream), ProductDetails.class);

//comment
inStream.close();
conn.disconnect();
return details;
}
//comment
return null;
}","public ProductDetails getProductDetails(long[] productIds) throws IOException {
//comment
if (null != mAccessToken) {

//comment
<start>StringBuilder stringIds = new StringBuilder();
for (long id : productIds) {
if (stringIds.length() > 0) {
stringIds.append(',');
}
stringIds.append(id);
}<end>

//comment
HttpURLConnection conn = (HttpURLConnection) new URL(""https://api.tcgplayer.com/"" +
TCGP_VERSION + ""/catalog/products/"" + stringIds.toString()).openConnection();
setDefaultOptions(conn, HttpMethod.GET);
addHeaders(conn);

//comment
InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
return new ProductDetails();
}
}

//comment
GsonBuilder builder = new GsonBuilder();
CatalogData.CatalogDataItem.setDateFormat(builder);
ProductDetails details = builder.create()
.fromJson(new InputStreamReader(inStream), ProductDetails.class);

//comment
inStream.close();
conn.disconnect();
return details;
}
//comment
return null;
}"
1989,"public ProductDetails getProductDetails(long[] productIds) throws IOException {
//comment
if (null != mAccessToken) {

//comment
StringBuilder stringIds = new StringBuilder();
for (long id : productIds) {
if (stringIds.length() > 0) {
stringIds.append(',');
}
stringIds.append(id);
}

//comment
<start>HttpURLConnection conn = (HttpURLConnection) new URL(""https://api.tcgplayer.com/"" +
TCGP_VERSION + ""/catalog/products/"" + stringIds.toString()).openConnection();<end>
setDefaultOptions(conn, HttpMethod.GET);
addHeaders(conn);

//comment
InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
return new ProductDetails();
}
}

//comment
GsonBuilder builder = new GsonBuilder();
CatalogData.CatalogDataItem.setDateFormat(builder);
ProductDetails details = builder.create()
.fromJson(new InputStreamReader(inStream), ProductDetails.class);

//comment
inStream.close();
conn.disconnect();
return details;
}
//comment
return null;
}","public ProductDetails getProductDetails(long[] productIds) throws IOException {
//comment
if (null != mAccessToken) {

//comment
StringBuilder stringIds = new StringBuilder();
for (long id : productIds) {
if (stringIds.length() > 0) {
stringIds.append(',');
}
stringIds.append(id);
}

//comment
<start>HttpURLConnection conn = (HttpURLConnection) new URL(""https://api.tcgplayer.com/"" +
TCGP_VERSION + ""/catalog/products/"" + stringIds.toString()).openConnection();
setDefaultOptions(conn, HttpMethod.GET);
addHeaders(conn);<end>

//comment
InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
return new ProductDetails();
}
}

//comment
GsonBuilder builder = new GsonBuilder();
CatalogData.CatalogDataItem.setDateFormat(builder);
ProductDetails details = builder.create()
.fromJson(new InputStreamReader(inStream), ProductDetails.class);

//comment
inStream.close();
conn.disconnect();
return details;
}
//comment
return null;
}"
1990,"public ProductDetails getProductDetails(long[] productIds) throws IOException {
//comment
if (null != mAccessToken) {

//comment
StringBuilder stringIds = new StringBuilder();
for (long id : productIds) {
if (stringIds.length() > 0) {
stringIds.append(',');
}
stringIds.append(id);
}

//comment
HttpURLConnection conn = (HttpURLConnection) new URL(""https://api.tcgplayer.com/"" +
TCGP_VERSION + ""/catalog/products/"" + stringIds.toString()).openConnection();
setDefaultOptions(conn, HttpMethod.GET);
addHeaders(conn);

//comment
<start>InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
return new ProductDetails();
}
}<end>

//comment
GsonBuilder builder = new GsonBuilder();
CatalogData.CatalogDataItem.setDateFormat(builder);
ProductDetails details = builder.create()
.fromJson(new InputStreamReader(inStream), ProductDetails.class);

//comment
inStream.close();
conn.disconnect();
return details;
}
//comment
return null;
}","public ProductDetails getProductDetails(long[] productIds) throws IOException {
//comment
if (null != mAccessToken) {

//comment
StringBuilder stringIds = new StringBuilder();
for (long id : productIds) {
if (stringIds.length() > 0) {
stringIds.append(',');
}
stringIds.append(id);
}

//comment
HttpURLConnection conn = (HttpURLConnection) new URL(""https://api.tcgplayer.com/"" +
TCGP_VERSION + ""/catalog/products/"" + stringIds.toString()).openConnection();
setDefaultOptions(conn, HttpMethod.GET);
addHeaders(conn);

//comment
<start>InputStream inStream;<end>
try {
<start>inStream = conn.getInputStream();<end>
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
return new ProductDetails();
}
}

//comment
GsonBuilder builder = new GsonBuilder();
CatalogData.CatalogDataItem.setDateFormat(builder);
ProductDetails details = builder.create()
.fromJson(new InputStreamReader(inStream), ProductDetails.class);

//comment
inStream.close();
conn.disconnect();
return details;
}
//comment
return null;
}"
1991,"public ProductDetails getProductDetails(long[] productIds) throws IOException {
//comment
if (null != mAccessToken) {

//comment
StringBuilder stringIds = new StringBuilder();
for (long id : productIds) {
if (stringIds.length() > 0) {
stringIds.append(',');
}
stringIds.append(id);
}

//comment
HttpURLConnection conn = (HttpURLConnection) new URL(""https://api.tcgplayer.com/"" +
TCGP_VERSION + ""/catalog/products/"" + stringIds.toString()).openConnection();
setDefaultOptions(conn, HttpMethod.GET);
addHeaders(conn);

//comment
InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
<start>return new ProductDetails();<end>
}
}

//comment
GsonBuilder builder = new GsonBuilder();
CatalogData.CatalogDataItem.setDateFormat(builder);
ProductDetails details = builder.create()
.fromJson(new InputStreamReader(inStream), ProductDetails.class);

//comment
inStream.close();
conn.disconnect();
return details;
}
//comment
return null;
}","public ProductDetails getProductDetails(long[] productIds) throws IOException {
//comment
if (null != mAccessToken) {

//comment
StringBuilder stringIds = new StringBuilder();
for (long id : productIds) {
if (stringIds.length() > 0) {
stringIds.append(',');
}
stringIds.append(id);
}

//comment
HttpURLConnection conn = (HttpURLConnection) new URL(""https://api.tcgplayer.com/"" +
TCGP_VERSION + ""/catalog/products/"" + stringIds.toString()).openConnection();
setDefaultOptions(conn, HttpMethod.GET);
addHeaders(conn);

//comment
InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
<start>return new ProductDetails();<end>
}
}

//comment
GsonBuilder builder = new GsonBuilder();
CatalogData.CatalogDataItem.setDateFormat(builder);
ProductDetails details = builder.create()
.fromJson(new InputStreamReader(inStream), ProductDetails.class);

//comment
inStream.close();
conn.disconnect();
return details;
}
//comment
return null;
}"
1992,"public ProductDetails getProductDetails(long[] productIds) throws IOException {
//comment
if (null != mAccessToken) {

//comment
StringBuilder stringIds = new StringBuilder();
for (long id : productIds) {
if (stringIds.length() > 0) {
stringIds.append(',');
}
stringIds.append(id);
}

//comment
HttpURLConnection conn = (HttpURLConnection) new URL(""https://api.tcgplayer.com/"" +
TCGP_VERSION + ""/catalog/products/"" + stringIds.toString()).openConnection();
setDefaultOptions(conn, HttpMethod.GET);
addHeaders(conn);

//comment
InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
return new ProductDetails();
}
}

//comment
<start>GsonBuilder builder = new GsonBuilder();<end>
CatalogData.CatalogDataItem.setDateFormat(builder);
ProductDetails details = builder.create()
.fromJson(new InputStreamReader(inStream), ProductDetails.class);

//comment
inStream.close();
conn.disconnect();
return details;
}
//comment
return null;
}","public ProductDetails getProductDetails(long[] productIds) throws IOException {
//comment
if (null != mAccessToken) {

//comment
StringBuilder stringIds = new StringBuilder();
for (long id : productIds) {
if (stringIds.length() > 0) {
stringIds.append(',');
}
stringIds.append(id);
}

//comment
HttpURLConnection conn = (HttpURLConnection) new URL(""https://api.tcgplayer.com/"" +
TCGP_VERSION + ""/catalog/products/"" + stringIds.toString()).openConnection();
setDefaultOptions(conn, HttpMethod.GET);
addHeaders(conn);

//comment
InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
return new ProductDetails();
}
}

//comment
<start>GsonBuilder builder = new GsonBuilder();
CatalogData.CatalogDataItem.setDateFormat(builder);
ProductDetails details = builder.create()
.fromJson(new InputStreamReader(inStream), ProductDetails.class);<end>

//comment
inStream.close();
conn.disconnect();
return details;
}
//comment
return null;
}"
1993,"public ProductDetails getProductDetails(long[] productIds) throws IOException {
//comment
if (null != mAccessToken) {

//comment
StringBuilder stringIds = new StringBuilder();
for (long id : productIds) {
if (stringIds.length() > 0) {
stringIds.append(',');
}
stringIds.append(id);
}

//comment
HttpURLConnection conn = (HttpURLConnection) new URL(""https://api.tcgplayer.com/"" +
TCGP_VERSION + ""/catalog/products/"" + stringIds.toString()).openConnection();
setDefaultOptions(conn, HttpMethod.GET);
addHeaders(conn);

//comment
InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
return new ProductDetails();
}
}

//comment
GsonBuilder builder = new GsonBuilder();
CatalogData.CatalogDataItem.setDateFormat(builder);
ProductDetails details = builder.create()
.fromJson(new InputStreamReader(inStream), ProductDetails.class);

//comment
<start>inStream.close();<end>
conn.disconnect();
return details;
}
//comment
return null;
}","public ProductDetails getProductDetails(long[] productIds) throws IOException {
//comment
if (null != mAccessToken) {

//comment
StringBuilder stringIds = new StringBuilder();
for (long id : productIds) {
if (stringIds.length() > 0) {
stringIds.append(',');
}
stringIds.append(id);
}

//comment
HttpURLConnection conn = (HttpURLConnection) new URL(""https://api.tcgplayer.com/"" +
TCGP_VERSION + ""/catalog/products/"" + stringIds.toString()).openConnection();
setDefaultOptions(conn, HttpMethod.GET);
addHeaders(conn);

//comment
InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
return new ProductDetails();
}
}

//comment
GsonBuilder builder = new GsonBuilder();
CatalogData.CatalogDataItem.setDateFormat(builder);
ProductDetails details = builder.create()
.fromJson(new InputStreamReader(inStream), ProductDetails.class);

//comment
<start>inStream.close();
conn.disconnect();<end>
return details;
}
//comment
return null;
}"
1321,"    @Override
public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

//comment
<start>View v = inflater.inflate(R.layout.card_view_pager, container, false);<end>
assert v != null;
mViewPager = v.findViewById(R.id.pager);

//comment
if (getParentFragment() == null) {
this.setRetainInstance(true);
}

Bundle args = getArguments();
long[] cardIds = Objects.requireNonNull(args).getLongArray(CARD_ID_ARRAY);
int currentPosition = args.getInt(STARTING_CARD_POSITION);

CardViewPagerAdapter pagerAdapter = new CardViewPagerAdapter(getChildFragmentManager(), cardIds);
mViewPager.setAdapter(pagerAdapter);
mViewPager.setCurrentItem(currentPosition);
mViewPager.setPageTransformer(true, new DepthPageTransformer());

return v;
}","    @Override
public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

//comment
<start>View v = inflater.inflate(R.layout.card_view_pager, container, false);
assert v != null;
mViewPager = v.findViewById(R.id.pager);<end>

//comment
if (getParentFragment() == null) {
this.setRetainInstance(true);
}

Bundle args = getArguments();
long[] cardIds = Objects.requireNonNull(args).getLongArray(CARD_ID_ARRAY);
int currentPosition = args.getInt(STARTING_CARD_POSITION);

CardViewPagerAdapter pagerAdapter = new CardViewPagerAdapter(getChildFragmentManager(), cardIds);
mViewPager.setAdapter(pagerAdapter);
mViewPager.setCurrentItem(currentPosition);
mViewPager.setPageTransformer(true, new DepthPageTransformer());

return v;
}"
1322,"    @Override
public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

//comment
View v = inflater.inflate(R.layout.card_view_pager, container, false);
assert v != null;
mViewPager = v.findViewById(R.id.pager);

//comment
<start>if (getParentFragment() == null) {
this.setRetainInstance(true);
}<end>

Bundle args = getArguments();
long[] cardIds = Objects.requireNonNull(args).getLongArray(CARD_ID_ARRAY);
int currentPosition = args.getInt(STARTING_CARD_POSITION);

CardViewPagerAdapter pagerAdapter = new CardViewPagerAdapter(getChildFragmentManager(), cardIds);
mViewPager.setAdapter(pagerAdapter);
mViewPager.setCurrentItem(currentPosition);
mViewPager.setPageTransformer(true, new DepthPageTransformer());

return v;
}","    @Override
public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

//comment
View v = inflater.inflate(R.layout.card_view_pager, container, false);
assert v != null;
mViewPager = v.findViewById(R.id.pager);

//comment
<start>if (getParentFragment() == null) {
this.setRetainInstance(true);
}<end>

Bundle args = getArguments();
long[] cardIds = Objects.requireNonNull(args).getLongArray(CARD_ID_ARRAY);
int currentPosition = args.getInt(STARTING_CARD_POSITION);

CardViewPagerAdapter pagerAdapter = new CardViewPagerAdapter(getChildFragmentManager(), cardIds);
mViewPager.setAdapter(pagerAdapter);
mViewPager.setCurrentItem(currentPosition);
mViewPager.setPageTransformer(true, new DepthPageTransformer());

return v;
}"
1323,"public void transformPage(@NonNull View view, float position) {
int pageWidth = view.getWidth();

if (position < -1) {
//comment
view.setAlpha(0);
} else if (position <= 0) {
//comment
view.setTranslationX(0);
view.setScaleX(1);
view.setScaleY(1);
view.setAlpha(1);
} else if (position <= 1) {
//comment
view.setAlpha(1 - position);

//comment
view.setTranslationX(pageWidth * -position);

//comment
<start>float MIN_SCALE = 0.75f;
float scaleFactor = MIN_SCALE + (1 - MIN_SCALE) * (1 - Math.abs(position));
view.setScaleX(scaleFactor);
view.setScaleY(scaleFactor);<end>

} else {
//comment
view.setAlpha(0);
}
}","public void transformPage(@NonNull View view, float position) {
int pageWidth = view.getWidth();

if (position < -1) {
//comment
view.setAlpha(0);
} else if (position <= 0) {
//comment
view.setTranslationX(0);
view.setScaleX(1);
view.setScaleY(1);
view.setAlpha(1);
} else if (position <= 1) {
//comment
view.setAlpha(1 - position);

//comment
view.setTranslationX(pageWidth * -position);

//comment
<start>float MIN_SCALE = 0.75f;
float scaleFactor = MIN_SCALE + (1 - MIN_SCALE) * (1 - Math.abs(position));<end>
view.setScaleX(scaleFactor);
view.setScaleY(scaleFactor);

} else {
//comment
view.setAlpha(0);
}
}"
2538,"    @Override
public View onCreateView(@NonNull LayoutInflater inflater,
ViewGroup container,
Bundle savedInstanceState) {

final View myFragmentView =
inflater.inflate(R.layout.decklist_frag, container, false);
assert myFragmentView != null;

final TextView.OnEditorActionListener addCardListener =
(textView, actionId, event) -> {

if (actionId == EditorInfo.IME_ACTION_SEARCH) {
addCardToDeck(false);
return true;
}
return false;

};

//comment
<start>synchronized (mCompressedDecklist) {<end>
initializeMembers(
myFragmentView,
new int[]{R.id.cardlist},
new CardDataAdapter[]{new DecklistDataAdapter(mCompressedDecklist)},
new int[]{R.id.decklistPrice}, null, R.menu.decklist_select_menu,
addCardListener);
}
myFragmentView.findViewById(R.id.add_card).setOnClickListener(view -> addCardToDeck(false));
myFragmentView.findViewById(R.id.add_card_sideboard).setOnClickListener(
v -> addCardToDeck(true));

//comment
mDeckName = myFragmentView.findViewById(R.id.decklistName);
mDeckName.setText(R.string.decklist_unnamed_deck);
mDeckCards = myFragmentView.findViewById(R.id.decklistCards);
updateDeckCounts(true);

mDecklistChain = new ComparatorChain<>();
mDecklistChain.addComparator(new CardHelpers.CardComparatorSideboard());
mDecklistChain.addComparator(new CardHelpers.CardComparatorSupertype(
getResources().getStringArray(R.array.card_types_extra)
));
mDecklistChain.addComparator(new CardHelpers.CardComparatorCMC());
mDecklistChain.addComparator(new CardHelpers.CardComparatorColor());
mDecklistChain.addComparator(new CardHelpers.CardComparatorName());


if (savedInstanceState != null) {
mCurrentDeck = Objects.requireNonNull(savedInstanceState.getBundle(FRAGMENT_TAG)).getString(CURRENT_DECKLIST_TAG);
readAndCompressDecklist(null, mCurrentDeck);
}

return myFragmentView;
}","    @Override
public View onCreateView(@NonNull LayoutInflater inflater,
ViewGroup container,
Bundle savedInstanceState) {

final View myFragmentView =
inflater.inflate(R.layout.decklist_frag, container, false);
assert myFragmentView != null;

final TextView.OnEditorActionListener addCardListener =
(textView, actionId, event) -> {

if (actionId == EditorInfo.IME_ACTION_SEARCH) {
addCardToDeck(false);
return true;
}
return false;

};

//comment
<start>synchronized (mCompressedDecklist) {
initializeMembers(
myFragmentView,
new int[]{R.id.cardlist},
new CardDataAdapter[]{new DecklistDataAdapter(mCompressedDecklist)},
new int[]{R.id.decklistPrice}, null, R.menu.decklist_select_menu,
addCardListener);
}<end>
myFragmentView.findViewById(R.id.add_card).setOnClickListener(view -> addCardToDeck(false));
myFragmentView.findViewById(R.id.add_card_sideboard).setOnClickListener(
v -> addCardToDeck(true));

//comment
mDeckName = myFragmentView.findViewById(R.id.decklistName);
mDeckName.setText(R.string.decklist_unnamed_deck);
mDeckCards = myFragmentView.findViewById(R.id.decklistCards);
updateDeckCounts(true);

mDecklistChain = new ComparatorChain<>();
mDecklistChain.addComparator(new CardHelpers.CardComparatorSideboard());
mDecklistChain.addComparator(new CardHelpers.CardComparatorSupertype(
getResources().getStringArray(R.array.card_types_extra)
));
mDecklistChain.addComparator(new CardHelpers.CardComparatorCMC());
mDecklistChain.addComparator(new CardHelpers.CardComparatorColor());
mDecklistChain.addComparator(new CardHelpers.CardComparatorName());


if (savedInstanceState != null) {
mCurrentDeck = Objects.requireNonNull(savedInstanceState.getBundle(FRAGMENT_TAG)).getString(CURRENT_DECKLIST_TAG);
readAndCompressDecklist(null, mCurrentDeck);
}

return myFragmentView;
}"
2539,"<start>private void addCardToDeck(final boolean isSideboard) {<end>

//comment
<start>if (getCardNameInput() == null || getCardNameInput().length() == 0 ||
getCardNumberInput() == null || getCardNumberInput().length() == 0) {
return;
}<end>

ArrayList<String> nonFoilSets;
FamiliarDbHandle handle = new FamiliarDbHandle();
try {
SQLiteDatabase database = DatabaseManager.openDatabase(getContext(), false, handle);
nonFoilSets = CardDbAdapter.getNonFoilSets(database);
} catch (SQLiteException | FamiliarDbException | IllegalStateException ignored) {
nonFoilSets = new ArrayList<>();
} finally {
DatabaseManager.closeDatabase(getContext(), handle);
}

final String name = String.valueOf(getCardNameInput());
final String numberOf = String.valueOf(getCardNumberInput());
try {
final MtgCard card = new MtgCard(getActivity(), name, null, null,
checkboxFoilIsChecked(), Integer.parseInt(numberOf), isSideboard);

final CompressedDecklistInfo decklistInfo =
new CompressedDecklistInfo(card);

synchronized (mCompressedDecklist) {
//comment
if (mCompressedDecklist.contains(decklistInfo)) {
boolean added = false;
final int firstIndex = mCompressedDecklist.indexOf(decklistInfo);
final CompressedDecklistInfo firstCard =
mCompressedDecklist.get(firstIndex);
for (int i = 0; i < firstCard.mInfo.size(); i++) {
CardHelpers.IndividualSetInfo firstIsi = firstCard.mInfo.get(i);
if (firstIsi.mSetCode.equals(card.getExpansion()) &&
(firstIsi.mIsFoil.equals(card.mIsFoil) || nonFoilSets.contains(firstIsi.mSetCode))) {
firstIsi.mNumberOf++;
added = true;
break;
}
}
if (!added) {
firstCard.add(card);
}
} else {
mCompressedDecklist.add(new CompressedDecklistInfo(card));
}

//comment
clearHeaders();

//comment
if (shouldShowPrice()) {
loadPrice(card);
}

//comment
Collections.sort(mCompressedDecklist, mDecklistChain);

if (!mDecklistReadError) {
//comment
DecklistHelpers.WriteCompressedDecklist(getActivity(), mCompressedDecklist, getCurrentDeckName());
}
}

//comment
clearCardNameInput();

//comment
//comment

//comment
uncheckFoilCheckbox();

//comment
updateDeckCounts(false);

//comment
setHeaderValues();
getCardDataAdapter(0).notifyDataSetChanged();
} catch (java.lang.InstantiationException e) {
//comment
}

}","private void addCardToDeck(final boolean isSideboard) {

//comment
<start>if (getCardNameInput() == null || getCardNameInput().length() == 0 ||
getCardNumberInput() == null || getCardNumberInput().length() == 0) {
return;
}<end>

ArrayList<String> nonFoilSets;
FamiliarDbHandle handle = new FamiliarDbHandle();
try {
SQLiteDatabase database = DatabaseManager.openDatabase(getContext(), false, handle);
nonFoilSets = CardDbAdapter.getNonFoilSets(database);
} catch (SQLiteException | FamiliarDbException | IllegalStateException ignored) {
nonFoilSets = new ArrayList<>();
} finally {
DatabaseManager.closeDatabase(getContext(), handle);
}

final String name = String.valueOf(getCardNameInput());
final String numberOf = String.valueOf(getCardNumberInput());
try {
final MtgCard card = new MtgCard(getActivity(), name, null, null,
checkboxFoilIsChecked(), Integer.parseInt(numberOf), isSideboard);

final CompressedDecklistInfo decklistInfo =
new CompressedDecklistInfo(card);

synchronized (mCompressedDecklist) {
//comment
if (mCompressedDecklist.contains(decklistInfo)) {
boolean added = false;
final int firstIndex = mCompressedDecklist.indexOf(decklistInfo);
final CompressedDecklistInfo firstCard =
mCompressedDecklist.get(firstIndex);
for (int i = 0; i < firstCard.mInfo.size(); i++) {
CardHelpers.IndividualSetInfo firstIsi = firstCard.mInfo.get(i);
if (firstIsi.mSetCode.equals(card.getExpansion()) &&
(firstIsi.mIsFoil.equals(card.mIsFoil) || nonFoilSets.contains(firstIsi.mSetCode))) {
firstIsi.mNumberOf++;
added = true;
break;
}
}
if (!added) {
firstCard.add(card);
}
} else {
mCompressedDecklist.add(new CompressedDecklistInfo(card));
}

//comment
clearHeaders();

//comment
if (shouldShowPrice()) {
loadPrice(card);
}

//comment
Collections.sort(mCompressedDecklist, mDecklistChain);

if (!mDecklistReadError) {
//comment
DecklistHelpers.WriteCompressedDecklist(getActivity(), mCompressedDecklist, getCurrentDeckName());
}
}

//comment
clearCardNameInput();

//comment
//comment

//comment
uncheckFoilCheckbox();

//comment
updateDeckCounts(false);

//comment
setHeaderValues();
getCardDataAdapter(0).notifyDataSetChanged();
} catch (java.lang.InstantiationException e) {
//comment
}

}"
2540,"private void addCardToDeck(final boolean isSideboard) {

//comment
if (getCardNameInput() == null || getCardNameInput().length() == 0 ||
getCardNumberInput() == null || getCardNumberInput().length() == 0) {
return;
}

ArrayList<String> nonFoilSets;
FamiliarDbHandle handle = new FamiliarDbHandle();
try {
SQLiteDatabase database = DatabaseManager.openDatabase(getContext(), false, handle);
nonFoilSets = CardDbAdapter.getNonFoilSets(database);
} catch (SQLiteException | FamiliarDbException | IllegalStateException ignored) {
nonFoilSets = new ArrayList<>();
} finally {
DatabaseManager.closeDatabase(getContext(), handle);
}

final String name = String.valueOf(getCardNameInput());
final String numberOf = String.valueOf(getCardNumberInput());
try {
final MtgCard card = new MtgCard(getActivity(), name, null, null,
checkboxFoilIsChecked(), Integer.parseInt(numberOf), isSideboard);

final CompressedDecklistInfo decklistInfo =
new CompressedDecklistInfo(card);

<start>synchronized (mCompressedDecklist) {<end>
//comment
if (mCompressedDecklist.contains(decklistInfo)) {
<start>boolean added = false;<end>
final int firstIndex = mCompressedDecklist.indexOf(decklistInfo);
final CompressedDecklistInfo firstCard =
mCompressedDecklist.get(firstIndex);
for (int i = 0; i < firstCard.mInfo.size(); i++) {
CardHelpers.IndividualSetInfo firstIsi = firstCard.mInfo.get(i);
if (firstIsi.mSetCode.equals(card.getExpansion()) &&
(firstIsi.mIsFoil.equals(card.mIsFoil) || nonFoilSets.contains(firstIsi.mSetCode))) {
firstIsi.mNumberOf++;
added = true;
break;
}
}
if (!added) {
firstCard.add(card);
}
} else {
mCompressedDecklist.add(new CompressedDecklistInfo(card));
}

//comment
clearHeaders();

//comment
if (shouldShowPrice()) {
loadPrice(card);
}

//comment
Collections.sort(mCompressedDecklist, mDecklistChain);

if (!mDecklistReadError) {
//comment
DecklistHelpers.WriteCompressedDecklist(getActivity(), mCompressedDecklist, getCurrentDeckName());
}
}

//comment
clearCardNameInput();

//comment
//comment

//comment
uncheckFoilCheckbox();

//comment
updateDeckCounts(false);

//comment
setHeaderValues();
getCardDataAdapter(0).notifyDataSetChanged();
} catch (java.lang.InstantiationException e) {
//comment
}

}","private void addCardToDeck(final boolean isSideboard) {

//comment
if (getCardNameInput() == null || getCardNameInput().length() == 0 ||
getCardNumberInput() == null || getCardNumberInput().length() == 0) {
return;
}

ArrayList<String> nonFoilSets;
FamiliarDbHandle handle = new FamiliarDbHandle();
try {
SQLiteDatabase database = DatabaseManager.openDatabase(getContext(), false, handle);
nonFoilSets = CardDbAdapter.getNonFoilSets(database);
} catch (SQLiteException | FamiliarDbException | IllegalStateException ignored) {
nonFoilSets = new ArrayList<>();
} finally {
DatabaseManager.closeDatabase(getContext(), handle);
}

final String name = String.valueOf(getCardNameInput());
final String numberOf = String.valueOf(getCardNumberInput());
try {
final MtgCard card = new MtgCard(getActivity(), name, null, null,
checkboxFoilIsChecked(), Integer.parseInt(numberOf), isSideboard);

final CompressedDecklistInfo decklistInfo =
new CompressedDecklistInfo(card);

<start>synchronized (mCompressedDecklist) {
//comment
if (mCompressedDecklist.contains(decklistInfo)) {
boolean added = false;
final int firstIndex = mCompressedDecklist.indexOf(decklistInfo);
final CompressedDecklistInfo firstCard =
mCompressedDecklist.get(firstIndex);
for (int i = 0; i < firstCard.mInfo.size(); i++) {
CardHelpers.IndividualSetInfo firstIsi = firstCard.mInfo.get(i);
if (firstIsi.mSetCode.equals(card.getExpansion()) &&
(firstIsi.mIsFoil.equals(card.mIsFoil) || nonFoilSets.contains(firstIsi.mSetCode))) {
firstIsi.mNumberOf++;
added = true;
break;
}
}
if (!added) {
firstCard.add(card);
}
} else {
mCompressedDecklist.add(new CompressedDecklistInfo(card));
}<end>

//comment
clearHeaders();

//comment
if (shouldShowPrice()) {
loadPrice(card);
}

//comment
Collections.sort(mCompressedDecklist, mDecklistChain);

if (!mDecklistReadError) {
//comment
DecklistHelpers.WriteCompressedDecklist(getActivity(), mCompressedDecklist, getCurrentDeckName());
}
<start>}<end>

//comment
clearCardNameInput();

//comment
//comment

//comment
uncheckFoilCheckbox();

//comment
updateDeckCounts(false);

//comment
setHeaderValues();
getCardDataAdapter(0).notifyDataSetChanged();
} catch (java.lang.InstantiationException e) {
//comment
}

}"
2541,"private void addCardToDeck(final boolean isSideboard) {

//comment
if (getCardNameInput() == null || getCardNameInput().length() == 0 ||
getCardNumberInput() == null || getCardNumberInput().length() == 0) {
return;
}

ArrayList<String> nonFoilSets;
FamiliarDbHandle handle = new FamiliarDbHandle();
try {
SQLiteDatabase database = DatabaseManager.openDatabase(getContext(), false, handle);
nonFoilSets = CardDbAdapter.getNonFoilSets(database);
} catch (SQLiteException | FamiliarDbException | IllegalStateException ignored) {
nonFoilSets = new ArrayList<>();
} finally {
DatabaseManager.closeDatabase(getContext(), handle);
}

final String name = String.valueOf(getCardNameInput());
final String numberOf = String.valueOf(getCardNumberInput());
try {
final MtgCard card = new MtgCard(getActivity(), name, null, null,
checkboxFoilIsChecked(), Integer.parseInt(numberOf), isSideboard);

final CompressedDecklistInfo decklistInfo =
new CompressedDecklistInfo(card);

synchronized (mCompressedDecklist) {
//comment
if (mCompressedDecklist.contains(decklistInfo)) {
boolean added = false;
final int firstIndex = mCompressedDecklist.indexOf(decklistInfo);
final CompressedDecklistInfo firstCard =
mCompressedDecklist.get(firstIndex);
for (int i = 0; i < firstCard.mInfo.size(); i++) {
CardHelpers.IndividualSetInfo firstIsi = firstCard.mInfo.get(i);
if (firstIsi.mSetCode.equals(card.getExpansion()) &&
(firstIsi.mIsFoil.equals(card.mIsFoil) || nonFoilSets.contains(firstIsi.mSetCode))) {
firstIsi.mNumberOf++;
added = true;
break;
}
}
if (!added) {
firstCard.add(card);
}
} else {
mCompressedDecklist.add(new CompressedDecklistInfo(card));
}

//comment
clearHeaders();

//comment
<start>if (shouldShowPrice()) {
loadPrice(card);
}<end>

//comment
Collections.sort(mCompressedDecklist, mDecklistChain);

if (!mDecklistReadError) {
//comment
DecklistHelpers.WriteCompressedDecklist(getActivity(), mCompressedDecklist, getCurrentDeckName());
}
}

//comment
clearCardNameInput();

//comment
//comment

//comment
uncheckFoilCheckbox();

//comment
updateDeckCounts(false);

//comment
setHeaderValues();
getCardDataAdapter(0).notifyDataSetChanged();
} catch (java.lang.InstantiationException e) {
//comment
}

}","private void addCardToDeck(final boolean isSideboard) {

//comment
if (getCardNameInput() == null || getCardNameInput().length() == 0 ||
getCardNumberInput() == null || getCardNumberInput().length() == 0) {
return;
}

ArrayList<String> nonFoilSets;
FamiliarDbHandle handle = new FamiliarDbHandle();
try {
SQLiteDatabase database = DatabaseManager.openDatabase(getContext(), false, handle);
nonFoilSets = CardDbAdapter.getNonFoilSets(database);
} catch (SQLiteException | FamiliarDbException | IllegalStateException ignored) {
nonFoilSets = new ArrayList<>();
} finally {
DatabaseManager.closeDatabase(getContext(), handle);
}

final String name = String.valueOf(getCardNameInput());
final String numberOf = String.valueOf(getCardNumberInput());
try {
final MtgCard card = new MtgCard(getActivity(), name, null, null,
checkboxFoilIsChecked(), Integer.parseInt(numberOf), isSideboard);

final CompressedDecklistInfo decklistInfo =
new CompressedDecklistInfo(card);

synchronized (mCompressedDecklist) {
//comment
if (mCompressedDecklist.contains(decklistInfo)) {
boolean added = false;
final int firstIndex = mCompressedDecklist.indexOf(decklistInfo);
final CompressedDecklistInfo firstCard =
mCompressedDecklist.get(firstIndex);
for (int i = 0; i < firstCard.mInfo.size(); i++) {
CardHelpers.IndividualSetInfo firstIsi = firstCard.mInfo.get(i);
if (firstIsi.mSetCode.equals(card.getExpansion()) &&
(firstIsi.mIsFoil.equals(card.mIsFoil) || nonFoilSets.contains(firstIsi.mSetCode))) {
firstIsi.mNumberOf++;
added = true;
break;
}
}
if (!added) {
firstCard.add(card);
}
} else {
mCompressedDecklist.add(new CompressedDecklistInfo(card));
}

//comment
clearHeaders();

//comment
if (shouldShowPrice()) {
<start>loadPrice(card);<end>
}

//comment
Collections.sort(mCompressedDecklist, mDecklistChain);

if (!mDecklistReadError) {
//comment
DecklistHelpers.WriteCompressedDecklist(getActivity(), mCompressedDecklist, getCurrentDeckName());
}
}

//comment
clearCardNameInput();

//comment
//comment

//comment
uncheckFoilCheckbox();

//comment
updateDeckCounts(false);

//comment
setHeaderValues();
getCardDataAdapter(0).notifyDataSetChanged();
} catch (java.lang.InstantiationException e) {
//comment
}

}"
2542,"private void addCardToDeck(final boolean isSideboard) {

//comment
if (getCardNameInput() == null || getCardNameInput().length() == 0 ||
getCardNumberInput() == null || getCardNumberInput().length() == 0) {
return;
}

ArrayList<String> nonFoilSets;
FamiliarDbHandle handle = new FamiliarDbHandle();
try {
SQLiteDatabase database = DatabaseManager.openDatabase(getContext(), false, handle);
nonFoilSets = CardDbAdapter.getNonFoilSets(database);
} catch (SQLiteException | FamiliarDbException | IllegalStateException ignored) {
nonFoilSets = new ArrayList<>();
} finally {
DatabaseManager.closeDatabase(getContext(), handle);
}

final String name = String.valueOf(getCardNameInput());
final String numberOf = String.valueOf(getCardNumberInput());
try {
final MtgCard card = new MtgCard(getActivity(), name, null, null,
checkboxFoilIsChecked(), Integer.parseInt(numberOf), isSideboard);

final CompressedDecklistInfo decklistInfo =
new CompressedDecklistInfo(card);

synchronized (mCompressedDecklist) {
//comment
if (mCompressedDecklist.contains(decklistInfo)) {
boolean added = false;
final int firstIndex = mCompressedDecklist.indexOf(decklistInfo);
final CompressedDecklistInfo firstCard =
mCompressedDecklist.get(firstIndex);
for (int i = 0; i < firstCard.mInfo.size(); i++) {
CardHelpers.IndividualSetInfo firstIsi = firstCard.mInfo.get(i);
if (firstIsi.mSetCode.equals(card.getExpansion()) &&
(firstIsi.mIsFoil.equals(card.mIsFoil) || nonFoilSets.contains(firstIsi.mSetCode))) {
firstIsi.mNumberOf++;
added = true;
break;
}
}
if (!added) {
firstCard.add(card);
}
} else {
mCompressedDecklist.add(new CompressedDecklistInfo(card));
}

//comment
clearHeaders();

//comment
if (shouldShowPrice()) {
loadPrice(card);
}

//comment
<start>Collections.sort(mCompressedDecklist, mDecklistChain);<end>

if (!mDecklistReadError) {
//comment
DecklistHelpers.WriteCompressedDecklist(getActivity(), mCompressedDecklist, getCurrentDeckName());
}
}

//comment
clearCardNameInput();

//comment
//comment

//comment
uncheckFoilCheckbox();

//comment
updateDeckCounts(false);

//comment
setHeaderValues();
getCardDataAdapter(0).notifyDataSetChanged();
} catch (java.lang.InstantiationException e) {
//comment
}

}","private void addCardToDeck(final boolean isSideboard) {

//comment
if (getCardNameInput() == null || getCardNameInput().length() == 0 ||
getCardNumberInput() == null || getCardNumberInput().length() == 0) {
return;
}

ArrayList<String> nonFoilSets;
FamiliarDbHandle handle = new FamiliarDbHandle();
try {
SQLiteDatabase database = DatabaseManager.openDatabase(getContext(), false, handle);
nonFoilSets = CardDbAdapter.getNonFoilSets(database);
} catch (SQLiteException | FamiliarDbException | IllegalStateException ignored) {
nonFoilSets = new ArrayList<>();
} finally {
DatabaseManager.closeDatabase(getContext(), handle);
}

final String name = String.valueOf(getCardNameInput());
final String numberOf = String.valueOf(getCardNumberInput());
try {
final MtgCard card = new MtgCard(getActivity(), name, null, null,
checkboxFoilIsChecked(), Integer.parseInt(numberOf), isSideboard);

final CompressedDecklistInfo decklistInfo =
new CompressedDecklistInfo(card);

synchronized (mCompressedDecklist) {
//comment
if (mCompressedDecklist.contains(decklistInfo)) {
boolean added = false;
final int firstIndex = mCompressedDecklist.indexOf(decklistInfo);
final CompressedDecklistInfo firstCard =
mCompressedDecklist.get(firstIndex);
for (int i = 0; i < firstCard.mInfo.size(); i++) {
CardHelpers.IndividualSetInfo firstIsi = firstCard.mInfo.get(i);
if (firstIsi.mSetCode.equals(card.getExpansion()) &&
(firstIsi.mIsFoil.equals(card.mIsFoil) || nonFoilSets.contains(firstIsi.mSetCode))) {
firstIsi.mNumberOf++;
added = true;
break;
}
}
if (!added) {
firstCard.add(card);
}
} else {
mCompressedDecklist.add(new CompressedDecklistInfo(card));
}

//comment
clearHeaders();

//comment
if (shouldShowPrice()) {
loadPrice(card);
}

//comment
<start>Collections.sort(mCompressedDecklist, mDecklistChain);<end>

if (!mDecklistReadError) {
//comment
DecklistHelpers.WriteCompressedDecklist(getActivity(), mCompressedDecklist, getCurrentDeckName());
}
}

//comment
clearCardNameInput();

//comment
//comment

//comment
uncheckFoilCheckbox();

//comment
updateDeckCounts(false);

//comment
setHeaderValues();
getCardDataAdapter(0).notifyDataSetChanged();
} catch (java.lang.InstantiationException e) {
//comment
}

}"
2543,"private void addCardToDeck(final boolean isSideboard) {

//comment
if (getCardNameInput() == null || getCardNameInput().length() == 0 ||
getCardNumberInput() == null || getCardNumberInput().length() == 0) {
return;
}

ArrayList<String> nonFoilSets;
FamiliarDbHandle handle = new FamiliarDbHandle();
try {
SQLiteDatabase database = DatabaseManager.openDatabase(getContext(), false, handle);
nonFoilSets = CardDbAdapter.getNonFoilSets(database);
} catch (SQLiteException | FamiliarDbException | IllegalStateException ignored) {
nonFoilSets = new ArrayList<>();
} finally {
DatabaseManager.closeDatabase(getContext(), handle);
}

final String name = String.valueOf(getCardNameInput());
final String numberOf = String.valueOf(getCardNumberInput());
try {
final MtgCard card = new MtgCard(getActivity(), name, null, null,
checkboxFoilIsChecked(), Integer.parseInt(numberOf), isSideboard);

final CompressedDecklistInfo decklistInfo =
new CompressedDecklistInfo(card);

synchronized (mCompressedDecklist) {
//comment
if (mCompressedDecklist.contains(decklistInfo)) {
boolean added = false;
final int firstIndex = mCompressedDecklist.indexOf(decklistInfo);
final CompressedDecklistInfo firstCard =
mCompressedDecklist.get(firstIndex);
for (int i = 0; i < firstCard.mInfo.size(); i++) {
CardHelpers.IndividualSetInfo firstIsi = firstCard.mInfo.get(i);
if (firstIsi.mSetCode.equals(card.getExpansion()) &&
(firstIsi.mIsFoil.equals(card.mIsFoil) || nonFoilSets.contains(firstIsi.mSetCode))) {
firstIsi.mNumberOf++;
added = true;
break;
}
}
if (!added) {
firstCard.add(card);
}
} else {
mCompressedDecklist.add(new CompressedDecklistInfo(card));
}

//comment
clearHeaders();

//comment
if (shouldShowPrice()) {
loadPrice(card);
}

//comment
Collections.sort(mCompressedDecklist, mDecklistChain);

if (!mDecklistReadError) {
//comment
DecklistHelpers.WriteCompressedDecklist(getActivity(), mCompressedDecklist, getCurrentDeckName());
}
}

//comment
clearCardNameInput();

//comment
//comment

//comment
uncheckFoilCheckbox();

//comment
updateDeckCounts(false);

//comment
setHeaderValues();
getCardDataAdapter(0).notifyDataSetChanged();
} catch (java.lang.InstantiationException e) {
//comment
}

}","private void addCardToDeck(final boolean isSideboard) {

//comment
if (getCardNameInput() == null || getCardNameInput().length() == 0 ||
getCardNumberInput() == null || getCardNumberInput().length() == 0) {
return;
}

ArrayList<String> nonFoilSets;
FamiliarDbHandle handle = new FamiliarDbHandle();
try {
SQLiteDatabase database = DatabaseManager.openDatabase(getContext(), false, handle);
nonFoilSets = CardDbAdapter.getNonFoilSets(database);
} catch (SQLiteException | FamiliarDbException | IllegalStateException ignored) {
nonFoilSets = new ArrayList<>();
} finally {
DatabaseManager.closeDatabase(getContext(), handle);
}

final String name = String.valueOf(getCardNameInput());
final String numberOf = String.valueOf(getCardNumberInput());
try {
final MtgCard card = new MtgCard(getActivity(), name, null, null,
checkboxFoilIsChecked(), Integer.parseInt(numberOf), isSideboard);

final CompressedDecklistInfo decklistInfo =
new CompressedDecklistInfo(card);

synchronized (mCompressedDecklist) {
//comment
if (mCompressedDecklist.contains(decklistInfo)) {
boolean added = false;
final int firstIndex = mCompressedDecklist.indexOf(decklistInfo);
final CompressedDecklistInfo firstCard =
mCompressedDecklist.get(firstIndex);
for (int i = 0; i < firstCard.mInfo.size(); i++) {
CardHelpers.IndividualSetInfo firstIsi = firstCard.mInfo.get(i);
if (firstIsi.mSetCode.equals(card.getExpansion()) &&
(firstIsi.mIsFoil.equals(card.mIsFoil) || nonFoilSets.contains(firstIsi.mSetCode))) {
firstIsi.mNumberOf++;
added = true;
break;
}
}
if (!added) {
firstCard.add(card);
}
} else {
mCompressedDecklist.add(new CompressedDecklistInfo(card));
}

//comment
clearHeaders();

//comment
if (shouldShowPrice()) {
loadPrice(card);
}

//comment
Collections.sort(mCompressedDecklist, mDecklistChain);

if (!mDecklistReadError) {
//comment
<start>DecklistHelpers.WriteCompressedDecklist(getActivity(), mCompressedDecklist, getCurrentDeckName());<end>
}
}

//comment
clearCardNameInput();

//comment
//comment

//comment
uncheckFoilCheckbox();

//comment
updateDeckCounts(false);

//comment
setHeaderValues();
getCardDataAdapter(0).notifyDataSetChanged();
} catch (java.lang.InstantiationException e) {
//comment
}

}"
2544,"private void addCardToDeck(final boolean isSideboard) {

//comment
if (getCardNameInput() == null || getCardNameInput().length() == 0 ||
getCardNumberInput() == null || getCardNumberInput().length() == 0) {
return;
}

ArrayList<String> nonFoilSets;
FamiliarDbHandle handle = new FamiliarDbHandle();
try {
SQLiteDatabase database = DatabaseManager.openDatabase(getContext(), false, handle);
nonFoilSets = CardDbAdapter.getNonFoilSets(database);
} catch (SQLiteException | FamiliarDbException | IllegalStateException ignored) {
nonFoilSets = new ArrayList<>();
} finally {
DatabaseManager.closeDatabase(getContext(), handle);
}

final String name = String.valueOf(getCardNameInput());
final String numberOf = String.valueOf(getCardNumberInput());
try {
final MtgCard card = new MtgCard(getActivity(), name, null, null,
checkboxFoilIsChecked(), Integer.parseInt(numberOf), isSideboard);

final CompressedDecklistInfo decklistInfo =
new CompressedDecklistInfo(card);

synchronized (mCompressedDecklist) {
//comment
if (mCompressedDecklist.contains(decklistInfo)) {
boolean added = false;
final int firstIndex = mCompressedDecklist.indexOf(decklistInfo);
final CompressedDecklistInfo firstCard =
mCompressedDecklist.get(firstIndex);
for (int i = 0; i < firstCard.mInfo.size(); i++) {
CardHelpers.IndividualSetInfo firstIsi = firstCard.mInfo.get(i);
if (firstIsi.mSetCode.equals(card.getExpansion()) &&
(firstIsi.mIsFoil.equals(card.mIsFoil) || nonFoilSets.contains(firstIsi.mSetCode))) {
firstIsi.mNumberOf++;
added = true;
break;
}
}
if (!added) {
firstCard.add(card);
}
} else {
mCompressedDecklist.add(new CompressedDecklistInfo(card));
}

//comment
clearHeaders();

//comment
if (shouldShowPrice()) {
loadPrice(card);
}

//comment
Collections.sort(mCompressedDecklist, mDecklistChain);

if (!mDecklistReadError) {
//comment
DecklistHelpers.WriteCompressedDecklist(getActivity(), mCompressedDecklist, getCurrentDeckName());
}
}

//comment
<start>clearCardNameInput();<end>

//comment
//comment

//comment
uncheckFoilCheckbox();

//comment
updateDeckCounts(false);

//comment
setHeaderValues();
getCardDataAdapter(0).notifyDataSetChanged();
} catch (java.lang.InstantiationException e) {
//comment
}

}","private void addCardToDeck(final boolean isSideboard) {

//comment
if (getCardNameInput() == null || getCardNameInput().length() == 0 ||
getCardNumberInput() == null || getCardNumberInput().length() == 0) {
return;
}

ArrayList<String> nonFoilSets;
FamiliarDbHandle handle = new FamiliarDbHandle();
try {
SQLiteDatabase database = DatabaseManager.openDatabase(getContext(), false, handle);
nonFoilSets = CardDbAdapter.getNonFoilSets(database);
} catch (SQLiteException | FamiliarDbException | IllegalStateException ignored) {
nonFoilSets = new ArrayList<>();
} finally {
DatabaseManager.closeDatabase(getContext(), handle);
}

final String name = String.valueOf(getCardNameInput());
final String numberOf = String.valueOf(getCardNumberInput());
try {
final MtgCard card = new MtgCard(getActivity(), name, null, null,
checkboxFoilIsChecked(), Integer.parseInt(numberOf), isSideboard);

final CompressedDecklistInfo decklistInfo =
new CompressedDecklistInfo(card);

synchronized (mCompressedDecklist) {
//comment
if (mCompressedDecklist.contains(decklistInfo)) {
boolean added = false;
final int firstIndex = mCompressedDecklist.indexOf(decklistInfo);
final CompressedDecklistInfo firstCard =
mCompressedDecklist.get(firstIndex);
for (int i = 0; i < firstCard.mInfo.size(); i++) {
CardHelpers.IndividualSetInfo firstIsi = firstCard.mInfo.get(i);
if (firstIsi.mSetCode.equals(card.getExpansion()) &&
(firstIsi.mIsFoil.equals(card.mIsFoil) || nonFoilSets.contains(firstIsi.mSetCode))) {
firstIsi.mNumberOf++;
added = true;
break;
}
}
if (!added) {
firstCard.add(card);
}
} else {
mCompressedDecklist.add(new CompressedDecklistInfo(card));
}

//comment
clearHeaders();

//comment
if (shouldShowPrice()) {
loadPrice(card);
}

//comment
Collections.sort(mCompressedDecklist, mDecklistChain);

if (!mDecklistReadError) {
//comment
DecklistHelpers.WriteCompressedDecklist(getActivity(), mCompressedDecklist, getCurrentDeckName());
}
}

//comment
<start>clearCardNameInput();<end>

//comment
//comment

//comment
uncheckFoilCheckbox();

//comment
updateDeckCounts(false);

//comment
setHeaderValues();
getCardDataAdapter(0).notifyDataSetChanged();
} catch (java.lang.InstantiationException e) {
//comment
}

}"
2545,"private void addCardToDeck(final boolean isSideboard) {

//comment
if (getCardNameInput() == null || getCardNameInput().length() == 0 ||
getCardNumberInput() == null || getCardNumberInput().length() == 0) {
return;
}

ArrayList<String> nonFoilSets;
FamiliarDbHandle handle = new FamiliarDbHandle();
try {
SQLiteDatabase database = DatabaseManager.openDatabase(getContext(), false, handle);
nonFoilSets = CardDbAdapter.getNonFoilSets(database);
} catch (SQLiteException | FamiliarDbException | IllegalStateException ignored) {
nonFoilSets = new ArrayList<>();
} finally {
DatabaseManager.closeDatabase(getContext(), handle);
}

final String name = String.valueOf(getCardNameInput());
final String numberOf = String.valueOf(getCardNumberInput());
try {
final MtgCard card = new MtgCard(getActivity(), name, null, null,
checkboxFoilIsChecked(), Integer.parseInt(numberOf), isSideboard);

final CompressedDecklistInfo decklistInfo =
new CompressedDecklistInfo(card);

synchronized (mCompressedDecklist) {
//comment
if (mCompressedDecklist.contains(decklistInfo)) {
boolean added = false;
final int firstIndex = mCompressedDecklist.indexOf(decklistInfo);
final CompressedDecklistInfo firstCard =
mCompressedDecklist.get(firstIndex);
for (int i = 0; i < firstCard.mInfo.size(); i++) {
CardHelpers.IndividualSetInfo firstIsi = firstCard.mInfo.get(i);
if (firstIsi.mSetCode.equals(card.getExpansion()) &&
(firstIsi.mIsFoil.equals(card.mIsFoil) || nonFoilSets.contains(firstIsi.mSetCode))) {
firstIsi.mNumberOf++;
added = true;
break;
}
}
if (!added) {
firstCard.add(card);
}
} else {
mCompressedDecklist.add(new CompressedDecklistInfo(card));
}

//comment
clearHeaders();

//comment
if (shouldShowPrice()) {
loadPrice(card);
}

//comment
Collections.sort(mCompressedDecklist, mDecklistChain);

if (!mDecklistReadError) {
//comment
DecklistHelpers.WriteCompressedDecklist(getActivity(), mCompressedDecklist, getCurrentDeckName());
}
}

//comment
clearCardNameInput();

//comment
//comment

//comment
<start>uncheckFoilCheckbox();<end>

//comment
updateDeckCounts(false);

//comment
setHeaderValues();
getCardDataAdapter(0).notifyDataSetChanged();
} catch (java.lang.InstantiationException e) {
//comment
}

}","private void addCardToDeck(final boolean isSideboard) {

//comment
if (getCardNameInput() == null || getCardNameInput().length() == 0 ||
getCardNumberInput() == null || getCardNumberInput().length() == 0) {
return;
}

ArrayList<String> nonFoilSets;
FamiliarDbHandle handle = new FamiliarDbHandle();
try {
SQLiteDatabase database = DatabaseManager.openDatabase(getContext(), false, handle);
nonFoilSets = CardDbAdapter.getNonFoilSets(database);
} catch (SQLiteException | FamiliarDbException | IllegalStateException ignored) {
nonFoilSets = new ArrayList<>();
} finally {
DatabaseManager.closeDatabase(getContext(), handle);
}

final String name = String.valueOf(getCardNameInput());
final String numberOf = String.valueOf(getCardNumberInput());
try {
final MtgCard card = new MtgCard(getActivity(), name, null, null,
checkboxFoilIsChecked(), Integer.parseInt(numberOf), isSideboard);

final CompressedDecklistInfo decklistInfo =
new CompressedDecklistInfo(card);

synchronized (mCompressedDecklist) {
//comment
if (mCompressedDecklist.contains(decklistInfo)) {
boolean added = false;
final int firstIndex = mCompressedDecklist.indexOf(decklistInfo);
final CompressedDecklistInfo firstCard =
mCompressedDecklist.get(firstIndex);
for (int i = 0; i < firstCard.mInfo.size(); i++) {
CardHelpers.IndividualSetInfo firstIsi = firstCard.mInfo.get(i);
if (firstIsi.mSetCode.equals(card.getExpansion()) &&
(firstIsi.mIsFoil.equals(card.mIsFoil) || nonFoilSets.contains(firstIsi.mSetCode))) {
firstIsi.mNumberOf++;
added = true;
break;
}
}
if (!added) {
firstCard.add(card);
}
} else {
mCompressedDecklist.add(new CompressedDecklistInfo(card));
}

//comment
clearHeaders();

//comment
if (shouldShowPrice()) {
loadPrice(card);
}

//comment
Collections.sort(mCompressedDecklist, mDecklistChain);

if (!mDecklistReadError) {
//comment
DecklistHelpers.WriteCompressedDecklist(getActivity(), mCompressedDecklist, getCurrentDeckName());
}
}

//comment
clearCardNameInput();

//comment
//comment

//comment
<start>uncheckFoilCheckbox();<end>

//comment
updateDeckCounts(false);

//comment
setHeaderValues();
getCardDataAdapter(0).notifyDataSetChanged();
} catch (java.lang.InstantiationException e) {
//comment
}

}"
2546,"private void addCardToDeck(final boolean isSideboard) {

//comment
if (getCardNameInput() == null || getCardNameInput().length() == 0 ||
getCardNumberInput() == null || getCardNumberInput().length() == 0) {
return;
}

ArrayList<String> nonFoilSets;
FamiliarDbHandle handle = new FamiliarDbHandle();
try {
SQLiteDatabase database = DatabaseManager.openDatabase(getContext(), false, handle);
nonFoilSets = CardDbAdapter.getNonFoilSets(database);
} catch (SQLiteException | FamiliarDbException | IllegalStateException ignored) {
nonFoilSets = new ArrayList<>();
} finally {
DatabaseManager.closeDatabase(getContext(), handle);
}

final String name = String.valueOf(getCardNameInput());
final String numberOf = String.valueOf(getCardNumberInput());
try {
final MtgCard card = new MtgCard(getActivity(), name, null, null,
checkboxFoilIsChecked(), Integer.parseInt(numberOf), isSideboard);

final CompressedDecklistInfo decklistInfo =
new CompressedDecklistInfo(card);

synchronized (mCompressedDecklist) {
//comment
if (mCompressedDecklist.contains(decklistInfo)) {
boolean added = false;
final int firstIndex = mCompressedDecklist.indexOf(decklistInfo);
final CompressedDecklistInfo firstCard =
mCompressedDecklist.get(firstIndex);
for (int i = 0; i < firstCard.mInfo.size(); i++) {
CardHelpers.IndividualSetInfo firstIsi = firstCard.mInfo.get(i);
if (firstIsi.mSetCode.equals(card.getExpansion()) &&
(firstIsi.mIsFoil.equals(card.mIsFoil) || nonFoilSets.contains(firstIsi.mSetCode))) {
firstIsi.mNumberOf++;
added = true;
break;
}
}
if (!added) {
firstCard.add(card);
}
} else {
mCompressedDecklist.add(new CompressedDecklistInfo(card));
}

//comment
clearHeaders();

//comment
if (shouldShowPrice()) {
loadPrice(card);
}

//comment
Collections.sort(mCompressedDecklist, mDecklistChain);

if (!mDecklistReadError) {
//comment
DecklistHelpers.WriteCompressedDecklist(getActivity(), mCompressedDecklist, getCurrentDeckName());
}
}

//comment
clearCardNameInput();

//comment
//comment

//comment
uncheckFoilCheckbox();

//comment
<start>updateDeckCounts(false);<end>

//comment
setHeaderValues();
getCardDataAdapter(0).notifyDataSetChanged();
} catch (java.lang.InstantiationException e) {
//comment
}

}","private void addCardToDeck(final boolean isSideboard) {

//comment
if (getCardNameInput() == null || getCardNameInput().length() == 0 ||
getCardNumberInput() == null || getCardNumberInput().length() == 0) {
return;
}

ArrayList<String> nonFoilSets;
FamiliarDbHandle handle = new FamiliarDbHandle();
try {
SQLiteDatabase database = DatabaseManager.openDatabase(getContext(), false, handle);
nonFoilSets = CardDbAdapter.getNonFoilSets(database);
} catch (SQLiteException | FamiliarDbException | IllegalStateException ignored) {
nonFoilSets = new ArrayList<>();
} finally {
DatabaseManager.closeDatabase(getContext(), handle);
}

final String name = String.valueOf(getCardNameInput());
final String numberOf = String.valueOf(getCardNumberInput());
try {
final MtgCard card = new MtgCard(getActivity(), name, null, null,
checkboxFoilIsChecked(), Integer.parseInt(numberOf), isSideboard);

final CompressedDecklistInfo decklistInfo =
new CompressedDecklistInfo(card);

synchronized (mCompressedDecklist) {
//comment
if (mCompressedDecklist.contains(decklistInfo)) {
boolean added = false;
final int firstIndex = mCompressedDecklist.indexOf(decklistInfo);
final CompressedDecklistInfo firstCard =
mCompressedDecklist.get(firstIndex);
for (int i = 0; i < firstCard.mInfo.size(); i++) {
CardHelpers.IndividualSetInfo firstIsi = firstCard.mInfo.get(i);
if (firstIsi.mSetCode.equals(card.getExpansion()) &&
(firstIsi.mIsFoil.equals(card.mIsFoil) || nonFoilSets.contains(firstIsi.mSetCode))) {
firstIsi.mNumberOf++;
added = true;
break;
}
}
if (!added) {
firstCard.add(card);
}
} else {
mCompressedDecklist.add(new CompressedDecklistInfo(card));
}

//comment
clearHeaders();

//comment
if (shouldShowPrice()) {
loadPrice(card);
}

//comment
Collections.sort(mCompressedDecklist, mDecklistChain);

if (!mDecklistReadError) {
//comment
DecklistHelpers.WriteCompressedDecklist(getActivity(), mCompressedDecklist, getCurrentDeckName());
}
}

//comment
clearCardNameInput();

//comment
//comment

//comment
uncheckFoilCheckbox();

//comment
<start>updateDeckCounts(false);<end>

//comment
setHeaderValues();
getCardDataAdapter(0).notifyDataSetChanged();
} catch (java.lang.InstantiationException e) {
//comment
}

}"
2547,"private void addCardToDeck(final boolean isSideboard) {

//comment
if (getCardNameInput() == null || getCardNameInput().length() == 0 ||
getCardNumberInput() == null || getCardNumberInput().length() == 0) {
return;
}

ArrayList<String> nonFoilSets;
FamiliarDbHandle handle = new FamiliarDbHandle();
try {
SQLiteDatabase database = DatabaseManager.openDatabase(getContext(), false, handle);
nonFoilSets = CardDbAdapter.getNonFoilSets(database);
} catch (SQLiteException | FamiliarDbException | IllegalStateException ignored) {
nonFoilSets = new ArrayList<>();
} finally {
DatabaseManager.closeDatabase(getContext(), handle);
}

final String name = String.valueOf(getCardNameInput());
<start>final String numberOf = String.valueOf(getCardNumberInput());<end>
try {
final MtgCard card = new MtgCard(getActivity(), name, null, null,
checkboxFoilIsChecked(), Integer.parseInt(numberOf), isSideboard);

final CompressedDecklistInfo decklistInfo =
new CompressedDecklistInfo(card);

synchronized (mCompressedDecklist) {
//comment
if (mCompressedDecklist.contains(decklistInfo)) {
boolean added = false;
final int firstIndex = mCompressedDecklist.indexOf(decklistInfo);
final CompressedDecklistInfo firstCard =
mCompressedDecklist.get(firstIndex);
for (int i = 0; i < firstCard.mInfo.size(); i++) {
CardHelpers.IndividualSetInfo firstIsi = firstCard.mInfo.get(i);
if (firstIsi.mSetCode.equals(card.getExpansion()) &&
(firstIsi.mIsFoil.equals(card.mIsFoil) || nonFoilSets.contains(firstIsi.mSetCode))) {
firstIsi.mNumberOf++;
added = true;
break;
}
}
if (!added) {
firstCard.add(card);
}
} else {
mCompressedDecklist.add(new CompressedDecklistInfo(card));
}

//comment
clearHeaders();

//comment
if (shouldShowPrice()) {
loadPrice(card);
}

//comment
Collections.sort(mCompressedDecklist, mDecklistChain);

if (!mDecklistReadError) {
//comment
DecklistHelpers.WriteCompressedDecklist(getActivity(), mCompressedDecklist, getCurrentDeckName());
}
}

//comment
clearCardNameInput();

//comment
//comment

//comment
uncheckFoilCheckbox();

//comment
updateDeckCounts(false);

//comment
<start>setHeaderValues();
getCardDataAdapter(0).notifyDataSetChanged();<end>
} catch (java.lang.InstantiationException e) {
//comment
}

}","private void addCardToDeck(final boolean isSideboard) {

//comment
if (getCardNameInput() == null || getCardNameInput().length() == 0 ||
getCardNumberInput() == null || getCardNumberInput().length() == 0) {
return;
}

ArrayList<String> nonFoilSets;
FamiliarDbHandle handle = new FamiliarDbHandle();
try {
SQLiteDatabase database = DatabaseManager.openDatabase(getContext(), false, handle);
nonFoilSets = CardDbAdapter.getNonFoilSets(database);
} catch (SQLiteException | FamiliarDbException | IllegalStateException ignored) {
nonFoilSets = new ArrayList<>();
} finally {
DatabaseManager.closeDatabase(getContext(), handle);
}

final String name = String.valueOf(getCardNameInput());
final String numberOf = String.valueOf(getCardNumberInput());
try {
final MtgCard card = new MtgCard(getActivity(), name, null, null,
checkboxFoilIsChecked(), Integer.parseInt(numberOf), isSideboard);

final CompressedDecklistInfo decklistInfo =
new CompressedDecklistInfo(card);

synchronized (mCompressedDecklist) {
//comment
if (mCompressedDecklist.contains(decklistInfo)) {
boolean added = false;
final int firstIndex = mCompressedDecklist.indexOf(decklistInfo);
final CompressedDecklistInfo firstCard =
mCompressedDecklist.get(firstIndex);
for (int i = 0; i < firstCard.mInfo.size(); i++) {
CardHelpers.IndividualSetInfo firstIsi = firstCard.mInfo.get(i);
if (firstIsi.mSetCode.equals(card.getExpansion()) &&
(firstIsi.mIsFoil.equals(card.mIsFoil) || nonFoilSets.contains(firstIsi.mSetCode))) {
firstIsi.mNumberOf++;
added = true;
break;
}
}
if (!added) {
firstCard.add(card);
}
} else {
mCompressedDecklist.add(new CompressedDecklistInfo(card));
}

//comment
clearHeaders();

//comment
if (shouldShowPrice()) {
loadPrice(card);
}

//comment
Collections.sort(mCompressedDecklist, mDecklistChain);

if (!mDecklistReadError) {
//comment
DecklistHelpers.WriteCompressedDecklist(getActivity(), mCompressedDecklist, getCurrentDeckName());
}
}

//comment
clearCardNameInput();

//comment
//comment

//comment
uncheckFoilCheckbox();

//comment
updateDeckCounts(false);

//comment
<start>setHeaderValues();
getCardDataAdapter(0).notifyDataSetChanged();<end>
} catch (java.lang.InstantiationException e) {
//comment
}

}"
2548,"public void readAndCompressDecklist(final String changedCardName, final String deckName) {
synchronized (mCompressedDecklist) {
try {
final String lDeckName = getAndSetDeckName(deckName);

//comment
<start>final ArrayList<MtgCard> decklist =
DecklistHelpers.ReadDecklist(getActivity(), lDeckName, true);<end>

//comment
clearCompressedInfo(changedCardName);

//comment
for (MtgCard card : decklist) {
//comment
if (!card.getName().isEmpty()) {
if (changedCardName == null || changedCardName.equals(card.getName())) {
CompressedDecklistInfo wrapped =
new CompressedDecklistInfo(card);
if (mCompressedDecklist.contains(wrapped)) {
mCompressedDecklist.get(mCompressedDecklist.indexOf(wrapped))
.add(card);
} else {
mCompressedDecklist.add(wrapped);
}
if (shouldShowPrice()) {
loadPrice(card);
}
}
}
}

//comment
if (changedCardName != null) {
for (int i = 0; i < mCompressedDecklist.size(); i++) {
if (mCompressedDecklist.get(i).mInfo.size() == 0) {
mCompressedDecklist.remove(i);
i--;
}
}
}
//comment
Collections.sort(mCompressedDecklist, mDecklistChain);
setHeaderValues();
updateDeckCounts(false);
} catch (FamiliarDbException e) {
handleFamiliarDbException(true);
mDecklistReadError = true;
return;
}
mDecklistReadError = false;
}
}","public void readAndCompressDecklist(final String changedCardName, final String deckName) {
synchronized (mCompressedDecklist) {
try {
final String lDeckName = getAndSetDeckName(deckName);

//comment
<start>final ArrayList<MtgCard> decklist =
DecklistHelpers.ReadDecklist(getActivity(), lDeckName, true);<end>

//comment
clearCompressedInfo(changedCardName);

//comment
for (MtgCard card : decklist) {
//comment
if (!card.getName().isEmpty()) {
if (changedCardName == null || changedCardName.equals(card.getName())) {
CompressedDecklistInfo wrapped =
new CompressedDecklistInfo(card);
if (mCompressedDecklist.contains(wrapped)) {
mCompressedDecklist.get(mCompressedDecklist.indexOf(wrapped))
.add(card);
} else {
mCompressedDecklist.add(wrapped);
}
if (shouldShowPrice()) {
loadPrice(card);
}
}
}
}

//comment
if (changedCardName != null) {
for (int i = 0; i < mCompressedDecklist.size(); i++) {
if (mCompressedDecklist.get(i).mInfo.size() == 0) {
mCompressedDecklist.remove(i);
i--;
}
}
}
//comment
Collections.sort(mCompressedDecklist, mDecklistChain);
setHeaderValues();
updateDeckCounts(false);
} catch (FamiliarDbException e) {
handleFamiliarDbException(true);
mDecklistReadError = true;
return;
}
mDecklistReadError = false;
}
}"
2549,"public void readAndCompressDecklist(final String changedCardName, final String deckName) {
synchronized (mCompressedDecklist) {
try {
final String lDeckName = getAndSetDeckName(deckName);

//comment
final ArrayList<MtgCard> decklist =
DecklistHelpers.ReadDecklist(getActivity(), lDeckName, true);

//comment
<start>clearCompressedInfo(changedCardName);<end>

//comment
for (MtgCard card : decklist) {
//comment
if (!card.getName().isEmpty()) {
if (changedCardName == null || changedCardName.equals(card.getName())) {
CompressedDecklistInfo wrapped =
new CompressedDecklistInfo(card);
if (mCompressedDecklist.contains(wrapped)) {
mCompressedDecklist.get(mCompressedDecklist.indexOf(wrapped))
.add(card);
} else {
mCompressedDecklist.add(wrapped);
}
if (shouldShowPrice()) {
loadPrice(card);
}
}
}
}

//comment
if (changedCardName != null) {
for (int i = 0; i < mCompressedDecklist.size(); i++) {
if (mCompressedDecklist.get(i).mInfo.size() == 0) {
mCompressedDecklist.remove(i);
i--;
}
}
}
//comment
Collections.sort(mCompressedDecklist, mDecklistChain);
setHeaderValues();
updateDeckCounts(false);
} catch (FamiliarDbException e) {
handleFamiliarDbException(true);
mDecklistReadError = true;
return;
}
mDecklistReadError = false;
}
}","public void readAndCompressDecklist(final String changedCardName, final String deckName) {
synchronized (mCompressedDecklist) {
try {
final String lDeckName = getAndSetDeckName(deckName);

//comment
final ArrayList<MtgCard> decklist =
DecklistHelpers.ReadDecklist(getActivity(), lDeckName, true);

//comment
<start>clearCompressedInfo(changedCardName);<end>

//comment
for (MtgCard card : decklist) {
//comment
if (!card.getName().isEmpty()) {
if (changedCardName == null || changedCardName.equals(card.getName())) {
CompressedDecklistInfo wrapped =
new CompressedDecklistInfo(card);
if (mCompressedDecklist.contains(wrapped)) {
mCompressedDecklist.get(mCompressedDecklist.indexOf(wrapped))
.add(card);
} else {
mCompressedDecklist.add(wrapped);
}
if (shouldShowPrice()) {
loadPrice(card);
}
}
}
}

//comment
if (changedCardName != null) {
for (int i = 0; i < mCompressedDecklist.size(); i++) {
if (mCompressedDecklist.get(i).mInfo.size() == 0) {
mCompressedDecklist.remove(i);
i--;
}
}
}
//comment
Collections.sort(mCompressedDecklist, mDecklistChain);
setHeaderValues();
updateDeckCounts(false);
} catch (FamiliarDbException e) {
handleFamiliarDbException(true);
mDecklistReadError = true;
return;
}
mDecklistReadError = false;
}
}"
2550,"public void readAndCompressDecklist(final String changedCardName, final String deckName) {
synchronized (mCompressedDecklist) {
try {
final String lDeckName = getAndSetDeckName(deckName);

//comment
final ArrayList<MtgCard> decklist =
DecklistHelpers.ReadDecklist(getActivity(), lDeckName, true);

//comment
clearCompressedInfo(changedCardName);

//comment
for (MtgCard card : decklist) {
//comment
<start>if (!card.getName().isEmpty()) {
if (changedCardName == null || changedCardName.equals(card.getName())) {
CompressedDecklistInfo wrapped =
new CompressedDecklistInfo(card);
if (mCompressedDecklist.contains(wrapped)) {
mCompressedDecklist.get(mCompressedDecklist.indexOf(wrapped))
.add(card);
} else {
mCompressedDecklist.add(wrapped);
}
if (shouldShowPrice()) {
loadPrice(card);
}
}
}<end>
}

//comment
if (changedCardName != null) {
for (int i = 0; i < mCompressedDecklist.size(); i++) {
if (mCompressedDecklist.get(i).mInfo.size() == 0) {
mCompressedDecklist.remove(i);
i--;
}
}
}
//comment
Collections.sort(mCompressedDecklist, mDecklistChain);
setHeaderValues();
updateDeckCounts(false);
} catch (FamiliarDbException e) {
handleFamiliarDbException(true);
mDecklistReadError = true;
return;
}
mDecklistReadError = false;
}
}","public void readAndCompressDecklist(final String changedCardName, final String deckName) {
synchronized (mCompressedDecklist) {
try {
final String lDeckName = getAndSetDeckName(deckName);

//comment
final ArrayList<MtgCard> decklist =
DecklistHelpers.ReadDecklist(getActivity(), lDeckName, true);

//comment
clearCompressedInfo(changedCardName);

//comment
<start>for (MtgCard card : decklist) {
//comment
if (!card.getName().isEmpty()) {
if (changedCardName == null || changedCardName.equals(card.getName())) {
CompressedDecklistInfo wrapped =
new CompressedDecklistInfo(card);
if (mCompressedDecklist.contains(wrapped)) {
mCompressedDecklist.get(mCompressedDecklist.indexOf(wrapped))
.add(card);
} else {
mCompressedDecklist.add(wrapped);
}
if (shouldShowPrice()) {
loadPrice(card);
}
}
}
}<end>

//comment
if (changedCardName != null) {
for (int i = 0; i < mCompressedDecklist.size(); i++) {
if (mCompressedDecklist.get(i).mInfo.size() == 0) {
mCompressedDecklist.remove(i);
i--;
}
}
}
//comment
Collections.sort(mCompressedDecklist, mDecklistChain);
setHeaderValues();
updateDeckCounts(false);
} catch (FamiliarDbException e) {
handleFamiliarDbException(true);
mDecklistReadError = true;
return;
}
mDecklistReadError = false;
}
}"
2551,"public void readAndCompressDecklist(final String changedCardName, final String deckName) {
synchronized (mCompressedDecklist) {
try {
final String lDeckName = getAndSetDeckName(deckName);

//comment
final ArrayList<MtgCard> decklist =
DecklistHelpers.ReadDecklist(getActivity(), lDeckName, true);

//comment
clearCompressedInfo(changedCardName);

//comment
for (MtgCard card : decklist) {
//comment
if (!card.getName().isEmpty()) {
if (changedCardName == null || changedCardName.equals(card.getName())) {
CompressedDecklistInfo wrapped =
new CompressedDecklistInfo(card);
if (mCompressedDecklist.contains(wrapped)) {
mCompressedDecklist.get(mCompressedDecklist.indexOf(wrapped))
.add(card);
} else {
mCompressedDecklist.add(wrapped);
}
if (shouldShowPrice()) {
loadPrice(card);
}
}
}
}

//comment
if (changedCardName != null) {
for (int i = 0; i < mCompressedDecklist.size(); i++) {
if (mCompressedDecklist.get(i).mInfo.size() == 0) {
<start>mCompressedDecklist.remove(i);<end>
i--;
}
}
}
//comment
Collections.sort(mCompressedDecklist, mDecklistChain);
setHeaderValues();
updateDeckCounts(false);
} catch (FamiliarDbException e) {
handleFamiliarDbException(true);
mDecklistReadError = true;
return;
}
mDecklistReadError = false;
}
}","public void readAndCompressDecklist(final String changedCardName, final String deckName) {
synchronized (mCompressedDecklist) {
try {
final String lDeckName = getAndSetDeckName(deckName);

//comment
final ArrayList<MtgCard> decklist =
DecklistHelpers.ReadDecklist(getActivity(), lDeckName, true);

//comment
clearCompressedInfo(changedCardName);

//comment
for (MtgCard card : decklist) {
//comment
if (!card.getName().isEmpty()) {
if (changedCardName == null || changedCardName.equals(card.getName())) {
CompressedDecklistInfo wrapped =
new CompressedDecklistInfo(card);
if (mCompressedDecklist.contains(wrapped)) {
mCompressedDecklist.get(mCompressedDecklist.indexOf(wrapped))
.add(card);
} else {
mCompressedDecklist.add(wrapped);
}
if (shouldShowPrice()) {
loadPrice(card);
}
}
}
}

//comment
<start>if (changedCardName != null) {
for (int i = 0; i < mCompressedDecklist.size(); i++) {
if (mCompressedDecklist.get(i).mInfo.size() == 0) {
mCompressedDecklist.remove(i);
i--;
}
}
}<end>
//comment
Collections.sort(mCompressedDecklist, mDecklistChain);
setHeaderValues();
updateDeckCounts(false);
} catch (FamiliarDbException e) {
handleFamiliarDbException(true);
mDecklistReadError = true;
return;
}
mDecklistReadError = false;
}
}"
2552,"public void readAndCompressDecklist(final String changedCardName, final String deckName) {
synchronized (mCompressedDecklist) {
try {
final String lDeckName = getAndSetDeckName(deckName);

//comment
final ArrayList<MtgCard> decklist =
DecklistHelpers.ReadDecklist(getActivity(), lDeckName, true);

//comment
clearCompressedInfo(changedCardName);

//comment
for (MtgCard card : decklist) {
//comment
if (!card.getName().isEmpty()) {
if (changedCardName == null || changedCardName.equals(card.getName())) {
CompressedDecklistInfo wrapped =
new CompressedDecklistInfo(card);
if (mCompressedDecklist.contains(wrapped)) {
mCompressedDecklist.get(mCompressedDecklist.indexOf(wrapped))
.add(card);
} else {
mCompressedDecklist.add(wrapped);
}
if (shouldShowPrice()) {
loadPrice(card);
}
}
}
}

//comment
if (changedCardName != null) {
for (int i = 0; i < mCompressedDecklist.size(); i++) {
if (mCompressedDecklist.get(i).mInfo.size() == 0) {
mCompressedDecklist.remove(i);
i--;
}
}
}
//comment
<start>Collections.sort(mCompressedDecklist, mDecklistChain);<end>
setHeaderValues();
updateDeckCounts(false);
<start>} catch (FamiliarDbException e) {<end>
handleFamiliarDbException(true);
mDecklistReadError = true;
return;
}
mDecklistReadError = false;
}
}","public void readAndCompressDecklist(final String changedCardName, final String deckName) {
synchronized (mCompressedDecklist) {
try {
final String lDeckName = getAndSetDeckName(deckName);

//comment
final ArrayList<MtgCard> decklist =
DecklistHelpers.ReadDecklist(getActivity(), lDeckName, true);

//comment
clearCompressedInfo(changedCardName);

//comment
for (MtgCard card : decklist) {
//comment
if (!card.getName().isEmpty()) {
if (changedCardName == null || changedCardName.equals(card.getName())) {
CompressedDecklistInfo wrapped =
new CompressedDecklistInfo(card);
if (mCompressedDecklist.contains(wrapped)) {
mCompressedDecklist.get(mCompressedDecklist.indexOf(wrapped))
.add(card);
} else {
mCompressedDecklist.add(wrapped);
}
if (shouldShowPrice()) {
loadPrice(card);
}
}
}
}

//comment
if (changedCardName != null) {
for (int i = 0; i < mCompressedDecklist.size(); i++) {
if (mCompressedDecklist.get(i).mInfo.size() == 0) {
mCompressedDecklist.remove(i);
i--;
}
}
}
//comment
<start>Collections.sort(mCompressedDecklist, mDecklistChain);
setHeaderValues();
updateDeckCounts(false);<end>
} catch (FamiliarDbException e) {
handleFamiliarDbException(true);
mDecklistReadError = true;
return;
}
mDecklistReadError = false;
}
}"
2553,"<start>    @Override
public boolean onOptionsItemSelected(MenuItem item) {<end>

//comment
if (item.getItemId() == R.id.deck_menu_new) {
showDialog(DecklistDialogFragment.DIALOG_NEW_DECK, null, false);
return true;
<start>} else if (item.getItemId() == R.id.deck_menu_save_as) {<end>
showDialog(DecklistDialogFragment.DIALOG_SAVE_DECK_AS, null, false);
return true;
} else if (item.getItemId() == R.id.deck_menu_load) {
showDialog(DecklistDialogFragment.DIALOG_LOAD_DECK, null, false);
return true;
} else if (item.getItemId() == R.id.deck_menu_delete) {
showDialog(DecklistDialogFragment.DIALOG_DELETE_DECK, null, false);
return true;
} else if (item.getItemId() == R.id.deck_menu_clear) {
showDialog(DecklistDialogFragment.DIALOG_CONFIRMATION, null, false);
return true;
} else if (item.getItemId() == R.id.deck_menu_import) {
startNewFragment(new ImportFragment(), null);
return true;
} else if (item.getItemId() == R.id.deck_menu_share) {
//comment
Intent sendIntent = new Intent();
sendIntent.setAction(Intent.ACTION_SEND);
sendIntent.putExtra(Intent.EXTRA_SUBJECT, R.string.decklist_share_title);
synchronized (mCompressedDecklist) {
sendIntent.putExtra(Intent.EXTRA_TEXT, DecklistHelpers
.getSharableDecklist(mCompressedDecklist, getActivity()));
}
sendIntent.setType(""text/plain"");
try {
startActivity(Intent.createChooser(sendIntent,
getString(R.string.decklist_share)));
} catch (ActivityNotFoundException anfe) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.error_no_email_client,
SnackbarWrapper.LENGTH_LONG);
}
return true;
} else if (item.getItemId() == R.id.deck_menu_stats) {
try {
//comment
if (null == mCurrentDeck || mCurrentDeck.isEmpty()) {
mCurrentDeck = AUTOSAVE_NAME;
saveCurrentDeck(false);
}
startNewFragment(new DeckStatsFragment(DecklistHelpers.ReadDecklist(getActivity(), mCurrentDeck + "".deck"", true)), null);
} catch (FamiliarDbException e) {
handleFamiliarDbException(false);
}
return true;
} else if (item.getItemId() == R.id.deck_menu_legality) {
getFamiliarActivity().setLoading();

if (null != mLegalityCheckerTask) {
mLegalityCheckerTask.cancel(true);
}
mLegalityCheckerTask = new LegalityCheckerTask();
mLegalityCheckerTask.execute(this);
return true;
} else if (item.getItemId() == R.id.deck_menu_settings) {
showDialog(DecklistDialogFragment.DIALOG_PRICE_SETTING, null, false);
return true;
} else {
return super.onOptionsItemSelected(item);
}
}","    @Override
public boolean onOptionsItemSelected(MenuItem item) {

//comment
<start>if (item.getItemId() == R.id.deck_menu_new) {<end>
showDialog(DecklistDialogFragment.DIALOG_NEW_DECK, null, false);
return true;
<start>} else if (item.getItemId() == R.id.deck_menu_save_as) {<end>
showDialog(DecklistDialogFragment.DIALOG_SAVE_DECK_AS, null, false);
return true;
<start>} else if (item.getItemId() == R.id.deck_menu_load) {<end>
showDialog(DecklistDialogFragment.DIALOG_LOAD_DECK, null, false);
return true;
<start>} else if (item.getItemId() == R.id.deck_menu_delete) {<end>
showDialog(DecklistDialogFragment.DIALOG_DELETE_DECK, null, false);
return true;
<start>} else if (item.getItemId() == R.id.deck_menu_clear) {<end>
showDialog(DecklistDialogFragment.DIALOG_CONFIRMATION, null, false);
return true;
<start>} else if (item.getItemId() == R.id.deck_menu_import) {<end>
startNewFragment(new ImportFragment(), null);
return true;
<start>} else if (item.getItemId() == R.id.deck_menu_share) {<end>
//comment
Intent sendIntent = new Intent();
sendIntent.setAction(Intent.ACTION_SEND);
sendIntent.putExtra(Intent.EXTRA_SUBJECT, R.string.decklist_share_title);
synchronized (mCompressedDecklist) {
sendIntent.putExtra(Intent.EXTRA_TEXT, DecklistHelpers
.getSharableDecklist(mCompressedDecklist, getActivity()));
}
sendIntent.setType(""text/plain"");
try {
startActivity(Intent.createChooser(sendIntent,
getString(R.string.decklist_share)));
} catch (ActivityNotFoundException anfe) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.error_no_email_client,
SnackbarWrapper.LENGTH_LONG);
}
return true;
<start>} else if (item.getItemId() == R.id.deck_menu_stats) {<end>
try {
//comment
if (null == mCurrentDeck || mCurrentDeck.isEmpty()) {
mCurrentDeck = AUTOSAVE_NAME;
saveCurrentDeck(false);
}
startNewFragment(new DeckStatsFragment(DecklistHelpers.ReadDecklist(getActivity(), mCurrentDeck + "".deck"", true)), null);
} catch (FamiliarDbException e) {
handleFamiliarDbException(false);
}
return true;
<start>} else if (item.getItemId() == R.id.deck_menu_legality) {<end>
getFamiliarActivity().setLoading();

if (null != mLegalityCheckerTask) {
mLegalityCheckerTask.cancel(true);
}
mLegalityCheckerTask = new LegalityCheckerTask();
mLegalityCheckerTask.execute(this);
return true;
<start>} else if (item.getItemId() == R.id.deck_menu_settings) {<end>
showDialog(DecklistDialogFragment.DIALOG_PRICE_SETTING, null, false);
return true;
<start>} else {<end>
return super.onOptionsItemSelected(item);
<start>}<end>
}"
2554,"    @Override
public boolean onOptionsItemSelected(MenuItem item) {

//comment
if (item.getItemId() == R.id.deck_menu_new) {
showDialog(DecklistDialogFragment.DIALOG_NEW_DECK, null, false);
return true;
} else if (item.getItemId() == R.id.deck_menu_save_as) {
showDialog(DecklistDialogFragment.DIALOG_SAVE_DECK_AS, null, false);
return true;
} else if (item.getItemId() == R.id.deck_menu_load) {
showDialog(DecklistDialogFragment.DIALOG_LOAD_DECK, null, false);
return true;
} else if (item.getItemId() == R.id.deck_menu_delete) {
showDialog(DecklistDialogFragment.DIALOG_DELETE_DECK, null, false);
return true;
} else if (item.getItemId() == R.id.deck_menu_clear) {
showDialog(DecklistDialogFragment.DIALOG_CONFIRMATION, null, false);
return true;
} else if (item.getItemId() == R.id.deck_menu_import) {
startNewFragment(new ImportFragment(), null);
return true;
<start>} else if (item.getItemId() == R.id.deck_menu_share) {<end>
//comment
Intent sendIntent = new Intent();
sendIntent.setAction(Intent.ACTION_SEND);
<start>sendIntent.putExtra(Intent.EXTRA_SUBJECT, R.string.decklist_share_title);<end>
synchronized (mCompressedDecklist) {
sendIntent.putExtra(Intent.EXTRA_TEXT, DecklistHelpers
.getSharableDecklist(mCompressedDecklist, getActivity()));
}
sendIntent.setType(""text/plain"");
try {
startActivity(Intent.createChooser(sendIntent,
getString(R.string.decklist_share)));
} catch (ActivityNotFoundException anfe) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.error_no_email_client,
SnackbarWrapper.LENGTH_LONG);
}
return true;
} else if (item.getItemId() == R.id.deck_menu_stats) {
try {
//comment
if (null == mCurrentDeck || mCurrentDeck.isEmpty()) {
mCurrentDeck = AUTOSAVE_NAME;
saveCurrentDeck(false);
}
startNewFragment(new DeckStatsFragment(DecklistHelpers.ReadDecklist(getActivity(), mCurrentDeck + "".deck"", true)), null);
} catch (FamiliarDbException e) {
handleFamiliarDbException(false);
}
return true;
} else if (item.getItemId() == R.id.deck_menu_legality) {
getFamiliarActivity().setLoading();

if (null != mLegalityCheckerTask) {
mLegalityCheckerTask.cancel(true);
}
mLegalityCheckerTask = new LegalityCheckerTask();
mLegalityCheckerTask.execute(this);
return true;
} else if (item.getItemId() == R.id.deck_menu_settings) {
showDialog(DecklistDialogFragment.DIALOG_PRICE_SETTING, null, false);
return true;
} else {
return super.onOptionsItemSelected(item);
}
}","    @Override
public boolean onOptionsItemSelected(MenuItem item) {

//comment
if (item.getItemId() == R.id.deck_menu_new) {
showDialog(DecklistDialogFragment.DIALOG_NEW_DECK, null, false);
return true;
} else if (item.getItemId() == R.id.deck_menu_save_as) {
showDialog(DecklistDialogFragment.DIALOG_SAVE_DECK_AS, null, false);
return true;
} else if (item.getItemId() == R.id.deck_menu_load) {
showDialog(DecklistDialogFragment.DIALOG_LOAD_DECK, null, false);
return true;
} else if (item.getItemId() == R.id.deck_menu_delete) {
showDialog(DecklistDialogFragment.DIALOG_DELETE_DECK, null, false);
return true;
} else if (item.getItemId() == R.id.deck_menu_clear) {
showDialog(DecklistDialogFragment.DIALOG_CONFIRMATION, null, false);
return true;
} else if (item.getItemId() == R.id.deck_menu_import) {
startNewFragment(new ImportFragment(), null);
return true;
} else if (item.getItemId() == R.id.deck_menu_share) {
//comment
<start>Intent sendIntent = new Intent();
sendIntent.setAction(Intent.ACTION_SEND);
sendIntent.putExtra(Intent.EXTRA_SUBJECT, R.string.decklist_share_title);
synchronized (mCompressedDecklist) {
sendIntent.putExtra(Intent.EXTRA_TEXT, DecklistHelpers
.getSharableDecklist(mCompressedDecklist, getActivity()));
}
sendIntent.setType(""text/plain"");
try {
startActivity(Intent.createChooser(sendIntent,
getString(R.string.decklist_share)));
} catch (ActivityNotFoundException anfe) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.error_no_email_client,
SnackbarWrapper.LENGTH_LONG);
}
return true;<end>
} else if (item.getItemId() == R.id.deck_menu_stats) {
try {
//comment
if (null == mCurrentDeck || mCurrentDeck.isEmpty()) {
mCurrentDeck = AUTOSAVE_NAME;
saveCurrentDeck(false);
}
startNewFragment(new DeckStatsFragment(DecklistHelpers.ReadDecklist(getActivity(), mCurrentDeck + "".deck"", true)), null);
} catch (FamiliarDbException e) {
handleFamiliarDbException(false);
}
return true;
} else if (item.getItemId() == R.id.deck_menu_legality) {
getFamiliarActivity().setLoading();

if (null != mLegalityCheckerTask) {
mLegalityCheckerTask.cancel(true);
}
mLegalityCheckerTask = new LegalityCheckerTask();
mLegalityCheckerTask.execute(this);
return true;
} else if (item.getItemId() == R.id.deck_menu_settings) {
showDialog(DecklistDialogFragment.DIALOG_PRICE_SETTING, null, false);
return true;
} else {
return super.onOptionsItemSelected(item);
}
}"
2555,"    @Override
public boolean onOptionsItemSelected(MenuItem item) {

//comment
if (item.getItemId() == R.id.deck_menu_new) {
showDialog(DecklistDialogFragment.DIALOG_NEW_DECK, null, false);
return true;
} else if (item.getItemId() == R.id.deck_menu_save_as) {
showDialog(DecklistDialogFragment.DIALOG_SAVE_DECK_AS, null, false);
return true;
} else if (item.getItemId() == R.id.deck_menu_load) {
showDialog(DecklistDialogFragment.DIALOG_LOAD_DECK, null, false);
return true;
} else if (item.getItemId() == R.id.deck_menu_delete) {
showDialog(DecklistDialogFragment.DIALOG_DELETE_DECK, null, false);
return true;
} else if (item.getItemId() == R.id.deck_menu_clear) {
showDialog(DecklistDialogFragment.DIALOG_CONFIRMATION, null, false);
return true;
} else if (item.getItemId() == R.id.deck_menu_import) {
startNewFragment(new ImportFragment(), null);
return true;
} else if (item.getItemId() == R.id.deck_menu_share) {
//comment
Intent sendIntent = new Intent();
sendIntent.setAction(Intent.ACTION_SEND);
sendIntent.putExtra(Intent.EXTRA_SUBJECT, R.string.decklist_share_title);
synchronized (mCompressedDecklist) {
sendIntent.putExtra(Intent.EXTRA_TEXT, DecklistHelpers
.getSharableDecklist(mCompressedDecklist, getActivity()));
}
sendIntent.setType(""text/plain"");
try {
startActivity(Intent.createChooser(sendIntent,
getString(R.string.decklist_share)));
} catch (ActivityNotFoundException anfe) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.error_no_email_client,
SnackbarWrapper.LENGTH_LONG);
}
return true;
} else if (item.getItemId() == R.id.deck_menu_stats) {
try {
//comment
if (null == mCurrentDeck || mCurrentDeck.isEmpty()) {
mCurrentDeck = AUTOSAVE_NAME;
saveCurrentDeck(false);
}
<start>startNewFragment(new DeckStatsFragment(DecklistHelpers.ReadDecklist(getActivity(), mCurrentDeck + "".deck"", true)), null);<end>
} catch (FamiliarDbException e) {
handleFamiliarDbException(false);
}
return true;
} else if (item.getItemId() == R.id.deck_menu_legality) {
getFamiliarActivity().setLoading();

if (null != mLegalityCheckerTask) {
mLegalityCheckerTask.cancel(true);
}
mLegalityCheckerTask = new LegalityCheckerTask();
mLegalityCheckerTask.execute(this);
return true;
} else if (item.getItemId() == R.id.deck_menu_settings) {
showDialog(DecklistDialogFragment.DIALOG_PRICE_SETTING, null, false);
return true;
} else {
return super.onOptionsItemSelected(item);
}
}","    @Override
public boolean onOptionsItemSelected(MenuItem item) {

//comment
if (item.getItemId() == R.id.deck_menu_new) {
showDialog(DecklistDialogFragment.DIALOG_NEW_DECK, null, false);
return true;
} else if (item.getItemId() == R.id.deck_menu_save_as) {
showDialog(DecklistDialogFragment.DIALOG_SAVE_DECK_AS, null, false);
return true;
} else if (item.getItemId() == R.id.deck_menu_load) {
showDialog(DecklistDialogFragment.DIALOG_LOAD_DECK, null, false);
return true;
} else if (item.getItemId() == R.id.deck_menu_delete) {
showDialog(DecklistDialogFragment.DIALOG_DELETE_DECK, null, false);
return true;
} else if (item.getItemId() == R.id.deck_menu_clear) {
showDialog(DecklistDialogFragment.DIALOG_CONFIRMATION, null, false);
return true;
} else if (item.getItemId() == R.id.deck_menu_import) {
startNewFragment(new ImportFragment(), null);
return true;
} else if (item.getItemId() == R.id.deck_menu_share) {
//comment
Intent sendIntent = new Intent();
sendIntent.setAction(Intent.ACTION_SEND);
sendIntent.putExtra(Intent.EXTRA_SUBJECT, R.string.decklist_share_title);
synchronized (mCompressedDecklist) {
sendIntent.putExtra(Intent.EXTRA_TEXT, DecklistHelpers
.getSharableDecklist(mCompressedDecklist, getActivity()));
}
sendIntent.setType(""text/plain"");
try {
startActivity(Intent.createChooser(sendIntent,
getString(R.string.decklist_share)));
} catch (ActivityNotFoundException anfe) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.error_no_email_client,
SnackbarWrapper.LENGTH_LONG);
}
return true;
} else if (item.getItemId() == R.id.deck_menu_stats) {
try {
//comment
<start>if (null == mCurrentDeck || mCurrentDeck.isEmpty()) {
mCurrentDeck = AUTOSAVE_NAME;
saveCurrentDeck(false);
}<end>
startNewFragment(new DeckStatsFragment(DecklistHelpers.ReadDecklist(getActivity(), mCurrentDeck + "".deck"", true)), null);
} catch (FamiliarDbException e) {
handleFamiliarDbException(false);
}
return true;
} else if (item.getItemId() == R.id.deck_menu_legality) {
getFamiliarActivity().setLoading();

if (null != mLegalityCheckerTask) {
mLegalityCheckerTask.cancel(true);
}
mLegalityCheckerTask = new LegalityCheckerTask();
mLegalityCheckerTask.execute(this);
return true;
} else if (item.getItemId() == R.id.deck_menu_settings) {
showDialog(DecklistDialogFragment.DIALOG_PRICE_SETTING, null, false);
return true;
} else {
return super.onOptionsItemSelected(item);
}
}"
2556,"    public void saveCurrentDeck(boolean showSnackbar) {
//comment
if (!mDecklistReadError) {
String currentDeckName = getCurrentDeckName();
synchronized (mCompressedDecklist) {
DecklistHelpers.WriteCompressedDecklist(getActivity(), mCompressedDecklist,
currentDeckName);
}
if (showSnackbar) {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.decklist_saved_toast,
currentDeckName), SnackbarWrapper.LENGTH_SHORT);
}
}
}","    public void saveCurrentDeck(boolean showSnackbar) {
//comment
<start>if (!mDecklistReadError) {<end>
String currentDeckName = getCurrentDeckName();
synchronized (mCompressedDecklist) {
DecklistHelpers.WriteCompressedDecklist(getActivity(), mCompressedDecklist,
currentDeckName);
}
if (showSnackbar) {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.decklist_saved_toast,
currentDeckName), SnackbarWrapper.LENGTH_SHORT);
}
}
}"
2675,"@Override
public View onCreateView(@NonNull LayoutInflater inflater,
ViewGroup container,
Bundle savedInstanceState) {

final View myFragmentView =
inflater.inflate(R.layout.import_frag, container, false);
assert myFragmentView != null;

mDeckName = myFragmentView.findViewById(R.id.importName);
mDeckText = myFragmentView.findViewById(R.id.import_editText);

//comment
<start>mDeckText.addTextChangedListener(new TextWatcher() {<end>
@Override
public void onTextChanged(CharSequence s, int start, int countBefore, int countAfter) {
//comment
//comment
if (mDeckName.length() == 0 && start < 100) {
mDeckName.setText(DeckListImporter.tryGuessDeckName(s.toString()));
}
}

@Override
public void afterTextChanged(Editable editable) {
}

@Override
public void beforeTextChanged(CharSequence s, int start, int countBefore, int countAfter) {
}
});

Button startButton = myFragmentView.findViewById(R.id.import_start);
startButton.setOnClickListener(view -> {
((Button) view).setText(R.string.import_loading);
importDeck();
((Button) view).setText(R.string.import_start);
});

return myFragmentView;
}","@Override
public View onCreateView(@NonNull LayoutInflater inflater,
ViewGroup container,
Bundle savedInstanceState) {

final View myFragmentView =
inflater.inflate(R.layout.import_frag, container, false);
assert myFragmentView != null;

mDeckName = myFragmentView.findViewById(R.id.importName);
mDeckText = myFragmentView.findViewById(R.id.import_editText);

//comment
mDeckText.addTextChangedListener(new TextWatcher() {
@Override
<start>public void onTextChanged(CharSequence s, int start, int countBefore, int countAfter) {
//comment
//comment
if (mDeckName.length() == 0 && start < 100) {
mDeckName.setText(DeckListImporter.tryGuessDeckName(s.toString()));
}
}<end>

@Override
public void afterTextChanged(Editable editable) {
}

@Override
public void beforeTextChanged(CharSequence s, int start, int countBefore, int countAfter) {
}
});

Button startButton = myFragmentView.findViewById(R.id.import_start);
startButton.setOnClickListener(view -> {
((Button) view).setText(R.string.import_loading);
importDeck();
((Button) view).setText(R.string.import_start);
});

return myFragmentView;
}"
2676,"private void importDeck() {

if (mImportStarted) {
return;
}
mImportStarted = true;

final FamiliarActivity activity = getFamiliarActivity();

//comment
<start>if (getDeckNameInput() == null || getDeckNameInput().length() == 0) {
SnackbarWrapper.makeAndShowText(getFamiliarActivity(), R.string.empty_deck_name, SnackbarWrapper.LENGTH_LONG);
mImportStarted = false;
return;
}<end>

if (getDeckTextInput() == null || getDeckTextInput().length() == 0) {
SnackbarWrapper.makeAndShowText(getFamiliarActivity(), R.string.empty_deck_text, SnackbarWrapper.LENGTH_LONG);
mImportStarted = false;
return;
}

//comment

activity.setLoading();

final String name = String.valueOf(getDeckNameInput());
final String lines = String.valueOf(getDeckTextInput());

mImportTask = new ImportTask(this, name, lines).execute();
}","private void importDeck() {

if (mImportStarted) {
return;
}
mImportStarted = true;

final FamiliarActivity activity = getFamiliarActivity();

//comment
<start>if (getDeckNameInput() == null || getDeckNameInput().length() == 0) {<end>
SnackbarWrapper.makeAndShowText(getFamiliarActivity(), R.string.empty_deck_name, SnackbarWrapper.LENGTH_LONG);
mImportStarted = false;
return;
}

if (getDeckTextInput() == null || getDeckTextInput().length() == 0) {
SnackbarWrapper.makeAndShowText(getFamiliarActivity(), R.string.empty_deck_text, SnackbarWrapper.LENGTH_LONG);
mImportStarted = false;
return;
}

//comment

activity.setLoading();

final String name = String.valueOf(getDeckNameInput());
final String lines = String.valueOf(getDeckTextInput());

mImportTask = new ImportTask(this, name, lines).execute();
}"
2677,"@Override
protected DeckListImporter doInBackground(ImportFragment... args) {
final DeckListImporter importer = new DeckListImporter();
try (BufferedReader br = new BufferedReader(new StringReader(mLines))) {
String line;
while ((line = br.readLine()) != null) {
importer.parseLine(line);
}
} catch (IOException e) {
//comment
//comment
return importer;
}
//comment
List<MtgCard> cardList = importer.getParsedCards();
//comment
try {
//comment
//comment
MtgCard.initCardListFromDb(mFrag.getContext(), cardList);
} catch (FamiliarDbException fde) {
mFrag.handleFamiliarDbException(false);
}

//comment
for (MtgCard card : cardList) {
if (card.getMultiverseId() == 0) {
try {
MtgCard noSetCard = new MtgCard(mFrag.getActivity(), card.getName(), null, null, card.mIsFoil, card.mNumberOf, card.isSideboard());
importedCards.add(noSetCard);
} catch (java.lang.InstantiationException e) {
unknownCards.add(card);
}
} else {
importedCards.add(card);
}
}
<start>publishProgress(importer.getErrorLines().toArray(new String[0]));<end>
//comment
if (!importedCards.isEmpty()) {
<start>DecklistHelpers.WriteDecklist(mFrag.getFamiliarActivity(), importedCards, mName + "".deck"");<end>
}

return importer;
}","@Override
protected DeckListImporter doInBackground(ImportFragment... args) {
final DeckListImporter importer = new DeckListImporter();
try (BufferedReader br = new BufferedReader(new StringReader(mLines))) {
String line;
while ((line = br.readLine()) != null) {
importer.parseLine(line);
}
} catch (IOException e) {
//comment
//comment
return importer;
}
//comment
List<MtgCard> cardList = importer.getParsedCards();
//comment
try {
//comment
//comment
MtgCard.initCardListFromDb(mFrag.getContext(), cardList);
} catch (FamiliarDbException fde) {
mFrag.handleFamiliarDbException(false);
}

//comment
for (MtgCard card : cardList) {
if (card.getMultiverseId() == 0) {
try {
MtgCard noSetCard = new MtgCard(mFrag.getActivity(), card.getName(), null, null, card.mIsFoil, card.mNumberOf, card.isSideboard());
importedCards.add(noSetCard);
} catch (java.lang.InstantiationException e) {
unknownCards.add(card);
}
} else {
importedCards.add(card);
}
}
publishProgress(importer.getErrorLines().toArray(new String[0]));
//comment
if (!importedCards.isEmpty()) {
<start>DecklistHelpers.WriteDecklist(mFrag.getFamiliarActivity(), importedCards, mName + "".deck"");<end>
}

return importer;
}"
6078,"    @Override
public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

mRandom = new Random(System.currentTimeMillis());

View myFragmentView = inflater.inflate(R.layout.mojhosto_frag, container, false);

assert myFragmentView != null;

//comment
<start>myFragmentView.findViewById(R.id.imageViewMo).setOnClickListener(v -> showDialog(MoJhoStoDialogFragment.DIALOG_MOMIR));<end>

myFragmentView.findViewById(R.id.imageViewSto).setOnClickListener(v -> showDialog(MoJhoStoDialogFragment.DIALOG_STONEHEWER));

myFragmentView.findViewById(R.id.imageViewJho).setOnClickListener(v -> showDialog(MoJhoStoDialogFragment.DIALOG_JHOIRA));

//comment
myFragmentView.findViewById(R.id.momir_button).setOnClickListener(v -> {
try {
int cmc = Integer.parseInt((String) mMomirCmcChoice.getSelectedItem());
getOneSpell(CREATURE, cmc);
} catch (NumberFormatException e) {
//comment
}
});

myFragmentView.findViewById(R.id.stonehewer_button).setOnClickListener(v -> {
try {
int cmc = Integer.parseInt((String) mStonehewerCmcChoice.getSelectedItem());
getOneSpell(EQUIPMENT, cmc);
} catch (NumberFormatException e) {
//comment
}
});

myFragmentView.findViewById(R.id.jhorira_instant_button).setOnClickListener(v -> getThreeSpells(INSTANT));

myFragmentView.findViewById(R.id.jhorira_sorcery_button).setOnClickListener(v -> getThreeSpells(SORCERY));

//comment
mMomirCmcChoice = myFragmentView.findViewById(R.id.momir_spinner);
mStonehewerCmcChoice = myFragmentView.findViewById(R.id.stonehewer_spinner);

//comment
return myFragmentView;
}","    @Override
public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

mRandom = new Random(System.currentTimeMillis());

View myFragmentView = inflater.inflate(R.layout.mojhosto_frag, container, false);

assert myFragmentView != null;

//comment
<start>myFragmentView.findViewById(R.id.imageViewMo).setOnClickListener(v -> showDialog(MoJhoStoDialogFragment.DIALOG_MOMIR));

myFragmentView.findViewById(R.id.imageViewSto).setOnClickListener(v -> showDialog(MoJhoStoDialogFragment.DIALOG_STONEHEWER));

myFragmentView.findViewById(R.id.imageViewJho).setOnClickListener(v -> showDialog(MoJhoStoDialogFragment.DIALOG_JHOIRA));<end>

//comment
myFragmentView.findViewById(R.id.momir_button).setOnClickListener(v -> {
try {
int cmc = Integer.parseInt((String) mMomirCmcChoice.getSelectedItem());
getOneSpell(CREATURE, cmc);
} catch (NumberFormatException e) {
//comment
}
});

myFragmentView.findViewById(R.id.stonehewer_button).setOnClickListener(v -> {
try {
int cmc = Integer.parseInt((String) mStonehewerCmcChoice.getSelectedItem());
getOneSpell(EQUIPMENT, cmc);
} catch (NumberFormatException e) {
//comment
}
});

myFragmentView.findViewById(R.id.jhorira_instant_button).setOnClickListener(v -> getThreeSpells(INSTANT));

myFragmentView.findViewById(R.id.jhorira_sorcery_button).setOnClickListener(v -> getThreeSpells(SORCERY));

//comment
mMomirCmcChoice = myFragmentView.findViewById(R.id.momir_spinner);
mStonehewerCmcChoice = myFragmentView.findViewById(R.id.stonehewer_spinner);

//comment
return myFragmentView;
}"
6079,"    @Override
public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

mRandom = new Random(System.currentTimeMillis());

View myFragmentView = inflater.inflate(R.layout.mojhosto_frag, container, false);

assert myFragmentView != null;

//comment
myFragmentView.findViewById(R.id.imageViewMo).setOnClickListener(v -> showDialog(MoJhoStoDialogFragment.DIALOG_MOMIR));

myFragmentView.findViewById(R.id.imageViewSto).setOnClickListener(v -> showDialog(MoJhoStoDialogFragment.DIALOG_STONEHEWER));

myFragmentView.findViewById(R.id.imageViewJho).setOnClickListener(v -> showDialog(MoJhoStoDialogFragment.DIALOG_JHOIRA));

//comment
<start>myFragmentView.findViewById(R.id.momir_button).setOnClickListener(v -> {<end>
try {
int cmc = Integer.parseInt((String) mMomirCmcChoice.getSelectedItem());
getOneSpell(CREATURE, cmc);
} catch (NumberFormatException e) {
//comment
}
});

myFragmentView.findViewById(R.id.stonehewer_button).setOnClickListener(v -> {
try {
int cmc = Integer.parseInt((String) mStonehewerCmcChoice.getSelectedItem());
getOneSpell(EQUIPMENT, cmc);
} catch (NumberFormatException e) {
//comment
}
});

myFragmentView.findViewById(R.id.jhorira_instant_button).setOnClickListener(v -> getThreeSpells(INSTANT));

myFragmentView.findViewById(R.id.jhorira_sorcery_button).setOnClickListener(v -> getThreeSpells(SORCERY));

//comment
mMomirCmcChoice = myFragmentView.findViewById(R.id.momir_spinner);
mStonehewerCmcChoice = myFragmentView.findViewById(R.id.stonehewer_spinner);

//comment
return myFragmentView;
}","    @Override
public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

mRandom = new Random(System.currentTimeMillis());

View myFragmentView = inflater.inflate(R.layout.mojhosto_frag, container, false);

assert myFragmentView != null;

//comment
myFragmentView.findViewById(R.id.imageViewMo).setOnClickListener(v -> showDialog(MoJhoStoDialogFragment.DIALOG_MOMIR));

myFragmentView.findViewById(R.id.imageViewSto).setOnClickListener(v -> showDialog(MoJhoStoDialogFragment.DIALOG_STONEHEWER));

myFragmentView.findViewById(R.id.imageViewJho).setOnClickListener(v -> showDialog(MoJhoStoDialogFragment.DIALOG_JHOIRA));

//comment
<start>myFragmentView.findViewById(R.id.momir_button).setOnClickListener(v -> {
try {
int cmc = Integer.parseInt((String) mMomirCmcChoice.getSelectedItem());
getOneSpell(CREATURE, cmc);
} catch (NumberFormatException e) {
//comment
}
});<end>

myFragmentView.findViewById(R.id.stonehewer_button).setOnClickListener(v -> {
try {
int cmc = Integer.parseInt((String) mStonehewerCmcChoice.getSelectedItem());
getOneSpell(EQUIPMENT, cmc);
} catch (NumberFormatException e) {
//comment
}
});

myFragmentView.findViewById(R.id.jhorira_instant_button).setOnClickListener(v -> getThreeSpells(INSTANT));

myFragmentView.findViewById(R.id.jhorira_sorcery_button).setOnClickListener(v -> getThreeSpells(SORCERY));

//comment
mMomirCmcChoice = myFragmentView.findViewById(R.id.momir_spinner);
mStonehewerCmcChoice = myFragmentView.findViewById(R.id.stonehewer_spinner);

//comment
return myFragmentView;
}"
6080,"    @Override
public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

mRandom = new Random(System.currentTimeMillis());

View myFragmentView = inflater.inflate(R.layout.mojhosto_frag, container, false);

assert myFragmentView != null;

//comment
myFragmentView.findViewById(R.id.imageViewMo).setOnClickListener(v -> showDialog(MoJhoStoDialogFragment.DIALOG_MOMIR));

myFragmentView.findViewById(R.id.imageViewSto).setOnClickListener(v -> showDialog(MoJhoStoDialogFragment.DIALOG_STONEHEWER));

myFragmentView.findViewById(R.id.imageViewJho).setOnClickListener(v -> showDialog(MoJhoStoDialogFragment.DIALOG_JHOIRA));

//comment
myFragmentView.findViewById(R.id.momir_button).setOnClickListener(v -> {
try {
int cmc = Integer.parseInt((String) mMomirCmcChoice.getSelectedItem());
getOneSpell(CREATURE, cmc);
} catch (NumberFormatException e) {
//comment
}
});

myFragmentView.findViewById(R.id.stonehewer_button).setOnClickListener(v -> {
try {
int cmc = Integer.parseInt((String) mStonehewerCmcChoice.getSelectedItem());
getOneSpell(EQUIPMENT, cmc);
} catch (NumberFormatException e) {
//comment
}
});

myFragmentView.findViewById(R.id.jhorira_instant_button).setOnClickListener(v -> getThreeSpells(INSTANT));

myFragmentView.findViewById(R.id.jhorira_sorcery_button).setOnClickListener(v -> getThreeSpells(SORCERY));

//comment
<start>mMomirCmcChoice = myFragmentView.findViewById(R.id.momir_spinner);<end>
mStonehewerCmcChoice = myFragmentView.findViewById(R.id.stonehewer_spinner);

//comment
return myFragmentView;
}","    @Override
public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

mRandom = new Random(System.currentTimeMillis());

View myFragmentView = inflater.inflate(R.layout.mojhosto_frag, container, false);

assert myFragmentView != null;

//comment
myFragmentView.findViewById(R.id.imageViewMo).setOnClickListener(v -> showDialog(MoJhoStoDialogFragment.DIALOG_MOMIR));

myFragmentView.findViewById(R.id.imageViewSto).setOnClickListener(v -> showDialog(MoJhoStoDialogFragment.DIALOG_STONEHEWER));

myFragmentView.findViewById(R.id.imageViewJho).setOnClickListener(v -> showDialog(MoJhoStoDialogFragment.DIALOG_JHOIRA));

//comment
myFragmentView.findViewById(R.id.momir_button).setOnClickListener(v -> {
try {
int cmc = Integer.parseInt((String) mMomirCmcChoice.getSelectedItem());
getOneSpell(CREATURE, cmc);
} catch (NumberFormatException e) {
//comment
}
});

myFragmentView.findViewById(R.id.stonehewer_button).setOnClickListener(v -> {
try {
int cmc = Integer.parseInt((String) mStonehewerCmcChoice.getSelectedItem());
getOneSpell(EQUIPMENT, cmc);
} catch (NumberFormatException e) {
//comment
}
});

myFragmentView.findViewById(R.id.jhorira_instant_button).setOnClickListener(v -> getThreeSpells(INSTANT));

myFragmentView.findViewById(R.id.jhorira_sorcery_button).setOnClickListener(v -> getThreeSpells(SORCERY));

//comment
<start>mMomirCmcChoice = myFragmentView.findViewById(R.id.momir_spinner);
mStonehewerCmcChoice = myFragmentView.findViewById(R.id.stonehewer_spinner);<end>

//comment
return myFragmentView;
}"
6081,"    @Override
public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

mRandom = new Random(System.currentTimeMillis());

View myFragmentView = inflater.inflate(R.layout.mojhosto_frag, container, false);

assert myFragmentView != null;

//comment
myFragmentView.findViewById(R.id.imageViewMo).setOnClickListener(v -> showDialog(MoJhoStoDialogFragment.DIALOG_MOMIR));

myFragmentView.findViewById(R.id.imageViewSto).setOnClickListener(v -> showDialog(MoJhoStoDialogFragment.DIALOG_STONEHEWER));

myFragmentView.findViewById(R.id.imageViewJho).setOnClickListener(v -> showDialog(MoJhoStoDialogFragment.DIALOG_JHOIRA));

//comment
myFragmentView.findViewById(R.id.momir_button).setOnClickListener(v -> {
try {
int cmc = Integer.parseInt((String) mMomirCmcChoice.getSelectedItem());
getOneSpell(CREATURE, cmc);
} catch (NumberFormatException e) {
//comment
}
});

myFragmentView.findViewById(R.id.stonehewer_button).setOnClickListener(v -> {
try {
int cmc = Integer.parseInt((String) mStonehewerCmcChoice.getSelectedItem());
getOneSpell(EQUIPMENT, cmc);
} catch (NumberFormatException e) {
//comment
}
});

myFragmentView.findViewById(R.id.jhorira_instant_button).setOnClickListener(v -> getThreeSpells(INSTANT));

myFragmentView.findViewById(R.id.jhorira_sorcery_button).setOnClickListener(v -> getThreeSpells(SORCERY));

//comment
mMomirCmcChoice = myFragmentView.findViewById(R.id.momir_spinner);
mStonehewerCmcChoice = myFragmentView.findViewById(R.id.stonehewer_spinner);

//comment
<start>return myFragmentView;<end>
}","    @Override
public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

mRandom = new Random(System.currentTimeMillis());

View myFragmentView = inflater.inflate(R.layout.mojhosto_frag, container, false);

assert myFragmentView != null;

//comment
myFragmentView.findViewById(R.id.imageViewMo).setOnClickListener(v -> showDialog(MoJhoStoDialogFragment.DIALOG_MOMIR));

myFragmentView.findViewById(R.id.imageViewSto).setOnClickListener(v -> showDialog(MoJhoStoDialogFragment.DIALOG_STONEHEWER));

myFragmentView.findViewById(R.id.imageViewJho).setOnClickListener(v -> showDialog(MoJhoStoDialogFragment.DIALOG_JHOIRA));

//comment
myFragmentView.findViewById(R.id.momir_button).setOnClickListener(v -> {
try {
int cmc = Integer.parseInt((String) mMomirCmcChoice.getSelectedItem());
getOneSpell(CREATURE, cmc);
} catch (NumberFormatException e) {
//comment
}
});

myFragmentView.findViewById(R.id.stonehewer_button).setOnClickListener(v -> {
try {
int cmc = Integer.parseInt((String) mStonehewerCmcChoice.getSelectedItem());
getOneSpell(EQUIPMENT, cmc);
} catch (NumberFormatException e) {
//comment
}
});

myFragmentView.findViewById(R.id.jhorira_instant_button).setOnClickListener(v -> getThreeSpells(INSTANT));

myFragmentView.findViewById(R.id.jhorira_sorcery_button).setOnClickListener(v -> getThreeSpells(SORCERY));

//comment
mMomirCmcChoice = myFragmentView.findViewById(R.id.momir_spinner);
mStonehewerCmcChoice = myFragmentView.findViewById(R.id.stonehewer_spinner);

//comment
<start>return myFragmentView;<end>
}"
6082,"    private void showDialog(int id) throws IllegalStateException {
//comment
//comment

//comment
<start>if (!this.isVisible()) {
return;
}<end>

removeDialog(getParentFragmentManager());

//comment
MoJhoStoDialogFragment newFragment = new MoJhoStoDialogFragment();
Bundle arguments = new Bundle();
arguments.putInt(FamiliarDialogFragment.ID_KEY, id);
newFragment.setArguments(arguments);
newFragment.show(getParentFragmentManager(), FamiliarActivity.DIALOG_TAG);
}","    private void showDialog(int id) throws IllegalStateException {
//comment
//comment

//comment
<start>if (!this.isVisible()) {
return;
}<end>

removeDialog(getParentFragmentManager());

//comment
MoJhoStoDialogFragment newFragment = new MoJhoStoDialogFragment();
Bundle arguments = new Bundle();
arguments.putInt(FamiliarDialogFragment.ID_KEY, id);
newFragment.setArguments(arguments);
newFragment.show(getParentFragmentManager(), FamiliarActivity.DIALOG_TAG);
}"
6083,"    private void showDialog(int id) throws IllegalStateException {
//comment
//comment

//comment
if (!this.isVisible()) {
return;
}

removeDialog(getParentFragmentManager());

//comment
<start>MoJhoStoDialogFragment newFragment = new MoJhoStoDialogFragment();<end>
Bundle arguments = new Bundle();
<start>arguments.putInt(FamiliarDialogFragment.ID_KEY, id);<end>
newFragment.setArguments(arguments);
newFragment.show(getParentFragmentManager(), FamiliarActivity.DIALOG_TAG);
}","    private void showDialog(int id) throws IllegalStateException {
//comment
//comment

//comment
if (!this.isVisible()) {
return;
}

removeDialog(getParentFragmentManager());

//comment
<start>MoJhoStoDialogFragment newFragment = new MoJhoStoDialogFragment();
Bundle arguments = new Bundle();
arguments.putInt(FamiliarDialogFragment.ID_KEY, id);
newFragment.setArguments(arguments);
newFragment.show(getParentFragmentManager(), FamiliarActivity.DIALOG_TAG);<end>
}"
6084,"private void getThreeSpells(String type) {
Cursor spells = null;
FamiliarDbHandle handle = new FamiliarDbHandle();
try {
SQLiteDatabase database = DatabaseManager.openDatabase(getActivity(), false, handle);
String[] returnTypes = new String[]{CardDbAdapter.KEY_ID, CardDbAdapter.KEY_NAME};
SearchCriteria criteria = new SearchCriteria();
criteria.superTypes = Collections.singletonList(type);
spells = CardDbAdapter.Search(criteria, false, returnTypes, true, null, database);

<start>if (spells == null) {
throw new FamiliarDbException(new Exception(""three spell failure""));
}
//comment
int[] pos = new int[3];
pos[0] = mRandom.nextInt(spells.getCount());<end>
pos[1] = mRandom.nextInt(spells.getCount());
while (pos[0] == pos[1]) {
pos[1] = mRandom.nextInt(spells.getCount());
}
pos[2] = mRandom.nextInt(spells.getCount());
while (pos[0] == pos[2] || pos[1] == pos[2]) {
pos[2] = mRandom.nextInt(spells.getCount());
}

Bundle args = new Bundle();

spells.moveToPosition(pos[0]);
args.putLong(ResultListFragment.CARD_ID_0, CardDbAdapter.getLongFromCursor(spells, CardDbAdapter.KEY_ID));
spells.moveToPosition(pos[1]);
args.putLong(ResultListFragment.CARD_ID_1, CardDbAdapter.getLongFromCursor(spells, CardDbAdapter.KEY_ID));
spells.moveToPosition(pos[2]);
args.putLong(ResultListFragment.CARD_ID_2, CardDbAdapter.getLongFromCursor(spells, CardDbAdapter.KEY_ID));

//comment
ResultListFragment rlFrag = new ResultListFragment();
startNewFragment(rlFrag, args);
} catch (SQLiteException | FamiliarDbException | CursorIndexOutOfBoundsException e) {
handleFamiliarDbException(true);
} finally {
if (null != spells) {
spells.close();
}
DatabaseManager.closeDatabase(getActivity(), handle);
}
}","private void getThreeSpells(String type) {
Cursor spells = null;
FamiliarDbHandle handle = new FamiliarDbHandle();
try {
SQLiteDatabase database = DatabaseManager.openDatabase(getActivity(), false, handle);
String[] returnTypes = new String[]{CardDbAdapter.KEY_ID, CardDbAdapter.KEY_NAME};
SearchCriteria criteria = new SearchCriteria();
criteria.superTypes = Collections.singletonList(type);
spells = CardDbAdapter.Search(criteria, false, returnTypes, true, null, database);

if (spells == null) {
throw new FamiliarDbException(new Exception(""three spell failure""));
}
//comment
<start>int[] pos = new int[3];
pos[0] = mRandom.nextInt(spells.getCount());
pos[1] = mRandom.nextInt(spells.getCount());
while (pos[0] == pos[1]) {
pos[1] = mRandom.nextInt(spells.getCount());
}
pos[2] = mRandom.nextInt(spells.getCount());
while (pos[0] == pos[2] || pos[1] == pos[2]) {
pos[2] = mRandom.nextInt(spells.getCount());
}<end>

Bundle args = new Bundle();

spells.moveToPosition(pos[0]);
args.putLong(ResultListFragment.CARD_ID_0, CardDbAdapter.getLongFromCursor(spells, CardDbAdapter.KEY_ID));
spells.moveToPosition(pos[1]);
args.putLong(ResultListFragment.CARD_ID_1, CardDbAdapter.getLongFromCursor(spells, CardDbAdapter.KEY_ID));
spells.moveToPosition(pos[2]);
args.putLong(ResultListFragment.CARD_ID_2, CardDbAdapter.getLongFromCursor(spells, CardDbAdapter.KEY_ID));

//comment
ResultListFragment rlFrag = new ResultListFragment();
startNewFragment(rlFrag, args);
} catch (SQLiteException | FamiliarDbException | CursorIndexOutOfBoundsException e) {
handleFamiliarDbException(true);
} finally {
if (null != spells) {
spells.close();
}
DatabaseManager.closeDatabase(getActivity(), handle);
}
}"
6085,"private void getThreeSpells(String type) {
Cursor spells = null;
FamiliarDbHandle handle = new FamiliarDbHandle();
try {
SQLiteDatabase database = DatabaseManager.openDatabase(getActivity(), false, handle);
String[] returnTypes = new String[]{CardDbAdapter.KEY_ID, CardDbAdapter.KEY_NAME};
SearchCriteria criteria = new SearchCriteria();
criteria.superTypes = Collections.singletonList(type);
spells = CardDbAdapter.Search(criteria, false, returnTypes, true, null, database);

if (spells == null) {
throw new FamiliarDbException(new Exception(""three spell failure""));
}
//comment
int[] pos = new int[3];
pos[0] = mRandom.nextInt(spells.getCount());
pos[1] = mRandom.nextInt(spells.getCount());
while (pos[0] == pos[1]) {
pos[1] = mRandom.nextInt(spells.getCount());
}
pos[2] = mRandom.nextInt(spells.getCount());
while (pos[0] == pos[2] || pos[1] == pos[2]) {
pos[2] = mRandom.nextInt(spells.getCount());
}

Bundle args = new Bundle();

spells.moveToPosition(pos[0]);
args.putLong(ResultListFragment.CARD_ID_0, CardDbAdapter.getLongFromCursor(spells, CardDbAdapter.KEY_ID));
spells.moveToPosition(pos[1]);
args.putLong(ResultListFragment.CARD_ID_1, CardDbAdapter.getLongFromCursor(spells, CardDbAdapter.KEY_ID));
spells.moveToPosition(pos[2]);
args.putLong(ResultListFragment.CARD_ID_2, CardDbAdapter.getLongFromCursor(spells, CardDbAdapter.KEY_ID));

//comment
<start>ResultListFragment rlFrag = new ResultListFragment();<end>
startNewFragment(rlFrag, args);
} catch (SQLiteException | FamiliarDbException | CursorIndexOutOfBoundsException e) {
handleFamiliarDbException(true);
} finally {
if (null != spells) {
<start>spells.close();<end>
}
DatabaseManager.closeDatabase(getActivity(), handle);
}
}","private void getThreeSpells(String type) {
Cursor spells = null;
FamiliarDbHandle handle = new FamiliarDbHandle();
try {
SQLiteDatabase database = DatabaseManager.openDatabase(getActivity(), false, handle);
String[] returnTypes = new String[]{CardDbAdapter.KEY_ID, CardDbAdapter.KEY_NAME};
SearchCriteria criteria = new SearchCriteria();
criteria.superTypes = Collections.singletonList(type);
spells = CardDbAdapter.Search(criteria, false, returnTypes, true, null, database);

if (spells == null) {
throw new FamiliarDbException(new Exception(""three spell failure""));
}
//comment
int[] pos = new int[3];
pos[0] = mRandom.nextInt(spells.getCount());
pos[1] = mRandom.nextInt(spells.getCount());
while (pos[0] == pos[1]) {
pos[1] = mRandom.nextInt(spells.getCount());
}
pos[2] = mRandom.nextInt(spells.getCount());
while (pos[0] == pos[2] || pos[1] == pos[2]) {
pos[2] = mRandom.nextInt(spells.getCount());
}

Bundle args = new Bundle();

spells.moveToPosition(pos[0]);
args.putLong(ResultListFragment.CARD_ID_0, CardDbAdapter.getLongFromCursor(spells, CardDbAdapter.KEY_ID));
spells.moveToPosition(pos[1]);
args.putLong(ResultListFragment.CARD_ID_1, CardDbAdapter.getLongFromCursor(spells, CardDbAdapter.KEY_ID));
spells.moveToPosition(pos[2]);
args.putLong(ResultListFragment.CARD_ID_2, CardDbAdapter.getLongFromCursor(spells, CardDbAdapter.KEY_ID));

//comment
<start>ResultListFragment rlFrag = new ResultListFragment();
startNewFragment(rlFrag, args);<end>
} catch (SQLiteException | FamiliarDbException | CursorIndexOutOfBoundsException e) {
handleFamiliarDbException(true);
} finally {
if (null != spells) {
spells.close();
}
DatabaseManager.closeDatabase(getActivity(), handle);
}
}"
6238,"    @Override
public View getView(int position, View convertView, ViewGroup parent) {
try {
return super.getView(position, convertView, parent);
} catch (Exception e) {
//comment
<start>this.swapCursor(null);<end>
if (convertView != null) {
<start>return convertView;
} else {
return new View(mFragment.getActivity());<end>
}
}
}","    @Override
public View getView(int position, View convertView, ViewGroup parent) {
<start>try {
return super.getView(position, convertView, parent);
} catch (Exception e) {
//comment
this.swapCursor(null);
if (convertView != null) {
return convertView;
} else {
return new View(mFragment.getActivity());
}
}<end>
}"
2738,"@Override
public void onClick(View view) {
int position = getAdapterPosition();
if (RecyclerView.NO_POSITION != position) {
if (mAdapter.isInSelectMode()) {
if (itemView.isSelected()) {
//comment
<start>mAdapter.setItemSelected(itemView, position, false, true);<end>

//comment
if (mFragment.adaptersGetAllSelected() < 1) {
//comment
mFragment.finishActionMode();
}
} else {
//comment
mAdapter.setItemSelected(itemView, position, true, true);
}
} else {
onClickNotSelectMode(view, position);
}
}
}","@Override
public void onClick(View view) {
int position = getAdapterPosition();
if (RecyclerView.NO_POSITION != position) {
if (mAdapter.isInSelectMode()) {
if (itemView.isSelected()) {
//comment
<start>mAdapter.setItemSelected(itemView, position, false, true);<end>

//comment
if (mFragment.adaptersGetAllSelected() < 1) {
//comment
mFragment.finishActionMode();
}
} else {
//comment
mAdapter.setItemSelected(itemView, position, true, true);
}
} else {
onClickNotSelectMode(view, position);
}
}
}"
2739,"@Override
public void onClick(View view) {
int position = getAdapterPosition();
if (RecyclerView.NO_POSITION != position) {
if (mAdapter.isInSelectMode()) {
if (itemView.isSelected()) {
//comment
mAdapter.setItemSelected(itemView, position, false, true);

//comment
if (mFragment.adaptersGetAllSelected() < 1) {
//comment
mFragment.finishActionMode();
}
} else {
//comment
mAdapter.setItemSelected(itemView, position, true, true);
}
} else {
onClickNotSelectMode(view, position);
}
}
}","@Override
public void onClick(View view) {
int position = getAdapterPosition();
if (RecyclerView.NO_POSITION != position) {
if (mAdapter.isInSelectMode()) {
if (itemView.isSelected()) {
//comment
mAdapter.setItemSelected(itemView, position, false, true);

//comment
<start>if (mFragment.adaptersGetAllSelected() < 1) {<end>
//comment
mFragment.finishActionMode();
}
} else {
//comment
mAdapter.setItemSelected(itemView, position, true, true);
}
} else {
onClickNotSelectMode(view, position);
}
}
}"
2740,"@Override
public void onClick(View view) {
int position = getAdapterPosition();
if (RecyclerView.NO_POSITION != position) {
if (mAdapter.isInSelectMode()) {
if (itemView.isSelected()) {
//comment
mAdapter.setItemSelected(itemView, position, false, true);

//comment
if (mFragment.adaptersGetAllSelected() < 1) {
//comment
<start>mFragment.finishActionMode();<end>
}
} else {
//comment
mAdapter.setItemSelected(itemView, position, true, true);
}
} else {
onClickNotSelectMode(view, position);
}
}
}","@Override
public void onClick(View view) {
int position = getAdapterPosition();
if (RecyclerView.NO_POSITION != position) {
if (mAdapter.isInSelectMode()) {
if (itemView.isSelected()) {
//comment
mAdapter.setItemSelected(itemView, position, false, true);

//comment
if (mFragment.adaptersGetAllSelected() < 1) {
//comment
<start>mFragment.finishActionMode();<end>
}
} else {
//comment
mAdapter.setItemSelected(itemView, position, true, true);
}
} else {
onClickNotSelectMode(view, position);
}
}
}"
2741,"@Override
public void onClick(View view) {
int position = getAdapterPosition();
if (RecyclerView.NO_POSITION != position) {
if (mAdapter.isInSelectMode()) {
if (itemView.isSelected()) {
//comment
mAdapter.setItemSelected(itemView, position, false, true);

//comment
if (mFragment.adaptersGetAllSelected() < 1) {
//comment
mFragment.finishActionMode();
}
} else {
//comment
<start>mAdapter.setItemSelected(itemView, position, true, true);<end>
}
} else {
onClickNotSelectMode(view, position);
}
}
}","@Override
public void onClick(View view) {
int position = getAdapterPosition();
if (RecyclerView.NO_POSITION != position) {
if (mAdapter.isInSelectMode()) {
if (itemView.isSelected()) {
//comment
mAdapter.setItemSelected(itemView, position, false, true);

//comment
if (mFragment.adaptersGetAllSelected() < 1) {
//comment
mFragment.finishActionMode();
}
} else {
//comment
<start>mAdapter.setItemSelected(itemView, position, true, true);<end>
}
} else {
onClickNotSelectMode(view, position);
}
}
}"
2742,"    @Override
public boolean onLongClick(View view) {
int position = getAdapterPosition();
if (RecyclerView.NO_POSITION != position) {
if (!mAdapter.isInSelectMode()) {
//comment
<start>mFragment.startActionMode();<end>

//comment
mAdapter.setItemSelected(itemView, position, true, true);

//comment
return true;
}
}
//comment
return false;
}","    @Override
public boolean onLongClick(View view) {
int position = getAdapterPosition();
if (RecyclerView.NO_POSITION != position) {
if (!mAdapter.isInSelectMode()) {
//comment
<start>mFragment.startActionMode();<end>

//comment
mAdapter.setItemSelected(itemView, position, true, true);

//comment
return true;
}
}
//comment
return false;
}"
2743,"    @Override
public boolean onLongClick(View view) {
int position = getAdapterPosition();
if (RecyclerView.NO_POSITION != position) {
if (!mAdapter.isInSelectMode()) {
//comment
mFragment.startActionMode();

//comment
<start>mAdapter.setItemSelected(itemView, position, true, true);<end>

//comment
return true;
}
}
//comment
return false;
}","    @Override
public boolean onLongClick(View view) {
int position = getAdapterPosition();
if (RecyclerView.NO_POSITION != position) {
if (!mAdapter.isInSelectMode()) {
//comment
mFragment.startActionMode();

//comment
<start>mAdapter.setItemSelected(itemView, position, true, true);<end>

//comment
return true;
}
}
//comment
return false;
}"
6100,"static int[] getNumberOfCardsInList(ArrayList<MtgCard> cards, String cardName, String setCode,
String cardNumber, boolean isSideboard,
HashMap<Boolean, ArrayList<String>> emptyNumberSetCodes) {
int[] numberOf = new int[]{0, 0};
for (MtgCard card : cards) {
if (card.getName().equals(cardName) &&
card.getExpansion().equals(setCode) &&
card.isSideboard() == isSideboard) {

//comment
if (card.getNumber().equals(cardNumber) ||
<start>(!emptyNumberSetCodes.get(card.mIsFoil).contains(setCode) && card.getNumber().isEmpty())) {<end>
if (card.getNumber().isEmpty()) {
<start>emptyNumberSetCodes.get(card.mIsFoil).add(setCode);<end>
}

if (!card.mIsFoil) {
numberOf[0] += card.mNumberOf;
} else {
numberOf[1] += card.mNumberOf;
}
}
}
}
return numberOf;
}","static int[] getNumberOfCardsInList(ArrayList<MtgCard> cards, String cardName, String setCode,
String cardNumber, boolean isSideboard,
HashMap<Boolean, ArrayList<String>> emptyNumberSetCodes) {
int[] numberOf = new int[]{0, 0};
for (MtgCard card : cards) {
if (card.getName().equals(cardName) &&
card.getExpansion().equals(setCode) &&
card.isSideboard() == isSideboard) {

//comment
<start>if (card.getNumber().equals(cardNumber) ||
(!emptyNumberSetCodes.get(card.mIsFoil).contains(setCode) && card.getNumber().isEmpty())) {<end>
if (card.getNumber().isEmpty()) {
emptyNumberSetCodes.get(card.mIsFoil).add(setCode);
}

if (!card.mIsFoil) {
numberOf[0] += card.mNumberOf;
} else {
numberOf[1] += card.mNumberOf;
}
}
}
}
return numberOf;
}"
6101,"private String getColors(String c) {

<start>StringBuilder validColors = new StringBuilder();
//comment
if (c == null || c.isEmpty()) {
return """";
}<end>
//comment
for (int i = 0; i < c.length(); i++) {
if (COLORS.indexOf(c.charAt(i)) > -1) {
validColors.append(c.charAt(i));
}
}
return validColors.toString();

}","private String getColors(String c) {

StringBuilder validColors = new StringBuilder();
//comment
<start>if (c == null || c.isEmpty()) {<end>
return """";
}
//comment
for (int i = 0; i < c.length(); i++) {
if (COLORS.indexOf(c.charAt(i)) > -1) {
validColors.append(c.charAt(i));
}
}
return validColors.toString();

}"
6102,"private String getColors(String c) {

StringBuilder validColors = new StringBuilder();
//comment
if (c == null || c.isEmpty()) {
<start>return """";<end>
}
//comment
for (int i = 0; i < c.length(); i++) {
<start>if (COLORS.indexOf(c.charAt(i)) > -1) {
validColors.append(c.charAt(i));
}<end>
}
<start>return validColors.toString();<end>

}","private String getColors(String c) {

StringBuilder validColors = new StringBuilder();
//comment
if (c == null || c.isEmpty()) {
return """";
}
//comment
<start>for (int i = 0; i < c.length(); i++) {
if (COLORS.indexOf(c.charAt(i)) > -1) {
validColors.append(c.charAt(i));
}
}<end>
return validColors.toString();

}"
6103,"public void setMode(int mode) {

if (null == mReadoutTextView) {
return;
}

//comment
<start>if (mCommitting) {
mCommitting = false;
mHandler.removeCallbacks(mLifePoisonCommitter);
mLifePoisonCommitter.run();
}<end>

mMode = mode;
switch (mMode) {
case LifeCounterFragment.STAT_LIFE:
if (mHistoryList != null) {
mHistoryList.setAdapter(mHistoryLifeAdapter);
mHistoryList.invalidate();
}
mReadoutTextView.setText(formatInt(mLife, false));
mReadoutTextView.setTextColor(ContextCompat.getColor(mFragment.requireContext(),
R.color.material_red_500));
if (mCommanderReadoutTextView != null) {
mCommanderReadoutTextView.setText(formatInt(mLife, false));
mCommanderReadoutTextView.setTextColor(
ContextCompat.getColor(mFragment.getContext(), R.color.material_red_500));
}
break;
case LifeCounterFragment.STAT_POISON:
if (mHistoryList != null) {
mHistoryList.setAdapter(mHistoryPoisonAdapter);
mHistoryList.invalidate();
}
mReadoutTextView.setText(formatInt(mPoison, false));
mReadoutTextView.setTextColor(ContextCompat.getColor(mFragment.requireContext(),
R.color.material_green_500));
if (mCommanderReadoutTextView != null) {
mCommanderReadoutTextView.setText(formatInt(mPoison, false));
mCommanderReadoutTextView.setTextColor(
ContextCompat.getColor(mFragment.getContext(), R.color.material_green_500));
}
break;
case LifeCounterFragment.STAT_COMMANDER:
if (mHistoryList != null) {
mHistoryList.setAdapter(mCommanderDamageAdapter);
mHistoryList.invalidate();
}
mReadoutTextView.setText(formatInt(mLife, false));
mReadoutTextView.setTextColor(ContextCompat.getColor(mFragment.requireContext(),
R.color.material_red_500));
if (mCommanderReadoutTextView != null) {
mCommanderReadoutTextView.setText(formatInt(mLife, false));
mCommanderReadoutTextView.setTextColor(
ContextCompat.getColor(mFragment.getContext(), R.color.material_red_500));
}
break;
}
}","public void setMode(int mode) {

if (null == mReadoutTextView) {
return;
}

//comment
<start>if (mCommitting) {
mCommitting = false;
mHandler.removeCallbacks(mLifePoisonCommitter);
mLifePoisonCommitter.run();
}<end>

mMode = mode;
switch (mMode) {
case LifeCounterFragment.STAT_LIFE:
if (mHistoryList != null) {
mHistoryList.setAdapter(mHistoryLifeAdapter);
mHistoryList.invalidate();
}
mReadoutTextView.setText(formatInt(mLife, false));
mReadoutTextView.setTextColor(ContextCompat.getColor(mFragment.requireContext(),
R.color.material_red_500));
if (mCommanderReadoutTextView != null) {
mCommanderReadoutTextView.setText(formatInt(mLife, false));
mCommanderReadoutTextView.setTextColor(
ContextCompat.getColor(mFragment.getContext(), R.color.material_red_500));
}
break;
case LifeCounterFragment.STAT_POISON:
if (mHistoryList != null) {
mHistoryList.setAdapter(mHistoryPoisonAdapter);
mHistoryList.invalidate();
}
mReadoutTextView.setText(formatInt(mPoison, false));
mReadoutTextView.setTextColor(ContextCompat.getColor(mFragment.requireContext(),
R.color.material_green_500));
if (mCommanderReadoutTextView != null) {
mCommanderReadoutTextView.setText(formatInt(mPoison, false));
mCommanderReadoutTextView.setTextColor(
ContextCompat.getColor(mFragment.getContext(), R.color.material_green_500));
}
break;
case LifeCounterFragment.STAT_COMMANDER:
if (mHistoryList != null) {
mHistoryList.setAdapter(mCommanderDamageAdapter);
mHistoryList.invalidate();
}
mReadoutTextView.setText(formatInt(mLife, false));
mReadoutTextView.setTextColor(ContextCompat.getColor(mFragment.requireContext(),
R.color.material_red_500));
if (mCommanderReadoutTextView != null) {
mCommanderReadoutTextView.setText(formatInt(mLife, false));
mCommanderReadoutTextView.setTextColor(
ContextCompat.getColor(mFragment.getContext(), R.color.material_red_500));
}
break;
}
}"
6104,"public void changeValue(int delta, boolean immediate) {
switch (mMode) {
case LifeCounterFragment.STAT_POISON:
mPoison += delta;
mReadoutTextView.setText(formatInt(mPoison, false));
if (mCommanderReadoutTextView != null) {
mCommanderReadoutTextView.setText(formatInt(mPoison, false));
}
break;
case LifeCounterFragment.STAT_COMMANDER:
case LifeCounterFragment.STAT_LIFE:
mLife += delta;
mReadoutTextView.setText(formatInt(mLife, false));
if (mCommanderReadoutTextView != null) {
mCommanderReadoutTextView.setText(formatInt(mLife, false));
}
break;
}

if (delta == 0) {
return;
}

//comment
if (!mCommitting) {
<start>addNewLifeHistoryEntry();
addNewPoisonHistoryEntry();<end>
} else if (!immediate) {
//comment
switch (mMode) {
case LifeCounterFragment.STAT_POISON: {
if (mPoisonHistory.isEmpty()) {
addNewPoisonHistoryEntry();
}
mPoisonHistory.get(0).mDelta += delta;
mPoisonHistory.get(0).mAbsolute += delta;
if (null != mHistoryPoisonAdapter) {
mHistoryPoisonAdapter.notifyDataSetChanged();
}
break;
}
case LifeCounterFragment.STAT_COMMANDER:
case LifeCounterFragment.STAT_LIFE: {
if (mLifeHistory.isEmpty()) {
addNewLifeHistoryEntry();
}
mLifeHistory.get(0).mDelta += delta;
mLifeHistory.get(0).mAbsolute += delta;
if (null != mHistoryLifeAdapter) {
mHistoryLifeAdapter.notifyDataSetChanged();
}
break;
}
}
}

if (!immediate) {
mCommitting = true;
mHandler.removeCallbacks(mLifePoisonCommitter);
mHandler.postDelayed(mLifePoisonCommitter,
Integer.parseInt(PreferenceAdapter.getLifeTimer(mFragment.getContext())));

}
}","public void changeValue(int delta, boolean immediate) {
switch (mMode) {
case LifeCounterFragment.STAT_POISON:
mPoison += delta;
mReadoutTextView.setText(formatInt(mPoison, false));
if (mCommanderReadoutTextView != null) {
mCommanderReadoutTextView.setText(formatInt(mPoison, false));
}
break;
case LifeCounterFragment.STAT_COMMANDER:
case LifeCounterFragment.STAT_LIFE:
mLife += delta;
mReadoutTextView.setText(formatInt(mLife, false));
if (mCommanderReadoutTextView != null) {
mCommanderReadoutTextView.setText(formatInt(mLife, false));
}
break;
}

if (delta == 0) {
return;
}

//comment
<start>if (!mCommitting) {
addNewLifeHistoryEntry();
addNewPoisonHistoryEntry();
} else if (!immediate) {<end>
//comment
switch (mMode) {
case LifeCounterFragment.STAT_POISON: {
if (mPoisonHistory.isEmpty()) {
addNewPoisonHistoryEntry();
}
mPoisonHistory.get(0).mDelta += delta;
mPoisonHistory.get(0).mAbsolute += delta;
if (null != mHistoryPoisonAdapter) {
mHistoryPoisonAdapter.notifyDataSetChanged();
}
break;
}
case LifeCounterFragment.STAT_COMMANDER:
case LifeCounterFragment.STAT_LIFE: {
if (mLifeHistory.isEmpty()) {
addNewLifeHistoryEntry();
}
mLifeHistory.get(0).mDelta += delta;
mLifeHistory.get(0).mAbsolute += delta;
if (null != mHistoryLifeAdapter) {
mHistoryLifeAdapter.notifyDataSetChanged();
}
break;
}
}
}

if (!immediate) {
mCommitting = true;
mHandler.removeCallbacks(mLifePoisonCommitter);
mHandler.postDelayed(mLifePoisonCommitter,
Integer.parseInt(PreferenceAdapter.getLifeTimer(mFragment.getContext())));

}
}"
6105,"public void changeValue(int delta, boolean immediate) {
switch (mMode) {
case LifeCounterFragment.STAT_POISON:
mPoison += delta;
mReadoutTextView.setText(formatInt(mPoison, false));
if (mCommanderReadoutTextView != null) {
mCommanderReadoutTextView.setText(formatInt(mPoison, false));
}
break;
case LifeCounterFragment.STAT_COMMANDER:
case LifeCounterFragment.STAT_LIFE:
mLife += delta;
mReadoutTextView.setText(formatInt(mLife, false));
if (mCommanderReadoutTextView != null) {
mCommanderReadoutTextView.setText(formatInt(mLife, false));
}
break;
}

if (delta == 0) {
return;
}

//comment
if (!mCommitting) {
addNewLifeHistoryEntry();
addNewPoisonHistoryEntry();
} else if (!immediate) {
//comment
switch (mMode) {
case LifeCounterFragment.STAT_POISON: {
<start>if (mPoisonHistory.isEmpty()) {
addNewPoisonHistoryEntry();
}<end>
mPoisonHistory.get(0).mDelta += delta;
mPoisonHistory.get(0).mAbsolute += delta;
if (null != mHistoryPoisonAdapter) {
mHistoryPoisonAdapter.notifyDataSetChanged();
}
break;
}
case LifeCounterFragment.STAT_COMMANDER:
case LifeCounterFragment.STAT_LIFE: {
if (mLifeHistory.isEmpty()) {
addNewLifeHistoryEntry();
}
mLifeHistory.get(0).mDelta += delta;
mLifeHistory.get(0).mAbsolute += delta;
if (null != mHistoryLifeAdapter) {
mHistoryLifeAdapter.notifyDataSetChanged();
}
break;
}
}
}

if (!immediate) {
mCommitting = true;
mHandler.removeCallbacks(mLifePoisonCommitter);
mHandler.postDelayed(mLifePoisonCommitter,
Integer.parseInt(PreferenceAdapter.getLifeTimer(mFragment.getContext())));

}
}","public void changeValue(int delta, boolean immediate) {
switch (mMode) {
case LifeCounterFragment.STAT_POISON:
mPoison += delta;
mReadoutTextView.setText(formatInt(mPoison, false));
if (mCommanderReadoutTextView != null) {
mCommanderReadoutTextView.setText(formatInt(mPoison, false));
}
break;
case LifeCounterFragment.STAT_COMMANDER:
case LifeCounterFragment.STAT_LIFE:
mLife += delta;
mReadoutTextView.setText(formatInt(mLife, false));
if (mCommanderReadoutTextView != null) {
mCommanderReadoutTextView.setText(formatInt(mLife, false));
}
break;
}

if (delta == 0) {
return;
}

//comment
if (!mCommitting) {
addNewLifeHistoryEntry();
addNewPoisonHistoryEntry();
} else if (!immediate) {
//comment
<start>switch (mMode) {
case LifeCounterFragment.STAT_POISON: {
if (mPoisonHistory.isEmpty()) {
addNewPoisonHistoryEntry();
}
mPoisonHistory.get(0).mDelta += delta;
mPoisonHistory.get(0).mAbsolute += delta;
if (null != mHistoryPoisonAdapter) {
mHistoryPoisonAdapter.notifyDataSetChanged();
}
break;
}
case LifeCounterFragment.STAT_COMMANDER:
case LifeCounterFragment.STAT_LIFE: {
if (mLifeHistory.isEmpty()) {
addNewLifeHistoryEntry();
}
mLifeHistory.get(0).mDelta += delta;
mLifeHistory.get(0).mAbsolute += delta;
if (null != mHistoryLifeAdapter) {
mHistoryLifeAdapter.notifyDataSetChanged();
}
break;
}
}<end>
}

if (!immediate) {
mCommitting = true;
mHandler.removeCallbacks(mLifePoisonCommitter);
mHandler.postDelayed(mLifePoisonCommitter,
Integer.parseInt(PreferenceAdapter.getLifeTimer(mFragment.getContext())));

}
}"
6106,"<start>private void addNewLifeHistoryEntry() {
//comment
HistoryEntry entry = new HistoryEntry();<end>
//comment
if (mLifeHistory.size() == 0) {
entry.mDelta = mLife - mDefaultLifeTotal;
} else {
entry.mDelta = mLife - mLifeHistory.get(0).mAbsolute;
}
entry.mAbsolute = mLife;
if (entry.mDelta != 0) {
mLifeHistory.add(0, entry);
if (mHistoryLifeAdapter != null) {
mHistoryLifeAdapter.notifyDataSetChanged();
}
}
}","private void addNewLifeHistoryEntry() {
//comment
<start>HistoryEntry entry = new HistoryEntry();<end>
//comment
if (mLifeHistory.size() == 0) {
entry.mDelta = mLife - mDefaultLifeTotal;
} else {
entry.mDelta = mLife - mLifeHistory.get(0).mAbsolute;
}
entry.mAbsolute = mLife;
if (entry.mDelta != 0) {
mLifeHistory.add(0, entry);
if (mHistoryLifeAdapter != null) {
mHistoryLifeAdapter.notifyDataSetChanged();
}
}
}"
6107,"private void addNewLifeHistoryEntry() {
//comment
<start>HistoryEntry entry = new HistoryEntry();<end>
//comment
if (mLifeHistory.size() == 0) {
<start>entry.mDelta = mLife - mDefaultLifeTotal;<end>
} else {
<start>entry.mDelta = mLife - mLifeHistory.get(0).mAbsolute;<end>
}
entry.mAbsolute = mLife;
if (entry.mDelta != 0) {
mLifeHistory.add(0, entry);
if (mHistoryLifeAdapter != null) {
mHistoryLifeAdapter.notifyDataSetChanged();
}
}
}","private void addNewLifeHistoryEntry() {
//comment
HistoryEntry entry = new HistoryEntry();
//comment
<start>if (mLifeHistory.size() == 0) {
entry.mDelta = mLife - mDefaultLifeTotal;
} else {<end>
entry.mDelta = mLife - mLifeHistory.get(0).mAbsolute;
}
entry.mAbsolute = mLife;
if (entry.mDelta != 0) {
mLifeHistory.add(0, entry);
if (mHistoryLifeAdapter != null) {
mHistoryLifeAdapter.notifyDataSetChanged();
}
}
}"
6108,"public View newView(int displayMode, int statType, GridLayout playersView, LinearLayout commanderPlayerView) {
switch (displayMode) {
case LifeCounterFragment.DISPLAY_COMMANDER:
case LifeCounterFragment.DISPLAY_NORMAL: {
//comment
if (LifeCounterFragment.DISPLAY_COMMANDER == displayMode) {
<start>mView = LayoutInflater.from(mFragment.getActivity()).inflate(R.layout.life_counter_player, commanderPlayerView, false);<end>
} else {
<start>mView = LayoutInflater.from(mFragment.getActivity()).inflate(R.layout.life_counter_player, playersView, false);<end>
}
assert mView != null;
mHistoryList = mView.findViewById(R.id.player_history);
mCommanderCastingButton = mView.findViewById(R.id.commanderCast);
<start>mCommanderExperienceCountersButton = mView.findViewById(R.id.commanderExperienceCounter);<end>

//comment
mHistoryLifeAdapter = new HistoryArrayAdapter(mFragment.getActivity(), LifeCounterFragment.STAT_LIFE);
mHistoryPoisonAdapter
= new HistoryArrayAdapter(mFragment.getActivity(), LifeCounterFragment.STAT_POISON);
mCommanderDamageAdapter = new CommanderDamageAdapter(mFragment.getActivity());

//comment
if (displayMode == LifeCounterFragment.DISPLAY_COMMANDER) {
setupCommanderCastingButton();
setupCommanderExperienceCounterButton();

mCommanderRowView = LayoutInflater.from(
mFragment.getActivity()).inflate(R.layout.life_counter_player_commander, playersView, false);
assert mCommanderRowView != null;
mCommanderNameTextView = mCommanderRowView.findViewById(R.id.player_name);
if (mName != null) {
mCommanderNameTextView.setText(mName);
}
mCommanderReadoutTextView = mCommanderRowView.findViewById(R.id.player_readout);
}
//comment
else {
mView.findViewById(R.id.commanderCastText).setVisibility(View.GONE);
mCommanderCastingButton.setVisibility(View.GONE);

mView.findViewById(R.id.commanderExperienceCounterText).setVisibility(View.GONE);
mCommanderExperienceCountersButton.setVisibility(View.GONE);
}

break;
}
case LifeCounterFragment.DISPLAY_COMPACT: {
//comment
mView = LayoutInflater
.from(mFragment.getActivity()).inflate(R.layout.life_counter_player_compact, playersView, false);
//comment
mHistoryList = null;
mHistoryLifeAdapter = null;
mHistoryPoisonAdapter = null;
mCommanderDamageAdapter = null;
break;
}
}
assert mView != null;

//comment
mNameTextView = mView.findViewById(R.id.player_name);
if (mName != null) {
mNameTextView.setText(mName);
}
//comment
mReadoutTextView = mView.findViewById(R.id.player_readout);
mReadoutTextView.setOnClickListener(view -> {
//comment
if (mCommitting) {
mCommitting = false;
mHandler.removeCallbacks(mLifePoisonCommitter);
mLifePoisonCommitter.run();
}
showDialog(LcPlayerDialogFragment.DIALOG_CHANGE_LIFE, -1);
});

//comment
mView.findViewById(R.id.player_minus1).setOnClickListener(view -> changeValue(-1, false));
mView.findViewById(R.id.player_minus5).setOnClickListener(view -> changeValue(-5, false));
mView.findViewById(R.id.player_plus1).setOnClickListener(view -> changeValue(1, false));
mView.findViewById(R.id.player_plus5).setOnClickListener(view -> changeValue(5, false));

mView.findViewById(R.id.player_name).setOnClickListener(view -> showDialog(LcPlayerDialogFragment.DIALOG_SET_NAME, -1));

setMode(statType);

if (displayMode == LifeCounterFragment.DISPLAY_COMMANDER) {
return mCommanderRowView;
} else {
return mView;
}
}","public View newView(int displayMode, int statType, GridLayout playersView, LinearLayout commanderPlayerView) {
switch (displayMode) {
case LifeCounterFragment.DISPLAY_COMMANDER:
case LifeCounterFragment.DISPLAY_NORMAL: {
//comment
<start>if (LifeCounterFragment.DISPLAY_COMMANDER == displayMode) {
mView = LayoutInflater.from(mFragment.getActivity()).inflate(R.layout.life_counter_player, commanderPlayerView, false);
} else {
mView = LayoutInflater.from(mFragment.getActivity()).inflate(R.layout.life_counter_player, playersView, false);
}<end>
assert mView != null;
mHistoryList = mView.findViewById(R.id.player_history);
mCommanderCastingButton = mView.findViewById(R.id.commanderCast);
mCommanderExperienceCountersButton = mView.findViewById(R.id.commanderExperienceCounter);

//comment
mHistoryLifeAdapter = new HistoryArrayAdapter(mFragment.getActivity(), LifeCounterFragment.STAT_LIFE);
mHistoryPoisonAdapter
= new HistoryArrayAdapter(mFragment.getActivity(), LifeCounterFragment.STAT_POISON);
mCommanderDamageAdapter = new CommanderDamageAdapter(mFragment.getActivity());

//comment
if (displayMode == LifeCounterFragment.DISPLAY_COMMANDER) {
setupCommanderCastingButton();
setupCommanderExperienceCounterButton();

mCommanderRowView = LayoutInflater.from(
mFragment.getActivity()).inflate(R.layout.life_counter_player_commander, playersView, false);
assert mCommanderRowView != null;
mCommanderNameTextView = mCommanderRowView.findViewById(R.id.player_name);
if (mName != null) {
mCommanderNameTextView.setText(mName);
}
mCommanderReadoutTextView = mCommanderRowView.findViewById(R.id.player_readout);
}
//comment
else {
mView.findViewById(R.id.commanderCastText).setVisibility(View.GONE);
mCommanderCastingButton.setVisibility(View.GONE);

mView.findViewById(R.id.commanderExperienceCounterText).setVisibility(View.GONE);
mCommanderExperienceCountersButton.setVisibility(View.GONE);
}

break;
}
case LifeCounterFragment.DISPLAY_COMPACT: {
//comment
mView = LayoutInflater
.from(mFragment.getActivity()).inflate(R.layout.life_counter_player_compact, playersView, false);
//comment
mHistoryList = null;
mHistoryLifeAdapter = null;
mHistoryPoisonAdapter = null;
mCommanderDamageAdapter = null;
break;
}
}
assert mView != null;

//comment
mNameTextView = mView.findViewById(R.id.player_name);
if (mName != null) {
mNameTextView.setText(mName);
}
//comment
mReadoutTextView = mView.findViewById(R.id.player_readout);
mReadoutTextView.setOnClickListener(view -> {
//comment
if (mCommitting) {
mCommitting = false;
mHandler.removeCallbacks(mLifePoisonCommitter);
mLifePoisonCommitter.run();
}
showDialog(LcPlayerDialogFragment.DIALOG_CHANGE_LIFE, -1);
});

//comment
mView.findViewById(R.id.player_minus1).setOnClickListener(view -> changeValue(-1, false));
mView.findViewById(R.id.player_minus5).setOnClickListener(view -> changeValue(-5, false));
mView.findViewById(R.id.player_plus1).setOnClickListener(view -> changeValue(1, false));
mView.findViewById(R.id.player_plus5).setOnClickListener(view -> changeValue(5, false));

mView.findViewById(R.id.player_name).setOnClickListener(view -> showDialog(LcPlayerDialogFragment.DIALOG_SET_NAME, -1));

setMode(statType);

if (displayMode == LifeCounterFragment.DISPLAY_COMMANDER) {
return mCommanderRowView;
} else {
return mView;
}
}"
6109,"public View newView(int displayMode, int statType, GridLayout playersView, LinearLayout commanderPlayerView) {
switch (displayMode) {
case LifeCounterFragment.DISPLAY_COMMANDER:
case LifeCounterFragment.DISPLAY_NORMAL: {
//comment
if (LifeCounterFragment.DISPLAY_COMMANDER == displayMode) {
mView = LayoutInflater.from(mFragment.getActivity()).inflate(R.layout.life_counter_player, commanderPlayerView, false);
} else {
mView = LayoutInflater.from(mFragment.getActivity()).inflate(R.layout.life_counter_player, playersView, false);
}
assert mView != null;
mHistoryList = mView.findViewById(R.id.player_history);
<start>mCommanderCastingButton = mView.findViewById(R.id.commanderCast);<end>
mCommanderExperienceCountersButton = mView.findViewById(R.id.commanderExperienceCounter);

//comment
<start>mHistoryLifeAdapter = new HistoryArrayAdapter(mFragment.getActivity(), LifeCounterFragment.STAT_LIFE);<end>
mHistoryPoisonAdapter
= new HistoryArrayAdapter(mFragment.getActivity(), LifeCounterFragment.STAT_POISON);
<start>mCommanderDamageAdapter = new CommanderDamageAdapter(mFragment.getActivity());<end>

//comment
if (displayMode == LifeCounterFragment.DISPLAY_COMMANDER) {
setupCommanderCastingButton();
setupCommanderExperienceCounterButton();

mCommanderRowView = LayoutInflater.from(
mFragment.getActivity()).inflate(R.layout.life_counter_player_commander, playersView, false);
assert mCommanderRowView != null;
mCommanderNameTextView = mCommanderRowView.findViewById(R.id.player_name);
if (mName != null) {
mCommanderNameTextView.setText(mName);
}
mCommanderReadoutTextView = mCommanderRowView.findViewById(R.id.player_readout);
}
//comment
else {
mView.findViewById(R.id.commanderCastText).setVisibility(View.GONE);
mCommanderCastingButton.setVisibility(View.GONE);

mView.findViewById(R.id.commanderExperienceCounterText).setVisibility(View.GONE);
mCommanderExperienceCountersButton.setVisibility(View.GONE);
}

break;
}
case LifeCounterFragment.DISPLAY_COMPACT: {
//comment
mView = LayoutInflater
.from(mFragment.getActivity()).inflate(R.layout.life_counter_player_compact, playersView, false);
//comment
mHistoryList = null;
mHistoryLifeAdapter = null;
mHistoryPoisonAdapter = null;
mCommanderDamageAdapter = null;
break;
}
}
assert mView != null;

//comment
mNameTextView = mView.findViewById(R.id.player_name);
if (mName != null) {
mNameTextView.setText(mName);
}
//comment
mReadoutTextView = mView.findViewById(R.id.player_readout);
mReadoutTextView.setOnClickListener(view -> {
//comment
if (mCommitting) {
mCommitting = false;
mHandler.removeCallbacks(mLifePoisonCommitter);
mLifePoisonCommitter.run();
}
showDialog(LcPlayerDialogFragment.DIALOG_CHANGE_LIFE, -1);
});

//comment
mView.findViewById(R.id.player_minus1).setOnClickListener(view -> changeValue(-1, false));
mView.findViewById(R.id.player_minus5).setOnClickListener(view -> changeValue(-5, false));
mView.findViewById(R.id.player_plus1).setOnClickListener(view -> changeValue(1, false));
mView.findViewById(R.id.player_plus5).setOnClickListener(view -> changeValue(5, false));

mView.findViewById(R.id.player_name).setOnClickListener(view -> showDialog(LcPlayerDialogFragment.DIALOG_SET_NAME, -1));

setMode(statType);

if (displayMode == LifeCounterFragment.DISPLAY_COMMANDER) {
return mCommanderRowView;
} else {
return mView;
}
}","public View newView(int displayMode, int statType, GridLayout playersView, LinearLayout commanderPlayerView) {
switch (displayMode) {
case LifeCounterFragment.DISPLAY_COMMANDER:
case LifeCounterFragment.DISPLAY_NORMAL: {
//comment
if (LifeCounterFragment.DISPLAY_COMMANDER == displayMode) {
mView = LayoutInflater.from(mFragment.getActivity()).inflate(R.layout.life_counter_player, commanderPlayerView, false);
} else {
mView = LayoutInflater.from(mFragment.getActivity()).inflate(R.layout.life_counter_player, playersView, false);
}
assert mView != null;
mHistoryList = mView.findViewById(R.id.player_history);
mCommanderCastingButton = mView.findViewById(R.id.commanderCast);
mCommanderExperienceCountersButton = mView.findViewById(R.id.commanderExperienceCounter);

//comment
<start>mHistoryLifeAdapter = new HistoryArrayAdapter(mFragment.getActivity(), LifeCounterFragment.STAT_LIFE);
mHistoryPoisonAdapter
= new HistoryArrayAdapter(mFragment.getActivity(), LifeCounterFragment.STAT_POISON);
mCommanderDamageAdapter = new CommanderDamageAdapter(mFragment.getActivity());<end>

//comment
if (displayMode == LifeCounterFragment.DISPLAY_COMMANDER) {
setupCommanderCastingButton();
setupCommanderExperienceCounterButton();

mCommanderRowView = LayoutInflater.from(
mFragment.getActivity()).inflate(R.layout.life_counter_player_commander, playersView, false);
assert mCommanderRowView != null;
mCommanderNameTextView = mCommanderRowView.findViewById(R.id.player_name);
if (mName != null) {
mCommanderNameTextView.setText(mName);
}
mCommanderReadoutTextView = mCommanderRowView.findViewById(R.id.player_readout);
}
//comment
else {
mView.findViewById(R.id.commanderCastText).setVisibility(View.GONE);
mCommanderCastingButton.setVisibility(View.GONE);

mView.findViewById(R.id.commanderExperienceCounterText).setVisibility(View.GONE);
mCommanderExperienceCountersButton.setVisibility(View.GONE);
}

break;
}
case LifeCounterFragment.DISPLAY_COMPACT: {
//comment
mView = LayoutInflater
.from(mFragment.getActivity()).inflate(R.layout.life_counter_player_compact, playersView, false);
//comment
mHistoryList = null;
mHistoryLifeAdapter = null;
mHistoryPoisonAdapter = null;
mCommanderDamageAdapter = null;
break;
}
}
assert mView != null;

//comment
mNameTextView = mView.findViewById(R.id.player_name);
if (mName != null) {
mNameTextView.setText(mName);
}
//comment
mReadoutTextView = mView.findViewById(R.id.player_readout);
mReadoutTextView.setOnClickListener(view -> {
//comment
if (mCommitting) {
mCommitting = false;
mHandler.removeCallbacks(mLifePoisonCommitter);
mLifePoisonCommitter.run();
}
showDialog(LcPlayerDialogFragment.DIALOG_CHANGE_LIFE, -1);
});

//comment
mView.findViewById(R.id.player_minus1).setOnClickListener(view -> changeValue(-1, false));
mView.findViewById(R.id.player_minus5).setOnClickListener(view -> changeValue(-5, false));
mView.findViewById(R.id.player_plus1).setOnClickListener(view -> changeValue(1, false));
mView.findViewById(R.id.player_plus5).setOnClickListener(view -> changeValue(5, false));

mView.findViewById(R.id.player_name).setOnClickListener(view -> showDialog(LcPlayerDialogFragment.DIALOG_SET_NAME, -1));

setMode(statType);

if (displayMode == LifeCounterFragment.DISPLAY_COMMANDER) {
return mCommanderRowView;
} else {
return mView;
}
}"
6110,"public View newView(int displayMode, int statType, GridLayout playersView, LinearLayout commanderPlayerView) {
switch (displayMode) {
case LifeCounterFragment.DISPLAY_COMMANDER:
case LifeCounterFragment.DISPLAY_NORMAL: {
//comment
if (LifeCounterFragment.DISPLAY_COMMANDER == displayMode) {
mView = LayoutInflater.from(mFragment.getActivity()).inflate(R.layout.life_counter_player, commanderPlayerView, false);
} else {
mView = LayoutInflater.from(mFragment.getActivity()).inflate(R.layout.life_counter_player, playersView, false);
}
assert mView != null;
mHistoryList = mView.findViewById(R.id.player_history);
mCommanderCastingButton = mView.findViewById(R.id.commanderCast);
mCommanderExperienceCountersButton = mView.findViewById(R.id.commanderExperienceCounter);

//comment
mHistoryLifeAdapter = new HistoryArrayAdapter(mFragment.getActivity(), LifeCounterFragment.STAT_LIFE);
mHistoryPoisonAdapter
= new HistoryArrayAdapter(mFragment.getActivity(), LifeCounterFragment.STAT_POISON);
mCommanderDamageAdapter = new CommanderDamageAdapter(mFragment.getActivity());

//comment
if (displayMode == LifeCounterFragment.DISPLAY_COMMANDER) {
<start>setupCommanderCastingButton();
setupCommanderExperienceCounterButton();<end>

mCommanderRowView = LayoutInflater.from(
mFragment.getActivity()).inflate(R.layout.life_counter_player_commander, playersView, false);
assert mCommanderRowView != null;
mCommanderNameTextView = mCommanderRowView.findViewById(R.id.player_name);
if (mName != null) {
mCommanderNameTextView.setText(mName);
}
mCommanderReadoutTextView = mCommanderRowView.findViewById(R.id.player_readout);
}
//comment
else {
mView.findViewById(R.id.commanderCastText).setVisibility(View.GONE);
mCommanderCastingButton.setVisibility(View.GONE);

mView.findViewById(R.id.commanderExperienceCounterText).setVisibility(View.GONE);
mCommanderExperienceCountersButton.setVisibility(View.GONE);
}

break;
}
case LifeCounterFragment.DISPLAY_COMPACT: {
//comment
mView = LayoutInflater
.from(mFragment.getActivity()).inflate(R.layout.life_counter_player_compact, playersView, false);
//comment
mHistoryList = null;
mHistoryLifeAdapter = null;
mHistoryPoisonAdapter = null;
mCommanderDamageAdapter = null;
break;
}
}
assert mView != null;

//comment
mNameTextView = mView.findViewById(R.id.player_name);
if (mName != null) {
mNameTextView.setText(mName);
}
//comment
mReadoutTextView = mView.findViewById(R.id.player_readout);
mReadoutTextView.setOnClickListener(view -> {
//comment
if (mCommitting) {
mCommitting = false;
mHandler.removeCallbacks(mLifePoisonCommitter);
mLifePoisonCommitter.run();
}
showDialog(LcPlayerDialogFragment.DIALOG_CHANGE_LIFE, -1);
});

//comment
mView.findViewById(R.id.player_minus1).setOnClickListener(view -> changeValue(-1, false));
mView.findViewById(R.id.player_minus5).setOnClickListener(view -> changeValue(-5, false));
mView.findViewById(R.id.player_plus1).setOnClickListener(view -> changeValue(1, false));
mView.findViewById(R.id.player_plus5).setOnClickListener(view -> changeValue(5, false));

mView.findViewById(R.id.player_name).setOnClickListener(view -> showDialog(LcPlayerDialogFragment.DIALOG_SET_NAME, -1));

setMode(statType);

if (displayMode == LifeCounterFragment.DISPLAY_COMMANDER) {
return mCommanderRowView;
} else {
return mView;
}
}","public View newView(int displayMode, int statType, GridLayout playersView, LinearLayout commanderPlayerView) {
switch (displayMode) {
case LifeCounterFragment.DISPLAY_COMMANDER:
case LifeCounterFragment.DISPLAY_NORMAL: {
//comment
if (LifeCounterFragment.DISPLAY_COMMANDER == displayMode) {
mView = LayoutInflater.from(mFragment.getActivity()).inflate(R.layout.life_counter_player, commanderPlayerView, false);
} else {
mView = LayoutInflater.from(mFragment.getActivity()).inflate(R.layout.life_counter_player, playersView, false);
}
assert mView != null;
mHistoryList = mView.findViewById(R.id.player_history);
mCommanderCastingButton = mView.findViewById(R.id.commanderCast);
mCommanderExperienceCountersButton = mView.findViewById(R.id.commanderExperienceCounter);

//comment
mHistoryLifeAdapter = new HistoryArrayAdapter(mFragment.getActivity(), LifeCounterFragment.STAT_LIFE);
mHistoryPoisonAdapter
= new HistoryArrayAdapter(mFragment.getActivity(), LifeCounterFragment.STAT_POISON);
mCommanderDamageAdapter = new CommanderDamageAdapter(mFragment.getActivity());

//comment
<start>if (displayMode == LifeCounterFragment.DISPLAY_COMMANDER) {
setupCommanderCastingButton();
setupCommanderExperienceCounterButton();

mCommanderRowView = LayoutInflater.from(
mFragment.getActivity()).inflate(R.layout.life_counter_player_commander, playersView, false);
assert mCommanderRowView != null;
mCommanderNameTextView = mCommanderRowView.findViewById(R.id.player_name);
if (mName != null) {
mCommanderNameTextView.setText(mName);
}
mCommanderReadoutTextView = mCommanderRowView.findViewById(R.id.player_readout);
}<end>
//comment
else {
mView.findViewById(R.id.commanderCastText).setVisibility(View.GONE);
mCommanderCastingButton.setVisibility(View.GONE);

mView.findViewById(R.id.commanderExperienceCounterText).setVisibility(View.GONE);
mCommanderExperienceCountersButton.setVisibility(View.GONE);
}

break;
}
case LifeCounterFragment.DISPLAY_COMPACT: {
//comment
mView = LayoutInflater
.from(mFragment.getActivity()).inflate(R.layout.life_counter_player_compact, playersView, false);
//comment
mHistoryList = null;
mHistoryLifeAdapter = null;
mHistoryPoisonAdapter = null;
mCommanderDamageAdapter = null;
break;
}
}
assert mView != null;

//comment
mNameTextView = mView.findViewById(R.id.player_name);
if (mName != null) {
mNameTextView.setText(mName);
}
//comment
mReadoutTextView = mView.findViewById(R.id.player_readout);
mReadoutTextView.setOnClickListener(view -> {
//comment
if (mCommitting) {
mCommitting = false;
mHandler.removeCallbacks(mLifePoisonCommitter);
mLifePoisonCommitter.run();
}
showDialog(LcPlayerDialogFragment.DIALOG_CHANGE_LIFE, -1);
});

//comment
mView.findViewById(R.id.player_minus1).setOnClickListener(view -> changeValue(-1, false));
mView.findViewById(R.id.player_minus5).setOnClickListener(view -> changeValue(-5, false));
mView.findViewById(R.id.player_plus1).setOnClickListener(view -> changeValue(1, false));
mView.findViewById(R.id.player_plus5).setOnClickListener(view -> changeValue(5, false));

mView.findViewById(R.id.player_name).setOnClickListener(view -> showDialog(LcPlayerDialogFragment.DIALOG_SET_NAME, -1));

setMode(statType);

if (displayMode == LifeCounterFragment.DISPLAY_COMMANDER) {
return mCommanderRowView;
} else {
return mView;
}
}"
6111,"public View newView(int displayMode, int statType, GridLayout playersView, LinearLayout commanderPlayerView) {
switch (displayMode) {
case LifeCounterFragment.DISPLAY_COMMANDER:
case LifeCounterFragment.DISPLAY_NORMAL: {
//comment
if (LifeCounterFragment.DISPLAY_COMMANDER == displayMode) {
mView = LayoutInflater.from(mFragment.getActivity()).inflate(R.layout.life_counter_player, commanderPlayerView, false);
} else {
mView = LayoutInflater.from(mFragment.getActivity()).inflate(R.layout.life_counter_player, playersView, false);
}
assert mView != null;
mHistoryList = mView.findViewById(R.id.player_history);
mCommanderCastingButton = mView.findViewById(R.id.commanderCast);
mCommanderExperienceCountersButton = mView.findViewById(R.id.commanderExperienceCounter);

//comment
mHistoryLifeAdapter = new HistoryArrayAdapter(mFragment.getActivity(), LifeCounterFragment.STAT_LIFE);
mHistoryPoisonAdapter
= new HistoryArrayAdapter(mFragment.getActivity(), LifeCounterFragment.STAT_POISON);
mCommanderDamageAdapter = new CommanderDamageAdapter(mFragment.getActivity());

//comment
if (displayMode == LifeCounterFragment.DISPLAY_COMMANDER) {
setupCommanderCastingButton();
setupCommanderExperienceCounterButton();

mCommanderRowView = LayoutInflater.from(
mFragment.getActivity()).inflate(R.layout.life_counter_player_commander, playersView, false);
assert mCommanderRowView != null;
mCommanderNameTextView = mCommanderRowView.findViewById(R.id.player_name);
if (mName != null) {
mCommanderNameTextView.setText(mName);
}
<start>mCommanderReadoutTextView = mCommanderRowView.findViewById(R.id.player_readout);<end>
}
//comment
else {
<start>mView.findViewById(R.id.commanderCastText).setVisibility(View.GONE);
mCommanderCastingButton.setVisibility(View.GONE);<end>

mView.findViewById(R.id.commanderExperienceCounterText).setVisibility(View.GONE);
mCommanderExperienceCountersButton.setVisibility(View.GONE);
}

break;
}
case LifeCounterFragment.DISPLAY_COMPACT: {
//comment
mView = LayoutInflater
.from(mFragment.getActivity()).inflate(R.layout.life_counter_player_compact, playersView, false);
//comment
mHistoryList = null;
mHistoryLifeAdapter = null;
mHistoryPoisonAdapter = null;
mCommanderDamageAdapter = null;
break;
}
}
assert mView != null;

//comment
mNameTextView = mView.findViewById(R.id.player_name);
if (mName != null) {
mNameTextView.setText(mName);
}
//comment
mReadoutTextView = mView.findViewById(R.id.player_readout);
mReadoutTextView.setOnClickListener(view -> {
//comment
if (mCommitting) {
mCommitting = false;
mHandler.removeCallbacks(mLifePoisonCommitter);
mLifePoisonCommitter.run();
}
showDialog(LcPlayerDialogFragment.DIALOG_CHANGE_LIFE, -1);
});

//comment
mView.findViewById(R.id.player_minus1).setOnClickListener(view -> changeValue(-1, false));
mView.findViewById(R.id.player_minus5).setOnClickListener(view -> changeValue(-5, false));
mView.findViewById(R.id.player_plus1).setOnClickListener(view -> changeValue(1, false));
mView.findViewById(R.id.player_plus5).setOnClickListener(view -> changeValue(5, false));

mView.findViewById(R.id.player_name).setOnClickListener(view -> showDialog(LcPlayerDialogFragment.DIALOG_SET_NAME, -1));

setMode(statType);

if (displayMode == LifeCounterFragment.DISPLAY_COMMANDER) {
return mCommanderRowView;
} else {
return mView;
}
}","public View newView(int displayMode, int statType, GridLayout playersView, LinearLayout commanderPlayerView) {
switch (displayMode) {
case LifeCounterFragment.DISPLAY_COMMANDER:
case LifeCounterFragment.DISPLAY_NORMAL: {
//comment
if (LifeCounterFragment.DISPLAY_COMMANDER == displayMode) {
mView = LayoutInflater.from(mFragment.getActivity()).inflate(R.layout.life_counter_player, commanderPlayerView, false);
} else {
mView = LayoutInflater.from(mFragment.getActivity()).inflate(R.layout.life_counter_player, playersView, false);
}
assert mView != null;
mHistoryList = mView.findViewById(R.id.player_history);
mCommanderCastingButton = mView.findViewById(R.id.commanderCast);
mCommanderExperienceCountersButton = mView.findViewById(R.id.commanderExperienceCounter);

//comment
mHistoryLifeAdapter = new HistoryArrayAdapter(mFragment.getActivity(), LifeCounterFragment.STAT_LIFE);
mHistoryPoisonAdapter
= new HistoryArrayAdapter(mFragment.getActivity(), LifeCounterFragment.STAT_POISON);
mCommanderDamageAdapter = new CommanderDamageAdapter(mFragment.getActivity());

//comment
<start>if (displayMode == LifeCounterFragment.DISPLAY_COMMANDER) {<end>
setupCommanderCastingButton();
setupCommanderExperienceCounterButton();

mCommanderRowView = LayoutInflater.from(
mFragment.getActivity()).inflate(R.layout.life_counter_player_commander, playersView, false);
assert mCommanderRowView != null;
mCommanderNameTextView = mCommanderRowView.findViewById(R.id.player_name);
if (mName != null) {
mCommanderNameTextView.setText(mName);
}
mCommanderReadoutTextView = mCommanderRowView.findViewById(R.id.player_readout);
<start>}
//comment
else {
mView.findViewById(R.id.commanderCastText).setVisibility(View.GONE);
mCommanderCastingButton.setVisibility(View.GONE);

mView.findViewById(R.id.commanderExperienceCounterText).setVisibility(View.GONE);
mCommanderExperienceCountersButton.setVisibility(View.GONE);
}<end>

break;
}
case LifeCounterFragment.DISPLAY_COMPACT: {
//comment
mView = LayoutInflater
.from(mFragment.getActivity()).inflate(R.layout.life_counter_player_compact, playersView, false);
//comment
mHistoryList = null;
mHistoryLifeAdapter = null;
mHistoryPoisonAdapter = null;
mCommanderDamageAdapter = null;
break;
}
}
assert mView != null;

//comment
mNameTextView = mView.findViewById(R.id.player_name);
if (mName != null) {
mNameTextView.setText(mName);
}
//comment
mReadoutTextView = mView.findViewById(R.id.player_readout);
mReadoutTextView.setOnClickListener(view -> {
//comment
if (mCommitting) {
mCommitting = false;
mHandler.removeCallbacks(mLifePoisonCommitter);
mLifePoisonCommitter.run();
}
showDialog(LcPlayerDialogFragment.DIALOG_CHANGE_LIFE, -1);
});

//comment
mView.findViewById(R.id.player_minus1).setOnClickListener(view -> changeValue(-1, false));
mView.findViewById(R.id.player_minus5).setOnClickListener(view -> changeValue(-5, false));
mView.findViewById(R.id.player_plus1).setOnClickListener(view -> changeValue(1, false));
mView.findViewById(R.id.player_plus5).setOnClickListener(view -> changeValue(5, false));

mView.findViewById(R.id.player_name).setOnClickListener(view -> showDialog(LcPlayerDialogFragment.DIALOG_SET_NAME, -1));

setMode(statType);

if (displayMode == LifeCounterFragment.DISPLAY_COMMANDER) {
return mCommanderRowView;
} else {
return mView;
}
}"
6112,"public View newView(int displayMode, int statType, GridLayout playersView, LinearLayout commanderPlayerView) {
switch (displayMode) {
case LifeCounterFragment.DISPLAY_COMMANDER:
case LifeCounterFragment.DISPLAY_NORMAL: {
//comment
if (LifeCounterFragment.DISPLAY_COMMANDER == displayMode) {
mView = LayoutInflater.from(mFragment.getActivity()).inflate(R.layout.life_counter_player, commanderPlayerView, false);
} else {
mView = LayoutInflater.from(mFragment.getActivity()).inflate(R.layout.life_counter_player, playersView, false);
}
assert mView != null;
mHistoryList = mView.findViewById(R.id.player_history);
mCommanderCastingButton = mView.findViewById(R.id.commanderCast);
mCommanderExperienceCountersButton = mView.findViewById(R.id.commanderExperienceCounter);

//comment
mHistoryLifeAdapter = new HistoryArrayAdapter(mFragment.getActivity(), LifeCounterFragment.STAT_LIFE);
mHistoryPoisonAdapter
= new HistoryArrayAdapter(mFragment.getActivity(), LifeCounterFragment.STAT_POISON);
mCommanderDamageAdapter = new CommanderDamageAdapter(mFragment.getActivity());

//comment
if (displayMode == LifeCounterFragment.DISPLAY_COMMANDER) {
setupCommanderCastingButton();
setupCommanderExperienceCounterButton();

mCommanderRowView = LayoutInflater.from(
mFragment.getActivity()).inflate(R.layout.life_counter_player_commander, playersView, false);
assert mCommanderRowView != null;
mCommanderNameTextView = mCommanderRowView.findViewById(R.id.player_name);
if (mName != null) {
mCommanderNameTextView.setText(mName);
}
mCommanderReadoutTextView = mCommanderRowView.findViewById(R.id.player_readout);
}
//comment
else {
mView.findViewById(R.id.commanderCastText).setVisibility(View.GONE);
mCommanderCastingButton.setVisibility(View.GONE);

mView.findViewById(R.id.commanderExperienceCounterText).setVisibility(View.GONE);
mCommanderExperienceCountersButton.setVisibility(View.GONE);
}

break;
}
<start>case LifeCounterFragment.DISPLAY_COMPACT: {
//comment
mView = LayoutInflater
.from(mFragment.getActivity()).inflate(R.layout.life_counter_player_compact, playersView, false);<end>
//comment
mHistoryList = null;
mHistoryLifeAdapter = null;
mHistoryPoisonAdapter = null;
mCommanderDamageAdapter = null;
break;
}
}
assert mView != null;

//comment
mNameTextView = mView.findViewById(R.id.player_name);
if (mName != null) {
mNameTextView.setText(mName);
}
//comment
mReadoutTextView = mView.findViewById(R.id.player_readout);
mReadoutTextView.setOnClickListener(view -> {
//comment
if (mCommitting) {
mCommitting = false;
mHandler.removeCallbacks(mLifePoisonCommitter);
mLifePoisonCommitter.run();
}
showDialog(LcPlayerDialogFragment.DIALOG_CHANGE_LIFE, -1);
});

//comment
mView.findViewById(R.id.player_minus1).setOnClickListener(view -> changeValue(-1, false));
mView.findViewById(R.id.player_minus5).setOnClickListener(view -> changeValue(-5, false));
mView.findViewById(R.id.player_plus1).setOnClickListener(view -> changeValue(1, false));
mView.findViewById(R.id.player_plus5).setOnClickListener(view -> changeValue(5, false));

mView.findViewById(R.id.player_name).setOnClickListener(view -> showDialog(LcPlayerDialogFragment.DIALOG_SET_NAME, -1));

setMode(statType);

if (displayMode == LifeCounterFragment.DISPLAY_COMMANDER) {
return mCommanderRowView;
} else {
return mView;
}
}","public View newView(int displayMode, int statType, GridLayout playersView, LinearLayout commanderPlayerView) {
switch (displayMode) {
case LifeCounterFragment.DISPLAY_COMMANDER:
case LifeCounterFragment.DISPLAY_NORMAL: {
//comment
if (LifeCounterFragment.DISPLAY_COMMANDER == displayMode) {
mView = LayoutInflater.from(mFragment.getActivity()).inflate(R.layout.life_counter_player, commanderPlayerView, false);
} else {
mView = LayoutInflater.from(mFragment.getActivity()).inflate(R.layout.life_counter_player, playersView, false);
}
assert mView != null;
mHistoryList = mView.findViewById(R.id.player_history);
mCommanderCastingButton = mView.findViewById(R.id.commanderCast);
mCommanderExperienceCountersButton = mView.findViewById(R.id.commanderExperienceCounter);

//comment
mHistoryLifeAdapter = new HistoryArrayAdapter(mFragment.getActivity(), LifeCounterFragment.STAT_LIFE);
mHistoryPoisonAdapter
= new HistoryArrayAdapter(mFragment.getActivity(), LifeCounterFragment.STAT_POISON);
mCommanderDamageAdapter = new CommanderDamageAdapter(mFragment.getActivity());

//comment
if (displayMode == LifeCounterFragment.DISPLAY_COMMANDER) {
setupCommanderCastingButton();
setupCommanderExperienceCounterButton();

mCommanderRowView = LayoutInflater.from(
mFragment.getActivity()).inflate(R.layout.life_counter_player_commander, playersView, false);
assert mCommanderRowView != null;
mCommanderNameTextView = mCommanderRowView.findViewById(R.id.player_name);
if (mName != null) {
mCommanderNameTextView.setText(mName);
}
mCommanderReadoutTextView = mCommanderRowView.findViewById(R.id.player_readout);
}
//comment
else {
mView.findViewById(R.id.commanderCastText).setVisibility(View.GONE);
mCommanderCastingButton.setVisibility(View.GONE);

mView.findViewById(R.id.commanderExperienceCounterText).setVisibility(View.GONE);
mCommanderExperienceCountersButton.setVisibility(View.GONE);
}

break;
}
case LifeCounterFragment.DISPLAY_COMPACT: {
//comment
<start>mView = LayoutInflater
.from(mFragment.getActivity()).inflate(R.layout.life_counter_player_compact, playersView, false);<end>
//comment
mHistoryList = null;
mHistoryLifeAdapter = null;
mHistoryPoisonAdapter = null;
mCommanderDamageAdapter = null;
break;
}
}
assert mView != null;

//comment
mNameTextView = mView.findViewById(R.id.player_name);
if (mName != null) {
mNameTextView.setText(mName);
}
//comment
mReadoutTextView = mView.findViewById(R.id.player_readout);
mReadoutTextView.setOnClickListener(view -> {
//comment
if (mCommitting) {
mCommitting = false;
mHandler.removeCallbacks(mLifePoisonCommitter);
mLifePoisonCommitter.run();
}
showDialog(LcPlayerDialogFragment.DIALOG_CHANGE_LIFE, -1);
});

//comment
mView.findViewById(R.id.player_minus1).setOnClickListener(view -> changeValue(-1, false));
mView.findViewById(R.id.player_minus5).setOnClickListener(view -> changeValue(-5, false));
mView.findViewById(R.id.player_plus1).setOnClickListener(view -> changeValue(1, false));
mView.findViewById(R.id.player_plus5).setOnClickListener(view -> changeValue(5, false));

mView.findViewById(R.id.player_name).setOnClickListener(view -> showDialog(LcPlayerDialogFragment.DIALOG_SET_NAME, -1));

setMode(statType);

if (displayMode == LifeCounterFragment.DISPLAY_COMMANDER) {
return mCommanderRowView;
} else {
return mView;
}
}"
6113,"public View newView(int displayMode, int statType, GridLayout playersView, LinearLayout commanderPlayerView) {
switch (displayMode) {
case LifeCounterFragment.DISPLAY_COMMANDER:
case LifeCounterFragment.DISPLAY_NORMAL: {
//comment
if (LifeCounterFragment.DISPLAY_COMMANDER == displayMode) {
mView = LayoutInflater.from(mFragment.getActivity()).inflate(R.layout.life_counter_player, commanderPlayerView, false);
} else {
mView = LayoutInflater.from(mFragment.getActivity()).inflate(R.layout.life_counter_player, playersView, false);
}
assert mView != null;
mHistoryList = mView.findViewById(R.id.player_history);
mCommanderCastingButton = mView.findViewById(R.id.commanderCast);
mCommanderExperienceCountersButton = mView.findViewById(R.id.commanderExperienceCounter);

//comment
mHistoryLifeAdapter = new HistoryArrayAdapter(mFragment.getActivity(), LifeCounterFragment.STAT_LIFE);
mHistoryPoisonAdapter
= new HistoryArrayAdapter(mFragment.getActivity(), LifeCounterFragment.STAT_POISON);
mCommanderDamageAdapter = new CommanderDamageAdapter(mFragment.getActivity());

//comment
if (displayMode == LifeCounterFragment.DISPLAY_COMMANDER) {
setupCommanderCastingButton();
setupCommanderExperienceCounterButton();

mCommanderRowView = LayoutInflater.from(
mFragment.getActivity()).inflate(R.layout.life_counter_player_commander, playersView, false);
assert mCommanderRowView != null;
mCommanderNameTextView = mCommanderRowView.findViewById(R.id.player_name);
if (mName != null) {
mCommanderNameTextView.setText(mName);
}
mCommanderReadoutTextView = mCommanderRowView.findViewById(R.id.player_readout);
}
//comment
else {
mView.findViewById(R.id.commanderCastText).setVisibility(View.GONE);
mCommanderCastingButton.setVisibility(View.GONE);

mView.findViewById(R.id.commanderExperienceCounterText).setVisibility(View.GONE);
mCommanderExperienceCountersButton.setVisibility(View.GONE);
}

break;
}
case LifeCounterFragment.DISPLAY_COMPACT: {
//comment
mView = LayoutInflater
.from(mFragment.getActivity()).inflate(R.layout.life_counter_player_compact, playersView, false);
//comment
<start>mHistoryList = null;
mHistoryLifeAdapter = null;
mHistoryPoisonAdapter = null;<end>
mCommanderDamageAdapter = null;
break;
}
}
assert mView != null;

//comment
mNameTextView = mView.findViewById(R.id.player_name);
if (mName != null) {
mNameTextView.setText(mName);
}
//comment
mReadoutTextView = mView.findViewById(R.id.player_readout);
mReadoutTextView.setOnClickListener(view -> {
//comment
if (mCommitting) {
mCommitting = false;
mHandler.removeCallbacks(mLifePoisonCommitter);
mLifePoisonCommitter.run();
}
showDialog(LcPlayerDialogFragment.DIALOG_CHANGE_LIFE, -1);
});

//comment
mView.findViewById(R.id.player_minus1).setOnClickListener(view -> changeValue(-1, false));
mView.findViewById(R.id.player_minus5).setOnClickListener(view -> changeValue(-5, false));
mView.findViewById(R.id.player_plus1).setOnClickListener(view -> changeValue(1, false));
mView.findViewById(R.id.player_plus5).setOnClickListener(view -> changeValue(5, false));

mView.findViewById(R.id.player_name).setOnClickListener(view -> showDialog(LcPlayerDialogFragment.DIALOG_SET_NAME, -1));

setMode(statType);

if (displayMode == LifeCounterFragment.DISPLAY_COMMANDER) {
return mCommanderRowView;
} else {
return mView;
}
}","public View newView(int displayMode, int statType, GridLayout playersView, LinearLayout commanderPlayerView) {
switch (displayMode) {
case LifeCounterFragment.DISPLAY_COMMANDER:
case LifeCounterFragment.DISPLAY_NORMAL: {
//comment
if (LifeCounterFragment.DISPLAY_COMMANDER == displayMode) {
mView = LayoutInflater.from(mFragment.getActivity()).inflate(R.layout.life_counter_player, commanderPlayerView, false);
} else {
mView = LayoutInflater.from(mFragment.getActivity()).inflate(R.layout.life_counter_player, playersView, false);
}
assert mView != null;
mHistoryList = mView.findViewById(R.id.player_history);
mCommanderCastingButton = mView.findViewById(R.id.commanderCast);
mCommanderExperienceCountersButton = mView.findViewById(R.id.commanderExperienceCounter);

//comment
mHistoryLifeAdapter = new HistoryArrayAdapter(mFragment.getActivity(), LifeCounterFragment.STAT_LIFE);
mHistoryPoisonAdapter
= new HistoryArrayAdapter(mFragment.getActivity(), LifeCounterFragment.STAT_POISON);
mCommanderDamageAdapter = new CommanderDamageAdapter(mFragment.getActivity());

//comment
if (displayMode == LifeCounterFragment.DISPLAY_COMMANDER) {
setupCommanderCastingButton();
setupCommanderExperienceCounterButton();

mCommanderRowView = LayoutInflater.from(
mFragment.getActivity()).inflate(R.layout.life_counter_player_commander, playersView, false);
assert mCommanderRowView != null;
mCommanderNameTextView = mCommanderRowView.findViewById(R.id.player_name);
if (mName != null) {
mCommanderNameTextView.setText(mName);
}
mCommanderReadoutTextView = mCommanderRowView.findViewById(R.id.player_readout);
}
//comment
else {
mView.findViewById(R.id.commanderCastText).setVisibility(View.GONE);
mCommanderCastingButton.setVisibility(View.GONE);

mView.findViewById(R.id.commanderExperienceCounterText).setVisibility(View.GONE);
mCommanderExperienceCountersButton.setVisibility(View.GONE);
}

break;
}
case LifeCounterFragment.DISPLAY_COMPACT: {
//comment
mView = LayoutInflater
.from(mFragment.getActivity()).inflate(R.layout.life_counter_player_compact, playersView, false);
//comment
<start>mHistoryList = null;
mHistoryLifeAdapter = null;
mHistoryPoisonAdapter = null;
mCommanderDamageAdapter = null;<end>
break;
}
}
assert mView != null;

//comment
mNameTextView = mView.findViewById(R.id.player_name);
if (mName != null) {
mNameTextView.setText(mName);
}
//comment
mReadoutTextView = mView.findViewById(R.id.player_readout);
mReadoutTextView.setOnClickListener(view -> {
//comment
if (mCommitting) {
mCommitting = false;
mHandler.removeCallbacks(mLifePoisonCommitter);
mLifePoisonCommitter.run();
}
showDialog(LcPlayerDialogFragment.DIALOG_CHANGE_LIFE, -1);
});

//comment
mView.findViewById(R.id.player_minus1).setOnClickListener(view -> changeValue(-1, false));
mView.findViewById(R.id.player_minus5).setOnClickListener(view -> changeValue(-5, false));
mView.findViewById(R.id.player_plus1).setOnClickListener(view -> changeValue(1, false));
mView.findViewById(R.id.player_plus5).setOnClickListener(view -> changeValue(5, false));

mView.findViewById(R.id.player_name).setOnClickListener(view -> showDialog(LcPlayerDialogFragment.DIALOG_SET_NAME, -1));

setMode(statType);

if (displayMode == LifeCounterFragment.DISPLAY_COMMANDER) {
return mCommanderRowView;
} else {
return mView;
}
}"
6114,"public View newView(int displayMode, int statType, GridLayout playersView, LinearLayout commanderPlayerView) {
switch (displayMode) {
case LifeCounterFragment.DISPLAY_COMMANDER:
case LifeCounterFragment.DISPLAY_NORMAL: {
//comment
if (LifeCounterFragment.DISPLAY_COMMANDER == displayMode) {
mView = LayoutInflater.from(mFragment.getActivity()).inflate(R.layout.life_counter_player, commanderPlayerView, false);
} else {
mView = LayoutInflater.from(mFragment.getActivity()).inflate(R.layout.life_counter_player, playersView, false);
}
assert mView != null;
mHistoryList = mView.findViewById(R.id.player_history);
mCommanderCastingButton = mView.findViewById(R.id.commanderCast);
mCommanderExperienceCountersButton = mView.findViewById(R.id.commanderExperienceCounter);

//comment
mHistoryLifeAdapter = new HistoryArrayAdapter(mFragment.getActivity(), LifeCounterFragment.STAT_LIFE);
mHistoryPoisonAdapter
= new HistoryArrayAdapter(mFragment.getActivity(), LifeCounterFragment.STAT_POISON);
mCommanderDamageAdapter = new CommanderDamageAdapter(mFragment.getActivity());

//comment
if (displayMode == LifeCounterFragment.DISPLAY_COMMANDER) {
setupCommanderCastingButton();
setupCommanderExperienceCounterButton();

mCommanderRowView = LayoutInflater.from(
mFragment.getActivity()).inflate(R.layout.life_counter_player_commander, playersView, false);
assert mCommanderRowView != null;
mCommanderNameTextView = mCommanderRowView.findViewById(R.id.player_name);
if (mName != null) {
mCommanderNameTextView.setText(mName);
}
mCommanderReadoutTextView = mCommanderRowView.findViewById(R.id.player_readout);
}
//comment
else {
mView.findViewById(R.id.commanderCastText).setVisibility(View.GONE);
mCommanderCastingButton.setVisibility(View.GONE);

mView.findViewById(R.id.commanderExperienceCounterText).setVisibility(View.GONE);
mCommanderExperienceCountersButton.setVisibility(View.GONE);
}

break;
}
case LifeCounterFragment.DISPLAY_COMPACT: {
//comment
mView = LayoutInflater
.from(mFragment.getActivity()).inflate(R.layout.life_counter_player_compact, playersView, false);
//comment
mHistoryList = null;
mHistoryLifeAdapter = null;
mHistoryPoisonAdapter = null;
mCommanderDamageAdapter = null;
break;
}
}
assert mView != null;

//comment
<start>mNameTextView = mView.findViewById(R.id.player_name);
if (mName != null) {
mNameTextView.setText(mName);
}<end>
//comment
mReadoutTextView = mView.findViewById(R.id.player_readout);
mReadoutTextView.setOnClickListener(view -> {
//comment
if (mCommitting) {
mCommitting = false;
mHandler.removeCallbacks(mLifePoisonCommitter);
mLifePoisonCommitter.run();
}
showDialog(LcPlayerDialogFragment.DIALOG_CHANGE_LIFE, -1);
});

//comment
mView.findViewById(R.id.player_minus1).setOnClickListener(view -> changeValue(-1, false));
mView.findViewById(R.id.player_minus5).setOnClickListener(view -> changeValue(-5, false));
mView.findViewById(R.id.player_plus1).setOnClickListener(view -> changeValue(1, false));
mView.findViewById(R.id.player_plus5).setOnClickListener(view -> changeValue(5, false));

mView.findViewById(R.id.player_name).setOnClickListener(view -> showDialog(LcPlayerDialogFragment.DIALOG_SET_NAME, -1));

setMode(statType);

if (displayMode == LifeCounterFragment.DISPLAY_COMMANDER) {
return mCommanderRowView;
} else {
return mView;
}
}","public View newView(int displayMode, int statType, GridLayout playersView, LinearLayout commanderPlayerView) {
switch (displayMode) {
case LifeCounterFragment.DISPLAY_COMMANDER:
case LifeCounterFragment.DISPLAY_NORMAL: {
//comment
if (LifeCounterFragment.DISPLAY_COMMANDER == displayMode) {
mView = LayoutInflater.from(mFragment.getActivity()).inflate(R.layout.life_counter_player, commanderPlayerView, false);
} else {
mView = LayoutInflater.from(mFragment.getActivity()).inflate(R.layout.life_counter_player, playersView, false);
}
assert mView != null;
mHistoryList = mView.findViewById(R.id.player_history);
mCommanderCastingButton = mView.findViewById(R.id.commanderCast);
mCommanderExperienceCountersButton = mView.findViewById(R.id.commanderExperienceCounter);

//comment
mHistoryLifeAdapter = new HistoryArrayAdapter(mFragment.getActivity(), LifeCounterFragment.STAT_LIFE);
mHistoryPoisonAdapter
= new HistoryArrayAdapter(mFragment.getActivity(), LifeCounterFragment.STAT_POISON);
mCommanderDamageAdapter = new CommanderDamageAdapter(mFragment.getActivity());

//comment
if (displayMode == LifeCounterFragment.DISPLAY_COMMANDER) {
setupCommanderCastingButton();
setupCommanderExperienceCounterButton();

mCommanderRowView = LayoutInflater.from(
mFragment.getActivity()).inflate(R.layout.life_counter_player_commander, playersView, false);
assert mCommanderRowView != null;
mCommanderNameTextView = mCommanderRowView.findViewById(R.id.player_name);
if (mName != null) {
mCommanderNameTextView.setText(mName);
}
mCommanderReadoutTextView = mCommanderRowView.findViewById(R.id.player_readout);
}
//comment
else {
mView.findViewById(R.id.commanderCastText).setVisibility(View.GONE);
mCommanderCastingButton.setVisibility(View.GONE);

mView.findViewById(R.id.commanderExperienceCounterText).setVisibility(View.GONE);
mCommanderExperienceCountersButton.setVisibility(View.GONE);
}

break;
}
case LifeCounterFragment.DISPLAY_COMPACT: {
//comment
mView = LayoutInflater
.from(mFragment.getActivity()).inflate(R.layout.life_counter_player_compact, playersView, false);
//comment
mHistoryList = null;
mHistoryLifeAdapter = null;
mHistoryPoisonAdapter = null;
mCommanderDamageAdapter = null;
break;
}
}
assert mView != null;

//comment
<start>mNameTextView = mView.findViewById(R.id.player_name);
if (mName != null) {
mNameTextView.setText(mName);
}<end>
//comment
mReadoutTextView = mView.findViewById(R.id.player_readout);
mReadoutTextView.setOnClickListener(view -> {
//comment
if (mCommitting) {
mCommitting = false;
mHandler.removeCallbacks(mLifePoisonCommitter);
mLifePoisonCommitter.run();
}
showDialog(LcPlayerDialogFragment.DIALOG_CHANGE_LIFE, -1);
});

//comment
mView.findViewById(R.id.player_minus1).setOnClickListener(view -> changeValue(-1, false));
mView.findViewById(R.id.player_minus5).setOnClickListener(view -> changeValue(-5, false));
mView.findViewById(R.id.player_plus1).setOnClickListener(view -> changeValue(1, false));
mView.findViewById(R.id.player_plus5).setOnClickListener(view -> changeValue(5, false));

mView.findViewById(R.id.player_name).setOnClickListener(view -> showDialog(LcPlayerDialogFragment.DIALOG_SET_NAME, -1));

setMode(statType);

if (displayMode == LifeCounterFragment.DISPLAY_COMMANDER) {
return mCommanderRowView;
} else {
return mView;
}
}"
6115,"public View newView(int displayMode, int statType, GridLayout playersView, LinearLayout commanderPlayerView) {
switch (displayMode) {
case LifeCounterFragment.DISPLAY_COMMANDER:
case LifeCounterFragment.DISPLAY_NORMAL: {
//comment
if (LifeCounterFragment.DISPLAY_COMMANDER == displayMode) {
mView = LayoutInflater.from(mFragment.getActivity()).inflate(R.layout.life_counter_player, commanderPlayerView, false);
} else {
mView = LayoutInflater.from(mFragment.getActivity()).inflate(R.layout.life_counter_player, playersView, false);
}
assert mView != null;
mHistoryList = mView.findViewById(R.id.player_history);
mCommanderCastingButton = mView.findViewById(R.id.commanderCast);
mCommanderExperienceCountersButton = mView.findViewById(R.id.commanderExperienceCounter);

//comment
mHistoryLifeAdapter = new HistoryArrayAdapter(mFragment.getActivity(), LifeCounterFragment.STAT_LIFE);
mHistoryPoisonAdapter
= new HistoryArrayAdapter(mFragment.getActivity(), LifeCounterFragment.STAT_POISON);
mCommanderDamageAdapter = new CommanderDamageAdapter(mFragment.getActivity());

//comment
if (displayMode == LifeCounterFragment.DISPLAY_COMMANDER) {
setupCommanderCastingButton();
setupCommanderExperienceCounterButton();

mCommanderRowView = LayoutInflater.from(
mFragment.getActivity()).inflate(R.layout.life_counter_player_commander, playersView, false);
assert mCommanderRowView != null;
mCommanderNameTextView = mCommanderRowView.findViewById(R.id.player_name);
if (mName != null) {
mCommanderNameTextView.setText(mName);
}
mCommanderReadoutTextView = mCommanderRowView.findViewById(R.id.player_readout);
}
//comment
else {
mView.findViewById(R.id.commanderCastText).setVisibility(View.GONE);
mCommanderCastingButton.setVisibility(View.GONE);

mView.findViewById(R.id.commanderExperienceCounterText).setVisibility(View.GONE);
mCommanderExperienceCountersButton.setVisibility(View.GONE);
}

break;
}
case LifeCounterFragment.DISPLAY_COMPACT: {
//comment
mView = LayoutInflater
.from(mFragment.getActivity()).inflate(R.layout.life_counter_player_compact, playersView, false);
//comment
mHistoryList = null;
mHistoryLifeAdapter = null;
mHistoryPoisonAdapter = null;
mCommanderDamageAdapter = null;
break;
}
}
assert mView != null;

//comment
mNameTextView = mView.findViewById(R.id.player_name);
if (mName != null) {
mNameTextView.setText(mName);
}
//comment
mReadoutTextView = mView.findViewById(R.id.player_readout);
<start>mReadoutTextView.setOnClickListener(view -> {<end>
//comment
if (mCommitting) {
<start>mCommitting = false;
mHandler.removeCallbacks(mLifePoisonCommitter);<end>
mLifePoisonCommitter.run();
}
showDialog(LcPlayerDialogFragment.DIALOG_CHANGE_LIFE, -1);
});

//comment
mView.findViewById(R.id.player_minus1).setOnClickListener(view -> changeValue(-1, false));
mView.findViewById(R.id.player_minus5).setOnClickListener(view -> changeValue(-5, false));
mView.findViewById(R.id.player_plus1).setOnClickListener(view -> changeValue(1, false));
mView.findViewById(R.id.player_plus5).setOnClickListener(view -> changeValue(5, false));

mView.findViewById(R.id.player_name).setOnClickListener(view -> showDialog(LcPlayerDialogFragment.DIALOG_SET_NAME, -1));

setMode(statType);

if (displayMode == LifeCounterFragment.DISPLAY_COMMANDER) {
return mCommanderRowView;
} else {
return mView;
}
}","public View newView(int displayMode, int statType, GridLayout playersView, LinearLayout commanderPlayerView) {
switch (displayMode) {
case LifeCounterFragment.DISPLAY_COMMANDER:
case LifeCounterFragment.DISPLAY_NORMAL: {
//comment
if (LifeCounterFragment.DISPLAY_COMMANDER == displayMode) {
mView = LayoutInflater.from(mFragment.getActivity()).inflate(R.layout.life_counter_player, commanderPlayerView, false);
} else {
mView = LayoutInflater.from(mFragment.getActivity()).inflate(R.layout.life_counter_player, playersView, false);
}
assert mView != null;
mHistoryList = mView.findViewById(R.id.player_history);
mCommanderCastingButton = mView.findViewById(R.id.commanderCast);
mCommanderExperienceCountersButton = mView.findViewById(R.id.commanderExperienceCounter);

//comment
mHistoryLifeAdapter = new HistoryArrayAdapter(mFragment.getActivity(), LifeCounterFragment.STAT_LIFE);
mHistoryPoisonAdapter
= new HistoryArrayAdapter(mFragment.getActivity(), LifeCounterFragment.STAT_POISON);
mCommanderDamageAdapter = new CommanderDamageAdapter(mFragment.getActivity());

//comment
if (displayMode == LifeCounterFragment.DISPLAY_COMMANDER) {
setupCommanderCastingButton();
setupCommanderExperienceCounterButton();

mCommanderRowView = LayoutInflater.from(
mFragment.getActivity()).inflate(R.layout.life_counter_player_commander, playersView, false);
assert mCommanderRowView != null;
mCommanderNameTextView = mCommanderRowView.findViewById(R.id.player_name);
if (mName != null) {
mCommanderNameTextView.setText(mName);
}
mCommanderReadoutTextView = mCommanderRowView.findViewById(R.id.player_readout);
}
//comment
else {
mView.findViewById(R.id.commanderCastText).setVisibility(View.GONE);
mCommanderCastingButton.setVisibility(View.GONE);

mView.findViewById(R.id.commanderExperienceCounterText).setVisibility(View.GONE);
mCommanderExperienceCountersButton.setVisibility(View.GONE);
}

break;
}
case LifeCounterFragment.DISPLAY_COMPACT: {
//comment
mView = LayoutInflater
.from(mFragment.getActivity()).inflate(R.layout.life_counter_player_compact, playersView, false);
//comment
mHistoryList = null;
mHistoryLifeAdapter = null;
mHistoryPoisonAdapter = null;
mCommanderDamageAdapter = null;
break;
}
}
assert mView != null;

//comment
mNameTextView = mView.findViewById(R.id.player_name);
if (mName != null) {
mNameTextView.setText(mName);
}
//comment
<start>mReadoutTextView = mView.findViewById(R.id.player_readout);
mReadoutTextView.setOnClickListener(view -> {
//comment
if (mCommitting) {
mCommitting = false;
mHandler.removeCallbacks(mLifePoisonCommitter);
mLifePoisonCommitter.run();
}
showDialog(LcPlayerDialogFragment.DIALOG_CHANGE_LIFE, -1);
});<end>

//comment
mView.findViewById(R.id.player_minus1).setOnClickListener(view -> changeValue(-1, false));
mView.findViewById(R.id.player_minus5).setOnClickListener(view -> changeValue(-5, false));
mView.findViewById(R.id.player_plus1).setOnClickListener(view -> changeValue(1, false));
mView.findViewById(R.id.player_plus5).setOnClickListener(view -> changeValue(5, false));

mView.findViewById(R.id.player_name).setOnClickListener(view -> showDialog(LcPlayerDialogFragment.DIALOG_SET_NAME, -1));

setMode(statType);

if (displayMode == LifeCounterFragment.DISPLAY_COMMANDER) {
return mCommanderRowView;
} else {
return mView;
}
}"
6116,"public View newView(int displayMode, int statType, GridLayout playersView, LinearLayout commanderPlayerView) {
switch (displayMode) {
case LifeCounterFragment.DISPLAY_COMMANDER:
case LifeCounterFragment.DISPLAY_NORMAL: {
//comment
if (LifeCounterFragment.DISPLAY_COMMANDER == displayMode) {
mView = LayoutInflater.from(mFragment.getActivity()).inflate(R.layout.life_counter_player, commanderPlayerView, false);
} else {
mView = LayoutInflater.from(mFragment.getActivity()).inflate(R.layout.life_counter_player, playersView, false);
}
assert mView != null;
mHistoryList = mView.findViewById(R.id.player_history);
mCommanderCastingButton = mView.findViewById(R.id.commanderCast);
mCommanderExperienceCountersButton = mView.findViewById(R.id.commanderExperienceCounter);

//comment
mHistoryLifeAdapter = new HistoryArrayAdapter(mFragment.getActivity(), LifeCounterFragment.STAT_LIFE);
mHistoryPoisonAdapter
= new HistoryArrayAdapter(mFragment.getActivity(), LifeCounterFragment.STAT_POISON);
mCommanderDamageAdapter = new CommanderDamageAdapter(mFragment.getActivity());

//comment
if (displayMode == LifeCounterFragment.DISPLAY_COMMANDER) {
setupCommanderCastingButton();
setupCommanderExperienceCounterButton();

mCommanderRowView = LayoutInflater.from(
mFragment.getActivity()).inflate(R.layout.life_counter_player_commander, playersView, false);
assert mCommanderRowView != null;
mCommanderNameTextView = mCommanderRowView.findViewById(R.id.player_name);
if (mName != null) {
mCommanderNameTextView.setText(mName);
}
mCommanderReadoutTextView = mCommanderRowView.findViewById(R.id.player_readout);
}
//comment
else {
<start>mView.findViewById(R.id.commanderCastText).setVisibility(View.GONE);<end>
mCommanderCastingButton.setVisibility(View.GONE);

mView.findViewById(R.id.commanderExperienceCounterText).setVisibility(View.GONE);
mCommanderExperienceCountersButton.setVisibility(View.GONE);
}

break;
}
case LifeCounterFragment.DISPLAY_COMPACT: {
//comment
mView = LayoutInflater
.from(mFragment.getActivity()).inflate(R.layout.life_counter_player_compact, playersView, false);
//comment
mHistoryList = null;
mHistoryLifeAdapter = null;
mHistoryPoisonAdapter = null;
mCommanderDamageAdapter = null;
break;
}
}
assert mView != null;

//comment
mNameTextView = mView.findViewById(R.id.player_name);
if (mName != null) {
mNameTextView.setText(mName);
}
//comment
mReadoutTextView = mView.findViewById(R.id.player_readout);
<start>mReadoutTextView.setOnClickListener(view -> {<end>
//comment
if (mCommitting) {
mCommitting = false;
<start>mHandler.removeCallbacks(mLifePoisonCommitter);<end>
mLifePoisonCommitter.run();
}
showDialog(LcPlayerDialogFragment.DIALOG_CHANGE_LIFE, -1);
});

//comment
mView.findViewById(R.id.player_minus1).setOnClickListener(view -> changeValue(-1, false));
mView.findViewById(R.id.player_minus5).setOnClickListener(view -> changeValue(-5, false));
mView.findViewById(R.id.player_plus1).setOnClickListener(view -> changeValue(1, false));
mView.findViewById(R.id.player_plus5).setOnClickListener(view -> changeValue(5, false));

mView.findViewById(R.id.player_name).setOnClickListener(view -> showDialog(LcPlayerDialogFragment.DIALOG_SET_NAME, -1));

setMode(statType);

if (displayMode == LifeCounterFragment.DISPLAY_COMMANDER) {
return mCommanderRowView;
} else {
return mView;
}
}","public View newView(int displayMode, int statType, GridLayout playersView, LinearLayout commanderPlayerView) {
switch (displayMode) {
case LifeCounterFragment.DISPLAY_COMMANDER:
case LifeCounterFragment.DISPLAY_NORMAL: {
//comment
if (LifeCounterFragment.DISPLAY_COMMANDER == displayMode) {
mView = LayoutInflater.from(mFragment.getActivity()).inflate(R.layout.life_counter_player, commanderPlayerView, false);
} else {
mView = LayoutInflater.from(mFragment.getActivity()).inflate(R.layout.life_counter_player, playersView, false);
}
assert mView != null;
mHistoryList = mView.findViewById(R.id.player_history);
mCommanderCastingButton = mView.findViewById(R.id.commanderCast);
mCommanderExperienceCountersButton = mView.findViewById(R.id.commanderExperienceCounter);

//comment
mHistoryLifeAdapter = new HistoryArrayAdapter(mFragment.getActivity(), LifeCounterFragment.STAT_LIFE);
mHistoryPoisonAdapter
= new HistoryArrayAdapter(mFragment.getActivity(), LifeCounterFragment.STAT_POISON);
mCommanderDamageAdapter = new CommanderDamageAdapter(mFragment.getActivity());

//comment
if (displayMode == LifeCounterFragment.DISPLAY_COMMANDER) {
setupCommanderCastingButton();
setupCommanderExperienceCounterButton();

mCommanderRowView = LayoutInflater.from(
mFragment.getActivity()).inflate(R.layout.life_counter_player_commander, playersView, false);
assert mCommanderRowView != null;
mCommanderNameTextView = mCommanderRowView.findViewById(R.id.player_name);
if (mName != null) {
mCommanderNameTextView.setText(mName);
}
mCommanderReadoutTextView = mCommanderRowView.findViewById(R.id.player_readout);
}
//comment
else {
mView.findViewById(R.id.commanderCastText).setVisibility(View.GONE);
mCommanderCastingButton.setVisibility(View.GONE);

mView.findViewById(R.id.commanderExperienceCounterText).setVisibility(View.GONE);
mCommanderExperienceCountersButton.setVisibility(View.GONE);
}

break;
}
case LifeCounterFragment.DISPLAY_COMPACT: {
//comment
mView = LayoutInflater
.from(mFragment.getActivity()).inflate(R.layout.life_counter_player_compact, playersView, false);
//comment
mHistoryList = null;
mHistoryLifeAdapter = null;
mHistoryPoisonAdapter = null;
mCommanderDamageAdapter = null;
break;
}
}
assert mView != null;

//comment
mNameTextView = mView.findViewById(R.id.player_name);
if (mName != null) {
mNameTextView.setText(mName);
}
//comment
mReadoutTextView = mView.findViewById(R.id.player_readout);
mReadoutTextView.setOnClickListener(view -> {
//comment
<start>if (mCommitting) {
mCommitting = false;
mHandler.removeCallbacks(mLifePoisonCommitter);
mLifePoisonCommitter.run();
}<end>
showDialog(LcPlayerDialogFragment.DIALOG_CHANGE_LIFE, -1);
});

//comment
mView.findViewById(R.id.player_minus1).setOnClickListener(view -> changeValue(-1, false));
mView.findViewById(R.id.player_minus5).setOnClickListener(view -> changeValue(-5, false));
mView.findViewById(R.id.player_plus1).setOnClickListener(view -> changeValue(1, false));
mView.findViewById(R.id.player_plus5).setOnClickListener(view -> changeValue(5, false));

mView.findViewById(R.id.player_name).setOnClickListener(view -> showDialog(LcPlayerDialogFragment.DIALOG_SET_NAME, -1));

setMode(statType);

if (displayMode == LifeCounterFragment.DISPLAY_COMMANDER) {
return mCommanderRowView;
} else {
return mView;
}
}"
6117,"public View newView(int displayMode, int statType, GridLayout playersView, LinearLayout commanderPlayerView) {
switch (displayMode) {
case LifeCounterFragment.DISPLAY_COMMANDER:
case LifeCounterFragment.DISPLAY_NORMAL: {
//comment
if (LifeCounterFragment.DISPLAY_COMMANDER == displayMode) {
mView = LayoutInflater.from(mFragment.getActivity()).inflate(R.layout.life_counter_player, commanderPlayerView, false);
} else {
mView = LayoutInflater.from(mFragment.getActivity()).inflate(R.layout.life_counter_player, playersView, false);
}
assert mView != null;
mHistoryList = mView.findViewById(R.id.player_history);
mCommanderCastingButton = mView.findViewById(R.id.commanderCast);
mCommanderExperienceCountersButton = mView.findViewById(R.id.commanderExperienceCounter);

//comment
mHistoryLifeAdapter = new HistoryArrayAdapter(mFragment.getActivity(), LifeCounterFragment.STAT_LIFE);
mHistoryPoisonAdapter
= new HistoryArrayAdapter(mFragment.getActivity(), LifeCounterFragment.STAT_POISON);
mCommanderDamageAdapter = new CommanderDamageAdapter(mFragment.getActivity());

//comment
if (displayMode == LifeCounterFragment.DISPLAY_COMMANDER) {
setupCommanderCastingButton();
setupCommanderExperienceCounterButton();

mCommanderRowView = LayoutInflater.from(
mFragment.getActivity()).inflate(R.layout.life_counter_player_commander, playersView, false);
assert mCommanderRowView != null;
mCommanderNameTextView = mCommanderRowView.findViewById(R.id.player_name);
if (mName != null) {
mCommanderNameTextView.setText(mName);
}
mCommanderReadoutTextView = mCommanderRowView.findViewById(R.id.player_readout);
}
//comment
else {
mView.findViewById(R.id.commanderCastText).setVisibility(View.GONE);
mCommanderCastingButton.setVisibility(View.GONE);

mView.findViewById(R.id.commanderExperienceCounterText).setVisibility(View.GONE);
mCommanderExperienceCountersButton.setVisibility(View.GONE);
}

break;
}
case LifeCounterFragment.DISPLAY_COMPACT: {
//comment
mView = LayoutInflater
.from(mFragment.getActivity()).inflate(R.layout.life_counter_player_compact, playersView, false);
//comment
mHistoryList = null;
mHistoryLifeAdapter = null;
mHistoryPoisonAdapter = null;
mCommanderDamageAdapter = null;
break;
}
}
assert mView != null;

//comment
mNameTextView = mView.findViewById(R.id.player_name);
if (mName != null) {
mNameTextView.setText(mName);
}
//comment
mReadoutTextView = mView.findViewById(R.id.player_readout);
mReadoutTextView.setOnClickListener(view -> {
//comment
if (mCommitting) {
mCommitting = false;
mHandler.removeCallbacks(mLifePoisonCommitter);
mLifePoisonCommitter.run();
}
showDialog(LcPlayerDialogFragment.DIALOG_CHANGE_LIFE, -1);
});

//comment
<start>mView.findViewById(R.id.player_minus1).setOnClickListener(view -> changeValue(-1, false));
mView.findViewById(R.id.player_minus5).setOnClickListener(view -> changeValue(-5, false));<end>
mView.findViewById(R.id.player_plus1).setOnClickListener(view -> changeValue(1, false));
mView.findViewById(R.id.player_plus5).setOnClickListener(view -> changeValue(5, false));

mView.findViewById(R.id.player_name).setOnClickListener(view -> showDialog(LcPlayerDialogFragment.DIALOG_SET_NAME, -1));

setMode(statType);

if (displayMode == LifeCounterFragment.DISPLAY_COMMANDER) {
return mCommanderRowView;
} else {
return mView;
}
}","public View newView(int displayMode, int statType, GridLayout playersView, LinearLayout commanderPlayerView) {
switch (displayMode) {
case LifeCounterFragment.DISPLAY_COMMANDER:
case LifeCounterFragment.DISPLAY_NORMAL: {
//comment
if (LifeCounterFragment.DISPLAY_COMMANDER == displayMode) {
mView = LayoutInflater.from(mFragment.getActivity()).inflate(R.layout.life_counter_player, commanderPlayerView, false);
} else {
mView = LayoutInflater.from(mFragment.getActivity()).inflate(R.layout.life_counter_player, playersView, false);
}
assert mView != null;
mHistoryList = mView.findViewById(R.id.player_history);
mCommanderCastingButton = mView.findViewById(R.id.commanderCast);
mCommanderExperienceCountersButton = mView.findViewById(R.id.commanderExperienceCounter);

//comment
mHistoryLifeAdapter = new HistoryArrayAdapter(mFragment.getActivity(), LifeCounterFragment.STAT_LIFE);
mHistoryPoisonAdapter
= new HistoryArrayAdapter(mFragment.getActivity(), LifeCounterFragment.STAT_POISON);
mCommanderDamageAdapter = new CommanderDamageAdapter(mFragment.getActivity());

//comment
if (displayMode == LifeCounterFragment.DISPLAY_COMMANDER) {
setupCommanderCastingButton();
setupCommanderExperienceCounterButton();

mCommanderRowView = LayoutInflater.from(
mFragment.getActivity()).inflate(R.layout.life_counter_player_commander, playersView, false);
assert mCommanderRowView != null;
mCommanderNameTextView = mCommanderRowView.findViewById(R.id.player_name);
if (mName != null) {
mCommanderNameTextView.setText(mName);
}
mCommanderReadoutTextView = mCommanderRowView.findViewById(R.id.player_readout);
}
//comment
else {
mView.findViewById(R.id.commanderCastText).setVisibility(View.GONE);
mCommanderCastingButton.setVisibility(View.GONE);

mView.findViewById(R.id.commanderExperienceCounterText).setVisibility(View.GONE);
mCommanderExperienceCountersButton.setVisibility(View.GONE);
}

break;
}
case LifeCounterFragment.DISPLAY_COMPACT: {
//comment
mView = LayoutInflater
.from(mFragment.getActivity()).inflate(R.layout.life_counter_player_compact, playersView, false);
//comment
mHistoryList = null;
mHistoryLifeAdapter = null;
mHistoryPoisonAdapter = null;
mCommanderDamageAdapter = null;
break;
}
}
assert mView != null;

//comment
mNameTextView = mView.findViewById(R.id.player_name);
if (mName != null) {
mNameTextView.setText(mName);
}
//comment
mReadoutTextView = mView.findViewById(R.id.player_readout);
mReadoutTextView.setOnClickListener(view -> {
//comment
if (mCommitting) {
mCommitting = false;
mHandler.removeCallbacks(mLifePoisonCommitter);
mLifePoisonCommitter.run();
}
showDialog(LcPlayerDialogFragment.DIALOG_CHANGE_LIFE, -1);
});

//comment
<start>mView.findViewById(R.id.player_minus1).setOnClickListener(view -> changeValue(-1, false));
mView.findViewById(R.id.player_minus5).setOnClickListener(view -> changeValue(-5, false));
mView.findViewById(R.id.player_plus1).setOnClickListener(view -> changeValue(1, false));
mView.findViewById(R.id.player_plus5).setOnClickListener(view -> changeValue(5, false));<end>

mView.findViewById(R.id.player_name).setOnClickListener(view -> showDialog(LcPlayerDialogFragment.DIALOG_SET_NAME, -1));

setMode(statType);

if (displayMode == LifeCounterFragment.DISPLAY_COMMANDER) {
return mCommanderRowView;
} else {
return mView;
}
}"
6118,"public void resetStats() {
mLifeHistory.clear();
mPoisonHistory.clear();
mLife = mDefaultLifeTotal;
mPoison = 0;
mCommanderCasting = 0;
mCommanderExperienceCounter = 0;

for (CommanderEntry entry : mCommanderDamage) {
entry.mLife = 0;
}

if (mHistoryLifeAdapter != null) {
mHistoryLifeAdapter.notifyDataSetChanged();
}
if (mHistoryPoisonAdapter != null) {
mHistoryPoisonAdapter.notifyDataSetChanged();
}
if (mCommanderDamageAdapter != null) {
mCommanderDamageAdapter.notifyDataSetChanged();
}

//comment
if (mLife == -1) {
mLife = LifeCounterFragment.DEFAULT_LIFE;
}

//comment
<start>changeValue(0, true);<end>
if (mCommanderCastingButton != null) {
mCommanderCastingButton.setText(formatInt(mCommanderCasting, false));
}

if (mCommanderExperienceCountersButton != null) {
mCommanderExperienceCountersButton.setText(formatInt(mCommanderExperienceCounter, false));
}
}","public void resetStats() {
mLifeHistory.clear();
mPoisonHistory.clear();
mLife = mDefaultLifeTotal;
mPoison = 0;
mCommanderCasting = 0;
mCommanderExperienceCounter = 0;

for (CommanderEntry entry : mCommanderDamage) {
entry.mLife = 0;
}

if (mHistoryLifeAdapter != null) {
mHistoryLifeAdapter.notifyDataSetChanged();
}
if (mHistoryPoisonAdapter != null) {
mHistoryPoisonAdapter.notifyDataSetChanged();
}
if (mCommanderDamageAdapter != null) {
mCommanderDamageAdapter.notifyDataSetChanged();
}

//comment
if (mLife == -1) {
mLife = LifeCounterFragment.DEFAULT_LIFE;
}

//comment
<start>changeValue(0, true);<end>
if (mCommanderCastingButton != null) {
mCommanderCastingButton.setText(formatInt(mCommanderCasting, false));
}

if (mCommanderExperienceCountersButton != null) {
mCommanderExperienceCountersButton.setText(formatInt(mCommanderExperienceCounter, false));
}
}"
6119,"public void setSize(int mGridLayoutWidth, int mGridLayoutHeight, int numRows, int numCols, int displayMode, boolean isPortrait, boolean isSingle) {

if (null == mView) {
return;
}

switch (displayMode) {
case LifeCounterFragment.DISPLAY_NORMAL: {
ViewGroup.LayoutParams params = mView.getLayoutParams();
if (null != params) {
if (isSingle) {
params.width = mGridLayoutWidth;
params.height = mGridLayoutHeight;
} else if (isPortrait) {
params.width = mGridLayoutWidth;
params.height = mGridLayoutHeight / 2;
} else {
params.width = mGridLayoutWidth / 2;
params.height = mGridLayoutHeight;
}
mView.setLayoutParams(params);
}
break;
}
case LifeCounterFragment.DISPLAY_COMPACT: {
ViewGroup.LayoutParams params = mView.getLayoutParams();
<start>if (null != params) {
params.width = mGridLayoutWidth / numCols;
params.height = mGridLayoutHeight / numRows;
mView.setLayoutParams(params);
}
break;<end>
}
<start>case LifeCounterFragment.DISPLAY_COMMANDER: {<end>
//comment
if (null != mCommanderRowView) {
<start>ViewGroup.LayoutParams rowParams = mCommanderRowView.getLayoutParams();<end>
if (null != rowParams) {
rowParams.height = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 48,
mFragment.requireActivity().getResources().getDisplayMetrics());
if (isPortrait) {
rowParams.width = mGridLayoutWidth / 2;
} else {
rowParams.width = mGridLayoutWidth / 4;
}
mCommanderRowView.setLayoutParams(rowParams);
}
}

//comment
ViewGroup.LayoutParams viewParams = mView.getLayoutParams();
if (null != viewParams) {
if (!isPortrait) {
viewParams.width = mGridLayoutWidth / 2;
}
mView.setLayoutParams(viewParams);
}
break;
}
}
}","public void setSize(int mGridLayoutWidth, int mGridLayoutHeight, int numRows, int numCols, int displayMode, boolean isPortrait, boolean isSingle) {

if (null == mView) {
return;
}

switch (displayMode) {
case LifeCounterFragment.DISPLAY_NORMAL: {
ViewGroup.LayoutParams params = mView.getLayoutParams();
if (null != params) {
if (isSingle) {
params.width = mGridLayoutWidth;
params.height = mGridLayoutHeight;
} else if (isPortrait) {
params.width = mGridLayoutWidth;
params.height = mGridLayoutHeight / 2;
} else {
params.width = mGridLayoutWidth / 2;
params.height = mGridLayoutHeight;
}
mView.setLayoutParams(params);
}
break;
}
case LifeCounterFragment.DISPLAY_COMPACT: {
ViewGroup.LayoutParams params = mView.getLayoutParams();
if (null != params) {
params.width = mGridLayoutWidth / numCols;
params.height = mGridLayoutHeight / numRows;
mView.setLayoutParams(params);
}
break;
}
case LifeCounterFragment.DISPLAY_COMMANDER: {
//comment
<start>if (null != mCommanderRowView) {
ViewGroup.LayoutParams rowParams = mCommanderRowView.getLayoutParams();
if (null != rowParams) {
rowParams.height = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 48,
mFragment.requireActivity().getResources().getDisplayMetrics());
if (isPortrait) {
rowParams.width = mGridLayoutWidth / 2;
} else {
rowParams.width = mGridLayoutWidth / 4;
}
mCommanderRowView.setLayoutParams(rowParams);
}
}<end>

//comment
ViewGroup.LayoutParams viewParams = mView.getLayoutParams();
if (null != viewParams) {
if (!isPortrait) {
viewParams.width = mGridLayoutWidth / 2;
}
mView.setLayoutParams(viewParams);
}
break;
}
}
}"
6120,"public void setSize(int mGridLayoutWidth, int mGridLayoutHeight, int numRows, int numCols, int displayMode, boolean isPortrait, boolean isSingle) {

if (null == mView) {
return;
}

switch (displayMode) {
case LifeCounterFragment.DISPLAY_NORMAL: {
ViewGroup.LayoutParams params = mView.getLayoutParams();
if (null != params) {
if (isSingle) {
params.width = mGridLayoutWidth;
params.height = mGridLayoutHeight;
} else if (isPortrait) {
params.width = mGridLayoutWidth;
params.height = mGridLayoutHeight / 2;
} else {
params.width = mGridLayoutWidth / 2;
params.height = mGridLayoutHeight;
}
mView.setLayoutParams(params);
}
break;
}
case LifeCounterFragment.DISPLAY_COMPACT: {
ViewGroup.LayoutParams params = mView.getLayoutParams();
if (null != params) {
params.width = mGridLayoutWidth / numCols;
params.height = mGridLayoutHeight / numRows;
mView.setLayoutParams(params);
}
break;
}
case LifeCounterFragment.DISPLAY_COMMANDER: {
//comment
if (null != mCommanderRowView) {
ViewGroup.LayoutParams rowParams = mCommanderRowView.getLayoutParams();
if (null != rowParams) {
rowParams.height = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 48,
mFragment.requireActivity().getResources().getDisplayMetrics());
if (isPortrait) {
rowParams.width = mGridLayoutWidth / 2;
} else {
rowParams.width = mGridLayoutWidth / 4;
}
mCommanderRowView.setLayoutParams(rowParams);
}
}

//comment
<start>ViewGroup.LayoutParams viewParams = mView.getLayoutParams();
if (null != viewParams) {
if (!isPortrait) {
viewParams.width = mGridLayoutWidth / 2;
}
mView.setLayoutParams(viewParams);
}
break;<end>
}
}
}","public void setSize(int mGridLayoutWidth, int mGridLayoutHeight, int numRows, int numCols, int displayMode, boolean isPortrait, boolean isSingle) {

if (null == mView) {
return;
}

switch (displayMode) {
case LifeCounterFragment.DISPLAY_NORMAL: {
ViewGroup.LayoutParams params = mView.getLayoutParams();
if (null != params) {
if (isSingle) {
params.width = mGridLayoutWidth;
params.height = mGridLayoutHeight;
} else if (isPortrait) {
params.width = mGridLayoutWidth;
params.height = mGridLayoutHeight / 2;
} else {
params.width = mGridLayoutWidth / 2;
params.height = mGridLayoutHeight;
}
mView.setLayoutParams(params);
}
break;
}
case LifeCounterFragment.DISPLAY_COMPACT: {
ViewGroup.LayoutParams params = mView.getLayoutParams();
if (null != params) {
params.width = mGridLayoutWidth / numCols;
params.height = mGridLayoutHeight / numRows;
mView.setLayoutParams(params);
}
break;
}
case LifeCounterFragment.DISPLAY_COMMANDER: {
//comment
if (null != mCommanderRowView) {
ViewGroup.LayoutParams rowParams = mCommanderRowView.getLayoutParams();
if (null != rowParams) {
rowParams.height = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 48,
mFragment.requireActivity().getResources().getDisplayMetrics());
if (isPortrait) {
rowParams.width = mGridLayoutWidth / 2;
} else {
rowParams.width = mGridLayoutWidth / 4;
}
mCommanderRowView.setLayoutParams(rowParams);
}
}

//comment
<start>ViewGroup.LayoutParams viewParams = mView.getLayoutParams();
if (null != viewParams) {
if (!isPortrait) {
viewParams.width = mGridLayoutWidth / 2;
}<end>
mView.setLayoutParams(viewParams);
}
break;
}
}
}"
6121,"    private void showDialog(final int id, final int position) throws IllegalStateException {
//comment
//comment

((FamiliarActivity) mFragment.getActivity())
.removeDialogFragment(mFragment.requireActivity().getSupportFragmentManager());

//comment
<start>LcPlayerDialogFragment newFragment = new LcPlayerDialogFragment();<end>
Bundle arguments = new Bundle();
<start>arguments.putInt(FamiliarDialogFragment.ID_KEY, id);
arguments.putInt(LcPlayerDialogFragment.POSITION_KEY, position);<end>
newFragment.setArguments(arguments);
newFragment.setLcPlayer(this);
newFragment.show(mFragment.getActivity().getSupportFragmentManager(), FamiliarActivity.DIALOG_TAG);
}","    private void showDialog(final int id, final int position) throws IllegalStateException {
//comment
//comment

((FamiliarActivity) mFragment.getActivity())
.removeDialogFragment(mFragment.requireActivity().getSupportFragmentManager());

//comment
<start>LcPlayerDialogFragment newFragment = new LcPlayerDialogFragment();
Bundle arguments = new Bundle();
arguments.putInt(FamiliarDialogFragment.ID_KEY, id);
arguments.putInt(LcPlayerDialogFragment.POSITION_KEY, position);
newFragment.setArguments(arguments);
newFragment.setLcPlayer(this);
newFragment.show(mFragment.getActivity().getSupportFragmentManager(), FamiliarActivity.DIALOG_TAG);<end>
}"
6122,"public static synchronized long getRoundTimerEnd(@Nullable Context context) {
if (null == context) {
<start>return -1;<end>
}
<start>long endTime = PreferenceManager.getDefaultSharedPreferences(context).getLong(context.getString(R.string.key_currentRoundTimer), -1);<end>
//comment
if (endTime < System.currentTimeMillis()) {
endTime = -1L;
setRoundTimerEnd(context, endTime);
}
return endTime;
}","public static synchronized long getRoundTimerEnd(@Nullable Context context) {
if (null == context) {
return -1;
}
long endTime = PreferenceManager.getDefaultSharedPreferences(context).getLong(context.getString(R.string.key_currentRoundTimer), -1);
//comment
<start>if (endTime < System.currentTimeMillis()) {
endTime = -1L;
setRoundTimerEnd(context, endTime);
}<end>
return endTime;
}"
6123,"public static synchronized int getImageCacheSize(@Nullable Context context) {
final int MIN_CACHE_MB = 50;
if (null == context) {
return MIN_CACHE_MB;
}
int cacheSize = PreferenceManager.getDefaultSharedPreferences(context).getInt(context.getString(R.string.key_imageCacheSize), MIN_CACHE_MB);

//comment
if (cacheSize < MIN_CACHE_MB) {
<start>setImageCacheSize(context, MIN_CACHE_MB);<end>
return MIN_CACHE_MB;
}
return cacheSize;
}","public static synchronized int getImageCacheSize(@Nullable Context context) {
final int MIN_CACHE_MB = 50;
if (null == context) {
return MIN_CACHE_MB;
}
int cacheSize = PreferenceManager.getDefaultSharedPreferences(context).getInt(context.getString(R.string.key_imageCacheSize), MIN_CACHE_MB);

//comment
<start>if (cacheSize < MIN_CACHE_MB) {
setImageCacheSize(context, MIN_CACHE_MB);
return MIN_CACHE_MB;
}<end>
return cacheSize;
}"
6124,"@Override
public void onReceive(final Context context, Intent intent) {
assert intent.getExtras() != null;
int type = intent.getExtras().getInt(RoundTimerFragment.ROUND_TIMER_INTENT);

switch (type) {
<start>case RoundTimerFragment.TIMER_RING_ALARM:
//comment
PlayNotificationSound(context, PreferenceAdapter.getTimerSound(context));<end>

//comment
NotificationHelper.createChannels(context);
NotificationCompat.Builder builder = new NotificationCompat.Builder(context, NotificationHelper.NOTIFICATION_CHANNEL_ROUND_TIMER);
int pendingIntentFlags = 0;
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
pendingIntentFlags |= PendingIntent.FLAG_MUTABLE;
}
@SuppressLint(""UnspecifiedImmutableFlag"") Notification notification = builder
.setSmallIcon(R.drawable.notification_icon)
.setWhen(System.currentTimeMillis())
.setContentTitle(context.getString(R.string.main_timer))
.setContentText(context.getString(R.string.timer_ended))
.setContentIntent(PendingIntent.getActivity(context, 7, (new Intent(context,
FamiliarActivity.class).setAction(FamiliarActivity.ACTION_ROUND_TIMER)), pendingIntentFlags))
.build();
notification.flags |= Notification.FLAG_AUTO_CANCEL;

NotificationManagerCompat notificationManager = NotificationManagerCompat.from(context);
notificationManager.cancel(RoundTimerFragment.TIMER_NOTIFICATION_ID);
notificationManager.notify(RoundTimerFragment.TIMER_NOTIFICATION_ID, notification);
break;
case RoundTimerFragment.TIMER_2_MIN_WARNING:
VerifyPlayNotificationSoundOrTTS(context, PreferenceAdapter.getTwoMinutePref(context), PreferenceAdapter.getUseSoundInsteadOfTTSPref(context)
, PreferenceAdapter.getTimerSound(context), R.string.timer_two_minutes_left);

break;
case RoundTimerFragment.TIMER_5_MIN_WARNING:
VerifyPlayNotificationSoundOrTTS(context, PreferenceAdapter.getFiveMinutePref(context), PreferenceAdapter.getUseSoundInsteadOfTTSPref(context)
, PreferenceAdapter.getTimerSound(context), R.string.timer_five_minutes_left);
break;
case RoundTimerFragment.TIMER_10_MIN_WARNING:
VerifyPlayNotificationSoundOrTTS(context, PreferenceAdapter.getTenMinutePref(context), PreferenceAdapter.getUseSoundInsteadOfTTSPref(context)
, PreferenceAdapter.getTimerSound(context), R.string.timer_ten_minutes_left);
break;
case RoundTimerFragment.TIMER_15_MIN_WARNING:
VerifyPlayNotificationSoundOrTTS(context, PreferenceAdapter.getFifteenMinutePref(context), PreferenceAdapter.getUseSoundInsteadOfTTSPref(context)
, PreferenceAdapter.getTimerSound(context), R.string.timer_fifteen_minutes_left);
break;
case RoundTimerFragment.TIMER_EASTER_EGG:
VerifyPlayNotificationSoundOrTTS(context, PreferenceAdapter.getFifteenMinutePref(context), PreferenceAdapter.getUseSoundInsteadOfTTSPref(context)
, PreferenceAdapter.getTimerSound(context), R.string.timer_easter_egg);
break;
}
}","@Override
public void onReceive(final Context context, Intent intent) {
assert intent.getExtras() != null;
int type = intent.getExtras().getInt(RoundTimerFragment.ROUND_TIMER_INTENT);

switch (type) {
case RoundTimerFragment.TIMER_RING_ALARM:
//comment
<start>PlayNotificationSound(context, PreferenceAdapter.getTimerSound(context));<end>

//comment
NotificationHelper.createChannels(context);
NotificationCompat.Builder builder = new NotificationCompat.Builder(context, NotificationHelper.NOTIFICATION_CHANNEL_ROUND_TIMER);
int pendingIntentFlags = 0;
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
pendingIntentFlags |= PendingIntent.FLAG_MUTABLE;
}
@SuppressLint(""UnspecifiedImmutableFlag"") Notification notification = builder
.setSmallIcon(R.drawable.notification_icon)
.setWhen(System.currentTimeMillis())
.setContentTitle(context.getString(R.string.main_timer))
.setContentText(context.getString(R.string.timer_ended))
.setContentIntent(PendingIntent.getActivity(context, 7, (new Intent(context,
FamiliarActivity.class).setAction(FamiliarActivity.ACTION_ROUND_TIMER)), pendingIntentFlags))
.build();
notification.flags |= Notification.FLAG_AUTO_CANCEL;

NotificationManagerCompat notificationManager = NotificationManagerCompat.from(context);
notificationManager.cancel(RoundTimerFragment.TIMER_NOTIFICATION_ID);
notificationManager.notify(RoundTimerFragment.TIMER_NOTIFICATION_ID, notification);
break;
case RoundTimerFragment.TIMER_2_MIN_WARNING:
VerifyPlayNotificationSoundOrTTS(context, PreferenceAdapter.getTwoMinutePref(context), PreferenceAdapter.getUseSoundInsteadOfTTSPref(context)
, PreferenceAdapter.getTimerSound(context), R.string.timer_two_minutes_left);

break;
case RoundTimerFragment.TIMER_5_MIN_WARNING:
VerifyPlayNotificationSoundOrTTS(context, PreferenceAdapter.getFiveMinutePref(context), PreferenceAdapter.getUseSoundInsteadOfTTSPref(context)
, PreferenceAdapter.getTimerSound(context), R.string.timer_five_minutes_left);
break;
case RoundTimerFragment.TIMER_10_MIN_WARNING:
VerifyPlayNotificationSoundOrTTS(context, PreferenceAdapter.getTenMinutePref(context), PreferenceAdapter.getUseSoundInsteadOfTTSPref(context)
, PreferenceAdapter.getTimerSound(context), R.string.timer_ten_minutes_left);
break;
case RoundTimerFragment.TIMER_15_MIN_WARNING:
VerifyPlayNotificationSoundOrTTS(context, PreferenceAdapter.getFifteenMinutePref(context), PreferenceAdapter.getUseSoundInsteadOfTTSPref(context)
, PreferenceAdapter.getTimerSound(context), R.string.timer_fifteen_minutes_left);
break;
case RoundTimerFragment.TIMER_EASTER_EGG:
VerifyPlayNotificationSoundOrTTS(context, PreferenceAdapter.getFifteenMinutePref(context), PreferenceAdapter.getUseSoundInsteadOfTTSPref(context)
, PreferenceAdapter.getTimerSound(context), R.string.timer_easter_egg);
break;
}
}"
6125,"@Override
public void onReceive(final Context context, Intent intent) {
assert intent.getExtras() != null;
int type = intent.getExtras().getInt(RoundTimerFragment.ROUND_TIMER_INTENT);

switch (type) {
case RoundTimerFragment.TIMER_RING_ALARM:
//comment
PlayNotificationSound(context, PreferenceAdapter.getTimerSound(context));

//comment
<start>NotificationHelper.createChannels(context);
NotificationCompat.Builder builder = new NotificationCompat.Builder(context, NotificationHelper.NOTIFICATION_CHANNEL_ROUND_TIMER);<end>
int pendingIntentFlags = 0;
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
pendingIntentFlags |= PendingIntent.FLAG_MUTABLE;
}
@SuppressLint(""UnspecifiedImmutableFlag"") Notification notification = builder
.setSmallIcon(R.drawable.notification_icon)
.setWhen(System.currentTimeMillis())
.setContentTitle(context.getString(R.string.main_timer))
.setContentText(context.getString(R.string.timer_ended))
.setContentIntent(PendingIntent.getActivity(context, 7, (new Intent(context,
FamiliarActivity.class).setAction(FamiliarActivity.ACTION_ROUND_TIMER)), pendingIntentFlags))
.build();
notification.flags |= Notification.FLAG_AUTO_CANCEL;

NotificationManagerCompat notificationManager = NotificationManagerCompat.from(context);
notificationManager.cancel(RoundTimerFragment.TIMER_NOTIFICATION_ID);
notificationManager.notify(RoundTimerFragment.TIMER_NOTIFICATION_ID, notification);
break;
case RoundTimerFragment.TIMER_2_MIN_WARNING:
VerifyPlayNotificationSoundOrTTS(context, PreferenceAdapter.getTwoMinutePref(context), PreferenceAdapter.getUseSoundInsteadOfTTSPref(context)
, PreferenceAdapter.getTimerSound(context), R.string.timer_two_minutes_left);

break;
case RoundTimerFragment.TIMER_5_MIN_WARNING:
VerifyPlayNotificationSoundOrTTS(context, PreferenceAdapter.getFiveMinutePref(context), PreferenceAdapter.getUseSoundInsteadOfTTSPref(context)
, PreferenceAdapter.getTimerSound(context), R.string.timer_five_minutes_left);
break;
case RoundTimerFragment.TIMER_10_MIN_WARNING:
VerifyPlayNotificationSoundOrTTS(context, PreferenceAdapter.getTenMinutePref(context), PreferenceAdapter.getUseSoundInsteadOfTTSPref(context)
, PreferenceAdapter.getTimerSound(context), R.string.timer_ten_minutes_left);
break;
case RoundTimerFragment.TIMER_15_MIN_WARNING:
VerifyPlayNotificationSoundOrTTS(context, PreferenceAdapter.getFifteenMinutePref(context), PreferenceAdapter.getUseSoundInsteadOfTTSPref(context)
, PreferenceAdapter.getTimerSound(context), R.string.timer_fifteen_minutes_left);
break;
case RoundTimerFragment.TIMER_EASTER_EGG:
VerifyPlayNotificationSoundOrTTS(context, PreferenceAdapter.getFifteenMinutePref(context), PreferenceAdapter.getUseSoundInsteadOfTTSPref(context)
, PreferenceAdapter.getTimerSound(context), R.string.timer_easter_egg);
break;
}
}","@Override
public void onReceive(final Context context, Intent intent) {
assert intent.getExtras() != null;
int type = intent.getExtras().getInt(RoundTimerFragment.ROUND_TIMER_INTENT);

switch (type) {
case RoundTimerFragment.TIMER_RING_ALARM:
//comment
PlayNotificationSound(context, PreferenceAdapter.getTimerSound(context));

//comment
<start>NotificationHelper.createChannels(context);
NotificationCompat.Builder builder = new NotificationCompat.Builder(context, NotificationHelper.NOTIFICATION_CHANNEL_ROUND_TIMER);
int pendingIntentFlags = 0;
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
pendingIntentFlags |= PendingIntent.FLAG_MUTABLE;
}
@SuppressLint(""UnspecifiedImmutableFlag"") Notification notification = builder
.setSmallIcon(R.drawable.notification_icon)
.setWhen(System.currentTimeMillis())
.setContentTitle(context.getString(R.string.main_timer))
.setContentText(context.getString(R.string.timer_ended))
.setContentIntent(PendingIntent.getActivity(context, 7, (new Intent(context,
FamiliarActivity.class).setAction(FamiliarActivity.ACTION_ROUND_TIMER)), pendingIntentFlags))
.build();
notification.flags |= Notification.FLAG_AUTO_CANCEL;

NotificationManagerCompat notificationManager = NotificationManagerCompat.from(context);
notificationManager.cancel(RoundTimerFragment.TIMER_NOTIFICATION_ID);
notificationManager.notify(RoundTimerFragment.TIMER_NOTIFICATION_ID, notification);<end>
break;
case RoundTimerFragment.TIMER_2_MIN_WARNING:
VerifyPlayNotificationSoundOrTTS(context, PreferenceAdapter.getTwoMinutePref(context), PreferenceAdapter.getUseSoundInsteadOfTTSPref(context)
, PreferenceAdapter.getTimerSound(context), R.string.timer_two_minutes_left);

break;
case RoundTimerFragment.TIMER_5_MIN_WARNING:
VerifyPlayNotificationSoundOrTTS(context, PreferenceAdapter.getFiveMinutePref(context), PreferenceAdapter.getUseSoundInsteadOfTTSPref(context)
, PreferenceAdapter.getTimerSound(context), R.string.timer_five_minutes_left);
break;
case RoundTimerFragment.TIMER_10_MIN_WARNING:
VerifyPlayNotificationSoundOrTTS(context, PreferenceAdapter.getTenMinutePref(context), PreferenceAdapter.getUseSoundInsteadOfTTSPref(context)
, PreferenceAdapter.getTimerSound(context), R.string.timer_ten_minutes_left);
break;
case RoundTimerFragment.TIMER_15_MIN_WARNING:
VerifyPlayNotificationSoundOrTTS(context, PreferenceAdapter.getFifteenMinutePref(context), PreferenceAdapter.getUseSoundInsteadOfTTSPref(context)
, PreferenceAdapter.getTimerSound(context), R.string.timer_fifteen_minutes_left);
break;
case RoundTimerFragment.TIMER_EASTER_EGG:
VerifyPlayNotificationSoundOrTTS(context, PreferenceAdapter.getFifteenMinutePref(context), PreferenceAdapter.getUseSoundInsteadOfTTSPref(context)
, PreferenceAdapter.getTimerSound(context), R.string.timer_easter_egg);
break;
}
}"
6126,"        @Override
public void onInit(int status) {
if (status == TextToSpeech.SUCCESS) {
//comment
int result = mTts.setLanguage(getResources().getConfiguration().locale);
if (result == TextToSpeech.LANG_MISSING_DATA || result == TextToSpeech.LANG_NOT_SUPPORTED) {
//comment
PlayNotificationSound(getApplicationContext(), PreferenceAdapter.getTimerSound(getApplicationContext()));
<start>} else {
//comment
int res = mAudioManager.requestAudioFocus(this, AudioManager.STREAM_ALARM,
AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK);<end>

if (res == AudioManager.AUDIOFOCUS_REQUEST_GRANTED) {
//comment
HashMap<String, String> ttsParams = new HashMap<>();
ttsParams.put(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID, WARNING_SPEECH);
ttsParams.put(TextToSpeech.Engine.KEY_PARAM_STREAM, String.valueOf(AudioManager.STREAM_ALARM));
mTts.speak(mTextToSpeak, TextToSpeech.QUEUE_FLUSH, ttsParams);
return;
} else {
//comment
PlayNotificationSound(getApplicationContext(), PreferenceAdapter.getTimerSound(getApplicationContext()));
}
}
} else {
//comment
PlayNotificationSound(getApplicationContext(), PreferenceAdapter.getTimerSound(getApplicationContext()));
}
//comment
stopSelf();
}","        @Override
public void onInit(int status) {
if (status == TextToSpeech.SUCCESS) {
//comment
int result = mTts.setLanguage(getResources().getConfiguration().locale);
if (result == TextToSpeech.LANG_MISSING_DATA || result == TextToSpeech.LANG_NOT_SUPPORTED) {
//comment
PlayNotificationSound(getApplicationContext(), PreferenceAdapter.getTimerSound(getApplicationContext()));
} else {
//comment
<start>int res = mAudioManager.requestAudioFocus(this, AudioManager.STREAM_ALARM,
AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK);<end>

<start>if (res == AudioManager.AUDIOFOCUS_REQUEST_GRANTED) {<end>
//comment
HashMap<String, String> ttsParams = new HashMap<>();
ttsParams.put(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID, WARNING_SPEECH);
ttsParams.put(TextToSpeech.Engine.KEY_PARAM_STREAM, String.valueOf(AudioManager.STREAM_ALARM));
mTts.speak(mTextToSpeak, TextToSpeech.QUEUE_FLUSH, ttsParams);
return;
} else {
//comment
PlayNotificationSound(getApplicationContext(), PreferenceAdapter.getTimerSound(getApplicationContext()));
}
}
} else {
//comment
PlayNotificationSound(getApplicationContext(), PreferenceAdapter.getTimerSound(getApplicationContext()));
}
//comment
stopSelf();
}"
6127,"        @Override
public void onInit(int status) {
if (status == TextToSpeech.SUCCESS) {
//comment
int result = mTts.setLanguage(getResources().getConfiguration().locale);
if (result == TextToSpeech.LANG_MISSING_DATA || result == TextToSpeech.LANG_NOT_SUPPORTED) {
//comment
PlayNotificationSound(getApplicationContext(), PreferenceAdapter.getTimerSound(getApplicationContext()));
} else {
//comment
int res = mAudioManager.requestAudioFocus(this, AudioManager.STREAM_ALARM,
AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK);

if (res == AudioManager.AUDIOFOCUS_REQUEST_GRANTED) {
//comment
HashMap<String, String> ttsParams = new HashMap<>();
<start>ttsParams.put(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID, WARNING_SPEECH);
ttsParams.put(TextToSpeech.Engine.KEY_PARAM_STREAM, String.valueOf(AudioManager.STREAM_ALARM));<end>
mTts.speak(mTextToSpeak, TextToSpeech.QUEUE_FLUSH, ttsParams);
return;
<start>} else {<end>
//comment
PlayNotificationSound(getApplicationContext(), PreferenceAdapter.getTimerSound(getApplicationContext()));
}
}
} else {
//comment
PlayNotificationSound(getApplicationContext(), PreferenceAdapter.getTimerSound(getApplicationContext()));
}
//comment
stopSelf();
}","        @Override
public void onInit(int status) {
if (status == TextToSpeech.SUCCESS) {
//comment
int result = mTts.setLanguage(getResources().getConfiguration().locale);
if (result == TextToSpeech.LANG_MISSING_DATA || result == TextToSpeech.LANG_NOT_SUPPORTED) {
//comment
PlayNotificationSound(getApplicationContext(), PreferenceAdapter.getTimerSound(getApplicationContext()));
} else {
//comment
int res = mAudioManager.requestAudioFocus(this, AudioManager.STREAM_ALARM,
AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK);

if (res == AudioManager.AUDIOFOCUS_REQUEST_GRANTED) {
//comment
<start>HashMap<String, String> ttsParams = new HashMap<>();
ttsParams.put(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID, WARNING_SPEECH);
ttsParams.put(TextToSpeech.Engine.KEY_PARAM_STREAM, String.valueOf(AudioManager.STREAM_ALARM));
mTts.speak(mTextToSpeak, TextToSpeech.QUEUE_FLUSH, ttsParams);<end>
return;
} else {
//comment
PlayNotificationSound(getApplicationContext(), PreferenceAdapter.getTimerSound(getApplicationContext()));
}
}
} else {
//comment
PlayNotificationSound(getApplicationContext(), PreferenceAdapter.getTimerSound(getApplicationContext()));
}
//comment
stopSelf();
}"
6128,"        @Override
public void onInit(int status) {
if (status == TextToSpeech.SUCCESS) {
//comment
int result = mTts.setLanguage(getResources().getConfiguration().locale);
if (result == TextToSpeech.LANG_MISSING_DATA || result == TextToSpeech.LANG_NOT_SUPPORTED) {
//comment
PlayNotificationSound(getApplicationContext(), PreferenceAdapter.getTimerSound(getApplicationContext()));
} else {
//comment
int res = mAudioManager.requestAudioFocus(this, AudioManager.STREAM_ALARM,
AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK);

if (res == AudioManager.AUDIOFOCUS_REQUEST_GRANTED) {
//comment
HashMap<String, String> ttsParams = new HashMap<>();
ttsParams.put(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID, WARNING_SPEECH);
ttsParams.put(TextToSpeech.Engine.KEY_PARAM_STREAM, String.valueOf(AudioManager.STREAM_ALARM));
mTts.speak(mTextToSpeak, TextToSpeech.QUEUE_FLUSH, ttsParams);
return;
} else {
//comment
PlayNotificationSound(getApplicationContext(), PreferenceAdapter.getTimerSound(getApplicationContext()));
}
}
<start>} else {
//comment
PlayNotificationSound(getApplicationContext(), PreferenceAdapter.getTimerSound(getApplicationContext()));<end>
}
//comment
<start>stopSelf();<end>
}","        @Override
public void onInit(int status) {
if (status == TextToSpeech.SUCCESS) {
//comment
int result = mTts.setLanguage(getResources().getConfiguration().locale);
if (result == TextToSpeech.LANG_MISSING_DATA || result == TextToSpeech.LANG_NOT_SUPPORTED) {
//comment
PlayNotificationSound(getApplicationContext(), PreferenceAdapter.getTimerSound(getApplicationContext()));
} else {
//comment
int res = mAudioManager.requestAudioFocus(this, AudioManager.STREAM_ALARM,
AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK);

if (res == AudioManager.AUDIOFOCUS_REQUEST_GRANTED) {
//comment
HashMap<String, String> ttsParams = new HashMap<>();
ttsParams.put(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID, WARNING_SPEECH);
ttsParams.put(TextToSpeech.Engine.KEY_PARAM_STREAM, String.valueOf(AudioManager.STREAM_ALARM));
mTts.speak(mTextToSpeak, TextToSpeech.QUEUE_FLUSH, ttsParams);
return;
} else {
//comment
PlayNotificationSound(getApplicationContext(), PreferenceAdapter.getTimerSound(getApplicationContext()));
}
}
} else {
//comment
PlayNotificationSound(getApplicationContext(), PreferenceAdapter.getTimerSound(getApplicationContext()));
}
//comment
<start>stopSelf();<end>
}"
6129,"public static void exportData(Activity activity) {

//comment
<start>if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
SnackbarWrapper.makeAndShowText(activity, R.string.card_view_no_external_storage, SnackbarWrapper.LENGTH_LONG);
return;
}<end>

assert activity.getFilesDir() != null;

String sharedPrefsDir = activity.getFilesDir().getPath();
sharedPrefsDir = sharedPrefsDir.substring(0, sharedPrefsDir.lastIndexOf(""/"")) + ""/shared_prefs/"";

File zipOut = new File(activity.getApplicationContext().getExternalFilesDir(null), BACKUP_FILE_NAME);
if (zipOut.exists()) {
if (!zipOut.delete()) {
return;
}
}

ArrayList<File> files = findAllFiles(activity.getFilesDir(),
new File(sharedPrefsDir));

try {
zipIt(zipOut, files, activity);
SnackbarWrapper.makeAndShowText(activity, activity.getString(R.string.main_export_success) + "" "" + zipOut.getAbsolutePath(),
SnackbarWrapper.LENGTH_XLONG);
} catch (ZipException e) {
if (Objects.requireNonNull(e.getMessage()).equals(""No entries"")) {
SnackbarWrapper.makeAndShowText(activity, R.string.main_export_no_data, SnackbarWrapper.LENGTH_SHORT);
} else {
SnackbarWrapper.makeAndShowText(activity, R.string.main_export_fail, SnackbarWrapper.LENGTH_SHORT);
}
} catch (IOException e) {
SnackbarWrapper.makeAndShowText(activity, R.string.main_export_fail, SnackbarWrapper.LENGTH_SHORT);
}
}","public static void exportData(Activity activity) {

//comment
<start>if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {<end>
SnackbarWrapper.makeAndShowText(activity, R.string.card_view_no_external_storage, SnackbarWrapper.LENGTH_LONG);
return;
}

assert activity.getFilesDir() != null;

String sharedPrefsDir = activity.getFilesDir().getPath();
sharedPrefsDir = sharedPrefsDir.substring(0, sharedPrefsDir.lastIndexOf(""/"")) + ""/shared_prefs/"";

File zipOut = new File(activity.getApplicationContext().getExternalFilesDir(null), BACKUP_FILE_NAME);
if (zipOut.exists()) {
if (!zipOut.delete()) {
return;
}
}

ArrayList<File> files = findAllFiles(activity.getFilesDir(),
new File(sharedPrefsDir));

try {
zipIt(zipOut, files, activity);
SnackbarWrapper.makeAndShowText(activity, activity.getString(R.string.main_export_success) + "" "" + zipOut.getAbsolutePath(),
SnackbarWrapper.LENGTH_XLONG);
} catch (ZipException e) {
if (Objects.requireNonNull(e.getMessage()).equals(""No entries"")) {
SnackbarWrapper.makeAndShowText(activity, R.string.main_export_no_data, SnackbarWrapper.LENGTH_SHORT);
} else {
SnackbarWrapper.makeAndShowText(activity, R.string.main_export_fail, SnackbarWrapper.LENGTH_SHORT);
}
} catch (IOException e) {
SnackbarWrapper.makeAndShowText(activity, R.string.main_export_fail, SnackbarWrapper.LENGTH_SHORT);
}
}"
6130,"    public static void importData(Activity activity) {

//comment
<start>if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
SnackbarWrapper.makeAndShowText(activity, R.string.card_view_no_external_storage, SnackbarWrapper.LENGTH_LONG);
return;
}<end>

//comment
try (ZipFile zipFile = new ZipFile(new File(activity.getApplicationContext().getExternalFilesDir(null), BACKUP_FILE_NAME))) {
unZipIt(zipFile, activity);
SnackbarWrapper.makeAndShowText(activity, R.string.main_import_success, SnackbarWrapper.LENGTH_SHORT);
} catch (IOException e) {
SnackbarWrapper.makeAndShowText(activity,
String.format(activity.getString(R.string.main_import_fail),
BACKUP_FILE_NAME,
activity.getFilesDir().getAbsolutePath()),
SnackbarWrapper.LENGTH_XLONG);
}
}","    public static void importData(Activity activity) {

//comment
<start>if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {<end>
SnackbarWrapper.makeAndShowText(activity, R.string.card_view_no_external_storage, SnackbarWrapper.LENGTH_LONG);
return;
}

//comment
try (ZipFile zipFile = new ZipFile(new File(activity.getApplicationContext().getExternalFilesDir(null), BACKUP_FILE_NAME))) {
unZipIt(zipFile, activity);
SnackbarWrapper.makeAndShowText(activity, R.string.main_import_success, SnackbarWrapper.LENGTH_SHORT);
} catch (IOException e) {
SnackbarWrapper.makeAndShowText(activity,
String.format(activity.getString(R.string.main_import_fail),
BACKUP_FILE_NAME,
activity.getFilesDir().getAbsolutePath()),
SnackbarWrapper.LENGTH_XLONG);
}
}"
6131,"    public static void importData(Activity activity) {

//comment
if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
SnackbarWrapper.makeAndShowText(activity, R.string.card_view_no_external_storage, SnackbarWrapper.LENGTH_LONG);
return;
}

//comment
try (ZipFile zipFile = new ZipFile(new File(activity.getApplicationContext().getExternalFilesDir(null), BACKUP_FILE_NAME))) {
<start>unZipIt(zipFile, activity);<end>
SnackbarWrapper.makeAndShowText(activity, R.string.main_import_success, SnackbarWrapper.LENGTH_SHORT);
} catch (IOException e) {
SnackbarWrapper.makeAndShowText(activity,
String.format(activity.getString(R.string.main_import_fail),
BACKUP_FILE_NAME,
activity.getFilesDir().getAbsolutePath()),
SnackbarWrapper.LENGTH_XLONG);
}
}","    public static void importData(Activity activity) {

//comment
if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
SnackbarWrapper.makeAndShowText(activity, R.string.card_view_no_external_storage, SnackbarWrapper.LENGTH_LONG);
return;
}

//comment
<start>try (ZipFile zipFile = new ZipFile(new File(activity.getApplicationContext().getExternalFilesDir(null), BACKUP_FILE_NAME))) {<end>
unZipIt(zipFile, activity);
SnackbarWrapper.makeAndShowText(activity, R.string.main_import_success, SnackbarWrapper.LENGTH_SHORT);
} catch (IOException e) {
SnackbarWrapper.makeAndShowText(activity,
String.format(activity.getString(R.string.main_import_fail),
BACKUP_FILE_NAME,
activity.getFilesDir().getAbsolutePath()),
SnackbarWrapper.LENGTH_XLONG);
}
}"
6132,"private static void unZipItV2(ZipFile zipFile, Context context) throws IOException {
//comment
<start>String applicationPath = context.getFilesDir().getPath();<end>
applicationPath = applicationPath.substring(0, applicationPath.lastIndexOf(""/"") + 1);

//comment
Enumeration<? extends ZipEntry> entries = zipFile.entries();
while (entries.hasMoreElements()) {
ZipEntry entry = entries.nextElement();

//comment
if (entry.getName().contains(VERSION_PREFIX)) {
continue;
}

//comment
String[] path = entry.getName().split(""/"");
String pathCat = """";
if (path.length > 1) {
for (int i = 0; i < path.length - 1; i++) {
pathCat += path[i] + ""/"";
File tmp = new File(applicationPath, pathCat);
if (!tmp.exists() && !tmp.mkdir()) {
throw new IOException(""Couldn't mkdir"");
}
}
}

//comment
try (InputStream in = zipFile.getInputStream(entry);
OutputStream out = new BufferedOutputStream(new FileOutputStream(new File(applicationPath, entry.getName())))) {
IOUtils.copy(in, out);
}
}
}","private static void unZipItV2(ZipFile zipFile, Context context) throws IOException {
//comment
<start>String applicationPath = context.getFilesDir().getPath();
applicationPath = applicationPath.substring(0, applicationPath.lastIndexOf(""/"") + 1);<end>

//comment
Enumeration<? extends ZipEntry> entries = zipFile.entries();
while (entries.hasMoreElements()) {
ZipEntry entry = entries.nextElement();

//comment
if (entry.getName().contains(VERSION_PREFIX)) {
continue;
}

//comment
String[] path = entry.getName().split(""/"");
String pathCat = """";
if (path.length > 1) {
for (int i = 0; i < path.length - 1; i++) {
pathCat += path[i] + ""/"";
File tmp = new File(applicationPath, pathCat);
if (!tmp.exists() && !tmp.mkdir()) {
throw new IOException(""Couldn't mkdir"");
}
}
}

//comment
try (InputStream in = zipFile.getInputStream(entry);
OutputStream out = new BufferedOutputStream(new FileOutputStream(new File(applicationPath, entry.getName())))) {
IOUtils.copy(in, out);
}
}
}"
6133,"private static void unZipItV2(ZipFile zipFile, Context context) throws IOException {
//comment
<start>String applicationPath = context.getFilesDir().getPath();<end>
applicationPath = applicationPath.substring(0, applicationPath.lastIndexOf(""/"") + 1);

//comment
<start>Enumeration<? extends ZipEntry> entries = zipFile.entries();
while (entries.hasMoreElements()) {
ZipEntry entry = entries.nextElement();

//comment
if (entry.getName().contains(VERSION_PREFIX)) {
continue;
}

//comment
String[] path = entry.getName().split(""/"");
String pathCat = """";
if (path.length > 1) {
for (int i = 0; i < path.length - 1; i++) {
pathCat += path[i] + ""/"";
File tmp = new File(applicationPath, pathCat);
if (!tmp.exists() && !tmp.mkdir()) {
throw new IOException(""Couldn't mkdir"");
}
}
}

//comment
try (InputStream in = zipFile.getInputStream(entry);
OutputStream out = new BufferedOutputStream(new FileOutputStream(new File(applicationPath, entry.getName())))) {
IOUtils.copy(in, out);
}
}<end>
}","private static void unZipItV2(ZipFile zipFile, Context context) throws IOException {
//comment
String applicationPath = context.getFilesDir().getPath();
applicationPath = applicationPath.substring(0, applicationPath.lastIndexOf(""/"") + 1);

//comment
<start>Enumeration<? extends ZipEntry> entries = zipFile.entries();
while (entries.hasMoreElements()) {<end>
ZipEntry entry = entries.nextElement();

//comment
if (entry.getName().contains(VERSION_PREFIX)) {
continue;
}

//comment
String[] path = entry.getName().split(""/"");
String pathCat = """";
if (path.length > 1) {
for (int i = 0; i < path.length - 1; i++) {
pathCat += path[i] + ""/"";
File tmp = new File(applicationPath, pathCat);
if (!tmp.exists() && !tmp.mkdir()) {
throw new IOException(""Couldn't mkdir"");
}
}
}

//comment
try (InputStream in = zipFile.getInputStream(entry);
OutputStream out = new BufferedOutputStream(new FileOutputStream(new File(applicationPath, entry.getName())))) {
IOUtils.copy(in, out);
}
}
}"
6134,"private static void unZipItV2(ZipFile zipFile, Context context) throws IOException {
//comment
String applicationPath = context.getFilesDir().getPath();
applicationPath = applicationPath.substring(0, applicationPath.lastIndexOf(""/"") + 1);

//comment
Enumeration<? extends ZipEntry> entries = zipFile.entries();
while (entries.hasMoreElements()) {
ZipEntry entry = entries.nextElement();

//comment
if (entry.getName().contains(VERSION_PREFIX)) {
continue;
}

//comment
<start>String[] path = entry.getName().split(""/"");
String pathCat = """";<end>
if (path.length > 1) {
for (int i = 0; i < path.length - 1; i++) {
pathCat += path[i] + ""/"";
File tmp = new File(applicationPath, pathCat);
if (!tmp.exists() && !tmp.mkdir()) {
throw new IOException(""Couldn't mkdir"");
}
}
}

//comment
try (InputStream in = zipFile.getInputStream(entry);
OutputStream out = new BufferedOutputStream(new FileOutputStream(new File(applicationPath, entry.getName())))) {
IOUtils.copy(in, out);
}
}
}","private static void unZipItV2(ZipFile zipFile, Context context) throws IOException {
//comment
String applicationPath = context.getFilesDir().getPath();
applicationPath = applicationPath.substring(0, applicationPath.lastIndexOf(""/"") + 1);

//comment
Enumeration<? extends ZipEntry> entries = zipFile.entries();
while (entries.hasMoreElements()) {
ZipEntry entry = entries.nextElement();

//comment
if (entry.getName().contains(VERSION_PREFIX)) {
continue;
}

//comment
<start>String[] path = entry.getName().split(""/"");
String pathCat = """";
if (path.length > 1) {
for (int i = 0; i < path.length - 1; i++) {
pathCat += path[i] + ""/"";
File tmp = new File(applicationPath, pathCat);
if (!tmp.exists() && !tmp.mkdir()) {
throw new IOException(""Couldn't mkdir"");
}
}
}<end>

//comment
try (InputStream in = zipFile.getInputStream(entry);
OutputStream out = new BufferedOutputStream(new FileOutputStream(new File(applicationPath, entry.getName())))) {
IOUtils.copy(in, out);
}
}
}"
6135,"private static void unZipItV2(ZipFile zipFile, Context context) throws IOException {
//comment
String applicationPath = context.getFilesDir().getPath();
applicationPath = applicationPath.substring(0, applicationPath.lastIndexOf(""/"") + 1);

//comment
Enumeration<? extends ZipEntry> entries = zipFile.entries();
while (entries.hasMoreElements()) {
ZipEntry entry = entries.nextElement();

//comment
if (entry.getName().contains(VERSION_PREFIX)) {
continue;
}

//comment
String[] path = entry.getName().split(""/"");
String pathCat = """";
if (path.length > 1) {
for (int i = 0; i < path.length - 1; i++) {
pathCat += path[i] + ""/"";
File tmp = new File(applicationPath, pathCat);
if (!tmp.exists() && !tmp.mkdir()) {
throw new IOException(""Couldn't mkdir"");
}
}
}

//comment
try (InputStream in = zipFile.getInputStream(entry);
OutputStream out = new BufferedOutputStream(new FileOutputStream(new File(applicationPath, entry.getName())))) {
IOUtils.copy(in, out);
}
}
}","private static void unZipItV2(ZipFile zipFile, Context context) throws IOException {
//comment
String applicationPath = context.getFilesDir().getPath();
applicationPath = applicationPath.substring(0, applicationPath.lastIndexOf(""/"") + 1);

//comment
Enumeration<? extends ZipEntry> entries = zipFile.entries();
while (entries.hasMoreElements()) {
ZipEntry entry = entries.nextElement();

//comment
if (entry.getName().contains(VERSION_PREFIX)) {
continue;
}

//comment
String[] path = entry.getName().split(""/"");
String pathCat = """";
if (path.length > 1) {
for (int i = 0; i < path.length - 1; i++) {
pathCat += path[i] + ""/"";
File tmp = new File(applicationPath, pathCat);
if (!tmp.exists() && !tmp.mkdir()) {
throw new IOException(""Couldn't mkdir"");
}
}
}

//comment
<start>try (InputStream in = zipFile.getInputStream(entry);
OutputStream out = new BufferedOutputStream(new FileOutputStream(new File(applicationPath, entry.getName())))) {
IOUtils.copy(in, out);
}<end>
}
}"
6136,"private static void zipIt(File zipFile, ArrayList<File> files, Context context) throws IOException {
//comment
try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFile))) {
//comment
for (File file : files) {
//comment
ZipEntry ze = new ZipEntry(file.getCanonicalPath().split(context.getPackageName() + '/')[1]);
zos.putNextEntry(ze);
try (FileInputStream fis = new FileInputStream(file)) {
IOUtils.copy(fis, zos);
}
}
//comment
ZipEntry zipEntry = new ZipEntry(VERSION_PREFIX + '2');
zos.putNextEntry(zipEntry);
}
}","private static void zipIt(File zipFile, ArrayList<File> files, Context context) throws IOException {
//comment
<start>try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFile))) {<end>
//comment
for (File file : files) {
//comment
ZipEntry ze = new ZipEntry(file.getCanonicalPath().split(context.getPackageName() + '/')[1]);
zos.putNextEntry(ze);
try (FileInputStream fis = new FileInputStream(file)) {
IOUtils.copy(fis, zos);
}
}
//comment
ZipEntry zipEntry = new ZipEntry(VERSION_PREFIX + '2');
zos.putNextEntry(zipEntry);
}
}"
6137,"private static void zipIt(File zipFile, ArrayList<File> files, Context context) throws IOException {
//comment
try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFile))) {
//comment
for (File file : files) {
//comment
<start>ZipEntry ze = new ZipEntry(file.getCanonicalPath().split(context.getPackageName() + '/')[1]);<end>
zos.putNextEntry(ze);
<start>try (FileInputStream fis = new FileInputStream(file)) {
IOUtils.copy(fis, zos);
}<end>
}
//comment
ZipEntry zipEntry = new ZipEntry(VERSION_PREFIX + '2');
zos.putNextEntry(zipEntry);
}
}","private static void zipIt(File zipFile, ArrayList<File> files, Context context) throws IOException {
//comment
try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFile))) {
//comment
for (File file : files) {
//comment
<start>ZipEntry ze = new ZipEntry(file.getCanonicalPath().split(context.getPackageName() + '/')[1]);
zos.putNextEntry(ze);
try (FileInputStream fis = new FileInputStream(file)) {
IOUtils.copy(fis, zos);
}<end>
}
//comment
ZipEntry zipEntry = new ZipEntry(VERSION_PREFIX + '2');
zos.putNextEntry(zipEntry);
}
}"
6138,"private static void zipIt(File zipFile, ArrayList<File> files, Context context) throws IOException {
//comment
try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFile))) {
//comment
for (File file : files) {
//comment
ZipEntry ze = new ZipEntry(file.getCanonicalPath().split(context.getPackageName() + '/')[1]);
zos.putNextEntry(ze);
try (FileInputStream fis = new FileInputStream(file)) {
IOUtils.copy(fis, zos);
}
}
//comment
<start>ZipEntry zipEntry = new ZipEntry(VERSION_PREFIX + '2');<end>
zos.putNextEntry(zipEntry);
}
}","private static void zipIt(File zipFile, ArrayList<File> files, Context context) throws IOException {
//comment
try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFile))) {
//comment
for (File file : files) {
//comment
ZipEntry ze = new ZipEntry(file.getCanonicalPath().split(context.getPackageName() + '/')[1]);
zos.putNextEntry(ze);
try (FileInputStream fis = new FileInputStream(file)) {
IOUtils.copy(fis, zos);
}
}
//comment
<start>ZipEntry zipEntry = new ZipEntry(VERSION_PREFIX + '2');<end>
zos.putNextEntry(zipEntry);
}
}"
6139,"public static String[] getUniqueColumnArray(String table, String colKey, boolean shouldSplit,
SQLiteDatabase database) throws FamiliarDbException {
Cursor cursor = null;
try {
String query =
""SELECT "" + KEY_ID + "", "" + colKey +
"" FROM "" + table +
"" GROUP BY "" + colKey +
"" ORDER BY "" + colKey;
FamiliarLogger.logRawQuery(query, null, new Throwable().getStackTrace()[0].getMethodName());
<start>cursor = database.rawQuery(query, null);<end>

//comment
<start>if (null == cursor || cursor.getCount() == 0) {
return new String[]{};
}<end>

//comment
int colIndex = cursor.getColumnIndex(colKey);
cursor.moveToFirst();
while ("""".equals(cursor.getString(colIndex))) {
cursor.moveToNext();
}

//comment
HashSet<String> words = new HashSet<>();
while (!cursor.isAfterLast()) {
if (shouldSplit) {
Collections.addAll(words, cursor.getString(colIndex).split(""\\s+""));
} else {
words.add(cursor.getString(colIndex));
}
cursor.moveToNext();
}

//comment
String[] wordsArr = words.toArray(new String[0]);
Arrays.sort(wordsArr);
return wordsArr;

} catch (SQLiteException | IllegalStateException | NullPointerException | CursorIndexOutOfBoundsException e) {
throw new FamiliarDbException(e);
} finally {
if (cursor != null) {
cursor.close();
}
}
}","public static String[] getUniqueColumnArray(String table, String colKey, boolean shouldSplit,
SQLiteDatabase database) throws FamiliarDbException {
Cursor cursor = null;
try {
String query =
""SELECT "" + KEY_ID + "", "" + colKey +
"" FROM "" + table +
"" GROUP BY "" + colKey +
"" ORDER BY "" + colKey;
FamiliarLogger.logRawQuery(query, null, new Throwable().getStackTrace()[0].getMethodName());
cursor = database.rawQuery(query, null);

//comment
<start>if (null == cursor || cursor.getCount() == 0) {
return new String[]{};
}<end>

//comment
int colIndex = cursor.getColumnIndex(colKey);
cursor.moveToFirst();
while ("""".equals(cursor.getString(colIndex))) {
cursor.moveToNext();
}

//comment
HashSet<String> words = new HashSet<>();
while (!cursor.isAfterLast()) {
if (shouldSplit) {
Collections.addAll(words, cursor.getString(colIndex).split(""\\s+""));
} else {
words.add(cursor.getString(colIndex));
}
cursor.moveToNext();
}

//comment
String[] wordsArr = words.toArray(new String[0]);
Arrays.sort(wordsArr);
return wordsArr;

} catch (SQLiteException | IllegalStateException | NullPointerException | CursorIndexOutOfBoundsException e) {
throw new FamiliarDbException(e);
} finally {
if (cursor != null) {
cursor.close();
}
}
}"
6140,"public static String[] getUniqueColumnArray(String table, String colKey, boolean shouldSplit,
SQLiteDatabase database) throws FamiliarDbException {
Cursor cursor = null;
try {
String query =
""SELECT "" + KEY_ID + "", "" + colKey +
"" FROM "" + table +
"" GROUP BY "" + colKey +
"" ORDER BY "" + colKey;
FamiliarLogger.logRawQuery(query, null, new Throwable().getStackTrace()[0].getMethodName());
cursor = database.rawQuery(query, null);

//comment
if (null == cursor || cursor.getCount() == 0) {
return new String[]{};
}

//comment
<start>int colIndex = cursor.getColumnIndex(colKey);<end>
cursor.moveToFirst();
while ("""".equals(cursor.getString(colIndex))) {
cursor.moveToNext();
}

//comment
HashSet<String> words = new HashSet<>();
while (!cursor.isAfterLast()) {
if (shouldSplit) {
Collections.addAll(words, cursor.getString(colIndex).split(""\\s+""));
} else {
words.add(cursor.getString(colIndex));
}
cursor.moveToNext();
}

//comment
String[] wordsArr = words.toArray(new String[0]);
Arrays.sort(wordsArr);
return wordsArr;

} catch (SQLiteException | IllegalStateException | NullPointerException | CursorIndexOutOfBoundsException e) {
throw new FamiliarDbException(e);
} finally {
if (cursor != null) {
cursor.close();
}
}
}","public static String[] getUniqueColumnArray(String table, String colKey, boolean shouldSplit,
SQLiteDatabase database) throws FamiliarDbException {
Cursor cursor = null;
try {
String query =
""SELECT "" + KEY_ID + "", "" + colKey +
"" FROM "" + table +
"" GROUP BY "" + colKey +
"" ORDER BY "" + colKey;
FamiliarLogger.logRawQuery(query, null, new Throwable().getStackTrace()[0].getMethodName());
cursor = database.rawQuery(query, null);

//comment
if (null == cursor || cursor.getCount() == 0) {
return new String[]{};
}

//comment
<start>int colIndex = cursor.getColumnIndex(colKey);
cursor.moveToFirst();
while ("""".equals(cursor.getString(colIndex))) {
cursor.moveToNext();
}<end>

//comment
HashSet<String> words = new HashSet<>();
while (!cursor.isAfterLast()) {
if (shouldSplit) {
Collections.addAll(words, cursor.getString(colIndex).split(""\\s+""));
} else {
words.add(cursor.getString(colIndex));
}
cursor.moveToNext();
}

//comment
String[] wordsArr = words.toArray(new String[0]);
Arrays.sort(wordsArr);
return wordsArr;

} catch (SQLiteException | IllegalStateException | NullPointerException | CursorIndexOutOfBoundsException e) {
throw new FamiliarDbException(e);
} finally {
if (cursor != null) {
cursor.close();
}
}
}"
6141,"public static String[] getUniqueColumnArray(String table, String colKey, boolean shouldSplit,
SQLiteDatabase database) throws FamiliarDbException {
Cursor cursor = null;
try {
String query =
""SELECT "" + KEY_ID + "", "" + colKey +
"" FROM "" + table +
"" GROUP BY "" + colKey +
"" ORDER BY "" + colKey;
FamiliarLogger.logRawQuery(query, null, new Throwable().getStackTrace()[0].getMethodName());
cursor = database.rawQuery(query, null);

//comment
if (null == cursor || cursor.getCount() == 0) {
return new String[]{};
}

//comment
int colIndex = cursor.getColumnIndex(colKey);
cursor.moveToFirst();
while ("""".equals(cursor.getString(colIndex))) {
cursor.moveToNext();
}

//comment
<start>HashSet<String> words = new HashSet<>();<end>
while (!cursor.isAfterLast()) {
if (shouldSplit) {
Collections.addAll(words, cursor.getString(colIndex).split(""\\s+""));
} else {
words.add(cursor.getString(colIndex));
}
cursor.moveToNext();
}

//comment
String[] wordsArr = words.toArray(new String[0]);
Arrays.sort(wordsArr);
return wordsArr;

} catch (SQLiteException | IllegalStateException | NullPointerException | CursorIndexOutOfBoundsException e) {
throw new FamiliarDbException(e);
} finally {
if (cursor != null) {
cursor.close();
}
}
}","public static String[] getUniqueColumnArray(String table, String colKey, boolean shouldSplit,
SQLiteDatabase database) throws FamiliarDbException {
Cursor cursor = null;
try {
String query =
""SELECT "" + KEY_ID + "", "" + colKey +
"" FROM "" + table +
"" GROUP BY "" + colKey +
"" ORDER BY "" + colKey;
FamiliarLogger.logRawQuery(query, null, new Throwable().getStackTrace()[0].getMethodName());
cursor = database.rawQuery(query, null);

//comment
if (null == cursor || cursor.getCount() == 0) {
return new String[]{};
}

//comment
int colIndex = cursor.getColumnIndex(colKey);
cursor.moveToFirst();
while ("""".equals(cursor.getString(colIndex))) {
cursor.moveToNext();
}

//comment
<start>HashSet<String> words = new HashSet<>();
while (!cursor.isAfterLast()) {
if (shouldSplit) {
Collections.addAll(words, cursor.getString(colIndex).split(""\\s+""));
} else {
words.add(cursor.getString(colIndex));
}
cursor.moveToNext();
}<end>

//comment
String[] wordsArr = words.toArray(new String[0]);
Arrays.sort(wordsArr);
return wordsArr;

} catch (SQLiteException | IllegalStateException | NullPointerException | CursorIndexOutOfBoundsException e) {
throw new FamiliarDbException(e);
} finally {
if (cursor != null) {
cursor.close();
}
}
}"
6142,"public static String[] getUniqueColumnArray(String table, String colKey, boolean shouldSplit,
SQLiteDatabase database) throws FamiliarDbException {
Cursor cursor = null;
try {
String query =
""SELECT "" + KEY_ID + "", "" + colKey +
"" FROM "" + table +
"" GROUP BY "" + colKey +
"" ORDER BY "" + colKey;
FamiliarLogger.logRawQuery(query, null, new Throwable().getStackTrace()[0].getMethodName());
cursor = database.rawQuery(query, null);

//comment
if (null == cursor || cursor.getCount() == 0) {
return new String[]{};
}

//comment
int colIndex = cursor.getColumnIndex(colKey);
cursor.moveToFirst();
while ("""".equals(cursor.getString(colIndex))) {
cursor.moveToNext();
}

//comment
HashSet<String> words = new HashSet<>();
while (!cursor.isAfterLast()) {
if (shouldSplit) {
Collections.addAll(words, cursor.getString(colIndex).split(""\\s+""));
} else {
words.add(cursor.getString(colIndex));
}
cursor.moveToNext();
}

//comment
<start>String[] wordsArr = words.toArray(new String[0]);
Arrays.sort(wordsArr);<end>
return wordsArr;

} catch (SQLiteException | IllegalStateException | NullPointerException | CursorIndexOutOfBoundsException e) {
throw new FamiliarDbException(e);
} finally {
if (cursor != null) {
cursor.close();
}
}
}","public static String[] getUniqueColumnArray(String table, String colKey, boolean shouldSplit,
SQLiteDatabase database) throws FamiliarDbException {
Cursor cursor = null;
try {
String query =
""SELECT "" + KEY_ID + "", "" + colKey +
"" FROM "" + table +
"" GROUP BY "" + colKey +
"" ORDER BY "" + colKey;
FamiliarLogger.logRawQuery(query, null, new Throwable().getStackTrace()[0].getMethodName());
cursor = database.rawQuery(query, null);

//comment
if (null == cursor || cursor.getCount() == 0) {
return new String[]{};
}

//comment
int colIndex = cursor.getColumnIndex(colKey);
cursor.moveToFirst();
while ("""".equals(cursor.getString(colIndex))) {
cursor.moveToNext();
}

//comment
HashSet<String> words = new HashSet<>();
while (!cursor.isAfterLast()) {
if (shouldSplit) {
Collections.addAll(words, cursor.getString(colIndex).split(""\\s+""));
} else {
words.add(cursor.getString(colIndex));
}
cursor.moveToNext();
}

//comment
<start>String[] wordsArr = words.toArray(new String[0]);
Arrays.sort(wordsArr);<end>
return wordsArr;

} catch (SQLiteException | IllegalStateException | NullPointerException | CursorIndexOutOfBoundsException e) {
throw new FamiliarDbException(e);
} finally {
if (cursor != null) {
cursor.close();
}
}
}"
6143,"public static Cursor fetchCardByName(String name, List<String> fields, boolean shouldGroup,
boolean offlineOnly, boolean preferOptionalFoil, SQLiteDatabase mDb)
throws FamiliarDbException {
try {
//comment
name = sanitizeString(name, true);
<start>StringBuilder sql = new StringBuilder(""SELECT "");<end>
boolean first = true;
for (String field : fields) {
if (first) {
first = false;
} else {
sql.append("", "");
}
sql.append(field);
}
sql.append("" FROM "" + DATABASE_TABLE_CARDS +
"" JOIN "" + DATABASE_TABLE_SETS + "" ON "" + DATABASE_TABLE_SETS + ""."" + KEY_CODE + "" = "" + DATABASE_TABLE_CARDS + ""."" + KEY_SET +
"" WHERE "" + DATABASE_TABLE_CARDS + ""."" + KEY_NAME_NO_ACCENT + "" = "").append(name);
if (offlineOnly) {
sql.append("" AND "" + KEY_ONLINE_ONLY + "" = 0"");
}
sql.append("" COLLATE NOCASE"");
if (shouldGroup) {
sql.append("" GROUP BY "" + DATABASE_TABLE_SETS + ""."" + KEY_CODE);
}
if (preferOptionalFoil) {
sql.append("" ORDER BY "" + DATABASE_TABLE_SETS + ""."" + KEY_CAN_BE_FOIL + "" DESC, "" + DATABASE_TABLE_SETS + ""."" + KEY_DATE + "" DESC"");
} else {
sql.append("" ORDER BY "" + DATABASE_TABLE_SETS + ""."" + KEY_DATE + "" DESC"");
}

if (fields.contains(CardDbAdapter.DATABASE_TABLE_CARDS + ""."" + CardDbAdapter.KEY_NUMBER)) {
sql.append("", "").append(CardDbAdapter.DATABASE_TABLE_CARDS).append(""."").append(CardDbAdapter.KEY_NUMBER).append("" ASC"");
}

FamiliarLogger.logRawQuery(sql.toString(), null, new Throwable().getStackTrace()[0].getMethodName());
Cursor c = mDb.rawQuery(sql.toString(), null);
if (c != null) {
c.moveToFirst();
}
return c;
} catch (SQLiteException | CursorIndexOutOfBoundsException | IllegalStateException e) {
throw new FamiliarDbException(e);
}
}","public static Cursor fetchCardByName(String name, List<String> fields, boolean shouldGroup,
boolean offlineOnly, boolean preferOptionalFoil, SQLiteDatabase mDb)
throws FamiliarDbException {
try {
//comment
<start>name = sanitizeString(name, true);<end>
StringBuilder sql = new StringBuilder(""SELECT "");
boolean first = true;
for (String field : fields) {
if (first) {
first = false;
} else {
sql.append("", "");
}
sql.append(field);
}
sql.append("" FROM "" + DATABASE_TABLE_CARDS +
"" JOIN "" + DATABASE_TABLE_SETS + "" ON "" + DATABASE_TABLE_SETS + ""."" + KEY_CODE + "" = "" + DATABASE_TABLE_CARDS + ""."" + KEY_SET +
"" WHERE "" + DATABASE_TABLE_CARDS + ""."" + KEY_NAME_NO_ACCENT + "" = "").append(name);
if (offlineOnly) {
sql.append("" AND "" + KEY_ONLINE_ONLY + "" = 0"");
}
sql.append("" COLLATE NOCASE"");
if (shouldGroup) {
sql.append("" GROUP BY "" + DATABASE_TABLE_SETS + ""."" + KEY_CODE);
}
if (preferOptionalFoil) {
sql.append("" ORDER BY "" + DATABASE_TABLE_SETS + ""."" + KEY_CAN_BE_FOIL + "" DESC, "" + DATABASE_TABLE_SETS + ""."" + KEY_DATE + "" DESC"");
} else {
sql.append("" ORDER BY "" + DATABASE_TABLE_SETS + ""."" + KEY_DATE + "" DESC"");
}

if (fields.contains(CardDbAdapter.DATABASE_TABLE_CARDS + ""."" + CardDbAdapter.KEY_NUMBER)) {
sql.append("", "").append(CardDbAdapter.DATABASE_TABLE_CARDS).append(""."").append(CardDbAdapter.KEY_NUMBER).append("" ASC"");
}

FamiliarLogger.logRawQuery(sql.toString(), null, new Throwable().getStackTrace()[0].getMethodName());
Cursor c = mDb.rawQuery(sql.toString(), null);
if (c != null) {
c.moveToFirst();
}
return c;
} catch (SQLiteException | CursorIndexOutOfBoundsException | IllegalStateException e) {
throw new FamiliarDbException(e);
}
}"
6144,"public static Cursor fetchCardByNameAndSet(String name, String setCode, String cardNumber, List<String> fields,
SQLiteDatabase mDb)
throws FamiliarDbException {
try {
//comment
name = sanitizeString(name, true);
setCode = sanitizeString(setCode, false);

StringBuilder sql = new StringBuilder(""SELECT "");
boolean first = true;
for (String field : fields) {
if (first) {
first = false;
} else {
sql.append("", "");
}
sql.append(field);
}

sql.append("" FROM "" + DATABASE_TABLE_CARDS +
"" JOIN "" + DATABASE_TABLE_SETS + "" ON "" + DATABASE_TABLE_SETS + ""."" + KEY_CODE + "" = "" + DATABASE_TABLE_CARDS + ""."" + KEY_SET +
"" WHERE "" + DATABASE_TABLE_CARDS + ""."" + KEY_NAME_NO_ACCENT + "" = "").append(name).append("" COLLATE NOCASE"")
.append("" AND "")
.append(DATABASE_TABLE_CARDS).append(""."").append(KEY_SET).append("" = "").append(setCode);
if (null != cardNumber && !cardNumber.isEmpty()) {
sql.append("" AND "").append(DATABASE_TABLE_CARDS).append(""."").append(KEY_NUMBER).append("" = "").append(sanitizeString(cardNumber, false));
}
sql.append("" ORDER BY "").append(DATABASE_TABLE_SETS).append(""."").append(KEY_DATE).append("" DESC"");

FamiliarLogger.logRawQuery(sql.toString(), null, new Throwable().getStackTrace()[0].getMethodName());
Cursor c = mDb.rawQuery(sql.toString(), null);
if (c != null) {
c.moveToFirst();
}
return c;
} catch (SQLiteException | CursorIndexOutOfBoundsException | IllegalStateException e) {
throw new FamiliarDbException(e);
}
}","public static Cursor fetchCardByNameAndSet(String name, String setCode, String cardNumber, List<String> fields,
SQLiteDatabase mDb)
throws FamiliarDbException {
try {
//comment
<start>name = sanitizeString(name, true);<end>
setCode = sanitizeString(setCode, false);

StringBuilder sql = new StringBuilder(""SELECT "");
boolean first = true;
for (String field : fields) {
if (first) {
first = false;
} else {
sql.append("", "");
}
sql.append(field);
}

sql.append("" FROM "" + DATABASE_TABLE_CARDS +
"" JOIN "" + DATABASE_TABLE_SETS + "" ON "" + DATABASE_TABLE_SETS + ""."" + KEY_CODE + "" = "" + DATABASE_TABLE_CARDS + ""."" + KEY_SET +
"" WHERE "" + DATABASE_TABLE_CARDS + ""."" + KEY_NAME_NO_ACCENT + "" = "").append(name).append("" COLLATE NOCASE"")
.append("" AND "")
.append(DATABASE_TABLE_CARDS).append(""."").append(KEY_SET).append("" = "").append(setCode);
if (null != cardNumber && !cardNumber.isEmpty()) {
sql.append("" AND "").append(DATABASE_TABLE_CARDS).append(""."").append(KEY_NUMBER).append("" = "").append(sanitizeString(cardNumber, false));
}
sql.append("" ORDER BY "").append(DATABASE_TABLE_SETS).append(""."").append(KEY_DATE).append("" DESC"");

FamiliarLogger.logRawQuery(sql.toString(), null, new Throwable().getStackTrace()[0].getMethodName());
Cursor c = mDb.rawQuery(sql.toString(), null);
if (c != null) {
c.moveToFirst();
}
return c;
} catch (SQLiteException | CursorIndexOutOfBoundsException | IllegalStateException e) {
throw new FamiliarDbException(e);
}
}"
6152,"public static int getEquivalentMultiverseId(String mName, SQLiteDatabase mDb) throws FamiliarDbException {
//comment
<start>String statement = ""SELECT "" + KEY_MULTIVERSEID + "", "" + KEY_DATE +
"" FROM ("" + DATABASE_TABLE_CARDS + "" JOIN "" + DATABASE_TABLE_SETS + "" ON "" + DATABASE_TABLE_SETS + ""."" + KEY_CODE + "" = "" + DATABASE_TABLE_CARDS + ""."" + KEY_SET + "")"" +
"" WHERE ("" + DATABASE_TABLE_CARDS + ""."" + KEY_NAME + "" = "" + sanitizeString(mName, false) + "")"" +
"" ORDER BY "" + KEY_DATE + "" DESC"";<end>

//comment
try (Cursor c = mDb.rawQuery(statement, null)) {
c.moveToFirst();
while (!c.isAfterLast()) {
int multiverseId = CardDbAdapter.getIntFromCursor(c, KEY_MULTIVERSEID);
if (multiverseId > 0) {
return multiverseId;
}
c.moveToNext();
}
return 0;
} catch (SQLiteException | CursorIndexOutOfBoundsException | IllegalStateException e) {
throw new FamiliarDbException(e);
}
}","public static int getEquivalentMultiverseId(String mName, SQLiteDatabase mDb) throws FamiliarDbException {
//comment
<start>String statement = ""SELECT "" + KEY_MULTIVERSEID + "", "" + KEY_DATE +
"" FROM ("" + DATABASE_TABLE_CARDS + "" JOIN "" + DATABASE_TABLE_SETS + "" ON "" + DATABASE_TABLE_SETS + ""."" + KEY_CODE + "" = "" + DATABASE_TABLE_CARDS + ""."" + KEY_SET + "")"" +
"" WHERE ("" + DATABASE_TABLE_CARDS + ""."" + KEY_NAME + "" = "" + sanitizeString(mName, false) + "")"" +
"" ORDER BY "" + KEY_DATE + "" DESC"";<end>

//comment
try (Cursor c = mDb.rawQuery(statement, null)) {
c.moveToFirst();
while (!c.isAfterLast()) {
int multiverseId = CardDbAdapter.getIntFromCursor(c, KEY_MULTIVERSEID);
if (multiverseId > 0) {
return multiverseId;
}
c.moveToNext();
}
return 0;
} catch (SQLiteException | CursorIndexOutOfBoundsException | IllegalStateException e) {
throw new FamiliarDbException(e);
}
}"
621,"synchronized SQLiteDatabase openDatabase(@NonNull FamiliarDbHandle handle) throws FamiliarDbException {
//comment
if (mOpenHandles.isEmpty()) {
//comment
handle.setInfo(1, mTransactional);
<start>} else {<end>
//comment
handle.setInfo(mOpenHandles.get(mOpenHandles.size() - 1).getHandle() + 1, mTransactional);
}

try {
//comment
if (mOpenHandles.isEmpty()) {
//comment
if (mTransactional) {
mDatabase = mDatabaseHelper.getWritableDatabase();
if (mDatabase != null) {
mDatabase.execSQL(""BEGIN EXCLUSIVE TRANSACTION"");
}
} else {
mDatabase = mDatabaseHelper.getReadableDatabase();
}
}
//comment
mOpenHandles.add(handle);
return mDatabase;
} catch (SQLiteException e) {
throw new FamiliarDbException(e);
}
}","synchronized SQLiteDatabase openDatabase(@NonNull FamiliarDbHandle handle) throws FamiliarDbException {
//comment
<start>if (mOpenHandles.isEmpty()) {<end>
//comment
handle.setInfo(1, mTransactional);
} else {
//comment
handle.setInfo(mOpenHandles.get(mOpenHandles.size() - 1).getHandle() + 1, mTransactional);
}

try {
//comment
if (mOpenHandles.isEmpty()) {
//comment
if (mTransactional) {
mDatabase = mDatabaseHelper.getWritableDatabase();
if (mDatabase != null) {
mDatabase.execSQL(""BEGIN EXCLUSIVE TRANSACTION"");
}
} else {
mDatabase = mDatabaseHelper.getReadableDatabase();
}
}
//comment
mOpenHandles.add(handle);
return mDatabase;
} catch (SQLiteException e) {
throw new FamiliarDbException(e);
}
}"
622,"synchronized SQLiteDatabase openDatabase(@NonNull FamiliarDbHandle handle) throws FamiliarDbException {
//comment
if (mOpenHandles.isEmpty()) {
//comment
handle.setInfo(1, mTransactional);
} else {
//comment
handle.setInfo(mOpenHandles.get(mOpenHandles.size() - 1).getHandle() + 1, mTransactional);
}

try {
//comment
if (mOpenHandles.isEmpty()) {
//comment
if (mTransactional) {
mDatabase = mDatabaseHelper.getWritableDatabase();
if (mDatabase != null) {
mDatabase.execSQL(""BEGIN EXCLUSIVE TRANSACTION"");
}
} else {
mDatabase = mDatabaseHelper.getReadableDatabase();
}
}
//comment
mOpenHandles.add(handle);
return mDatabase;
} catch (SQLiteException e) {
throw new FamiliarDbException(e);
}
}","synchronized SQLiteDatabase openDatabase(@NonNull FamiliarDbHandle handle) throws FamiliarDbException {
//comment
if (mOpenHandles.isEmpty()) {
//comment
handle.setInfo(1, mTransactional);
} else {
//comment
handle.setInfo(mOpenHandles.get(mOpenHandles.size() - 1).getHandle() + 1, mTransactional);
}

try {
//comment
<start>if (mOpenHandles.isEmpty()) {
//comment
if (mTransactional) {
mDatabase = mDatabaseHelper.getWritableDatabase();
if (mDatabase != null) {
mDatabase.execSQL(""BEGIN EXCLUSIVE TRANSACTION"");
}
} else {
mDatabase = mDatabaseHelper.getReadableDatabase();
}
}<end>
//comment
mOpenHandles.add(handle);
return mDatabase;
} catch (SQLiteException e) {
throw new FamiliarDbException(e);
}
}"
623,"synchronized SQLiteDatabase openDatabase(@NonNull FamiliarDbHandle handle) throws FamiliarDbException {
//comment
if (mOpenHandles.isEmpty()) {
//comment
handle.setInfo(1, mTransactional);
} else {
//comment
handle.setInfo(mOpenHandles.get(mOpenHandles.size() - 1).getHandle() + 1, mTransactional);
}

try {
//comment
if (mOpenHandles.isEmpty()) {
//comment
if (mTransactional) {
mDatabase = mDatabaseHelper.getWritableDatabase();
<start>if (mDatabase != null) {
mDatabase.execSQL(""BEGIN EXCLUSIVE TRANSACTION"");
}<end>
} else {
mDatabase = mDatabaseHelper.getReadableDatabase();
}
}
//comment
mOpenHandles.add(handle);
return mDatabase;
} catch (SQLiteException e) {
throw new FamiliarDbException(e);
}
}","synchronized SQLiteDatabase openDatabase(@NonNull FamiliarDbHandle handle) throws FamiliarDbException {
//comment
if (mOpenHandles.isEmpty()) {
//comment
handle.setInfo(1, mTransactional);
} else {
//comment
handle.setInfo(mOpenHandles.get(mOpenHandles.size() - 1).getHandle() + 1, mTransactional);
}

try {
//comment
if (mOpenHandles.isEmpty()) {
//comment
<start>if (mTransactional) {
mDatabase = mDatabaseHelper.getWritableDatabase();
if (mDatabase != null) {
mDatabase.execSQL(""BEGIN EXCLUSIVE TRANSACTION"");
}
} else {
mDatabase = mDatabaseHelper.getReadableDatabase();
}<end>
}
//comment
mOpenHandles.add(handle);
return mDatabase;
} catch (SQLiteException e) {
throw new FamiliarDbException(e);
}
}"
624,"        synchronized void closeDatabase(@NonNull FamiliarDbHandle handle) {
//comment
if (mOpenHandles.contains(handle)) {
//comment
<start>mOpenHandles.remove(handle);<end>
//comment
if (mOpenHandles.isEmpty()) {
if (mTransactional) {
mDatabase.execSQL(""COMMIT"");
}
<start>mDatabase.close();<end>
}
}
}","        synchronized void closeDatabase(@NonNull FamiliarDbHandle handle) {
//comment
if (mOpenHandles.contains(handle)) {
//comment
<start>mOpenHandles.remove(handle);<end>
//comment
if (mOpenHandles.isEmpty()) {
if (mTransactional) {
mDatabase.execSQL(""COMMIT"");
}
mDatabase.close();
}
}
}"
625,"        synchronized void closeDatabase(@NonNull FamiliarDbHandle handle) {
//comment
if (mOpenHandles.contains(handle)) {
//comment
<start>mOpenHandles.remove(handle);<end>
//comment
if (mOpenHandles.isEmpty()) {
<start>if (mTransactional) {
mDatabase.execSQL(""COMMIT"");
}
mDatabase.close();<end>
}
}
}","        synchronized void closeDatabase(@NonNull FamiliarDbHandle handle) {
//comment
if (mOpenHandles.contains(handle)) {
//comment
mOpenHandles.remove(handle);
//comment
<start>if (mOpenHandles.isEmpty()) {
if (mTransactional) {
mDatabase.execSQL(""COMMIT"");
}
mDatabase.close();
}<end>
}
}"
6163,"public AccessToken getAccessToken(String publicKey, String privateKey, String accessToken)
throws IOException {

//comment
if (null == mAccessToken) {
//comment
HttpURLConnection conn = (HttpURLConnection)
new URL(""https://api.tcgplayer.com/token"").openConnection();
setDefaultOptions(conn, HttpMethod.POST);

//comment
conn.setRequestProperty(""Content-Type"", ""application/json"");
conn.setRequestProperty(""Accept"", ""application/json"");
conn.setRequestProperty(""X-Tcg-Access-Token"", accessToken);

//comment
String payload = ""grant_type=client_credentials&client_id="" + publicKey +
""&client_secret="" + privateKey;
conn.getOutputStream().write(payload.getBytes(StandardCharsets.UTF_8));

//comment
InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
return new AccessToken();
}
}

//comment
GsonBuilder builder = new GsonBuilder();
AccessToken.setDateFormat(builder);
AccessToken token = builder.create()
.fromJson(new InputStreamReader(inStream), AccessToken.class);
this.mAccessToken = token.access_token;

//comment
inStream.close();
conn.disconnect();

return token;
}

//comment
<start>return null;<end>
}","public AccessToken getAccessToken(String publicKey, String privateKey, String accessToken)
throws IOException {

//comment
if (null == mAccessToken) {
//comment
HttpURLConnection conn = (HttpURLConnection)
new URL(""https://api.tcgplayer.com/token"").openConnection();
setDefaultOptions(conn, HttpMethod.POST);

//comment
conn.setRequestProperty(""Content-Type"", ""application/json"");
conn.setRequestProperty(""Accept"", ""application/json"");
conn.setRequestProperty(""X-Tcg-Access-Token"", accessToken);

//comment
String payload = ""grant_type=client_credentials&client_id="" + publicKey +
""&client_secret="" + privateKey;
conn.getOutputStream().write(payload.getBytes(StandardCharsets.UTF_8));

//comment
InputStream inStream;
try {
inStream = conn.getInputStream();
} catch (FileNotFoundException e) {
inStream = conn.getErrorStream();
if (null == inStream) {
conn.disconnect();
//comment
return new AccessToken();
}
}

//comment
GsonBuilder builder = new GsonBuilder();
AccessToken.setDateFormat(builder);
AccessToken token = builder.create()
.fromJson(new InputStreamReader(inStream), AccessToken.class);
this.mAccessToken = token.access_token;

//comment
inStream.close();
conn.disconnect();

<start>return token;<end>
}

//comment
return null;
}"
6178,"@Override
public void onStop() {
super.onStop();

//comment
//comment
<start>Bundle args = new Bundle();
if (mActivity != null) {
mActivity.setFragmentResult(args);
}<end>
}","@Override
public void onStop() {
super.onStop();

//comment
//comment
<start>Bundle args = new Bundle();
if (mActivity != null) {
mActivity.setFragmentResult(args);
}<end>
}"
6179,"<start>    private void releaseImageResources(boolean isSplit) {<end>

//comment
<start>if (null != mGlideRequestManager && null != mGlideTarget) {
mGlideRequestManager.clear(mGlideTarget);
}<end>

//comment
if (mCardImageView != null) {
mCardImageView.setImageDrawable(null);
mCardImageView.setImageBitmap(null);
}

//comment
if (!isSplit) {
mNameTextView = null;
mCostTextView = null;
mTypeTextView = null;
mSetTextView = null;
mAbilityTextView = null;
mFlavorTextView = null;
mArtistTextView = null;
mNumberTextView = null;
mPowTouTextView = null;
mTransformButtonDivider = null;
mTransformButton = null;
mCardTextLinearLayout = null;
mCardImageView = null;
mColorIndicatorLayout = null;
}

mDrawableForDialog = null;
}","    private void releaseImageResources(boolean isSplit) {

//comment
<start>if (null != mGlideRequestManager && null != mGlideTarget) {
mGlideRequestManager.clear(mGlideTarget);
}<end>

//comment
if (mCardImageView != null) {
mCardImageView.setImageDrawable(null);
mCardImageView.setImageBitmap(null);
}

//comment
if (!isSplit) {
mNameTextView = null;
mCostTextView = null;
mTypeTextView = null;
mSetTextView = null;
mAbilityTextView = null;
mFlavorTextView = null;
mArtistTextView = null;
mNumberTextView = null;
mPowTouTextView = null;
mTransformButtonDivider = null;
mTransformButton = null;
mCardTextLinearLayout = null;
mCardImageView = null;
mColorIndicatorLayout = null;
}

mDrawableForDialog = null;
}"
6180,"    private void releaseImageResources(boolean isSplit) {

//comment
if (null != mGlideRequestManager && null != mGlideTarget) {
mGlideRequestManager.clear(mGlideTarget);
}

//comment
if (mCardImageView != null) {
mCardImageView.setImageDrawable(null);
mCardImageView.setImageBitmap(null);
}

//comment
if (!isSplit) {
mNameTextView = null;
mCostTextView = null;
mTypeTextView = null;
mSetTextView = null;
mAbilityTextView = null;
mFlavorTextView = null;
mArtistTextView = null;
mNumberTextView = null;
mPowTouTextView = null;
mTransformButtonDivider = null;
mTransformButton = null;
mCardTextLinearLayout = null;
mCardImageView = null;
mColorIndicatorLayout = null;
}

mDrawableForDialog = null;
}","    private void releaseImageResources(boolean isSplit) {

//comment
if (null != mGlideRequestManager && null != mGlideTarget) {
mGlideRequestManager.clear(mGlideTarget);
}

//comment
<start>if (mCardImageView != null) {
mCardImageView.setImageDrawable(null);
mCardImageView.setImageBitmap(null);
}<end>

//comment
if (!isSplit) {
mNameTextView = null;
mCostTextView = null;
mTypeTextView = null;
mSetTextView = null;
mAbilityTextView = null;
mFlavorTextView = null;
mArtistTextView = null;
mNumberTextView = null;
mPowTouTextView = null;
mTransformButtonDivider = null;
mTransformButton = null;
mCardTextLinearLayout = null;
mCardImageView = null;
mColorIndicatorLayout = null;
}

mDrawableForDialog = null;
}"
6181,"    private void releaseImageResources(boolean isSplit) {

//comment
if (null != mGlideRequestManager && null != mGlideTarget) {
mGlideRequestManager.clear(mGlideTarget);
}

//comment
if (mCardImageView != null) {
mCardImageView.setImageDrawable(null);
mCardImageView.setImageBitmap(null);
}

//comment
if (!isSplit) {
<start>mNameTextView = null;<end>
mCostTextView = null;
mTypeTextView = null;
mSetTextView = null;
mAbilityTextView = null;
mFlavorTextView = null;
mArtistTextView = null;
mNumberTextView = null;
mPowTouTextView = null;
mTransformButtonDivider = null;
mTransformButton = null;
mCardTextLinearLayout = null;
mCardImageView = null;
mColorIndicatorLayout = null;
}

mDrawableForDialog = null;
}","    private void releaseImageResources(boolean isSplit) {

//comment
if (null != mGlideRequestManager && null != mGlideTarget) {
mGlideRequestManager.clear(mGlideTarget);
}

//comment
if (mCardImageView != null) {
mCardImageView.setImageDrawable(null);
mCardImageView.setImageBitmap(null);
}

//comment
<start>if (!isSplit) {
mNameTextView = null;
mCostTextView = null;
mTypeTextView = null;
mSetTextView = null;
mAbilityTextView = null;
mFlavorTextView = null;
mArtistTextView = null;
mNumberTextView = null;
mPowTouTextView = null;
mTransformButtonDivider = null;
mTransformButton = null;
mCardTextLinearLayout = null;
mCardImageView = null;
mColorIndicatorLayout = null;
}<end>

mDrawableForDialog = null;
}"
6188,"<start>public void saveImageWithGlide(int whereTo) {<end>

//comment
<start>if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_no_external_storage, SnackbarWrapper.LENGTH_SHORT);
return;
}<end>

//comment
if (ContextCompat.checkSelfPermission(CardViewFragment.this.mActivity,
Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
//comment
ActivityCompat.requestPermissions(CardViewFragment.this.mActivity,
new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},
FamiliarActivity.REQUEST_WRITE_EXTERNAL_STORAGE_IMAGE);
//comment
mSaveImageWhereTo = whereTo;
return;
}

//comment
MediaStoreInfo msi = getMediaStoreInfo();

//comment
if (null != msi) {
if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(MediaStore.Images.Media.getContentUri(""external"") + ""/"" + msi.getId()));
} else {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
}
} else {
runGlideTarget(new FamiliarGlideTarget(this, new FamiliarGlideTarget.DrawableLoadedCallback() {
//comment
//comment
//comment
//comment
//comment
//comment
@Override
protected void onDrawableLoaded(Drawable resource) {
try {
if (resource instanceof BitmapDrawable) {
//comment
String url = MediaStore.Images.Media.insertImage(
getContext().getContentResolver(),
((BitmapDrawable) resource).getBitmap(),
getSavedFileName(), mCard.getName() + "" - "" + mCard.getSetName());

//comment
if (null == url) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
} else {
//comment
getFamiliarActivity().sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.parse(url)));

//comment
if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(url));
} else {
//comment
MediaStoreInfo msi = getMediaStoreInfo();
if (null != msi) {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
} else {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + url, SnackbarWrapper.LENGTH_LONG);
}
}
}
}
} catch (Exception e) {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
}
}
}), 0, 0);
}
}","public void saveImageWithGlide(int whereTo) {

//comment
<start>if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {<end>
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_no_external_storage, SnackbarWrapper.LENGTH_SHORT);
return;
}

//comment
if (ContextCompat.checkSelfPermission(CardViewFragment.this.mActivity,
Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
//comment
ActivityCompat.requestPermissions(CardViewFragment.this.mActivity,
new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},
FamiliarActivity.REQUEST_WRITE_EXTERNAL_STORAGE_IMAGE);
//comment
mSaveImageWhereTo = whereTo;
return;
}

//comment
MediaStoreInfo msi = getMediaStoreInfo();

//comment
if (null != msi) {
if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(MediaStore.Images.Media.getContentUri(""external"") + ""/"" + msi.getId()));
} else {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
}
} else {
runGlideTarget(new FamiliarGlideTarget(this, new FamiliarGlideTarget.DrawableLoadedCallback() {
//comment
//comment
//comment
//comment
//comment
//comment
@Override
protected void onDrawableLoaded(Drawable resource) {
try {
if (resource instanceof BitmapDrawable) {
//comment
String url = MediaStore.Images.Media.insertImage(
getContext().getContentResolver(),
((BitmapDrawable) resource).getBitmap(),
getSavedFileName(), mCard.getName() + "" - "" + mCard.getSetName());

//comment
if (null == url) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
} else {
//comment
getFamiliarActivity().sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.parse(url)));

//comment
if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(url));
} else {
//comment
MediaStoreInfo msi = getMediaStoreInfo();
if (null != msi) {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
} else {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + url, SnackbarWrapper.LENGTH_LONG);
}
}
}
}
} catch (Exception e) {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
}
}
}), 0, 0);
}
}"
6189,"public void saveImageWithGlide(int whereTo) {

//comment
if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_no_external_storage, SnackbarWrapper.LENGTH_SHORT);
return;
}

//comment
if (ContextCompat.checkSelfPermission(CardViewFragment.this.mActivity,
<start>Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {<end>
//comment
ActivityCompat.requestPermissions(CardViewFragment.this.mActivity,
new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},
FamiliarActivity.REQUEST_WRITE_EXTERNAL_STORAGE_IMAGE);
//comment
mSaveImageWhereTo = whereTo;
return;
}

//comment
MediaStoreInfo msi = getMediaStoreInfo();

//comment
if (null != msi) {
if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(MediaStore.Images.Media.getContentUri(""external"") + ""/"" + msi.getId()));
} else {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
}
} else {
runGlideTarget(new FamiliarGlideTarget(this, new FamiliarGlideTarget.DrawableLoadedCallback() {
//comment
//comment
//comment
//comment
//comment
//comment
@Override
protected void onDrawableLoaded(Drawable resource) {
try {
if (resource instanceof BitmapDrawable) {
//comment
String url = MediaStore.Images.Media.insertImage(
getContext().getContentResolver(),
((BitmapDrawable) resource).getBitmap(),
getSavedFileName(), mCard.getName() + "" - "" + mCard.getSetName());

//comment
if (null == url) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
} else {
//comment
getFamiliarActivity().sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.parse(url)));

//comment
if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(url));
} else {
//comment
MediaStoreInfo msi = getMediaStoreInfo();
if (null != msi) {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
} else {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + url, SnackbarWrapper.LENGTH_LONG);
}
}
}
}
} catch (Exception e) {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
}
}
}), 0, 0);
}
}","public void saveImageWithGlide(int whereTo) {

//comment
if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_no_external_storage, SnackbarWrapper.LENGTH_SHORT);
return;
}

//comment
<start>if (ContextCompat.checkSelfPermission(CardViewFragment.this.mActivity,
Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {<end>
//comment
ActivityCompat.requestPermissions(CardViewFragment.this.mActivity,
new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},
FamiliarActivity.REQUEST_WRITE_EXTERNAL_STORAGE_IMAGE);
//comment
mSaveImageWhereTo = whereTo;
return;
}

//comment
MediaStoreInfo msi = getMediaStoreInfo();

//comment
if (null != msi) {
if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(MediaStore.Images.Media.getContentUri(""external"") + ""/"" + msi.getId()));
} else {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
}
} else {
runGlideTarget(new FamiliarGlideTarget(this, new FamiliarGlideTarget.DrawableLoadedCallback() {
//comment
//comment
//comment
//comment
//comment
//comment
@Override
protected void onDrawableLoaded(Drawable resource) {
try {
if (resource instanceof BitmapDrawable) {
//comment
String url = MediaStore.Images.Media.insertImage(
getContext().getContentResolver(),
((BitmapDrawable) resource).getBitmap(),
getSavedFileName(), mCard.getName() + "" - "" + mCard.getSetName());

//comment
if (null == url) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
} else {
//comment
getFamiliarActivity().sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.parse(url)));

//comment
if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(url));
} else {
//comment
MediaStoreInfo msi = getMediaStoreInfo();
if (null != msi) {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
} else {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + url, SnackbarWrapper.LENGTH_LONG);
}
}
}
}
} catch (Exception e) {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
}
}
}), 0, 0);
}
}"
6190,"public void saveImageWithGlide(int whereTo) {

//comment
if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_no_external_storage, SnackbarWrapper.LENGTH_SHORT);
return;
}

//comment
if (ContextCompat.checkSelfPermission(CardViewFragment.this.mActivity,
<start>Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {<end>
//comment
ActivityCompat.requestPermissions(CardViewFragment.this.mActivity,
new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},
FamiliarActivity.REQUEST_WRITE_EXTERNAL_STORAGE_IMAGE);
//comment
mSaveImageWhereTo = whereTo;
return;
}

//comment
MediaStoreInfo msi = getMediaStoreInfo();

//comment
if (null != msi) {
if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(MediaStore.Images.Media.getContentUri(""external"") + ""/"" + msi.getId()));
} else {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
}
} else {
runGlideTarget(new FamiliarGlideTarget(this, new FamiliarGlideTarget.DrawableLoadedCallback() {
//comment
//comment
//comment
//comment
//comment
//comment
@Override
protected void onDrawableLoaded(Drawable resource) {
try {
if (resource instanceof BitmapDrawable) {
//comment
String url = MediaStore.Images.Media.insertImage(
getContext().getContentResolver(),
((BitmapDrawable) resource).getBitmap(),
getSavedFileName(), mCard.getName() + "" - "" + mCard.getSetName());

//comment
if (null == url) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
} else {
//comment
getFamiliarActivity().sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.parse(url)));

//comment
if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(url));
} else {
//comment
MediaStoreInfo msi = getMediaStoreInfo();
if (null != msi) {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
} else {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + url, SnackbarWrapper.LENGTH_LONG);
}
}
}
}
} catch (Exception e) {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
}
}
}), 0, 0);
}
}","public void saveImageWithGlide(int whereTo) {

//comment
if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_no_external_storage, SnackbarWrapper.LENGTH_SHORT);
return;
}

//comment
if (ContextCompat.checkSelfPermission(CardViewFragment.this.mActivity,
Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
//comment
<start>ActivityCompat.requestPermissions(CardViewFragment.this.mActivity,
new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},
FamiliarActivity.REQUEST_WRITE_EXTERNAL_STORAGE_IMAGE);<end>
//comment
mSaveImageWhereTo = whereTo;
return;
}

//comment
MediaStoreInfo msi = getMediaStoreInfo();

//comment
if (null != msi) {
if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(MediaStore.Images.Media.getContentUri(""external"") + ""/"" + msi.getId()));
} else {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
}
} else {
runGlideTarget(new FamiliarGlideTarget(this, new FamiliarGlideTarget.DrawableLoadedCallback() {
//comment
//comment
//comment
//comment
//comment
//comment
@Override
protected void onDrawableLoaded(Drawable resource) {
try {
if (resource instanceof BitmapDrawable) {
//comment
String url = MediaStore.Images.Media.insertImage(
getContext().getContentResolver(),
((BitmapDrawable) resource).getBitmap(),
getSavedFileName(), mCard.getName() + "" - "" + mCard.getSetName());

//comment
if (null == url) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
} else {
//comment
getFamiliarActivity().sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.parse(url)));

//comment
if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(url));
} else {
//comment
MediaStoreInfo msi = getMediaStoreInfo();
if (null != msi) {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
} else {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + url, SnackbarWrapper.LENGTH_LONG);
}
}
}
}
} catch (Exception e) {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
}
}
}), 0, 0);
}
}"
6191,"public void saveImageWithGlide(int whereTo) {

//comment
if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_no_external_storage, SnackbarWrapper.LENGTH_SHORT);
return;
}

//comment
if (ContextCompat.checkSelfPermission(CardViewFragment.this.mActivity,
Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
//comment
ActivityCompat.requestPermissions(CardViewFragment.this.mActivity,
new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},
FamiliarActivity.REQUEST_WRITE_EXTERNAL_STORAGE_IMAGE);
//comment
mSaveImageWhereTo = whereTo;
return;
}

//comment
<start>MediaStoreInfo msi = getMediaStoreInfo();<end>

//comment
if (null != msi) {
if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(MediaStore.Images.Media.getContentUri(""external"") + ""/"" + msi.getId()));
} else {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
}
} else {
runGlideTarget(new FamiliarGlideTarget(this, new FamiliarGlideTarget.DrawableLoadedCallback() {
//comment
//comment
//comment
//comment
//comment
//comment
@Override
protected void onDrawableLoaded(Drawable resource) {
try {
if (resource instanceof BitmapDrawable) {
//comment
String url = MediaStore.Images.Media.insertImage(
getContext().getContentResolver(),
((BitmapDrawable) resource).getBitmap(),
getSavedFileName(), mCard.getName() + "" - "" + mCard.getSetName());

//comment
if (null == url) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
} else {
//comment
getFamiliarActivity().sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.parse(url)));

//comment
if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(url));
} else {
//comment
MediaStoreInfo msi = getMediaStoreInfo();
if (null != msi) {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
} else {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + url, SnackbarWrapper.LENGTH_LONG);
}
}
}
}
} catch (Exception e) {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
}
}
}), 0, 0);
}
}","public void saveImageWithGlide(int whereTo) {

//comment
if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_no_external_storage, SnackbarWrapper.LENGTH_SHORT);
return;
}

//comment
if (ContextCompat.checkSelfPermission(CardViewFragment.this.mActivity,
Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
//comment
ActivityCompat.requestPermissions(CardViewFragment.this.mActivity,
new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},
FamiliarActivity.REQUEST_WRITE_EXTERNAL_STORAGE_IMAGE);
//comment
mSaveImageWhereTo = whereTo;
return;
}

//comment
<start>MediaStoreInfo msi = getMediaStoreInfo();<end>

//comment
if (null != msi) {
if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(MediaStore.Images.Media.getContentUri(""external"") + ""/"" + msi.getId()));
} else {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
}
} else {
runGlideTarget(new FamiliarGlideTarget(this, new FamiliarGlideTarget.DrawableLoadedCallback() {
//comment
//comment
//comment
//comment
//comment
//comment
@Override
protected void onDrawableLoaded(Drawable resource) {
try {
if (resource instanceof BitmapDrawable) {
//comment
String url = MediaStore.Images.Media.insertImage(
getContext().getContentResolver(),
((BitmapDrawable) resource).getBitmap(),
getSavedFileName(), mCard.getName() + "" - "" + mCard.getSetName());

//comment
if (null == url) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
} else {
//comment
getFamiliarActivity().sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.parse(url)));

//comment
if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(url));
} else {
//comment
MediaStoreInfo msi = getMediaStoreInfo();
if (null != msi) {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
} else {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + url, SnackbarWrapper.LENGTH_LONG);
}
}
}
}
} catch (Exception e) {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
}
}
}), 0, 0);
}
}"
6192,"public void saveImageWithGlide(int whereTo) {

//comment
if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_no_external_storage, SnackbarWrapper.LENGTH_SHORT);
return;
}

//comment
if (ContextCompat.checkSelfPermission(CardViewFragment.this.mActivity,
Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
//comment
ActivityCompat.requestPermissions(CardViewFragment.this.mActivity,
new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},
FamiliarActivity.REQUEST_WRITE_EXTERNAL_STORAGE_IMAGE);
//comment
mSaveImageWhereTo = whereTo;
return;
}

//comment
MediaStoreInfo msi = getMediaStoreInfo();

//comment
if (null != msi) {
if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(MediaStore.Images.Media.getContentUri(""external"") + ""/"" + msi.getId()));
} else {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
}
} else {
runGlideTarget(new FamiliarGlideTarget(this, new FamiliarGlideTarget.DrawableLoadedCallback() {
//comment
//comment
//comment
//comment
//comment
//comment
@Override
protected void onDrawableLoaded(Drawable resource) {
try {
if (resource instanceof BitmapDrawable) {
//comment
String url = MediaStore.Images.Media.insertImage(
getContext().getContentResolver(),
((BitmapDrawable) resource).getBitmap(),
getSavedFileName(), mCard.getName() + "" - "" + mCard.getSetName());

//comment
if (null == url) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
} else {
//comment
getFamiliarActivity().sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.parse(url)));

//comment
if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(url));
} else {
//comment
MediaStoreInfo msi = getMediaStoreInfo();
if (null != msi) {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
} else {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + url, SnackbarWrapper.LENGTH_LONG);
}
}
}
}
} catch (Exception e) {
//comment
<start>SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);<end>
}
}
}), 0, 0);
}
}","public void saveImageWithGlide(int whereTo) {

//comment
if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_no_external_storage, SnackbarWrapper.LENGTH_SHORT);
return;
}

//comment
if (ContextCompat.checkSelfPermission(CardViewFragment.this.mActivity,
Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
//comment
ActivityCompat.requestPermissions(CardViewFragment.this.mActivity,
new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},
FamiliarActivity.REQUEST_WRITE_EXTERNAL_STORAGE_IMAGE);
//comment
mSaveImageWhereTo = whereTo;
return;
}

//comment
<start>MediaStoreInfo msi = getMediaStoreInfo();<end>

//comment
<start>if (null != msi) {<end>
if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(MediaStore.Images.Media.getContentUri(""external"") + ""/"" + msi.getId()));
} else {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
}
} else {
runGlideTarget(new FamiliarGlideTarget(this, new FamiliarGlideTarget.DrawableLoadedCallback() {
//comment
//comment
//comment
//comment
//comment
//comment
@Override
protected void onDrawableLoaded(Drawable resource) {
try {
if (resource instanceof BitmapDrawable) {
//comment
String url = MediaStore.Images.Media.insertImage(
getContext().getContentResolver(),
((BitmapDrawable) resource).getBitmap(),
getSavedFileName(), mCard.getName() + "" - "" + mCard.getSetName());

//comment
if (null == url) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
} else {
//comment
getFamiliarActivity().sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.parse(url)));

//comment
if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(url));
} else {
//comment
MediaStoreInfo msi = getMediaStoreInfo();
if (null != msi) {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
} else {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + url, SnackbarWrapper.LENGTH_LONG);
}
}
}
}
} catch (Exception e) {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
}
}
}), 0, 0);
}
}"
6193,"public void saveImageWithGlide(int whereTo) {

//comment
if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_no_external_storage, SnackbarWrapper.LENGTH_SHORT);
return;
}

//comment
if (ContextCompat.checkSelfPermission(CardViewFragment.this.mActivity,
Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
//comment
ActivityCompat.requestPermissions(CardViewFragment.this.mActivity,
new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},
FamiliarActivity.REQUEST_WRITE_EXTERNAL_STORAGE_IMAGE);
//comment
mSaveImageWhereTo = whereTo;
return;
}

//comment
MediaStoreInfo msi = getMediaStoreInfo();

//comment
if (null != msi) {
if (SHARE == whereTo) {
//comment
<start>shareImage(Uri.parse(MediaStore.Images.Media.getContentUri(""external"") + ""/"" + msi.getId()));<end>
} else {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
}
} else {
runGlideTarget(new FamiliarGlideTarget(this, new FamiliarGlideTarget.DrawableLoadedCallback() {
//comment
//comment
//comment
//comment
//comment
//comment
@Override
protected void onDrawableLoaded(Drawable resource) {
try {
if (resource instanceof BitmapDrawable) {
//comment
String url = MediaStore.Images.Media.insertImage(
getContext().getContentResolver(),
((BitmapDrawable) resource).getBitmap(),
getSavedFileName(), mCard.getName() + "" - "" + mCard.getSetName());

//comment
if (null == url) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
} else {
//comment
getFamiliarActivity().sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.parse(url)));

//comment
if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(url));
} else {
//comment
MediaStoreInfo msi = getMediaStoreInfo();
if (null != msi) {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
} else {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + url, SnackbarWrapper.LENGTH_LONG);
}
}
}
}
} catch (Exception e) {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
}
}
}), 0, 0);
}
}","public void saveImageWithGlide(int whereTo) {

//comment
if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_no_external_storage, SnackbarWrapper.LENGTH_SHORT);
return;
}

//comment
if (ContextCompat.checkSelfPermission(CardViewFragment.this.mActivity,
Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
//comment
ActivityCompat.requestPermissions(CardViewFragment.this.mActivity,
new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},
FamiliarActivity.REQUEST_WRITE_EXTERNAL_STORAGE_IMAGE);
//comment
mSaveImageWhereTo = whereTo;
return;
}

//comment
MediaStoreInfo msi = getMediaStoreInfo();

//comment
if (null != msi) {
<start>if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(MediaStore.Images.Media.getContentUri(""external"") + ""/"" + msi.getId()));
} else {<end>
//comment
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
}
} else {
runGlideTarget(new FamiliarGlideTarget(this, new FamiliarGlideTarget.DrawableLoadedCallback() {
//comment
//comment
//comment
//comment
//comment
//comment
@Override
protected void onDrawableLoaded(Drawable resource) {
try {
if (resource instanceof BitmapDrawable) {
//comment
String url = MediaStore.Images.Media.insertImage(
getContext().getContentResolver(),
((BitmapDrawable) resource).getBitmap(),
getSavedFileName(), mCard.getName() + "" - "" + mCard.getSetName());

//comment
if (null == url) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
} else {
//comment
getFamiliarActivity().sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.parse(url)));

//comment
if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(url));
} else {
//comment
MediaStoreInfo msi = getMediaStoreInfo();
if (null != msi) {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
} else {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + url, SnackbarWrapper.LENGTH_LONG);
}
}
}
}
} catch (Exception e) {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
}
}
}), 0, 0);
}
}"
6194,"public void saveImageWithGlide(int whereTo) {

//comment
if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_no_external_storage, SnackbarWrapper.LENGTH_SHORT);
return;
}

//comment
if (ContextCompat.checkSelfPermission(CardViewFragment.this.mActivity,
Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
//comment
ActivityCompat.requestPermissions(CardViewFragment.this.mActivity,
new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},
FamiliarActivity.REQUEST_WRITE_EXTERNAL_STORAGE_IMAGE);
//comment
mSaveImageWhereTo = whereTo;
<start>return;<end>
}

//comment
MediaStoreInfo msi = getMediaStoreInfo();

//comment
if (null != msi) {
if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(MediaStore.Images.Media.getContentUri(""external"") + ""/"" + msi.getId()));
} else {
//comment
<start>SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);<end>
}
} else {
runGlideTarget(new FamiliarGlideTarget(this, new FamiliarGlideTarget.DrawableLoadedCallback() {
//comment
//comment
//comment
//comment
//comment
//comment
@Override
protected void onDrawableLoaded(Drawable resource) {
try {
if (resource instanceof BitmapDrawable) {
//comment
String url = MediaStore.Images.Media.insertImage(
getContext().getContentResolver(),
((BitmapDrawable) resource).getBitmap(),
getSavedFileName(), mCard.getName() + "" - "" + mCard.getSetName());

//comment
if (null == url) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
} else {
//comment
getFamiliarActivity().sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.parse(url)));

//comment
if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(url));
} else {
//comment
MediaStoreInfo msi = getMediaStoreInfo();
if (null != msi) {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
} else {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + url, SnackbarWrapper.LENGTH_LONG);
}
}
}
}
} catch (Exception e) {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
}
}
}), 0, 0);
}
}","public void saveImageWithGlide(int whereTo) {

//comment
if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_no_external_storage, SnackbarWrapper.LENGTH_SHORT);
return;
}

//comment
if (ContextCompat.checkSelfPermission(CardViewFragment.this.mActivity,
Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
//comment
ActivityCompat.requestPermissions(CardViewFragment.this.mActivity,
new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},
FamiliarActivity.REQUEST_WRITE_EXTERNAL_STORAGE_IMAGE);
//comment
mSaveImageWhereTo = whereTo;
return;
}

//comment
MediaStoreInfo msi = getMediaStoreInfo();

//comment
if (null != msi) {
<start>if (SHARE == whereTo) {<end>
//comment
shareImage(Uri.parse(MediaStore.Images.Media.getContentUri(""external"") + ""/"" + msi.getId()));
<start>} else {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
}<end>
} else {
runGlideTarget(new FamiliarGlideTarget(this, new FamiliarGlideTarget.DrawableLoadedCallback() {
//comment
//comment
//comment
//comment
//comment
//comment
@Override
protected void onDrawableLoaded(Drawable resource) {
try {
if (resource instanceof BitmapDrawable) {
//comment
String url = MediaStore.Images.Media.insertImage(
getContext().getContentResolver(),
((BitmapDrawable) resource).getBitmap(),
getSavedFileName(), mCard.getName() + "" - "" + mCard.getSetName());

//comment
if (null == url) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
} else {
//comment
getFamiliarActivity().sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.parse(url)));

//comment
if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(url));
} else {
//comment
MediaStoreInfo msi = getMediaStoreInfo();
if (null != msi) {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
} else {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + url, SnackbarWrapper.LENGTH_LONG);
}
}
}
}
} catch (Exception e) {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
}
}
}), 0, 0);
}
}"
6195,"public void saveImageWithGlide(int whereTo) {

//comment
if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_no_external_storage, SnackbarWrapper.LENGTH_SHORT);
return;
}

//comment
if (ContextCompat.checkSelfPermission(CardViewFragment.this.mActivity,
Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
//comment
ActivityCompat.requestPermissions(CardViewFragment.this.mActivity,
new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},
FamiliarActivity.REQUEST_WRITE_EXTERNAL_STORAGE_IMAGE);
//comment
mSaveImageWhereTo = whereTo;
return;
}

//comment
MediaStoreInfo msi = getMediaStoreInfo();

//comment
if (null != msi) {
if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(MediaStore.Images.Media.getContentUri(""external"") + ""/"" + msi.getId()));
} else {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
}
} else {
runGlideTarget(new FamiliarGlideTarget(this, new FamiliarGlideTarget.DrawableLoadedCallback() {
//comment
//comment
//comment
//comment
//comment
//comment
@Override
protected void onDrawableLoaded(Drawable resource) {
try {
if (resource instanceof BitmapDrawable) {
//comment
<start>String url = MediaStore.Images.Media.insertImage(
getContext().getContentResolver(),
((BitmapDrawable) resource).getBitmap(),
getSavedFileName(), mCard.getName() + "" - "" + mCard.getSetName());<end>

//comment
if (null == url) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
} else {
//comment
getFamiliarActivity().sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.parse(url)));

//comment
if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(url));
} else {
//comment
MediaStoreInfo msi = getMediaStoreInfo();
if (null != msi) {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
} else {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + url, SnackbarWrapper.LENGTH_LONG);
}
}
}
}
} catch (Exception e) {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
}
}
}), 0, 0);
}
}","public void saveImageWithGlide(int whereTo) {

//comment
if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_no_external_storage, SnackbarWrapper.LENGTH_SHORT);
return;
}

//comment
if (ContextCompat.checkSelfPermission(CardViewFragment.this.mActivity,
Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
//comment
ActivityCompat.requestPermissions(CardViewFragment.this.mActivity,
new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},
FamiliarActivity.REQUEST_WRITE_EXTERNAL_STORAGE_IMAGE);
//comment
mSaveImageWhereTo = whereTo;
return;
}

//comment
MediaStoreInfo msi = getMediaStoreInfo();

//comment
if (null != msi) {
if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(MediaStore.Images.Media.getContentUri(""external"") + ""/"" + msi.getId()));
} else {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
}
} else {
runGlideTarget(new FamiliarGlideTarget(this, new FamiliarGlideTarget.DrawableLoadedCallback() {
//comment
//comment
//comment
//comment
//comment
//comment
@Override
protected void onDrawableLoaded(Drawable resource) {
try {
if (resource instanceof BitmapDrawable) {
//comment
<start>String url = MediaStore.Images.Media.insertImage(
getContext().getContentResolver(),
((BitmapDrawable) resource).getBitmap(),
getSavedFileName(), mCard.getName() + "" - "" + mCard.getSetName());<end>

//comment
if (null == url) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
} else {
//comment
getFamiliarActivity().sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.parse(url)));

//comment
if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(url));
} else {
//comment
MediaStoreInfo msi = getMediaStoreInfo();
if (null != msi) {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
} else {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + url, SnackbarWrapper.LENGTH_LONG);
}
}
}
}
} catch (Exception e) {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
}
}
}), 0, 0);
}
}"
6196,"public void saveImageWithGlide(int whereTo) {

//comment
if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_no_external_storage, SnackbarWrapper.LENGTH_SHORT);
return;
}

//comment
if (ContextCompat.checkSelfPermission(CardViewFragment.this.mActivity,
Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
//comment
ActivityCompat.requestPermissions(CardViewFragment.this.mActivity,
new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},
FamiliarActivity.REQUEST_WRITE_EXTERNAL_STORAGE_IMAGE);
//comment
mSaveImageWhereTo = whereTo;
return;
}

//comment
MediaStoreInfo msi = getMediaStoreInfo();

//comment
if (null != msi) {
<start>if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(MediaStore.Images.Media.getContentUri(""external"") + ""/"" + msi.getId()));
} else {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
}<end>
} else {
runGlideTarget(new FamiliarGlideTarget(this, new FamiliarGlideTarget.DrawableLoadedCallback() {
//comment
//comment
//comment
//comment
//comment
//comment
@Override
protected void onDrawableLoaded(Drawable resource) {
try {
if (resource instanceof BitmapDrawable) {
//comment
String url = MediaStore.Images.Media.insertImage(
getContext().getContentResolver(),
((BitmapDrawable) resource).getBitmap(),
getSavedFileName(), mCard.getName() + "" - "" + mCard.getSetName());

//comment
if (null == url) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
} else {
//comment
<start>getFamiliarActivity().sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.parse(url)));<end>

//comment
if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(url));
} else {
//comment
MediaStoreInfo msi = getMediaStoreInfo();
if (null != msi) {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
} else {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + url, SnackbarWrapper.LENGTH_LONG);
}
}
}
}
} catch (Exception e) {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
}
}
}), 0, 0);
}
}","public void saveImageWithGlide(int whereTo) {

//comment
if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_no_external_storage, SnackbarWrapper.LENGTH_SHORT);
return;
}

//comment
if (ContextCompat.checkSelfPermission(CardViewFragment.this.mActivity,
Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
//comment
ActivityCompat.requestPermissions(CardViewFragment.this.mActivity,
new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},
FamiliarActivity.REQUEST_WRITE_EXTERNAL_STORAGE_IMAGE);
//comment
mSaveImageWhereTo = whereTo;
return;
}

//comment
MediaStoreInfo msi = getMediaStoreInfo();

//comment
if (null != msi) {
if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(MediaStore.Images.Media.getContentUri(""external"") + ""/"" + msi.getId()));
} else {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
}
} else {
runGlideTarget(new FamiliarGlideTarget(this, new FamiliarGlideTarget.DrawableLoadedCallback() {
//comment
//comment
//comment
//comment
//comment
//comment
@Override
protected void onDrawableLoaded(Drawable resource) {
try {
if (resource instanceof BitmapDrawable) {
//comment
String url = MediaStore.Images.Media.insertImage(
getContext().getContentResolver(),
((BitmapDrawable) resource).getBitmap(),
getSavedFileName(), mCard.getName() + "" - "" + mCard.getSetName());

//comment
if (null == url) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
} else {
//comment
<start>getFamiliarActivity().sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.parse(url)));<end>

//comment
if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(url));
} else {
//comment
MediaStoreInfo msi = getMediaStoreInfo();
if (null != msi) {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
} else {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + url, SnackbarWrapper.LENGTH_LONG);
}
}
}
}
} catch (Exception e) {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
}
}
}), 0, 0);
}
}"
6197,"public void saveImageWithGlide(int whereTo) {

//comment
if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_no_external_storage, SnackbarWrapper.LENGTH_SHORT);
return;
}

//comment
if (ContextCompat.checkSelfPermission(CardViewFragment.this.mActivity,
Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
//comment
ActivityCompat.requestPermissions(CardViewFragment.this.mActivity,
new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},
FamiliarActivity.REQUEST_WRITE_EXTERNAL_STORAGE_IMAGE);
//comment
mSaveImageWhereTo = whereTo;
return;
}

//comment
MediaStoreInfo msi = getMediaStoreInfo();

//comment
if (null != msi) {
if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(MediaStore.Images.Media.getContentUri(""external"") + ""/"" + msi.getId()));
} else {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
}
} else {
runGlideTarget(new FamiliarGlideTarget(this, new FamiliarGlideTarget.DrawableLoadedCallback() {
//comment
//comment
//comment
//comment
//comment
//comment
@Override
protected void onDrawableLoaded(Drawable resource) {
try {
if (resource instanceof BitmapDrawable) {
//comment
String url = MediaStore.Images.Media.insertImage(
getContext().getContentResolver(),
((BitmapDrawable) resource).getBitmap(),
getSavedFileName(), mCard.getName() + "" - "" + mCard.getSetName());

//comment
if (null == url) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
} else {
//comment
getFamiliarActivity().sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.parse(url)));

//comment
if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(url));
} else {
//comment
MediaStoreInfo msi = getMediaStoreInfo();
if (null != msi) {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
} else {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + url, SnackbarWrapper.LENGTH_LONG);
}
}
}
}
} catch (Exception e) {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
}
}
}), 0, 0);
}
}","public void saveImageWithGlide(int whereTo) {

//comment
if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_no_external_storage, SnackbarWrapper.LENGTH_SHORT);
return;
}

//comment
if (ContextCompat.checkSelfPermission(CardViewFragment.this.mActivity,
Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
//comment
ActivityCompat.requestPermissions(CardViewFragment.this.mActivity,
new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},
FamiliarActivity.REQUEST_WRITE_EXTERNAL_STORAGE_IMAGE);
//comment
mSaveImageWhereTo = whereTo;
return;
}

//comment
MediaStoreInfo msi = getMediaStoreInfo();

//comment
if (null != msi) {
if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(MediaStore.Images.Media.getContentUri(""external"") + ""/"" + msi.getId()));
} else {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
}
} else {
runGlideTarget(new FamiliarGlideTarget(this, new FamiliarGlideTarget.DrawableLoadedCallback() {
//comment
//comment
//comment
//comment
//comment
//comment
@Override
protected void onDrawableLoaded(Drawable resource) {
try {
if (resource instanceof BitmapDrawable) {
//comment
String url = MediaStore.Images.Media.insertImage(
getContext().getContentResolver(),
((BitmapDrawable) resource).getBitmap(),
getSavedFileName(), mCard.getName() + "" - "" + mCard.getSetName());

//comment
if (null == url) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
} else {
//comment
getFamiliarActivity().sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.parse(url)));

//comment
<start>if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(url));
} else {
//comment
MediaStoreInfo msi = getMediaStoreInfo();
if (null != msi) {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
} else {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + url, SnackbarWrapper.LENGTH_LONG);
}
}<end>
}
}
} catch (Exception e) {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
}
}
}), 0, 0);
}
}"
6198,"public void saveImageWithGlide(int whereTo) {

//comment
if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_no_external_storage, SnackbarWrapper.LENGTH_SHORT);
return;
}

//comment
if (ContextCompat.checkSelfPermission(CardViewFragment.this.mActivity,
Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
//comment
ActivityCompat.requestPermissions(CardViewFragment.this.mActivity,
new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},
FamiliarActivity.REQUEST_WRITE_EXTERNAL_STORAGE_IMAGE);
//comment
mSaveImageWhereTo = whereTo;
return;
}

//comment
MediaStoreInfo msi = getMediaStoreInfo();

//comment
if (null != msi) {
if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(MediaStore.Images.Media.getContentUri(""external"") + ""/"" + msi.getId()));
} else {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
}
} else {
runGlideTarget(new FamiliarGlideTarget(this, new FamiliarGlideTarget.DrawableLoadedCallback() {
//comment
//comment
//comment
//comment
//comment
//comment
@Override
protected void onDrawableLoaded(Drawable resource) {
try {
if (resource instanceof BitmapDrawable) {
//comment
String url = MediaStore.Images.Media.insertImage(
getContext().getContentResolver(),
((BitmapDrawable) resource).getBitmap(),
getSavedFileName(), mCard.getName() + "" - "" + mCard.getSetName());

//comment
if (null == url) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
} else {
//comment
getFamiliarActivity().sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.parse(url)));

//comment
if (SHARE == whereTo) {
//comment
<start>shareImage(Uri.parse(url));<end>
} else {
//comment
MediaStoreInfo msi = getMediaStoreInfo();
if (null != msi) {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
} else {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + url, SnackbarWrapper.LENGTH_LONG);
}
}
}
}
} catch (Exception e) {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
}
}
}), 0, 0);
}
}","public void saveImageWithGlide(int whereTo) {

//comment
if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_no_external_storage, SnackbarWrapper.LENGTH_SHORT);
return;
}

//comment
if (ContextCompat.checkSelfPermission(CardViewFragment.this.mActivity,
Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
//comment
ActivityCompat.requestPermissions(CardViewFragment.this.mActivity,
new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},
FamiliarActivity.REQUEST_WRITE_EXTERNAL_STORAGE_IMAGE);
//comment
mSaveImageWhereTo = whereTo;
return;
}

//comment
MediaStoreInfo msi = getMediaStoreInfo();

//comment
if (null != msi) {
if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(MediaStore.Images.Media.getContentUri(""external"") + ""/"" + msi.getId()));
} else {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
}
} else {
runGlideTarget(new FamiliarGlideTarget(this, new FamiliarGlideTarget.DrawableLoadedCallback() {
//comment
//comment
//comment
//comment
//comment
//comment
@Override
protected void onDrawableLoaded(Drawable resource) {
try {
if (resource instanceof BitmapDrawable) {
//comment
String url = MediaStore.Images.Media.insertImage(
getContext().getContentResolver(),
((BitmapDrawable) resource).getBitmap(),
getSavedFileName(), mCard.getName() + "" - "" + mCard.getSetName());

//comment
if (null == url) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
} else {
//comment
getFamiliarActivity().sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.parse(url)));

//comment
<start>if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(url));
} else {<end>
//comment
MediaStoreInfo msi = getMediaStoreInfo();
if (null != msi) {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
} else {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + url, SnackbarWrapper.LENGTH_LONG);
}
}
}
}
} catch (Exception e) {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
}
}
}), 0, 0);
}
}"
6199,"public void saveImageWithGlide(int whereTo) {

//comment
if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_no_external_storage, SnackbarWrapper.LENGTH_SHORT);
return;
}

//comment
if (ContextCompat.checkSelfPermission(CardViewFragment.this.mActivity,
Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
//comment
ActivityCompat.requestPermissions(CardViewFragment.this.mActivity,
new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},
FamiliarActivity.REQUEST_WRITE_EXTERNAL_STORAGE_IMAGE);
//comment
mSaveImageWhereTo = whereTo;
return;
}

//comment
MediaStoreInfo msi = getMediaStoreInfo();

//comment
if (null != msi) {
if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(MediaStore.Images.Media.getContentUri(""external"") + ""/"" + msi.getId()));
} else {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
}
} else {
runGlideTarget(new FamiliarGlideTarget(this, new FamiliarGlideTarget.DrawableLoadedCallback() {
//comment
//comment
//comment
//comment
//comment
//comment
@Override
protected void onDrawableLoaded(Drawable resource) {
try {
if (resource instanceof BitmapDrawable) {
//comment
String url = MediaStore.Images.Media.insertImage(
getContext().getContentResolver(),
((BitmapDrawable) resource).getBitmap(),
getSavedFileName(), mCard.getName() + "" - "" + mCard.getSetName());

//comment
if (null == url) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
} else {
//comment
getFamiliarActivity().sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.parse(url)));

//comment
if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(url));
} else {
//comment
MediaStoreInfo msi = getMediaStoreInfo();
<start>if (null != msi) {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
} else {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + url, SnackbarWrapper.LENGTH_LONG);
}<end>
}
}
}
} catch (Exception e) {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
}
}
}), 0, 0);
}
}","public void saveImageWithGlide(int whereTo) {

//comment
if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_no_external_storage, SnackbarWrapper.LENGTH_SHORT);
return;
}

//comment
if (ContextCompat.checkSelfPermission(CardViewFragment.this.mActivity,
Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
//comment
ActivityCompat.requestPermissions(CardViewFragment.this.mActivity,
new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},
FamiliarActivity.REQUEST_WRITE_EXTERNAL_STORAGE_IMAGE);
//comment
mSaveImageWhereTo = whereTo;
return;
}

//comment
MediaStoreInfo msi = getMediaStoreInfo();

//comment
if (null != msi) {
if (SHARE == whereTo) {
//comment
shareImage(Uri.parse(MediaStore.Images.Media.getContentUri(""external"") + ""/"" + msi.getId()));
} else {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
}
} else {
runGlideTarget(new FamiliarGlideTarget(this, new FamiliarGlideTarget.DrawableLoadedCallback() {
//comment
//comment
//comment
//comment
//comment
//comment
@Override
protected void onDrawableLoaded(Drawable resource) {
try {
if (resource instanceof BitmapDrawable) {
//comment
String url = MediaStore.Images.Media.insertImage(
getContext().getContentResolver(),
((BitmapDrawable) resource).getBitmap(),
getSavedFileName(), mCard.getName() + "" - "" + mCard.getSetName());

//comment
if (null == url) {
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
} else {
//comment
getFamiliarActivity().sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.parse(url)));

//comment
<start>if (SHARE == whereTo) {<end>
//comment
shareImage(Uri.parse(url));
<start>} else {
//comment
MediaStoreInfo msi = getMediaStoreInfo();
if (null != msi) {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + msi.getFilePath(), SnackbarWrapper.LENGTH_LONG);
} else {
SnackbarWrapper.makeAndShowText(getActivity(), getString(R.string.card_view_image_saved) + url, SnackbarWrapper.LENGTH_LONG);
}
}<end>
}
}
} catch (Exception e) {
//comment
SnackbarWrapper.makeAndShowText(getActivity(), R.string.card_view_save_failure, SnackbarWrapper.LENGTH_SHORT);
}
}
}), 0, 0);
}
}"
6200,"private void runGlideTarget(FamiliarGlideTarget familiarGlideTarget, int width, int height) {
//comment
<start>String cardLanguage = PreferenceAdapter.getCardLanguage(getContext());<end>
if (cardLanguage == null) {
<start>cardLanguage = ""en"";<end>
}

//comment
if (null == mGlideRequestManager) {
mGlideRequestManager = GlideApp.with(this);
} else {
if (null != mGlideTarget) {
mGlideRequestManager.clear(mGlideTarget);
mGlideTarget = null;
}
}

//comment
mGlideTarget = runGlideRequest(0, cardLanguage, width, height, true, familiarGlideTarget);
}","private void runGlideTarget(FamiliarGlideTarget familiarGlideTarget, int width, int height) {
//comment
<start>String cardLanguage = PreferenceAdapter.getCardLanguage(getContext());
if (cardLanguage == null) {
cardLanguage = ""en"";
}<end>

//comment
if (null == mGlideRequestManager) {
mGlideRequestManager = GlideApp.with(this);
} else {
if (null != mGlideTarget) {
mGlideRequestManager.clear(mGlideTarget);
mGlideTarget = null;
}
}

//comment
mGlideTarget = runGlideRequest(0, cardLanguage, width, height, true, familiarGlideTarget);
}"
6201,"private void runGlideTarget(FamiliarGlideTarget familiarGlideTarget, int width, int height) {
//comment
String cardLanguage = PreferenceAdapter.getCardLanguage(getContext());
if (cardLanguage == null) {
cardLanguage = ""en"";
}

//comment
if (null == mGlideRequestManager) {
mGlideRequestManager = GlideApp.with(this);
<start>} else {<end>
if (null != mGlideTarget) {
mGlideRequestManager.clear(mGlideTarget);
mGlideTarget = null;
}
}

//comment
mGlideTarget = runGlideRequest(0, cardLanguage, width, height, true, familiarGlideTarget);
}","private void runGlideTarget(FamiliarGlideTarget familiarGlideTarget, int width, int height) {
//comment
String cardLanguage = PreferenceAdapter.getCardLanguage(getContext());
if (cardLanguage == null) {
cardLanguage = ""en"";
}

//comment
<start>if (null == mGlideRequestManager) {
mGlideRequestManager = GlideApp.with(this);
} else {
if (null != mGlideTarget) {
mGlideRequestManager.clear(mGlideTarget);
mGlideTarget = null;
}
}<end>

//comment
mGlideTarget = runGlideRequest(0, cardLanguage, width, height, true, familiarGlideTarget);
}"
6202,"private void runGlideTarget(FamiliarGlideTarget familiarGlideTarget, int width, int height) {
//comment
String cardLanguage = PreferenceAdapter.getCardLanguage(getContext());
if (cardLanguage == null) {
cardLanguage = ""en"";
}

//comment
if (null == mGlideRequestManager) {
mGlideRequestManager = GlideApp.with(this);
} else {
if (null != mGlideTarget) {
mGlideRequestManager.clear(mGlideTarget);
mGlideTarget = null;
}
}

//comment
<start>mGlideTarget = runGlideRequest(0, cardLanguage, width, height, true, familiarGlideTarget);<end>
}","private void runGlideTarget(FamiliarGlideTarget familiarGlideTarget, int width, int height) {
//comment
String cardLanguage = PreferenceAdapter.getCardLanguage(getContext());
if (cardLanguage == null) {
cardLanguage = ""en"";
}

//comment
if (null == mGlideRequestManager) {
mGlideRequestManager = GlideApp.with(this);
} else {
if (null != mGlideTarget) {
mGlideRequestManager.clear(mGlideTarget);
mGlideTarget = null;
}
}

//comment
<start>mGlideTarget = runGlideRequest(0, cardLanguage, width, height, true, familiarGlideTarget);<end>
}"
6203,"private Target<Drawable> runGlideRequest(int attempt, String cardLanguage, int width, int height,
boolean onlyCheckCache, Target<Drawable> target) {
//comment
//comment
GlideRequest<Drawable> request = mGlideRequestManager
.load(mCard.getImageUrlString(attempt, cardLanguage))
.diskCacheStrategy(DiskCacheStrategy.ALL)
.listener(new RequestListener<Drawable>() {
@Override
public boolean onLoadFailed(@Nullable GlideException e, Object model, Target<Drawable> target, boolean isFirstResource) {
//comment
String thisUrl = mCard.getImageUrlString(attempt, cardLanguage);
String nextUrl = mCard.getImageUrlString(attempt + 1, cardLanguage);
if (thisUrl.equals(nextUrl)) {
//comment
if (onlyCheckCache) {
//comment
if (FamiliarActivity.getNetworkState(getActivity(), true) == -1) {
//comment
<start>return false;<end>
} else {
//comment
(new Handler()).post(() -> runGlideRequest(0, cardLanguage, width, height, false, target));
return true;
}
} else {
//comment
//comment
return false;
}
} else {
//comment
(new Handler()).post(() -> runGlideRequest(attempt + 1, cardLanguage, width, height, onlyCheckCache, target));
//comment
return true;
}
}

@Override
public boolean onResourceReady(Drawable resource, Object model, Target<Drawable> target, DataSource dataSource, boolean isFirstResource) {
//comment
return false;
}
});

//comment
if (onlyCheckCache) {
request = request.onlyRetrieveFromCache(true);
}

//comment
if (0 != width && 0 != height) {
request = request
.override(width, height)
.fitCenter();
}

//comment
return request.into(target);
}","private Target<Drawable> runGlideRequest(int attempt, String cardLanguage, int width, int height,
boolean onlyCheckCache, Target<Drawable> target) {
//comment
//comment
GlideRequest<Drawable> request = mGlideRequestManager
.load(mCard.getImageUrlString(attempt, cardLanguage))
.diskCacheStrategy(DiskCacheStrategy.ALL)
.listener(new RequestListener<Drawable>() {
@Override
public boolean onLoadFailed(@Nullable GlideException e, Object model, Target<Drawable> target, boolean isFirstResource) {
//comment
String thisUrl = mCard.getImageUrlString(attempt, cardLanguage);
String nextUrl = mCard.getImageUrlString(attempt + 1, cardLanguage);
if (thisUrl.equals(nextUrl)) {
//comment
<start>if (onlyCheckCache) {
//comment
if (FamiliarActivity.getNetworkState(getActivity(), true) == -1) {
//comment
return false;
} else {<end>
//comment
(new Handler()).post(() -> runGlideRequest(0, cardLanguage, width, height, false, target));
return true;
}
<start>} else {<end>
//comment
//comment
return false;
}
} else {
//comment
(new Handler()).post(() -> runGlideRequest(attempt + 1, cardLanguage, width, height, onlyCheckCache, target));
//comment
return true;
}
}

@Override
public boolean onResourceReady(Drawable resource, Object model, Target<Drawable> target, DataSource dataSource, boolean isFirstResource) {
//comment
return false;
}
});

//comment
if (onlyCheckCache) {
request = request.onlyRetrieveFromCache(true);
}

//comment
if (0 != width && 0 != height) {
request = request
.override(width, height)
.fitCenter();
}

//comment
return request.into(target);
}"
6204,"private Target<Drawable> runGlideRequest(int attempt, String cardLanguage, int width, int height,
boolean onlyCheckCache, Target<Drawable> target) {
//comment
//comment
GlideRequest<Drawable> request = mGlideRequestManager
.load(mCard.getImageUrlString(attempt, cardLanguage))
.diskCacheStrategy(DiskCacheStrategy.ALL)
.listener(new RequestListener<Drawable>() {
@Override
public boolean onLoadFailed(@Nullable GlideException e, Object model, Target<Drawable> target, boolean isFirstResource) {
//comment
String thisUrl = mCard.getImageUrlString(attempt, cardLanguage);
String nextUrl = mCard.getImageUrlString(attempt + 1, cardLanguage);
if (thisUrl.equals(nextUrl)) {
//comment
if (onlyCheckCache) {
//comment
if (FamiliarActivity.getNetworkState(getActivity(), true) == -1) {
//comment
return false;
} else {
//comment
(new Handler()).post(() -> runGlideRequest(0, cardLanguage, width, height, false, target));
return true;
}
} else {
//comment
//comment
return false;
}
} else {
//comment
(new Handler()).post(() -> runGlideRequest(attempt + 1, cardLanguage, width, height, onlyCheckCache, target));
//comment
return true;
}
}

@Override
public boolean onResourceReady(Drawable resource, Object model, Target<Drawable> target, DataSource dataSource, boolean isFirstResource) {
//comment
return false;
}
});

//comment
<start>if (onlyCheckCache) {
request = request.onlyRetrieveFromCache(true);
}<end>

//comment
if (0 != width && 0 != height) {
request = request
.override(width, height)
.fitCenter();
}

//comment
return request.into(target);
}","private Target<Drawable> runGlideRequest(int attempt, String cardLanguage, int width, int height,
boolean onlyCheckCache, Target<Drawable> target) {
//comment
//comment
GlideRequest<Drawable> request = mGlideRequestManager
.load(mCard.getImageUrlString(attempt, cardLanguage))
.diskCacheStrategy(DiskCacheStrategy.ALL)
.listener(new RequestListener<Drawable>() {
@Override
public boolean onLoadFailed(@Nullable GlideException e, Object model, Target<Drawable> target, boolean isFirstResource) {
//comment
String thisUrl = mCard.getImageUrlString(attempt, cardLanguage);
String nextUrl = mCard.getImageUrlString(attempt + 1, cardLanguage);
if (thisUrl.equals(nextUrl)) {
//comment
if (onlyCheckCache) {
//comment
if (FamiliarActivity.getNetworkState(getActivity(), true) == -1) {
//comment
return false;
} else {
//comment
(new Handler()).post(() -> runGlideRequest(0, cardLanguage, width, height, false, target));
return true;
}
} else {
//comment
//comment
return false;
}
} else {
//comment
(new Handler()).post(() -> runGlideRequest(attempt + 1, cardLanguage, width, height, onlyCheckCache, target));
//comment
return true;
}
}

@Override
public boolean onResourceReady(Drawable resource, Object model, Target<Drawable> target, DataSource dataSource, boolean isFirstResource) {
//comment
return false;
}
});

//comment
<start>if (onlyCheckCache) {
request = request.onlyRetrieveFromCache(true);
}<end>

//comment
if (0 != width && 0 != height) {
request = request
.override(width, height)
.fitCenter();
}

//comment
return request.into(target);
}"
6205,"private Target<Drawable> runGlideRequest(int attempt, String cardLanguage, int width, int height,
boolean onlyCheckCache, Target<Drawable> target) {
//comment
//comment
GlideRequest<Drawable> request = mGlideRequestManager
.load(mCard.getImageUrlString(attempt, cardLanguage))
.diskCacheStrategy(DiskCacheStrategy.ALL)
.listener(new RequestListener<Drawable>() {
@Override
public boolean onLoadFailed(@Nullable GlideException e, Object model, Target<Drawable> target, boolean isFirstResource) {
//comment
String thisUrl = mCard.getImageUrlString(attempt, cardLanguage);
String nextUrl = mCard.getImageUrlString(attempt + 1, cardLanguage);
if (thisUrl.equals(nextUrl)) {
//comment
if (onlyCheckCache) {
//comment
if (FamiliarActivity.getNetworkState(getActivity(), true) == -1) {
//comment
return false;
} else {
//comment
(new Handler()).post(() -> runGlideRequest(0, cardLanguage, width, height, false, target));
return true;
}
} else {
//comment
//comment
return false;
}
} else {
//comment
(new Handler()).post(() -> runGlideRequest(attempt + 1, cardLanguage, width, height, onlyCheckCache, target));
//comment
return true;
}
}

@Override
public boolean onResourceReady(Drawable resource, Object model, Target<Drawable> target, DataSource dataSource, boolean isFirstResource) {
//comment
return false;
}
});

//comment
if (onlyCheckCache) {
request = request.onlyRetrieveFromCache(true);
}

//comment
<start>if (0 != width && 0 != height) {
request = request
.override(width, height)
.fitCenter();
}<end>

//comment
return request.into(target);
}","private Target<Drawable> runGlideRequest(int attempt, String cardLanguage, int width, int height,
boolean onlyCheckCache, Target<Drawable> target) {
//comment
//comment
GlideRequest<Drawable> request = mGlideRequestManager
.load(mCard.getImageUrlString(attempt, cardLanguage))
.diskCacheStrategy(DiskCacheStrategy.ALL)
.listener(new RequestListener<Drawable>() {
@Override
public boolean onLoadFailed(@Nullable GlideException e, Object model, Target<Drawable> target, boolean isFirstResource) {
//comment
String thisUrl = mCard.getImageUrlString(attempt, cardLanguage);
String nextUrl = mCard.getImageUrlString(attempt + 1, cardLanguage);
if (thisUrl.equals(nextUrl)) {
//comment
if (onlyCheckCache) {
//comment
if (FamiliarActivity.getNetworkState(getActivity(), true) == -1) {
//comment
return false;
} else {
//comment
(new Handler()).post(() -> runGlideRequest(0, cardLanguage, width, height, false, target));
return true;
}
} else {
//comment
//comment
return false;
}
} else {
//comment
(new Handler()).post(() -> runGlideRequest(attempt + 1, cardLanguage, width, height, onlyCheckCache, target));
//comment
return true;
}
}

@Override
public boolean onResourceReady(Drawable resource, Object model, Target<Drawable> target, DataSource dataSource, boolean isFirstResource) {
//comment
return false;
}
});

//comment
if (onlyCheckCache) {
request = request.onlyRetrieveFromCache(true);
}

//comment
<start>if (0 != width && 0 != height) {
request = request
.override(width, height)
.fitCenter();
}<end>

//comment
return request.into(target);
}"
6206,"private Target<Drawable> runGlideRequest(int attempt, String cardLanguage, int width, int height,
boolean onlyCheckCache, Target<Drawable> target) {
//comment
//comment
GlideRequest<Drawable> request = mGlideRequestManager
.load(mCard.getImageUrlString(attempt, cardLanguage))
.diskCacheStrategy(DiskCacheStrategy.ALL)
.listener(new RequestListener<Drawable>() {
@Override
public boolean onLoadFailed(@Nullable GlideException e, Object model, Target<Drawable> target, boolean isFirstResource) {
//comment
String thisUrl = mCard.getImageUrlString(attempt, cardLanguage);
String nextUrl = mCard.getImageUrlString(attempt + 1, cardLanguage);
if (thisUrl.equals(nextUrl)) {
//comment
if (onlyCheckCache) {
//comment
if (FamiliarActivity.getNetworkState(getActivity(), true) == -1) {
//comment
return false;
} else {
//comment
(new Handler()).post(() -> runGlideRequest(0, cardLanguage, width, height, false, target));
return true;
}
} else {
//comment
//comment
return false;
}
} else {
//comment
(new Handler()).post(() -> runGlideRequest(attempt + 1, cardLanguage, width, height, onlyCheckCache, target));
//comment
return true;
}
}

@Override
public boolean onResourceReady(Drawable resource, Object model, Target<Drawable> target, DataSource dataSource, boolean isFirstResource) {
//comment
return false;
}
});

//comment
if (onlyCheckCache) {
request = request.onlyRetrieveFromCache(true);
}

//comment
if (0 != width && 0 != height) {
request = request
.override(width, height)
.fitCenter();
}

//comment
<start>return request.into(target);<end>
}","private Target<Drawable> runGlideRequest(int attempt, String cardLanguage, int width, int height,
boolean onlyCheckCache, Target<Drawable> target) {
//comment
//comment
GlideRequest<Drawable> request = mGlideRequestManager
.load(mCard.getImageUrlString(attempt, cardLanguage))
.diskCacheStrategy(DiskCacheStrategy.ALL)
.listener(new RequestListener<Drawable>() {
@Override
public boolean onLoadFailed(@Nullable GlideException e, Object model, Target<Drawable> target, boolean isFirstResource) {
//comment
String thisUrl = mCard.getImageUrlString(attempt, cardLanguage);
String nextUrl = mCard.getImageUrlString(attempt + 1, cardLanguage);
if (thisUrl.equals(nextUrl)) {
//comment
if (onlyCheckCache) {
//comment
if (FamiliarActivity.getNetworkState(getActivity(), true) == -1) {
//comment
return false;
} else {
//comment
(new Handler()).post(() -> runGlideRequest(0, cardLanguage, width, height, false, target));
return true;
}
} else {
//comment
//comment
return false;
}
} else {
//comment
(new Handler()).post(() -> runGlideRequest(attempt + 1, cardLanguage, width, height, onlyCheckCache, target));
//comment
return true;
}
}

@Override
public boolean onResourceReady(Drawable resource, Object model, Target<Drawable> target, DataSource dataSource, boolean isFirstResource) {
//comment
return false;
}
});

//comment
if (onlyCheckCache) {
request = request.onlyRetrieveFromCache(true);
}

//comment
if (0 != width && 0 != height) {
request = request
.override(width, height)
.fitCenter();
}

//comment
<start>return request.into(target);<end>
}"
1477,"@Override
public void onSaveInstanceState(@NonNull Bundle outState) {
Gathering savedGathering = new Gathering();

savedGathering.mDisplayMode = mDisplayModeSpinner.getSelectedItemPosition();

//comment
for (int idx = 0; idx < mLinearLayout.getChildCount(); idx++) {
<start>View player = mLinearLayout.getChildAt(idx);<end>
assert player != null;

EditText nameField = player.findViewById(R.id.custom_name);
assert nameField.getText() != null;
String name = nameField.getText().toString().trim();

int startingLife;
try {
EditText startingLifeField = player.findViewById(R.id.starting_life);
assert startingLifeField.getText() != null;
startingLife = Integer.parseInt(startingLifeField.getText().toString().trim());
} catch (NumberFormatException e) {
startingLife = 20;
}

savedGathering.mPlayerList.add(new GatheringsPlayerData(name, startingLife));
}
outState.remove(SAVED_GATHERING_KEY);
outState.remove(SAVED_NAME_KEY);
outState.putSerializable(SAVED_GATHERING_KEY, savedGathering);
outState.putString(SAVED_NAME_KEY, mCurrentGatheringName);

super.onSaveInstanceState(outState);
}","@Override
public void onSaveInstanceState(@NonNull Bundle outState) {
Gathering savedGathering = new Gathering();

savedGathering.mDisplayMode = mDisplayModeSpinner.getSelectedItemPosition();

//comment
<start>for (int idx = 0; idx < mLinearLayout.getChildCount(); idx++) {
View player = mLinearLayout.getChildAt(idx);
assert player != null;

EditText nameField = player.findViewById(R.id.custom_name);
assert nameField.getText() != null;
String name = nameField.getText().toString().trim();

int startingLife;
try {
EditText startingLifeField = player.findViewById(R.id.starting_life);
assert startingLifeField.getText() != null;
startingLife = Integer.parseInt(startingLifeField.getText().toString().trim());
} catch (NumberFormatException e) {
startingLife = 20;
}

savedGathering.mPlayerList.add(new GatheringsPlayerData(name, startingLife));
}<end>
outState.remove(SAVED_GATHERING_KEY);
outState.remove(SAVED_NAME_KEY);
outState.putSerializable(SAVED_GATHERING_KEY, savedGathering);
outState.putString(SAVED_NAME_KEY, mCurrentGatheringName);

super.onSaveInstanceState(outState);
}"
1478,"    public void showDialog(final int id) throws IllegalStateException {
//comment
//comment

//comment
<start>if (!this.isVisible()) {
return;
}<end>

removeDialog(getParentFragmentManager());

//comment
GatheringsDialogFragment newFragment = new GatheringsDialogFragment();
Bundle arguments = new Bundle();
arguments.putInt(FamiliarDialogFragment.ID_KEY, id);
newFragment.setArguments(arguments);
newFragment.show(getParentFragmentManager(), FamiliarActivity.DIALOG_TAG);
}","    public void showDialog(final int id) throws IllegalStateException {
//comment
//comment

//comment
<start>if (!this.isVisible()) {
return;
}<end>

removeDialog(getParentFragmentManager());

//comment
GatheringsDialogFragment newFragment = new GatheringsDialogFragment();
Bundle arguments = new Bundle();
arguments.putInt(FamiliarDialogFragment.ID_KEY, id);
newFragment.setArguments(arguments);
newFragment.show(getParentFragmentManager(), FamiliarActivity.DIALOG_TAG);
}"
1479,"    public void showDialog(final int id) throws IllegalStateException {
//comment
//comment

//comment
if (!this.isVisible()) {
return;
}

removeDialog(getParentFragmentManager());

//comment
<start>GatheringsDialogFragment newFragment = new GatheringsDialogFragment();<end>
Bundle arguments = new Bundle();
<start>arguments.putInt(FamiliarDialogFragment.ID_KEY, id);<end>
newFragment.setArguments(arguments);
newFragment.show(getParentFragmentManager(), FamiliarActivity.DIALOG_TAG);
}","    public void showDialog(final int id) throws IllegalStateException {
//comment
//comment

//comment
if (!this.isVisible()) {
return;
}

removeDialog(getParentFragmentManager());

//comment
<start>GatheringsDialogFragment newFragment = new GatheringsDialogFragment();
Bundle arguments = new Bundle();
arguments.putInt(FamiliarDialogFragment.ID_KEY, id);
newFragment.setArguments(arguments);
newFragment.show(getParentFragmentManager(), FamiliarActivity.DIALOG_TAG);<end>
}"
1758,"private synchronized void nextAttempt(boolean noConnectDelay)
{
try {
//comment
<start>if (isCancelled()) {
return;
}<end>

Optional<A> address = addressSelector.selectAddress(addressSelectionContext, attemptedAddresses);
if (!address.isPresent()) {
fail(""No hosts available"");
return;
}

if (invocationAttempts > 0) {
stat.recordRetry();
}

if (noConnectDelay) {
invoke(address.get());
return;
}

int connectionFailuresCount = failedConnectionAttempts.count(address.get());
if (connectionFailuresCount == 0) {
invoke(address.get());
return;
}

Duration connectDelay = retryPolicy.getBackoffDelay(connectionFailuresCount);
log.debug(""Failed connection to %s with attempt %s, will retry in %s"", address.get(), connectionFailuresCount, connectDelay);
schedule(connectDelay, () -> invoke(address.get()));
}
catch (Throwable t) {
//comment
unexpectedError(t);
}
}","private synchronized void nextAttempt(boolean noConnectDelay)
{
try {
//comment
<start>if (isCancelled()) {
return;
}<end>

Optional<A> address = addressSelector.selectAddress(addressSelectionContext, attemptedAddresses);
if (!address.isPresent()) {
fail(""No hosts available"");
return;
}

if (invocationAttempts > 0) {
stat.recordRetry();
}

if (noConnectDelay) {
invoke(address.get());
return;
}

int connectionFailuresCount = failedConnectionAttempts.count(address.get());
if (connectionFailuresCount == 0) {
invoke(address.get());
return;
}

Duration connectDelay = retryPolicy.getBackoffDelay(connectionFailuresCount);
log.debug(""Failed connection to %s with attempt %s, will retry in %s"", address.get(), connectionFailuresCount, connectDelay);
schedule(connectDelay, () -> invoke(address.get()));
}
catch (Throwable t) {
//comment
unexpectedError(t);
}
}"
1759,"private synchronized void handleFailure(A address, Throwable throwable)
{
try {
if (throwable instanceof ConnectionFailedException) {
failedConnections++;
}

ExceptionClassification exceptionClassification = retryPolicy.classifyException(throwable, metadata.isIdempotent());

//comment
<start>attemptedAddresses.add(address);<end>
if (exceptionClassification.getHostStatus() == NORMAL) {
//comment
lastException = throwable;
invocationAttempts++;
}
else if (exceptionClassification.getHostStatus() == DOWN || exceptionClassification.getHostStatus() == OVERLOADED) {
addressSelector.markdown(address);
failedConnectionAttempts.add(address);
if (exceptionClassification.getHostStatus() == OVERLOADED) {
overloadedRejects++;
}
}

//comment
Duration duration = succinctNanos(ticker.read() - startTime);
if (!exceptionClassification.isRetry().orElse(FALSE)) {
//comment
lastException = throwable;
fail(""Non-retryable exception"");
return;
}
if (invocationAttempts > retryPolicy.getMaxRetries()) {
fail(format(""Max retry attempts (%s) exceeded"", retryPolicy.getMaxRetries()));
return;
}
if (duration.compareTo(retryPolicy.getMaxRetryTime()) >= 0) {
fail(format(""Max retry time (%s) exceeded"", retryPolicy.getMaxRetryTime()));
return;
}

//comment
//comment
//comment
if (exceptionClassification.getHostStatus() != NORMAL) {
nextAttempt(false);
return;
}

//comment
Duration backoffDelay = retryPolicy.getBackoffDelay(invocationAttempts);
log.debug(""Failed invocation of %s with attempt %s, will retry in %s (overloadedRejects: %s). Exception: %s"",
metadata.getName(),
invocationAttempts,
backoffDelay,
overloadedRejects,
throwable.getMessage());
schedule(backoffDelay, () -> nextAttempt(true));
}
catch (Throwable t) {
//comment
unexpectedError(t);
}
}","private synchronized void handleFailure(A address, Throwable throwable)
{
try {
if (throwable instanceof ConnectionFailedException) {
failedConnections++;
}

<start>ExceptionClassification exceptionClassification = retryPolicy.classifyException(throwable, metadata.isIdempotent());<end>

//comment
<start>attemptedAddresses.add(address);
if (exceptionClassification.getHostStatus() == NORMAL) {
//comment
lastException = throwable;
invocationAttempts++;
}
else if (exceptionClassification.getHostStatus() == DOWN || exceptionClassification.getHostStatus() == OVERLOADED) {
addressSelector.markdown(address);
failedConnectionAttempts.add(address);
if (exceptionClassification.getHostStatus() == OVERLOADED) {
overloadedRejects++;
}
}<end>

//comment
Duration duration = succinctNanos(ticker.read() - startTime);
if (!exceptionClassification.isRetry().orElse(FALSE)) {
//comment
lastException = throwable;
fail(""Non-retryable exception"");
return;
}
if (invocationAttempts > retryPolicy.getMaxRetries()) {
fail(format(""Max retry attempts (%s) exceeded"", retryPolicy.getMaxRetries()));
return;
}
if (duration.compareTo(retryPolicy.getMaxRetryTime()) >= 0) {
fail(format(""Max retry time (%s) exceeded"", retryPolicy.getMaxRetryTime()));
return;
}

//comment
//comment
//comment
if (exceptionClassification.getHostStatus() != NORMAL) {
nextAttempt(false);
return;
}

//comment
Duration backoffDelay = retryPolicy.getBackoffDelay(invocationAttempts);
log.debug(""Failed invocation of %s with attempt %s, will retry in %s (overloadedRejects: %s). Exception: %s"",
metadata.getName(),
invocationAttempts,
backoffDelay,
overloadedRejects,
throwable.getMessage());
schedule(backoffDelay, () -> nextAttempt(true));
}
catch (Throwable t) {
//comment
unexpectedError(t);
}
}"
1760,"private synchronized void handleFailure(A address, Throwable throwable)
{
try {
if (throwable instanceof ConnectionFailedException) {
failedConnections++;
}

ExceptionClassification exceptionClassification = retryPolicy.classifyException(throwable, metadata.isIdempotent());

//comment
attemptedAddresses.add(address);
if (exceptionClassification.getHostStatus() == NORMAL) {
//comment
<start>lastException = throwable;<end>
invocationAttempts++;
}
else if (exceptionClassification.getHostStatus() == DOWN || exceptionClassification.getHostStatus() == OVERLOADED) {
addressSelector.markdown(address);
failedConnectionAttempts.add(address);
if (exceptionClassification.getHostStatus() == OVERLOADED) {
overloadedRejects++;
}
}

//comment
Duration duration = succinctNanos(ticker.read() - startTime);
if (!exceptionClassification.isRetry().orElse(FALSE)) {
//comment
lastException = throwable;
fail(""Non-retryable exception"");
return;
}
if (invocationAttempts > retryPolicy.getMaxRetries()) {
fail(format(""Max retry attempts (%s) exceeded"", retryPolicy.getMaxRetries()));
return;
}
if (duration.compareTo(retryPolicy.getMaxRetryTime()) >= 0) {
fail(format(""Max retry time (%s) exceeded"", retryPolicy.getMaxRetryTime()));
return;
}

//comment
//comment
//comment
if (exceptionClassification.getHostStatus() != NORMAL) {
nextAttempt(false);
return;
}

//comment
Duration backoffDelay = retryPolicy.getBackoffDelay(invocationAttempts);
log.debug(""Failed invocation of %s with attempt %s, will retry in %s (overloadedRejects: %s). Exception: %s"",
metadata.getName(),
invocationAttempts,
backoffDelay,
overloadedRejects,
throwable.getMessage());
schedule(backoffDelay, () -> nextAttempt(true));
}
catch (Throwable t) {
//comment
unexpectedError(t);
}
}","private synchronized void handleFailure(A address, Throwable throwable)
{
try {
if (throwable instanceof ConnectionFailedException) {
failedConnections++;
}

ExceptionClassification exceptionClassification = retryPolicy.classifyException(throwable, metadata.isIdempotent());

//comment
attemptedAddresses.add(address);
<start>if (exceptionClassification.getHostStatus() == NORMAL) {
//comment
lastException = throwable;
invocationAttempts++;
}<end>
else if (exceptionClassification.getHostStatus() == DOWN || exceptionClassification.getHostStatus() == OVERLOADED) {
addressSelector.markdown(address);
failedConnectionAttempts.add(address);
if (exceptionClassification.getHostStatus() == OVERLOADED) {
overloadedRejects++;
}
}

//comment
Duration duration = succinctNanos(ticker.read() - startTime);
if (!exceptionClassification.isRetry().orElse(FALSE)) {
//comment
lastException = throwable;
fail(""Non-retryable exception"");
return;
}
if (invocationAttempts > retryPolicy.getMaxRetries()) {
fail(format(""Max retry attempts (%s) exceeded"", retryPolicy.getMaxRetries()));
return;
}
if (duration.compareTo(retryPolicy.getMaxRetryTime()) >= 0) {
fail(format(""Max retry time (%s) exceeded"", retryPolicy.getMaxRetryTime()));
return;
}

//comment
//comment
//comment
if (exceptionClassification.getHostStatus() != NORMAL) {
nextAttempt(false);
return;
}

//comment
Duration backoffDelay = retryPolicy.getBackoffDelay(invocationAttempts);
log.debug(""Failed invocation of %s with attempt %s, will retry in %s (overloadedRejects: %s). Exception: %s"",
metadata.getName(),
invocationAttempts,
backoffDelay,
overloadedRejects,
throwable.getMessage());
schedule(backoffDelay, () -> nextAttempt(true));
}
catch (Throwable t) {
//comment
unexpectedError(t);
}
}"
1761,"private synchronized void handleFailure(A address, Throwable throwable)
{
try {
if (throwable instanceof ConnectionFailedException) {
failedConnections++;
}

ExceptionClassification exceptionClassification = retryPolicy.classifyException(throwable, metadata.isIdempotent());

//comment
attemptedAddresses.add(address);
if (exceptionClassification.getHostStatus() == NORMAL) {
//comment
lastException = throwable;
invocationAttempts++;
}
else if (exceptionClassification.getHostStatus() == DOWN || exceptionClassification.getHostStatus() == OVERLOADED) {
addressSelector.markdown(address);
failedConnectionAttempts.add(address);
if (exceptionClassification.getHostStatus() == OVERLOADED) {
overloadedRejects++;
}
}

//comment
Duration duration = succinctNanos(ticker.read() - startTime);
if (!exceptionClassification.isRetry().orElse(FALSE)) {
//comment
<start>lastException = throwable;<end>
fail(""Non-retryable exception"");
<start>return;<end>
}
if (invocationAttempts > retryPolicy.getMaxRetries()) {
fail(format(""Max retry attempts (%s) exceeded"", retryPolicy.getMaxRetries()));
return;
}
if (duration.compareTo(retryPolicy.getMaxRetryTime()) >= 0) {
fail(format(""Max retry time (%s) exceeded"", retryPolicy.getMaxRetryTime()));
return;
}

//comment
//comment
//comment
if (exceptionClassification.getHostStatus() != NORMAL) {
nextAttempt(false);
return;
}

//comment
Duration backoffDelay = retryPolicy.getBackoffDelay(invocationAttempts);
log.debug(""Failed invocation of %s with attempt %s, will retry in %s (overloadedRejects: %s). Exception: %s"",
metadata.getName(),
invocationAttempts,
backoffDelay,
overloadedRejects,
throwable.getMessage());
schedule(backoffDelay, () -> nextAttempt(true));
}
catch (Throwable t) {
//comment
unexpectedError(t);
}
}","private synchronized void handleFailure(A address, Throwable throwable)
{
try {
if (throwable instanceof ConnectionFailedException) {
failedConnections++;
}

ExceptionClassification exceptionClassification = retryPolicy.classifyException(throwable, metadata.isIdempotent());

//comment
attemptedAddresses.add(address);
if (exceptionClassification.getHostStatus() == NORMAL) {
//comment
lastException = throwable;
invocationAttempts++;
}
else if (exceptionClassification.getHostStatus() == DOWN || exceptionClassification.getHostStatus() == OVERLOADED) {
addressSelector.markdown(address);
failedConnectionAttempts.add(address);
if (exceptionClassification.getHostStatus() == OVERLOADED) {
overloadedRejects++;
}
}

//comment
Duration duration = succinctNanos(ticker.read() - startTime);
<start>if (!exceptionClassification.isRetry().orElse(FALSE)) {
//comment
lastException = throwable;
fail(""Non-retryable exception"");
return;
}<end>
if (invocationAttempts > retryPolicy.getMaxRetries()) {
fail(format(""Max retry attempts (%s) exceeded"", retryPolicy.getMaxRetries()));
return;
}
if (duration.compareTo(retryPolicy.getMaxRetryTime()) >= 0) {
fail(format(""Max retry time (%s) exceeded"", retryPolicy.getMaxRetryTime()));
return;
}

//comment
//comment
//comment
if (exceptionClassification.getHostStatus() != NORMAL) {
nextAttempt(false);
return;
}

//comment
Duration backoffDelay = retryPolicy.getBackoffDelay(invocationAttempts);
log.debug(""Failed invocation of %s with attempt %s, will retry in %s (overloadedRejects: %s). Exception: %s"",
metadata.getName(),
invocationAttempts,
backoffDelay,
overloadedRejects,
throwable.getMessage());
schedule(backoffDelay, () -> nextAttempt(true));
}
catch (Throwable t) {
//comment
unexpectedError(t);
}
}"
1762,"    private synchronized void fail(String reason)
{
Throwable cause = lastException;
if (cause == null) {
//comment
cause = new TTransportException(reason);
}

RetriesFailedException retriesFailedException = new RetriesFailedException(
reason,
invocationAttempts,
succinctNanos(ticker.read() - startTime),
failedConnections,
overloadedRejects);

//comment
if (cause instanceof DriftApplicationException) {
cause.getCause().addSuppressed(retriesFailedException);
}
else {
cause.addSuppressed(retriesFailedException);
}

setException(cause);
}","    private synchronized void fail(String reason)
{
<start>Throwable cause = lastException;
if (cause == null) {
//comment
cause = new TTransportException(reason);
}<end>

RetriesFailedException retriesFailedException = new RetriesFailedException(
reason,
invocationAttempts,
succinctNanos(ticker.read() - startTime),
failedConnections,
overloadedRejects);

//comment
if (cause instanceof DriftApplicationException) {
cause.getCause().addSuppressed(retriesFailedException);
}
else {
cause.addSuppressed(retriesFailedException);
}

setException(cause);
}"
1763,"    private synchronized void fail(String reason)
{
Throwable cause = lastException;
if (cause == null) {
//comment
cause = new TTransportException(reason);
}

RetriesFailedException retriesFailedException = new RetriesFailedException(
reason,
invocationAttempts,
succinctNanos(ticker.read() - startTime),
failedConnections,
overloadedRejects);

//comment
if (cause instanceof DriftApplicationException) {
cause.getCause().addSuppressed(retriesFailedException);
}
else {
cause.addSuppressed(retriesFailedException);
}

setException(cause);
}","    private synchronized void fail(String reason)
{
Throwable cause = lastException;
if (cause == null) {
//comment
cause = new TTransportException(reason);
}

RetriesFailedException retriesFailedException = new RetriesFailedException(
reason,
invocationAttempts,
succinctNanos(ticker.read() - startTime),
failedConnections,
overloadedRejects);

//comment
<start>if (cause instanceof DriftApplicationException) {
cause.getCause().addSuppressed(retriesFailedException);
}
else {
cause.addSuppressed(retriesFailedException);
}<end>

setException(cause);
}"
6564,"public void addDefaultCoercions(Class<?> coercionsClass)
{
requireNonNull(coercionsClass, ""coercionsClass is null"");
Map<ThriftType, Method> toThriftCoercions = new HashMap<>();
Map<ThriftType, Method> fromThriftCoercions = new HashMap<>();
for (Method method : coercionsClass.getDeclaredMethods()) {
if (method.isAnnotationPresent(ToThrift.class)) {
verifyCoercionMethod(method);
ThriftType thriftType = getThriftType(method.getGenericReturnType());
ThriftType coercedType = thriftType.coerceTo(method.getGenericParameterTypes()[0]);

Method oldValue = toThriftCoercions.put(coercedType, method);
checkArgument(
oldValue == null,
""Coercion class two @ToThrift methods (%s and %s) for type %s"",
coercionsClass.getName(),
method,
oldValue,
coercedType);
}
else if (method.isAnnotationPresent(FromThrift.class)) {
verifyCoercionMethod(method);
ThriftType thriftType = getThriftType(method.getGenericParameterTypes()[0]);
ThriftType coercedType = thriftType.coerceTo(method.getGenericReturnType());

Method oldValue = fromThriftCoercions.put(coercedType, method);
checkArgument(
oldValue == null,
""Coercion class two @FromThrift methods (%s and %s) for type %s"",
coercionsClass.getName(),
method,
oldValue,
coercedType);
}
}

//comment
<start>Set<ThriftType> difference = Sets.symmetricDifference(toThriftCoercions.keySet(), fromThriftCoercions.keySet());<end>
checkArgument(
difference.isEmpty(),
""Coercion class %s does not have matched @ToThrift and @FromThrift methods for types %s"",
coercionsClass.getName(),
difference);

//comment
Map<Type, TypeCoercion> coercions = new HashMap<>();
for (Map.Entry<ThriftType, Method> entry : toThriftCoercions.entrySet()) {
ThriftType type = entry.getKey();
Method toThriftMethod = entry.getValue();
Method fromThriftMethod = fromThriftCoercions.get(type);
//comment
checkState(
fromThriftMethod != null,
""Coercion class %s does not have matched @ToThrift and @FromThrift methods for type %s"",
coercionsClass.getName(),
type);
TypeCoercion coercion = new TypeCoercion(type, toThriftMethod, fromThriftMethod);
coercions.put(type.getJavaType(), coercion);
}
this.coercions.putAll(coercions);
}","public void addDefaultCoercions(Class<?> coercionsClass)
{
requireNonNull(coercionsClass, ""coercionsClass is null"");
Map<ThriftType, Method> toThriftCoercions = new HashMap<>();
Map<ThriftType, Method> fromThriftCoercions = new HashMap<>();
for (Method method : coercionsClass.getDeclaredMethods()) {
if (method.isAnnotationPresent(ToThrift.class)) {
verifyCoercionMethod(method);
ThriftType thriftType = getThriftType(method.getGenericReturnType());
ThriftType coercedType = thriftType.coerceTo(method.getGenericParameterTypes()[0]);

Method oldValue = toThriftCoercions.put(coercedType, method);
checkArgument(
oldValue == null,
""Coercion class two @ToThrift methods (%s and %s) for type %s"",
coercionsClass.getName(),
method,
oldValue,
coercedType);
}
else if (method.isAnnotationPresent(FromThrift.class)) {
verifyCoercionMethod(method);
ThriftType thriftType = getThriftType(method.getGenericParameterTypes()[0]);
ThriftType coercedType = thriftType.coerceTo(method.getGenericReturnType());

Method oldValue = fromThriftCoercions.put(coercedType, method);
checkArgument(
oldValue == null,
""Coercion class two @FromThrift methods (%s and %s) for type %s"",
coercionsClass.getName(),
method,
oldValue,
coercedType);
}
}

//comment
<start>Set<ThriftType> difference = Sets.symmetricDifference(toThriftCoercions.keySet(), fromThriftCoercions.keySet());
checkArgument(
difference.isEmpty(),
""Coercion class %s does not have matched @ToThrift and @FromThrift methods for types %s"",
coercionsClass.getName(),
difference);<end>

//comment
Map<Type, TypeCoercion> coercions = new HashMap<>();
for (Map.Entry<ThriftType, Method> entry : toThriftCoercions.entrySet()) {
ThriftType type = entry.getKey();
Method toThriftMethod = entry.getValue();
Method fromThriftMethod = fromThriftCoercions.get(type);
//comment
checkState(
fromThriftMethod != null,
""Coercion class %s does not have matched @ToThrift and @FromThrift methods for type %s"",
coercionsClass.getName(),
type);
TypeCoercion coercion = new TypeCoercion(type, toThriftMethod, fromThriftMethod);
coercions.put(type.getJavaType(), coercion);
}
this.coercions.putAll(coercions);
}"
6565,"public void addDefaultCoercions(Class<?> coercionsClass)
{
requireNonNull(coercionsClass, ""coercionsClass is null"");
Map<ThriftType, Method> toThriftCoercions = new HashMap<>();
Map<ThriftType, Method> fromThriftCoercions = new HashMap<>();
for (Method method : coercionsClass.getDeclaredMethods()) {
if (method.isAnnotationPresent(ToThrift.class)) {
verifyCoercionMethod(method);
ThriftType thriftType = getThriftType(method.getGenericReturnType());
ThriftType coercedType = thriftType.coerceTo(method.getGenericParameterTypes()[0]);

Method oldValue = toThriftCoercions.put(coercedType, method);
checkArgument(
oldValue == null,
""Coercion class two @ToThrift methods (%s and %s) for type %s"",
coercionsClass.getName(),
method,
oldValue,
coercedType);
}
else if (method.isAnnotationPresent(FromThrift.class)) {
verifyCoercionMethod(method);
ThriftType thriftType = getThriftType(method.getGenericParameterTypes()[0]);
ThriftType coercedType = thriftType.coerceTo(method.getGenericReturnType());

Method oldValue = fromThriftCoercions.put(coercedType, method);
checkArgument(
oldValue == null,
""Coercion class two @FromThrift methods (%s and %s) for type %s"",
coercionsClass.getName(),
method,
oldValue,
coercedType);
}
}

//comment
Set<ThriftType> difference = Sets.symmetricDifference(toThriftCoercions.keySet(), fromThriftCoercions.keySet());
checkArgument(
difference.isEmpty(),
""Coercion class %s does not have matched @ToThrift and @FromThrift methods for types %s"",
coercionsClass.getName(),
difference);

//comment
<start>Map<Type, TypeCoercion> coercions = new HashMap<>();<end>
for (Map.Entry<ThriftType, Method> entry : toThriftCoercions.entrySet()) {
ThriftType type = entry.getKey();
Method toThriftMethod = entry.getValue();
Method fromThriftMethod = fromThriftCoercions.get(type);
//comment
checkState(
fromThriftMethod != null,
""Coercion class %s does not have matched @ToThrift and @FromThrift methods for type %s"",
coercionsClass.getName(),
type);
TypeCoercion coercion = new TypeCoercion(type, toThriftMethod, fromThriftMethod);
coercions.put(type.getJavaType(), coercion);
}
this.coercions.putAll(coercions);
}","public void addDefaultCoercions(Class<?> coercionsClass)
{
requireNonNull(coercionsClass, ""coercionsClass is null"");
Map<ThriftType, Method> toThriftCoercions = new HashMap<>();
Map<ThriftType, Method> fromThriftCoercions = new HashMap<>();
for (Method method : coercionsClass.getDeclaredMethods()) {
if (method.isAnnotationPresent(ToThrift.class)) {
verifyCoercionMethod(method);
ThriftType thriftType = getThriftType(method.getGenericReturnType());
ThriftType coercedType = thriftType.coerceTo(method.getGenericParameterTypes()[0]);

Method oldValue = toThriftCoercions.put(coercedType, method);
checkArgument(
oldValue == null,
""Coercion class two @ToThrift methods (%s and %s) for type %s"",
coercionsClass.getName(),
method,
oldValue,
coercedType);
}
else if (method.isAnnotationPresent(FromThrift.class)) {
verifyCoercionMethod(method);
ThriftType thriftType = getThriftType(method.getGenericParameterTypes()[0]);
ThriftType coercedType = thriftType.coerceTo(method.getGenericReturnType());

Method oldValue = fromThriftCoercions.put(coercedType, method);
checkArgument(
oldValue == null,
""Coercion class two @FromThrift methods (%s and %s) for type %s"",
coercionsClass.getName(),
method,
oldValue,
coercedType);
}
}

//comment
Set<ThriftType> difference = Sets.symmetricDifference(toThriftCoercions.keySet(), fromThriftCoercions.keySet());
checkArgument(
difference.isEmpty(),
""Coercion class %s does not have matched @ToThrift and @FromThrift methods for types %s"",
coercionsClass.getName(),
difference);

//comment
<start>Map<Type, TypeCoercion> coercions = new HashMap<>();
for (Map.Entry<ThriftType, Method> entry : toThriftCoercions.entrySet()) {
ThriftType type = entry.getKey();
Method toThriftMethod = entry.getValue();
Method fromThriftMethod = fromThriftCoercions.get(type);
//comment
checkState(
fromThriftMethod != null,
""Coercion class %s does not have matched @ToThrift and @FromThrift methods for type %s"",
coercionsClass.getName(),
type);
TypeCoercion coercion = new TypeCoercion(type, toThriftMethod, fromThriftMethod);
coercions.put(type.getJavaType(), coercion);
}
this.coercions.putAll(coercions);<end>
}"
6566,"private ThriftType buildThriftTypeInternal(Type javaType)
throws IllegalArgumentException
{
Class<?> rawType = TypeToken.of(javaType).getRawType();
ThriftType manualType = manualTypes.get(rawType);
if (manualType != null) {
return manualType;
}
if (boolean.class == rawType) {
return BOOL;
}
if (byte.class == rawType) {
return BYTE;
}
if (short.class == rawType) {
return I16;
}
if (int.class == rawType) {
return I32;
}
if (long.class == rawType) {
return I64;
}
if (double.class == rawType) {
return DOUBLE;
}
if (String.class == rawType) {
return STRING;
}
if (ByteBuffer.class.isAssignableFrom(rawType)) {
return BINARY;
}
if (Enum.class.isAssignableFrom(rawType)) {
ThriftEnumMetadata<? extends Enum<?>> thriftEnumMetadata = getThriftEnumMetadata(rawType);
return enumType(thriftEnumMetadata);
}
if (rawType.isArray()) {
Class<?> elementType = rawType.getComponentType();
if (elementType == byte.class) {
//comment
return coercions.get(javaType).getThriftType();
}
return array(getCollectionElementThriftTypeReference(elementType));
}
if (Map.class.isAssignableFrom(rawType)) {
Type mapKeyType = getMapKeyType(javaType);
Type mapValueType = getMapValueType(javaType);
return map(getMapKeyThriftTypeReference(mapKeyType), getMapValueThriftTypeReference(mapValueType));
}
if (Set.class.isAssignableFrom(rawType)) {
Type elementType = getIterableType(javaType);
return set(getCollectionElementThriftTypeReference(elementType));
}
if (Iterable.class.isAssignableFrom(rawType)) {
Type elementType = getIterableType(javaType);
return list(getCollectionElementThriftTypeReference(elementType));
}
if (Optional.class.isAssignableFrom(rawType)) {
Type elementType = getOptionalType(javaType);
return optional(getOptionalThriftTypeReference(elementType));
}
//comment
if (void.class.isAssignableFrom(rawType) || Void.class.isAssignableFrom(rawType)) {
return VOID;
}
if (isStructType(rawType)) {
ThriftStructMetadata structMetadata = getThriftStructMetadata(javaType);
//comment
return struct(structMetadata);
}

if (ListenableFuture.class.isAssignableFrom(rawType)) {
Type returnType = getFutureReturnType(javaType);
//comment
//comment
return getThriftType(returnType);
}

//comment
TypeCoercion coercion = coercions.get(javaType);
<start>if (coercion != null) {
return coercion.getThriftType();
}<end>
throw new IllegalArgumentException(""Type can not be coerced to a Thrift type: "" + javaType);
}","private ThriftType buildThriftTypeInternal(Type javaType)
throws IllegalArgumentException
{
Class<?> rawType = TypeToken.of(javaType).getRawType();
ThriftType manualType = manualTypes.get(rawType);
if (manualType != null) {
return manualType;
}
if (boolean.class == rawType) {
return BOOL;
}
if (byte.class == rawType) {
return BYTE;
}
if (short.class == rawType) {
return I16;
}
if (int.class == rawType) {
return I32;
}
if (long.class == rawType) {
return I64;
}
if (double.class == rawType) {
return DOUBLE;
}
if (String.class == rawType) {
return STRING;
}
if (ByteBuffer.class.isAssignableFrom(rawType)) {
return BINARY;
}
if (Enum.class.isAssignableFrom(rawType)) {
ThriftEnumMetadata<? extends Enum<?>> thriftEnumMetadata = getThriftEnumMetadata(rawType);
return enumType(thriftEnumMetadata);
}
if (rawType.isArray()) {
Class<?> elementType = rawType.getComponentType();
if (elementType == byte.class) {
//comment
return coercions.get(javaType).getThriftType();
}
return array(getCollectionElementThriftTypeReference(elementType));
}
if (Map.class.isAssignableFrom(rawType)) {
Type mapKeyType = getMapKeyType(javaType);
Type mapValueType = getMapValueType(javaType);
return map(getMapKeyThriftTypeReference(mapKeyType), getMapValueThriftTypeReference(mapValueType));
}
if (Set.class.isAssignableFrom(rawType)) {
Type elementType = getIterableType(javaType);
return set(getCollectionElementThriftTypeReference(elementType));
}
if (Iterable.class.isAssignableFrom(rawType)) {
Type elementType = getIterableType(javaType);
return list(getCollectionElementThriftTypeReference(elementType));
}
if (Optional.class.isAssignableFrom(rawType)) {
Type elementType = getOptionalType(javaType);
return optional(getOptionalThriftTypeReference(elementType));
}
//comment
if (void.class.isAssignableFrom(rawType) || Void.class.isAssignableFrom(rawType)) {
return VOID;
}
if (isStructType(rawType)) {
ThriftStructMetadata structMetadata = getThriftStructMetadata(javaType);
//comment
return struct(structMetadata);
}

if (ListenableFuture.class.isAssignableFrom(rawType)) {
Type returnType = getFutureReturnType(javaType);
//comment
//comment
return getThriftType(returnType);
}

//comment
<start>TypeCoercion coercion = coercions.get(javaType);
if (coercion != null) {
return coercion.getThriftType();
}
throw new IllegalArgumentException(""Type can not be coerced to a Thrift type: "" + javaType);<end>
}"
6567,"    private ThriftTypeReference getThriftTypeReference(Type javaType, Recursiveness recursiveness)
{
ThriftType thriftType = getThriftTypeFromCache(javaType);
if (thriftType == null) {
if (recursiveness == Recursiveness.FORCED ||
<start>(recursiveness == Recursiveness.ALLOWED && stack.get().contains(javaType))) {<end>
//comment
deferredTypesWorkList.get().add(javaType);
<start>return new RecursiveThriftTypeReference(this, javaType);<end>
}
else {
thriftType = buildThriftType(javaType);
typeCache.putIfAbsent(javaType, thriftType);
}
}
return new DefaultThriftTypeReference(thriftType);
}","    private ThriftTypeReference getThriftTypeReference(Type javaType, Recursiveness recursiveness)
{
ThriftType thriftType = getThriftTypeFromCache(javaType);
if (thriftType == null) {
if (recursiveness == Recursiveness.FORCED ||
(recursiveness == Recursiveness.ALLOWED && stack.get().contains(javaType))) {
//comment
deferredTypesWorkList.get().add(javaType);
<start>return new RecursiveThriftTypeReference(this, javaType);<end>
}
else {
thriftType = buildThriftType(javaType);
typeCache.putIfAbsent(javaType, thriftType);
}
}
return new DefaultThriftTypeReference(thriftType);
}"
6568,"public ThriftProtocolType getThriftProtocolType(Type javaType)
{
ThriftType manualType = manualTypes.get(javaType);
if (manualType != null) {
return manualType.getProtocolType();
}

Class<?> rawType = TypeToken.of(javaType).getRawType();

if (boolean.class == rawType) {
return ThriftProtocolType.BOOL;
}
if (byte.class == rawType) {
return ThriftProtocolType.BYTE;
}
if (short.class == rawType) {
return ThriftProtocolType.I16;
}
if (int.class == rawType) {
return ThriftProtocolType.I32;
}
if (long.class == rawType) {
return ThriftProtocolType.I64;
}
if (double.class == rawType) {
return ThriftProtocolType.DOUBLE;
}
if (String.class == rawType) {
return ThriftProtocolType.STRING;
}
if (ByteBuffer.class.isAssignableFrom(rawType)) {
return ThriftProtocolType.BINARY;
}
if (Enum.class.isAssignableFrom(rawType)) {
return ThriftProtocolType.ENUM;
}
if (rawType.isArray()) {
Class<?> elementType = rawType.getComponentType();
if (isSupportedArrayComponentType(elementType)) {
return ThriftProtocolType.LIST;
}
}
if (Map.class.isAssignableFrom(rawType)) {
Type mapKeyType = getMapKeyType(javaType);
Type mapValueType = getMapValueType(javaType);
if (isSupportedStructFieldType(mapKeyType) &&
isSupportedStructFieldType(mapValueType)) {
return ThriftProtocolType.MAP;
}
}
if (Set.class.isAssignableFrom(rawType)) {
Type elementType = getIterableType(javaType);
if (isSupportedStructFieldType(elementType)) {
return ThriftProtocolType.SET;
}
}
if (Iterable.class.isAssignableFrom(rawType)) {
Type elementType = getIterableType(javaType);
if (isSupportedStructFieldType(elementType)) {
return ThriftProtocolType.LIST;
}
}
if (Optional.class.isAssignableFrom(rawType)) {
Type elementType = getOptionalType(javaType);
return getThriftProtocolType(elementType);
}
if (isStructType(rawType)) {
return ThriftProtocolType.STRUCT;
}

//comment

//comment
TypeCoercion coercion = coercions.get(javaType);
if (coercion != null) {
<start>return coercion.getThriftType().getProtocolType();<end>
}

return ThriftProtocolType.UNKNOWN;
}","public ThriftProtocolType getThriftProtocolType(Type javaType)
{
ThriftType manualType = manualTypes.get(javaType);
if (manualType != null) {
return manualType.getProtocolType();
}

Class<?> rawType = TypeToken.of(javaType).getRawType();

if (boolean.class == rawType) {
return ThriftProtocolType.BOOL;
}
if (byte.class == rawType) {
return ThriftProtocolType.BYTE;
}
if (short.class == rawType) {
return ThriftProtocolType.I16;
}
if (int.class == rawType) {
return ThriftProtocolType.I32;
}
if (long.class == rawType) {
return ThriftProtocolType.I64;
}
if (double.class == rawType) {
return ThriftProtocolType.DOUBLE;
}
if (String.class == rawType) {
return ThriftProtocolType.STRING;
}
if (ByteBuffer.class.isAssignableFrom(rawType)) {
return ThriftProtocolType.BINARY;
}
if (Enum.class.isAssignableFrom(rawType)) {
return ThriftProtocolType.ENUM;
}
if (rawType.isArray()) {
Class<?> elementType = rawType.getComponentType();
if (isSupportedArrayComponentType(elementType)) {
return ThriftProtocolType.LIST;
}
}
if (Map.class.isAssignableFrom(rawType)) {
Type mapKeyType = getMapKeyType(javaType);
Type mapValueType = getMapValueType(javaType);
if (isSupportedStructFieldType(mapKeyType) &&
isSupportedStructFieldType(mapValueType)) {
return ThriftProtocolType.MAP;
}
}
if (Set.class.isAssignableFrom(rawType)) {
Type elementType = getIterableType(javaType);
if (isSupportedStructFieldType(elementType)) {
return ThriftProtocolType.SET;
}
}
if (Iterable.class.isAssignableFrom(rawType)) {
Type elementType = getIterableType(javaType);
if (isSupportedStructFieldType(elementType)) {
return ThriftProtocolType.LIST;
}
}
if (Optional.class.isAssignableFrom(rawType)) {
Type elementType = getOptionalType(javaType);
return getThriftProtocolType(elementType);
}
if (isStructType(rawType)) {
return ThriftProtocolType.STRUCT;
}

//comment

//comment
<start>TypeCoercion coercion = coercions.get(javaType);
if (coercion != null) {
return coercion.getThriftType().getProtocolType();
}<end>

return ThriftProtocolType.UNKNOWN;
}"
6589,"private void writeFieldBeginInternal(TField field, byte typeOverride)
throws TException
{
//comment

//comment
byte typeToWrite = typeOverride == -1 ? getCompactType(field.getType()) : typeOverride;

//comment
if (field.getId() > lastFieldId && field.getId() - lastFieldId <= 15) {
//comment
<start>writeByteDirect((field.getId() - lastFieldId) << 4 | typeToWrite);<end>
}
else {
//comment
writeByteDirect(typeToWrite);
writeI16(field.getId());
}

lastFieldId = field.getId();
}","private void writeFieldBeginInternal(TField field, byte typeOverride)
throws TException
{
//comment

//comment
byte typeToWrite = typeOverride == -1 ? getCompactType(field.getType()) : typeOverride;

//comment
if (field.getId() > lastFieldId && field.getId() - lastFieldId <= 15) {
//comment
<start>writeByteDirect((field.getId() - lastFieldId) << 4 | typeToWrite);<end>
}
else {
//comment
writeByteDirect(typeToWrite);
writeI16(field.getId());
}

lastFieldId = field.getId();
}"
6590,"private void writeFieldBeginInternal(TField field, byte typeOverride)
throws TException
{
//comment

//comment
byte typeToWrite = typeOverride == -1 ? getCompactType(field.getType()) : typeOverride;

//comment
if (field.getId() > lastFieldId && field.getId() - lastFieldId <= 15) {
//comment
<start>writeByteDirect((field.getId() - lastFieldId) << 4 | typeToWrite);<end>
}
else {
//comment
<start>writeByteDirect(typeToWrite);<end>
writeI16(field.getId());
}

lastFieldId = field.getId();
}","private void writeFieldBeginInternal(TField field, byte typeOverride)
throws TException
{
//comment

//comment
byte typeToWrite = typeOverride == -1 ? getCompactType(field.getType()) : typeOverride;

//comment
if (field.getId() > lastFieldId && field.getId() - lastFieldId <= 15) {
//comment
writeByteDirect((field.getId() - lastFieldId) << 4 | typeToWrite);
}
else {
//comment
<start>writeByteDirect(typeToWrite);
writeI16(field.getId());<end>
}

lastFieldId = field.getId();
}"
6595,"@Override
public TField readFieldBegin()
throws TException
{
byte type = readByte();

//comment
if (type == TType.STOP) {
return TSTOP;
}

short fieldId;

//comment
short modifier = (short) ((type & 0xf0) >> 4);
if (modifier == 0) {
//comment
fieldId = readI16();
}
else {
//comment
fieldId = (short) (lastFieldId + modifier);
}

TField field = new TField("""", getTType((byte) (type & 0x0f)), fieldId);

//comment
if (isBoolType(type)) {
//comment
booleanValue = (byte) (type & 0x0f) == Types.BOOLEAN_TRUE ? Boolean.TRUE : Boolean.FALSE;
}

//comment
<start>lastFieldId = field.getId();<end>
return field;
}","@Override
public TField readFieldBegin()
throws TException
{
byte type = readByte();

//comment
if (type == TType.STOP) {
return TSTOP;
}

short fieldId;

//comment
short modifier = (short) ((type & 0xf0) >> 4);
if (modifier == 0) {
//comment
fieldId = readI16();
}
else {
//comment
fieldId = (short) (lastFieldId + modifier);
}

TField field = new TField("""", getTType((byte) (type & 0x0f)), fieldId);

//comment
if (isBoolType(type)) {
//comment
booleanValue = (byte) (type & 0x0f) == Types.BOOLEAN_TRUE ? Boolean.TRUE : Boolean.FALSE;
}

//comment
<start>lastFieldId = field.getId();<end>
return field;
}"
6571,"private synchronized void handleFailure(A address, Throwable throwable)
{
try {
if (throwable instanceof ConnectionFailedException) {
failedConnections++;
}

ExceptionClassification exceptionClassification = retryPolicy.classifyException(throwable, metadata.isIdempotent());

//comment
attemptedAddresses.add(address);
if (exceptionClassification.getHostStatus() == NORMAL) {
//comment
lastException = throwable;
invocationAttempts++;
}
else if (exceptionClassification.getHostStatus() == DOWN || exceptionClassification.getHostStatus() == OVERLOADED) {
addressSelector.markdown(address);
failedConnectionAttempts.add(address);
if (exceptionClassification.getHostStatus() == OVERLOADED) {
overloadedRejects++;
}
}

//comment
Duration duration = succinctNanos(ticker.read() - startTime);
if (!exceptionClassification.isRetry().orElse(FALSE)) {
//comment
lastException = throwable;
fail(""Non-retryable exception"");
return;
}
if (invocationAttempts > retryPolicy.getMaxRetries()) {
fail(format(""Max retry attempts (%s) exceeded"", retryPolicy.getMaxRetries()));
return;
}
if (duration.compareTo(retryPolicy.getMaxRetryTime()) >= 0) {
fail(format(""Max retry time (%s) exceeded"", retryPolicy.getMaxRetryTime()));
return;
}

//comment
//comment
//comment
if (exceptionClassification.getHostStatus() != NORMAL) {
nextAttempt(false);
return;
}

//comment
<start>Duration backoffDelay = retryPolicy.getBackoffDelay(invocationAttempts);
log.debug(""Failed invocation of %s with attempt %s, will retry in %s (overloadedRejects: %s). Exception: %s"",
metadata.getName(),
invocationAttempts,
backoffDelay,
overloadedRejects,
throwable.getMessage());<end>
schedule(backoffDelay, () -> nextAttempt(true));
}
catch (Throwable t) {
//comment
unexpectedError(t);
}
}","private synchronized void handleFailure(A address, Throwable throwable)
{
try {
if (throwable instanceof ConnectionFailedException) {
failedConnections++;
}

ExceptionClassification exceptionClassification = retryPolicy.classifyException(throwable, metadata.isIdempotent());

//comment
attemptedAddresses.add(address);
if (exceptionClassification.getHostStatus() == NORMAL) {
//comment
lastException = throwable;
invocationAttempts++;
}
else if (exceptionClassification.getHostStatus() == DOWN || exceptionClassification.getHostStatus() == OVERLOADED) {
addressSelector.markdown(address);
failedConnectionAttempts.add(address);
if (exceptionClassification.getHostStatus() == OVERLOADED) {
overloadedRejects++;
}
}

//comment
Duration duration = succinctNanos(ticker.read() - startTime);
if (!exceptionClassification.isRetry().orElse(FALSE)) {
//comment
lastException = throwable;
fail(""Non-retryable exception"");
return;
}
if (invocationAttempts > retryPolicy.getMaxRetries()) {
fail(format(""Max retry attempts (%s) exceeded"", retryPolicy.getMaxRetries()));
return;
}
if (duration.compareTo(retryPolicy.getMaxRetryTime()) >= 0) {
fail(format(""Max retry time (%s) exceeded"", retryPolicy.getMaxRetryTime()));
return;
}

//comment
//comment
//comment
if (exceptionClassification.getHostStatus() != NORMAL) {
nextAttempt(false);
return;
}

//comment
<start>Duration backoffDelay = retryPolicy.getBackoffDelay(invocationAttempts);<end>
log.debug(""Failed invocation of %s with attempt %s, will retry in %s (overloadedRejects: %s). Exception: %s"",
metadata.getName(),
invocationAttempts,
backoffDelay,
overloadedRejects,
throwable.getMessage());
schedule(backoffDelay, () -> nextAttempt(true));
}
catch (Throwable t) {
//comment
unexpectedError(t);
}
}"
6596,"    protected final void verifyClass(Class<? extends Annotation> annotation)
{
String annotationName = annotation.getSimpleName();
String structClassName = getStructClass().getName();

//comment
<start>if (!Modifier.isPublic(getStructClass().getModifiers())) {
metadataErrors.addError(""%s class '%s' is not public"", annotationName, structClassName);
}<end>

if (!getStructClass().isAnnotationPresent(annotation)) {
metadataErrors.addError(""%s class '%s' does not have a @%s annotation"", annotationName, structClassName, annotationName);
}
}","    protected final void verifyClass(Class<? extends Annotation> annotation)
{
String annotationName = annotation.getSimpleName();
String structClassName = getStructClass().getName();

//comment
<start>if (!Modifier.isPublic(getStructClass().getModifiers())) {
metadataErrors.addError(""%s class '%s' is not public"", annotationName, structClassName);
}<end>

if (!getStructClass().isAnnotationPresent(annotation)) {
metadataErrors.addError(""%s class '%s' does not have a @%s annotation"", annotationName, structClassName, annotationName);
}
}"
6597,"    protected final void extractFromConstructors()
{
if (builderType == null) {
//comment
addConstructors(structType);
}
else {
//comment
addConstructors(builderType);

//comment
addBuilderMethods();

//comment
for (Constructor<?> constructor : getStructClass().getConstructors()) {
<start>if (constructor.isAnnotationPresent(ThriftConstructor.class)) {
metadataErrors.addWarning(
""Thrift class '%s' has a builder class, but constructor '%s' annotated with @ThriftConstructor"",
getStructClass().getName(),
constructor);
}<end>
}
}
}","    protected final void extractFromConstructors()
{
if (builderType == null) {
//comment
addConstructors(structType);
}
else {
//comment
addConstructors(builderType);

//comment
addBuilderMethods();

//comment
<start>for (Constructor<?> constructor : getStructClass().getConstructors()) {
if (constructor.isAnnotationPresent(ThriftConstructor.class)) {
metadataErrors.addWarning(
""Thrift class '%s' has a builder class, but constructor '%s' annotated with @ThriftConstructor"",
getStructClass().getName(),
constructor);
}
}<end>
}
}"
6598,"protected final void addBuilderMethods()
{
for (Method method : findAnnotatedMethods(getBuilderClass(), ThriftConstructor.class)) {
List<ParameterInjection> parameters = getParameterInjections(
builderType,
method.getParameterAnnotations(),
resolveFieldTypes(builderType, method.getGenericParameterTypes()),
extractParameterNames(method));

//comment
if (parameters != null) {
fields.addAll(parameters);
builderMethodInjections.add(new MethodInjection(method, parameters));
}

if (!getStructClass().isAssignableFrom(method.getReturnType())) {
metadataErrors.addError(
""'%s' says that '%s' is its builder class, but @ThriftConstructor method '%s' in the builder does not build an instance assignable to that type"",
structType,
builderType,
method.getName());
}
}

//comment
for (Method method : getAllDeclaredMethods(getBuilderClass())) {
if (method.isAnnotationPresent(ThriftConstructor.class) || hasThriftFieldAnnotation(method)) {
<start>if (!Modifier.isPublic(method.getModifiers())) {
metadataErrors.addError(""@ThriftConstructor method '%s' is not public"", method.toGenericString());
}
if (Modifier.isStatic(method.getModifiers())) {
metadataErrors.addError(""@ThriftConstructor method '%s' is static"", method.toGenericString());
}<end>
}
}

if (builderMethodInjections.isEmpty()) {
metadataErrors.addError(""Struct builder class '%s' does not have a public builder method annotated with @ThriftConstructor"", getBuilderClass().getName());
}
if (builderMethodInjections.size() > 1) {
metadataErrors.addError(""Multiple builder methods are annotated with @ThriftConstructor "", builderMethodInjections);
}
}","protected final void addBuilderMethods()
{
for (Method method : findAnnotatedMethods(getBuilderClass(), ThriftConstructor.class)) {
List<ParameterInjection> parameters = getParameterInjections(
builderType,
method.getParameterAnnotations(),
resolveFieldTypes(builderType, method.getGenericParameterTypes()),
extractParameterNames(method));

//comment
if (parameters != null) {
fields.addAll(parameters);
builderMethodInjections.add(new MethodInjection(method, parameters));
}

if (!getStructClass().isAssignableFrom(method.getReturnType())) {
metadataErrors.addError(
""'%s' says that '%s' is its builder class, but @ThriftConstructor method '%s' in the builder does not build an instance assignable to that type"",
structType,
builderType,
method.getName());
}
}

//comment
<start>for (Method method : getAllDeclaredMethods(getBuilderClass())) {
if (method.isAnnotationPresent(ThriftConstructor.class) || hasThriftFieldAnnotation(method)) {
if (!Modifier.isPublic(method.getModifiers())) {
metadataErrors.addError(""@ThriftConstructor method '%s' is not public"", method.toGenericString());
}
if (Modifier.isStatic(method.getModifiers())) {
metadataErrors.addError(""@ThriftConstructor method '%s' is static"", method.toGenericString());
}
}
}<end>

if (builderMethodInjections.isEmpty()) {
metadataErrors.addError(""Struct builder class '%s' does not have a public builder method annotated with @ThriftConstructor"", getBuilderClass().getName());
}
if (builderMethodInjections.size() > 1) {
metadataErrors.addError(""Multiple builder methods are annotated with @ThriftConstructor "", builderMethodInjections);
}
}"
6599,"    protected final void addFields(Class<?> clazz, boolean allowReaders, boolean allowWriters)
{
<start>for (Field fieldField : ReflectionHelper.findAnnotatedFields(clazz, ThriftField.class)) {
addField(fieldField, allowReaders, allowWriters);
}<end>

//comment
for (Field field : getAllDeclaredFields(clazz)) {
if (field.isAnnotationPresent(ThriftField.class)) {
<start>if (!Modifier.isPublic(field.getModifiers())) {
metadataErrors.addError(""@ThriftField field '%s' is not public"", field.toGenericString());
}
if (Modifier.isStatic(field.getModifiers())) {
metadataErrors.addError(""@ThriftField field '%s' is static"", field.toGenericString());
}<end>
}
}
}","    protected final void addFields(Class<?> clazz, boolean allowReaders, boolean allowWriters)
{
for (Field fieldField : ReflectionHelper.findAnnotatedFields(clazz, ThriftField.class)) {
addField(fieldField, allowReaders, allowWriters);
}

//comment
<start>for (Field field : getAllDeclaredFields(clazz)) {
if (field.isAnnotationPresent(ThriftField.class)) {
if (!Modifier.isPublic(field.getModifiers())) {
metadataErrors.addError(""@ThriftField field '%s' is not public"", field.toGenericString());
}
if (Modifier.isStatic(field.getModifiers())) {
metadataErrors.addError(""@ThriftField field '%s' is static"", field.toGenericString());
}
}
}<end>
}"
6600,"    protected final void addMethods(Type type, boolean allowReaders, boolean allowWriters)
{
Class<?> clazz = TypeToken.of(type).getRawType();

for (Method fieldMethod : findAnnotatedMethods(clazz, ThriftField.class)) {
addMethod(type, fieldMethod, allowReaders, allowWriters);
}

//comment
for (Method method : getAllDeclaredMethods(clazz)) {
if (method.isAnnotationPresent(ThriftField.class) || hasThriftFieldAnnotation(method)) {
if (!Modifier.isPublic(method.getModifiers())) {
metadataErrors.addError(""@ThriftField method '%s' is not public"", method.toGenericString());
}
if (Modifier.isStatic(method.getModifiers())) {
metadataErrors.addError(""@ThriftField method '%s' is static"", method.toGenericString());
}
}
}
}","    protected final void addMethods(Type type, boolean allowReaders, boolean allowWriters)
{
Class<?> clazz = TypeToken.of(type).getRawType();

for (Method fieldMethod : findAnnotatedMethods(clazz, ThriftField.class)) {
addMethod(type, fieldMethod, allowReaders, allowWriters);
}

//comment
<start>for (Method method : getAllDeclaredMethods(clazz)) {
if (method.isAnnotationPresent(ThriftField.class) || hasThriftFieldAnnotation(method)) {
if (!Modifier.isPublic(method.getModifiers())) {
metadataErrors.addError(""@ThriftField method '%s' is not public"", method.toGenericString());
}
if (Modifier.isStatic(method.getModifiers())) {
metadataErrors.addError(""@ThriftField method '%s' is static"", method.toGenericString());
}
}
}<end>
}"
6601,"    protected final void normalizeThriftFields(ThriftCatalog catalog)
{
//comment
<start>Set<String> fieldsWithConflictingIds = inferThriftFieldIds();<end>

//comment
Map<Optional<Short>, List<FieldMetadata>> fieldsById = fields.stream()
.collect(groupingBy(field -> Optional.ofNullable(field.getId())));
for (Entry<Optional<Short>, List<FieldMetadata>> entry : fieldsById.entrySet()) {
Collection<FieldMetadata> fields = entry.getValue();

//comment
if (!entry.getKey().isPresent()) {
Set<String> sortedFields = fields.stream()
.map(FieldMetadata::getOrExtractThriftFieldName)
.collect(toCollection(TreeSet::new));
for (String fieldName : sortedFields) {
//comment
if (!fieldsWithConflictingIds.contains(fieldName)) {
metadataErrors.addError(""Thrift class '%s' fields %s do not have an id"", structName, sortedFields);
}
}
continue;
}

short fieldId = entry.getKey().get();

//comment
String fieldName = extractFieldName(fieldId, fields);
for (FieldMetadata field : fields) {
field.setName(fieldName);
}

//comment
Requiredness requiredness = extractFieldRequiredness(fieldId, fieldName, fields);
for (FieldMetadata field : fields) {
field.setRequiredness(requiredness);
}

//comment
//comment
//comment
//comment
//comment
boolean isLegacyId = extractFieldIsLegacyId(fieldId, fieldName, fields);
for (FieldMetadata field : fields) {
field.setIsLegacyId(isLegacyId);
}

Map<String, String> idlAnnotations = extractFieldIdlAnnotations(fieldId, fields);
for (FieldMetadata field : fields) {
field.setIdlAnnotations(idlAnnotations);
}

//comment
boolean isRecursiveReference = extractFieldIsRecursiveReference(fieldId, fields);
for (FieldMetadata field : fields) {
field.setIsRecursiveReference(isRecursiveReference);
}

//comment
//comment
verifyFieldType(fieldId, fieldName, fields, catalog);
}
}","    protected final void normalizeThriftFields(ThriftCatalog catalog)
{
//comment
<start>Set<String> fieldsWithConflictingIds = inferThriftFieldIds();<end>

//comment
Map<Optional<Short>, List<FieldMetadata>> fieldsById = fields.stream()
.collect(groupingBy(field -> Optional.ofNullable(field.getId())));
for (Entry<Optional<Short>, List<FieldMetadata>> entry : fieldsById.entrySet()) {
Collection<FieldMetadata> fields = entry.getValue();

//comment
if (!entry.getKey().isPresent()) {
Set<String> sortedFields = fields.stream()
.map(FieldMetadata::getOrExtractThriftFieldName)
.collect(toCollection(TreeSet::new));
for (String fieldName : sortedFields) {
//comment
if (!fieldsWithConflictingIds.contains(fieldName)) {
metadataErrors.addError(""Thrift class '%s' fields %s do not have an id"", structName, sortedFields);
}
}
continue;
}

short fieldId = entry.getKey().get();

//comment
String fieldName = extractFieldName(fieldId, fields);
for (FieldMetadata field : fields) {
field.setName(fieldName);
}

//comment
Requiredness requiredness = extractFieldRequiredness(fieldId, fieldName, fields);
for (FieldMetadata field : fields) {
field.setRequiredness(requiredness);
}

//comment
//comment
//comment
//comment
//comment
boolean isLegacyId = extractFieldIsLegacyId(fieldId, fieldName, fields);
for (FieldMetadata field : fields) {
field.setIsLegacyId(isLegacyId);
}

Map<String, String> idlAnnotations = extractFieldIdlAnnotations(fieldId, fields);
for (FieldMetadata field : fields) {
field.setIdlAnnotations(idlAnnotations);
}

//comment
boolean isRecursiveReference = extractFieldIsRecursiveReference(fieldId, fields);
for (FieldMetadata field : fields) {
field.setIsRecursiveReference(isRecursiveReference);
}

//comment
//comment
verifyFieldType(fieldId, fieldName, fields, catalog);
}
}"
6602,"    protected final void normalizeThriftFields(ThriftCatalog catalog)
{
//comment
Set<String> fieldsWithConflictingIds = inferThriftFieldIds();

//comment
<start>Map<Optional<Short>, List<FieldMetadata>> fieldsById = fields.stream()
.collect(groupingBy(field -> Optional.ofNullable(field.getId())));<end>
for (Entry<Optional<Short>, List<FieldMetadata>> entry : fieldsById.entrySet()) {
Collection<FieldMetadata> fields = entry.getValue();

//comment
if (!entry.getKey().isPresent()) {
Set<String> sortedFields = fields.stream()
.map(FieldMetadata::getOrExtractThriftFieldName)
.collect(toCollection(TreeSet::new));
for (String fieldName : sortedFields) {
//comment
if (!fieldsWithConflictingIds.contains(fieldName)) {
metadataErrors.addError(""Thrift class '%s' fields %s do not have an id"", structName, sortedFields);
}
}
continue;
}

short fieldId = entry.getKey().get();

//comment
String fieldName = extractFieldName(fieldId, fields);
for (FieldMetadata field : fields) {
field.setName(fieldName);
}

//comment
Requiredness requiredness = extractFieldRequiredness(fieldId, fieldName, fields);
for (FieldMetadata field : fields) {
field.setRequiredness(requiredness);
}

//comment
//comment
//comment
//comment
//comment
boolean isLegacyId = extractFieldIsLegacyId(fieldId, fieldName, fields);
for (FieldMetadata field : fields) {
field.setIsLegacyId(isLegacyId);
}

Map<String, String> idlAnnotations = extractFieldIdlAnnotations(fieldId, fields);
for (FieldMetadata field : fields) {
field.setIdlAnnotations(idlAnnotations);
}

//comment
boolean isRecursiveReference = extractFieldIsRecursiveReference(fieldId, fields);
for (FieldMetadata field : fields) {
field.setIsRecursiveReference(isRecursiveReference);
}

//comment
//comment
verifyFieldType(fieldId, fieldName, fields, catalog);
}
}","    protected final void normalizeThriftFields(ThriftCatalog catalog)
{
//comment
Set<String> fieldsWithConflictingIds = inferThriftFieldIds();

//comment
<start>Map<Optional<Short>, List<FieldMetadata>> fieldsById = fields.stream()
.collect(groupingBy(field -> Optional.ofNullable(field.getId())));<end>
for (Entry<Optional<Short>, List<FieldMetadata>> entry : fieldsById.entrySet()) {
Collection<FieldMetadata> fields = entry.getValue();

//comment
if (!entry.getKey().isPresent()) {
Set<String> sortedFields = fields.stream()
.map(FieldMetadata::getOrExtractThriftFieldName)
.collect(toCollection(TreeSet::new));
for (String fieldName : sortedFields) {
//comment
if (!fieldsWithConflictingIds.contains(fieldName)) {
metadataErrors.addError(""Thrift class '%s' fields %s do not have an id"", structName, sortedFields);
}
}
continue;
}

short fieldId = entry.getKey().get();

//comment
String fieldName = extractFieldName(fieldId, fields);
for (FieldMetadata field : fields) {
field.setName(fieldName);
}

//comment
Requiredness requiredness = extractFieldRequiredness(fieldId, fieldName, fields);
for (FieldMetadata field : fields) {
field.setRequiredness(requiredness);
}

//comment
//comment
//comment
//comment
//comment
boolean isLegacyId = extractFieldIsLegacyId(fieldId, fieldName, fields);
for (FieldMetadata field : fields) {
field.setIsLegacyId(isLegacyId);
}

Map<String, String> idlAnnotations = extractFieldIdlAnnotations(fieldId, fields);
for (FieldMetadata field : fields) {
field.setIdlAnnotations(idlAnnotations);
}

//comment
boolean isRecursiveReference = extractFieldIsRecursiveReference(fieldId, fields);
for (FieldMetadata field : fields) {
field.setIsRecursiveReference(isRecursiveReference);
}

//comment
//comment
verifyFieldType(fieldId, fieldName, fields, catalog);
}
}"
6603,"    protected final void normalizeThriftFields(ThriftCatalog catalog)
{
//comment
Set<String> fieldsWithConflictingIds = inferThriftFieldIds();

//comment
Map<Optional<Short>, List<FieldMetadata>> fieldsById = fields.stream()
.collect(groupingBy(field -> Optional.ofNullable(field.getId())));
for (Entry<Optional<Short>, List<FieldMetadata>> entry : fieldsById.entrySet()) {
Collection<FieldMetadata> fields = entry.getValue();

//comment
<start>if (!entry.getKey().isPresent()) {
Set<String> sortedFields = fields.stream()
.map(FieldMetadata::getOrExtractThriftFieldName)
.collect(toCollection(TreeSet::new));
for (String fieldName : sortedFields) {
//comment
if (!fieldsWithConflictingIds.contains(fieldName)) {
metadataErrors.addError(""Thrift class '%s' fields %s do not have an id"", structName, sortedFields);
}
}
continue;
}<end>

short fieldId = entry.getKey().get();

//comment
String fieldName = extractFieldName(fieldId, fields);
for (FieldMetadata field : fields) {
field.setName(fieldName);
}

//comment
Requiredness requiredness = extractFieldRequiredness(fieldId, fieldName, fields);
for (FieldMetadata field : fields) {
field.setRequiredness(requiredness);
}

//comment
//comment
//comment
//comment
//comment
boolean isLegacyId = extractFieldIsLegacyId(fieldId, fieldName, fields);
for (FieldMetadata field : fields) {
field.setIsLegacyId(isLegacyId);
}

Map<String, String> idlAnnotations = extractFieldIdlAnnotations(fieldId, fields);
for (FieldMetadata field : fields) {
field.setIdlAnnotations(idlAnnotations);
}

//comment
boolean isRecursiveReference = extractFieldIsRecursiveReference(fieldId, fields);
for (FieldMetadata field : fields) {
field.setIsRecursiveReference(isRecursiveReference);
}

//comment
//comment
verifyFieldType(fieldId, fieldName, fields, catalog);
}
}","    protected final void normalizeThriftFields(ThriftCatalog catalog)
{
//comment
Set<String> fieldsWithConflictingIds = inferThriftFieldIds();

//comment
Map<Optional<Short>, List<FieldMetadata>> fieldsById = fields.stream()
.collect(groupingBy(field -> Optional.ofNullable(field.getId())));
for (Entry<Optional<Short>, List<FieldMetadata>> entry : fieldsById.entrySet()) {
Collection<FieldMetadata> fields = entry.getValue();

//comment
if (!entry.getKey().isPresent()) {
Set<String> sortedFields = fields.stream()
.map(FieldMetadata::getOrExtractThriftFieldName)
.collect(toCollection(TreeSet::new));
for (String fieldName : sortedFields) {
//comment
<start>if (!fieldsWithConflictingIds.contains(fieldName)) {
metadataErrors.addError(""Thrift class '%s' fields %s do not have an id"", structName, sortedFields);
}<end>
}
continue;
}

short fieldId = entry.getKey().get();

//comment
String fieldName = extractFieldName(fieldId, fields);
for (FieldMetadata field : fields) {
field.setName(fieldName);
}

//comment
Requiredness requiredness = extractFieldRequiredness(fieldId, fieldName, fields);
for (FieldMetadata field : fields) {
field.setRequiredness(requiredness);
}

//comment
//comment
//comment
//comment
//comment
boolean isLegacyId = extractFieldIsLegacyId(fieldId, fieldName, fields);
for (FieldMetadata field : fields) {
field.setIsLegacyId(isLegacyId);
}

Map<String, String> idlAnnotations = extractFieldIdlAnnotations(fieldId, fields);
for (FieldMetadata field : fields) {
field.setIdlAnnotations(idlAnnotations);
}

//comment
boolean isRecursiveReference = extractFieldIsRecursiveReference(fieldId, fields);
for (FieldMetadata field : fields) {
field.setIsRecursiveReference(isRecursiveReference);
}

//comment
//comment
verifyFieldType(fieldId, fieldName, fields, catalog);
}
}"
6604,"    protected final void normalizeThriftFields(ThriftCatalog catalog)
{
//comment
Set<String> fieldsWithConflictingIds = inferThriftFieldIds();

//comment
Map<Optional<Short>, List<FieldMetadata>> fieldsById = fields.stream()
.collect(groupingBy(field -> Optional.ofNullable(field.getId())));
for (Entry<Optional<Short>, List<FieldMetadata>> entry : fieldsById.entrySet()) {
Collection<FieldMetadata> fields = entry.getValue();

//comment
if (!entry.getKey().isPresent()) {
Set<String> sortedFields = fields.stream()
.map(FieldMetadata::getOrExtractThriftFieldName)
.collect(toCollection(TreeSet::new));
for (String fieldName : sortedFields) {
//comment
if (!fieldsWithConflictingIds.contains(fieldName)) {
metadataErrors.addError(""Thrift class '%s' fields %s do not have an id"", structName, sortedFields);
}
}
continue;
}

short fieldId = entry.getKey().get();

//comment
<start>String fieldName = extractFieldName(fieldId, fields);
for (FieldMetadata field : fields) {
field.setName(fieldName);
}<end>

//comment
Requiredness requiredness = extractFieldRequiredness(fieldId, fieldName, fields);
for (FieldMetadata field : fields) {
field.setRequiredness(requiredness);
}

//comment
//comment
//comment
//comment
//comment
boolean isLegacyId = extractFieldIsLegacyId(fieldId, fieldName, fields);
for (FieldMetadata field : fields) {
field.setIsLegacyId(isLegacyId);
}

Map<String, String> idlAnnotations = extractFieldIdlAnnotations(fieldId, fields);
for (FieldMetadata field : fields) {
field.setIdlAnnotations(idlAnnotations);
}

//comment
boolean isRecursiveReference = extractFieldIsRecursiveReference(fieldId, fields);
for (FieldMetadata field : fields) {
field.setIsRecursiveReference(isRecursiveReference);
}

//comment
//comment
verifyFieldType(fieldId, fieldName, fields, catalog);
}
}","    protected final void normalizeThriftFields(ThriftCatalog catalog)
{
//comment
Set<String> fieldsWithConflictingIds = inferThriftFieldIds();

//comment
Map<Optional<Short>, List<FieldMetadata>> fieldsById = fields.stream()
.collect(groupingBy(field -> Optional.ofNullable(field.getId())));
for (Entry<Optional<Short>, List<FieldMetadata>> entry : fieldsById.entrySet()) {
Collection<FieldMetadata> fields = entry.getValue();

//comment
if (!entry.getKey().isPresent()) {
Set<String> sortedFields = fields.stream()
.map(FieldMetadata::getOrExtractThriftFieldName)
.collect(toCollection(TreeSet::new));
for (String fieldName : sortedFields) {
//comment
if (!fieldsWithConflictingIds.contains(fieldName)) {
metadataErrors.addError(""Thrift class '%s' fields %s do not have an id"", structName, sortedFields);
}
}
continue;
}

short fieldId = entry.getKey().get();

//comment
<start>String fieldName = extractFieldName(fieldId, fields);
for (FieldMetadata field : fields) {
field.setName(fieldName);
}<end>

//comment
Requiredness requiredness = extractFieldRequiredness(fieldId, fieldName, fields);
for (FieldMetadata field : fields) {
field.setRequiredness(requiredness);
}

//comment
//comment
//comment
//comment
//comment
boolean isLegacyId = extractFieldIsLegacyId(fieldId, fieldName, fields);
for (FieldMetadata field : fields) {
field.setIsLegacyId(isLegacyId);
}

Map<String, String> idlAnnotations = extractFieldIdlAnnotations(fieldId, fields);
for (FieldMetadata field : fields) {
field.setIdlAnnotations(idlAnnotations);
}

//comment
boolean isRecursiveReference = extractFieldIsRecursiveReference(fieldId, fields);
for (FieldMetadata field : fields) {
field.setIsRecursiveReference(isRecursiveReference);
}

//comment
//comment
verifyFieldType(fieldId, fieldName, fields, catalog);
}
}"
6605,"    protected final void normalizeThriftFields(ThriftCatalog catalog)
{
//comment
Set<String> fieldsWithConflictingIds = inferThriftFieldIds();

//comment
Map<Optional<Short>, List<FieldMetadata>> fieldsById = fields.stream()
.collect(groupingBy(field -> Optional.ofNullable(field.getId())));
for (Entry<Optional<Short>, List<FieldMetadata>> entry : fieldsById.entrySet()) {
Collection<FieldMetadata> fields = entry.getValue();

//comment
if (!entry.getKey().isPresent()) {
Set<String> sortedFields = fields.stream()
.map(FieldMetadata::getOrExtractThriftFieldName)
.collect(toCollection(TreeSet::new));
for (String fieldName : sortedFields) {
//comment
if (!fieldsWithConflictingIds.contains(fieldName)) {
metadataErrors.addError(""Thrift class '%s' fields %s do not have an id"", structName, sortedFields);
}
}
continue;
}

short fieldId = entry.getKey().get();

//comment
String fieldName = extractFieldName(fieldId, fields);
for (FieldMetadata field : fields) {
field.setName(fieldName);
}

//comment
<start>Requiredness requiredness = extractFieldRequiredness(fieldId, fieldName, fields);<end>
for (FieldMetadata field : fields) {
field.setRequiredness(requiredness);
}

//comment
//comment
//comment
//comment
//comment
boolean isLegacyId = extractFieldIsLegacyId(fieldId, fieldName, fields);
for (FieldMetadata field : fields) {
field.setIsLegacyId(isLegacyId);
}

Map<String, String> idlAnnotations = extractFieldIdlAnnotations(fieldId, fields);
for (FieldMetadata field : fields) {
field.setIdlAnnotations(idlAnnotations);
}

//comment
boolean isRecursiveReference = extractFieldIsRecursiveReference(fieldId, fields);
for (FieldMetadata field : fields) {
field.setIsRecursiveReference(isRecursiveReference);
}

//comment
//comment
verifyFieldType(fieldId, fieldName, fields, catalog);
}
}","    protected final void normalizeThriftFields(ThriftCatalog catalog)
{
//comment
Set<String> fieldsWithConflictingIds = inferThriftFieldIds();

//comment
Map<Optional<Short>, List<FieldMetadata>> fieldsById = fields.stream()
.collect(groupingBy(field -> Optional.ofNullable(field.getId())));
for (Entry<Optional<Short>, List<FieldMetadata>> entry : fieldsById.entrySet()) {
Collection<FieldMetadata> fields = entry.getValue();

//comment
if (!entry.getKey().isPresent()) {
Set<String> sortedFields = fields.stream()
.map(FieldMetadata::getOrExtractThriftFieldName)
.collect(toCollection(TreeSet::new));
for (String fieldName : sortedFields) {
//comment
if (!fieldsWithConflictingIds.contains(fieldName)) {
metadataErrors.addError(""Thrift class '%s' fields %s do not have an id"", structName, sortedFields);
}
}
continue;
}

short fieldId = entry.getKey().get();

//comment
String fieldName = extractFieldName(fieldId, fields);
for (FieldMetadata field : fields) {
field.setName(fieldName);
}

//comment
<start>Requiredness requiredness = extractFieldRequiredness(fieldId, fieldName, fields);
for (FieldMetadata field : fields) {
field.setRequiredness(requiredness);
}<end>

//comment
//comment
//comment
//comment
//comment
boolean isLegacyId = extractFieldIsLegacyId(fieldId, fieldName, fields);
for (FieldMetadata field : fields) {
field.setIsLegacyId(isLegacyId);
}

Map<String, String> idlAnnotations = extractFieldIdlAnnotations(fieldId, fields);
for (FieldMetadata field : fields) {
field.setIdlAnnotations(idlAnnotations);
}

//comment
boolean isRecursiveReference = extractFieldIsRecursiveReference(fieldId, fields);
for (FieldMetadata field : fields) {
field.setIsRecursiveReference(isRecursiveReference);
}

//comment
//comment
verifyFieldType(fieldId, fieldName, fields, catalog);
}
}"
6606,"    protected final void normalizeThriftFields(ThriftCatalog catalog)
{
//comment
Set<String> fieldsWithConflictingIds = inferThriftFieldIds();

//comment
Map<Optional<Short>, List<FieldMetadata>> fieldsById = fields.stream()
.collect(groupingBy(field -> Optional.ofNullable(field.getId())));
for (Entry<Optional<Short>, List<FieldMetadata>> entry : fieldsById.entrySet()) {
Collection<FieldMetadata> fields = entry.getValue();

//comment
if (!entry.getKey().isPresent()) {
Set<String> sortedFields = fields.stream()
.map(FieldMetadata::getOrExtractThriftFieldName)
.collect(toCollection(TreeSet::new));
for (String fieldName : sortedFields) {
//comment
if (!fieldsWithConflictingIds.contains(fieldName)) {
metadataErrors.addError(""Thrift class '%s' fields %s do not have an id"", structName, sortedFields);
}
}
continue;
}

short fieldId = entry.getKey().get();

//comment
String fieldName = extractFieldName(fieldId, fields);
for (FieldMetadata field : fields) {
field.setName(fieldName);
}

//comment
Requiredness requiredness = extractFieldRequiredness(fieldId, fieldName, fields);
for (FieldMetadata field : fields) {
field.setRequiredness(requiredness);
}

//comment
//comment
//comment
//comment
//comment
boolean isLegacyId = extractFieldIsLegacyId(fieldId, fieldName, fields);
for (FieldMetadata field : fields) {
field.setIsLegacyId(isLegacyId);
}

Map<String, String> idlAnnotations = extractFieldIdlAnnotations(fieldId, fields);
for (FieldMetadata field : fields) {
field.setIdlAnnotations(idlAnnotations);
}

//comment
<start>boolean isRecursiveReference = extractFieldIsRecursiveReference(fieldId, fields);<end>
for (FieldMetadata field : fields) {
<start>field.setIsRecursiveReference(isRecursiveReference);<end>
}

//comment
//comment
verifyFieldType(fieldId, fieldName, fields, catalog);
}
}","    protected final void normalizeThriftFields(ThriftCatalog catalog)
{
//comment
Set<String> fieldsWithConflictingIds = inferThriftFieldIds();

//comment
Map<Optional<Short>, List<FieldMetadata>> fieldsById = fields.stream()
.collect(groupingBy(field -> Optional.ofNullable(field.getId())));
for (Entry<Optional<Short>, List<FieldMetadata>> entry : fieldsById.entrySet()) {
Collection<FieldMetadata> fields = entry.getValue();

//comment
if (!entry.getKey().isPresent()) {
Set<String> sortedFields = fields.stream()
.map(FieldMetadata::getOrExtractThriftFieldName)
.collect(toCollection(TreeSet::new));
for (String fieldName : sortedFields) {
//comment
if (!fieldsWithConflictingIds.contains(fieldName)) {
metadataErrors.addError(""Thrift class '%s' fields %s do not have an id"", structName, sortedFields);
}
}
continue;
}

short fieldId = entry.getKey().get();

//comment
String fieldName = extractFieldName(fieldId, fields);
for (FieldMetadata field : fields) {
field.setName(fieldName);
}

//comment
Requiredness requiredness = extractFieldRequiredness(fieldId, fieldName, fields);
for (FieldMetadata field : fields) {
field.setRequiredness(requiredness);
}

//comment
//comment
//comment
//comment
//comment
boolean isLegacyId = extractFieldIsLegacyId(fieldId, fieldName, fields);
for (FieldMetadata field : fields) {
field.setIsLegacyId(isLegacyId);
}

Map<String, String> idlAnnotations = extractFieldIdlAnnotations(fieldId, fields);
for (FieldMetadata field : fields) {
field.setIdlAnnotations(idlAnnotations);
}

//comment
<start>boolean isRecursiveReference = extractFieldIsRecursiveReference(fieldId, fields);
for (FieldMetadata field : fields) {
field.setIsRecursiveReference(isRecursiveReference);
}<end>

//comment
//comment
verifyFieldType(fieldId, fieldName, fields, catalog);
}
}"
6607,"    protected final void normalizeThriftFields(ThriftCatalog catalog)
{
//comment
Set<String> fieldsWithConflictingIds = inferThriftFieldIds();

//comment
Map<Optional<Short>, List<FieldMetadata>> fieldsById = fields.stream()
.collect(groupingBy(field -> Optional.ofNullable(field.getId())));
for (Entry<Optional<Short>, List<FieldMetadata>> entry : fieldsById.entrySet()) {
Collection<FieldMetadata> fields = entry.getValue();

//comment
if (!entry.getKey().isPresent()) {
Set<String> sortedFields = fields.stream()
.map(FieldMetadata::getOrExtractThriftFieldName)
.collect(toCollection(TreeSet::new));
for (String fieldName : sortedFields) {
//comment
if (!fieldsWithConflictingIds.contains(fieldName)) {
metadataErrors.addError(""Thrift class '%s' fields %s do not have an id"", structName, sortedFields);
}
}
continue;
}

short fieldId = entry.getKey().get();

//comment
String fieldName = extractFieldName(fieldId, fields);
for (FieldMetadata field : fields) {
field.setName(fieldName);
}

//comment
Requiredness requiredness = extractFieldRequiredness(fieldId, fieldName, fields);
for (FieldMetadata field : fields) {
field.setRequiredness(requiredness);
}

//comment
//comment
//comment
//comment
//comment
boolean isLegacyId = extractFieldIsLegacyId(fieldId, fieldName, fields);
for (FieldMetadata field : fields) {
field.setIsLegacyId(isLegacyId);
}

Map<String, String> idlAnnotations = extractFieldIdlAnnotations(fieldId, fields);
for (FieldMetadata field : fields) {
field.setIdlAnnotations(idlAnnotations);
}

//comment
boolean isRecursiveReference = extractFieldIsRecursiveReference(fieldId, fields);
for (FieldMetadata field : fields) {
field.setIsRecursiveReference(isRecursiveReference);
}

//comment
//comment
<start>verifyFieldType(fieldId, fieldName, fields, catalog);<end>
}
}","    protected final void normalizeThriftFields(ThriftCatalog catalog)
{
//comment
Set<String> fieldsWithConflictingIds = inferThriftFieldIds();

//comment
Map<Optional<Short>, List<FieldMetadata>> fieldsById = fields.stream()
.collect(groupingBy(field -> Optional.ofNullable(field.getId())));
for (Entry<Optional<Short>, List<FieldMetadata>> entry : fieldsById.entrySet()) {
Collection<FieldMetadata> fields = entry.getValue();

//comment
if (!entry.getKey().isPresent()) {
Set<String> sortedFields = fields.stream()
.map(FieldMetadata::getOrExtractThriftFieldName)
.collect(toCollection(TreeSet::new));
for (String fieldName : sortedFields) {
//comment
if (!fieldsWithConflictingIds.contains(fieldName)) {
metadataErrors.addError(""Thrift class '%s' fields %s do not have an id"", structName, sortedFields);
}
}
continue;
}

short fieldId = entry.getKey().get();

//comment
String fieldName = extractFieldName(fieldId, fields);
for (FieldMetadata field : fields) {
field.setName(fieldName);
}

//comment
Requiredness requiredness = extractFieldRequiredness(fieldId, fieldName, fields);
for (FieldMetadata field : fields) {
field.setRequiredness(requiredness);
}

//comment
//comment
//comment
//comment
//comment
boolean isLegacyId = extractFieldIsLegacyId(fieldId, fieldName, fields);
for (FieldMetadata field : fields) {
field.setIsLegacyId(isLegacyId);
}

Map<String, String> idlAnnotations = extractFieldIdlAnnotations(fieldId, fields);
for (FieldMetadata field : fields) {
field.setIdlAnnotations(idlAnnotations);
}

//comment
boolean isRecursiveReference = extractFieldIsRecursiveReference(fieldId, fields);
for (FieldMetadata field : fields) {
field.setIsRecursiveReference(isRecursiveReference);
}

//comment
//comment
<start>verifyFieldType(fieldId, fieldName, fields, catalog);<end>
}
}"
6608,"    protected final Set<String> inferThriftFieldIds()
{
Set<String> fieldsWithConflictingIds = new HashSet<>();

//comment
<start>Multimap<String, FieldMetadata> fieldsByExplicitOrExtractedName = Multimaps.index(fields, FieldMetadata::getOrExtractThriftFieldName);
inferThriftFieldIds(fieldsByExplicitOrExtractedName, fieldsWithConflictingIds);<end>

//comment
//comment
//comment
Multimap<String, FieldMetadata> fieldsByExtractedName = Multimaps.index(fields, FieldMetadata::extractName);
inferThriftFieldIds(fieldsByExtractedName, fieldsWithConflictingIds);

return fieldsWithConflictingIds;
}","    protected final Set<String> inferThriftFieldIds()
{
Set<String> fieldsWithConflictingIds = new HashSet<>();

//comment
<start>Multimap<String, FieldMetadata> fieldsByExplicitOrExtractedName = Multimaps.index(fields, FieldMetadata::getOrExtractThriftFieldName);
inferThriftFieldIds(fieldsByExplicitOrExtractedName, fieldsWithConflictingIds);<end>

//comment
//comment
//comment
Multimap<String, FieldMetadata> fieldsByExtractedName = Multimaps.index(fields, FieldMetadata::extractName);
inferThriftFieldIds(fieldsByExtractedName, fieldsWithConflictingIds);

return fieldsWithConflictingIds;
}"
6609,"protected final void inferThriftFieldIds(Multimap<String, FieldMetadata> fieldsByName, Set<String> fieldsWithConflictingIds)
{
//comment
for (Entry<String, Collection<FieldMetadata>> entry : fieldsByName.asMap().entrySet()) {
Collection<FieldMetadata> fields = entry.getValue();
String fieldName = entry.getKey();

//comment
if (fields.size() <= 1) {
continue;
}

//comment
<start>Set<Short> ids = fields.stream()
.map(FieldMetadata::getId)
.filter(Objects::nonNull)
.collect(toSet());<end>

//comment
if (ids.size() > 1) {
if (!fieldsWithConflictingIds.contains(fieldName)) {
metadataErrors.addError(""Thrift class '%s' field '%s' has multiple ids: %s"", structName, fieldName, ids.toString());
fieldsWithConflictingIds.add(fieldName);
}
continue;
}

//comment
//comment
if (ids.size() == 1) {
short id = Iterables.getOnlyElement(ids);

boolean isLegacyId = extractFieldIsLegacyId(id, fieldName, fields);

//comment
for (FieldMetadata field : fields) {
field.setId(id);
field.setIsLegacyId(isLegacyId);
}
}
}
}","protected final void inferThriftFieldIds(Multimap<String, FieldMetadata> fieldsByName, Set<String> fieldsWithConflictingIds)
{
//comment
for (Entry<String, Collection<FieldMetadata>> entry : fieldsByName.asMap().entrySet()) {
Collection<FieldMetadata> fields = entry.getValue();
String fieldName = entry.getKey();

//comment
if (fields.size() <= 1) {
continue;
}

//comment
<start>Set<Short> ids = fields.stream()
.map(FieldMetadata::getId)
.filter(Objects::nonNull)
.collect(toSet());<end>

//comment
if (ids.size() > 1) {
if (!fieldsWithConflictingIds.contains(fieldName)) {
metadataErrors.addError(""Thrift class '%s' field '%s' has multiple ids: %s"", structName, fieldName, ids.toString());
fieldsWithConflictingIds.add(fieldName);
}
continue;
}

//comment
//comment
if (ids.size() == 1) {
short id = Iterables.getOnlyElement(ids);

boolean isLegacyId = extractFieldIsLegacyId(id, fieldName, fields);

//comment
for (FieldMetadata field : fields) {
field.setId(id);
field.setIsLegacyId(isLegacyId);
}
}
}
}"
6610,"protected final void inferThriftFieldIds(Multimap<String, FieldMetadata> fieldsByName, Set<String> fieldsWithConflictingIds)
{
//comment
for (Entry<String, Collection<FieldMetadata>> entry : fieldsByName.asMap().entrySet()) {
Collection<FieldMetadata> fields = entry.getValue();
String fieldName = entry.getKey();

//comment
if (fields.size() <= 1) {
continue;
}

//comment
Set<Short> ids = fields.stream()
.map(FieldMetadata::getId)
.filter(Objects::nonNull)
.collect(toSet());

//comment
if (ids.size() > 1) {
if (!fieldsWithConflictingIds.contains(fieldName)) {
metadataErrors.addError(""Thrift class '%s' field '%s' has multiple ids: %s"", structName, fieldName, ids.toString());
fieldsWithConflictingIds.add(fieldName);
}
continue;
}

//comment
//comment
if (ids.size() == 1) {
short id = Iterables.getOnlyElement(ids);

boolean isLegacyId = extractFieldIsLegacyId(id, fieldName, fields);

//comment
for (FieldMetadata field : fields) {
<start>field.setId(id);<end>
field.setIsLegacyId(isLegacyId);
}
}
}
}","protected final void inferThriftFieldIds(Multimap<String, FieldMetadata> fieldsByName, Set<String> fieldsWithConflictingIds)
{
//comment
for (Entry<String, Collection<FieldMetadata>> entry : fieldsByName.asMap().entrySet()) {
Collection<FieldMetadata> fields = entry.getValue();
String fieldName = entry.getKey();

//comment
if (fields.size() <= 1) {
continue;
}

//comment
Set<Short> ids = fields.stream()
.map(FieldMetadata::getId)
.filter(Objects::nonNull)
.collect(toSet());

//comment
if (ids.size() > 1) {
if (!fieldsWithConflictingIds.contains(fieldName)) {
metadataErrors.addError(""Thrift class '%s' field '%s' has multiple ids: %s"", structName, fieldName, ids.toString());
fieldsWithConflictingIds.add(fieldName);
}
continue;
}

//comment
//comment
if (ids.size() == 1) {
short id = Iterables.getOnlyElement(ids);

boolean isLegacyId = extractFieldIsLegacyId(id, fieldName, fields);

//comment
<start>for (FieldMetadata field : fields) {
field.setId(id);
field.setIsLegacyId(isLegacyId);
}<end>
}
}
}"
6573,"<start>public static Class<?> getArrayOfType(Type componentType)<end>
{
//comment
<start>Class<?> rawComponentType = TypeToken.of(componentType).getRawType();
return Array.newInstance(rawComponentType, 0).getClass();<end>
}","public static Class<?> getArrayOfType(Type componentType)
{
//comment
<start>Class<?> rawComponentType = TypeToken.of(componentType).getRawType();
return Array.newInstance(rawComponentType, 0).getClass();<end>
}"
6574,"<start>    public static <T extends Annotation> Set<T> getEffectiveClassAnnotations(Class<?> type, Class<T> annotation)<end>
{
//comment
<start>if (type.isAnnotationPresent(annotation)) {
return ImmutableSet.of(type.getAnnotation(annotation));
}<end>

//comment
ImmutableSet.Builder<T> builder = ImmutableSet.builder();
addEffectiveClassAnnotations(type, annotation, builder);
return builder.build();
}","    public static <T extends Annotation> Set<T> getEffectiveClassAnnotations(Class<?> type, Class<T> annotation)
{
//comment
<start>if (type.isAnnotationPresent(annotation)) {
return ImmutableSet.of(type.getAnnotation(annotation));
}<end>

//comment
ImmutableSet.Builder<T> builder = ImmutableSet.builder();
addEffectiveClassAnnotations(type, annotation, builder);
return builder.build();
}"
6575,"    public static <T extends Annotation> Set<T> getEffectiveClassAnnotations(Class<?> type, Class<T> annotation)
{
//comment
if (type.isAnnotationPresent(annotation)) {
return ImmutableSet.of(type.getAnnotation(annotation));
}

//comment
<start>ImmutableSet.Builder<T> builder = ImmutableSet.builder();
addEffectiveClassAnnotations(type, annotation, builder);<end>
return builder.build();
}","    public static <T extends Annotation> Set<T> getEffectiveClassAnnotations(Class<?> type, Class<T> annotation)
{
//comment
if (type.isAnnotationPresent(annotation)) {
return ImmutableSet.of(type.getAnnotation(annotation));
}

//comment
<start>ImmutableSet.Builder<T> builder = ImmutableSet.builder();
addEffectiveClassAnnotations(type, annotation, builder);<end>
return builder.build();
}"
6576,"    public static Collection<Method> findAnnotatedMethods(Class<?> type, Class<? extends Annotation> annotation)
{
List<Method> result = new ArrayList<>();

//comment
//comment
for (Method method : type.getMethods()) {
//comment
if (method.isSynthetic() || method.isBridge() || isStatic(method.getModifiers())) {
<start>continue;<end>
}

//comment
Method managedMethod = findAnnotatedMethod(
type,
annotation,
method.getName(),
method.getParameterTypes());
if (managedMethod != null) {
result.add(managedMethod);
}
}

return result;
}","    public static Collection<Method> findAnnotatedMethods(Class<?> type, Class<? extends Annotation> annotation)
{
List<Method> result = new ArrayList<>();

//comment
//comment
<start>for (Method method : type.getMethods()) {
//comment
if (method.isSynthetic() || method.isBridge() || isStatic(method.getModifiers())) {
continue;
}

//comment
Method managedMethod = findAnnotatedMethod(
type,
annotation,
method.getName(),
method.getParameterTypes());
if (managedMethod != null) {
result.add(managedMethod);
}
}

return result;<end>
}"
6577,"    public static Collection<Method> findAnnotatedMethods(Class<?> type, Class<? extends Annotation> annotation)
{
List<Method> result = new ArrayList<>();

//comment
//comment
for (Method method : type.getMethods()) {
//comment
<start>if (method.isSynthetic() || method.isBridge() || isStatic(method.getModifiers())) {
continue;
}<end>

//comment
Method managedMethod = findAnnotatedMethod(
type,
annotation,
method.getName(),
method.getParameterTypes());
if (managedMethod != null) {
result.add(managedMethod);
}
}

return result;
}","    public static Collection<Method> findAnnotatedMethods(Class<?> type, Class<? extends Annotation> annotation)
{
List<Method> result = new ArrayList<>();

//comment
//comment
for (Method method : type.getMethods()) {
//comment
<start>if (method.isSynthetic() || method.isBridge() || isStatic(method.getModifiers())) {
continue;
}<end>

//comment
Method managedMethod = findAnnotatedMethod(
type,
annotation,
method.getName(),
method.getParameterTypes());
if (managedMethod != null) {
result.add(managedMethod);
}
}

return result;
}"
6578,"    public static Collection<Method> findAnnotatedMethods(Class<?> type, Class<? extends Annotation> annotation)
{
List<Method> result = new ArrayList<>();

//comment
//comment
for (Method method : type.getMethods()) {
//comment
if (method.isSynthetic() || method.isBridge() || isStatic(method.getModifiers())) {
continue;
}

//comment
Method managedMethod = findAnnotatedMethod(
type,
annotation,
method.getName(),
method.getParameterTypes());
if (managedMethod != null) {
result.add(managedMethod);
}
}

return result;
}","    public static Collection<Method> findAnnotatedMethods(Class<?> type, Class<? extends Annotation> annotation)
{
List<Method> result = new ArrayList<>();

//comment
//comment
for (Method method : type.getMethods()) {
//comment
if (method.isSynthetic() || method.isBridge() || isStatic(method.getModifiers())) {
continue;
}

//comment
<start>Method managedMethod = findAnnotatedMethod(
type,
annotation,
method.getName(),
method.getParameterTypes());<end>
if (managedMethod != null) {
result.add(managedMethod);
}
}

return result;
}"
6579,"    public static Collection<Field> findAnnotatedFields(Class<?> type, Class<? extends Annotation> annotation)
{
List<Field> result = new ArrayList<>();

//comment
//comment
for (Field field : type.getFields()) {
if (field.isSynthetic() || isStatic(field.getModifiers())) {
continue;
}

if (field.isAnnotationPresent(annotation)) {
result.add(field);
}
}

return result;
}","    public static Collection<Field> findAnnotatedFields(Class<?> type, Class<? extends Annotation> annotation)
{
List<Field> result = new ArrayList<>();

//comment
//comment
<start>for (Field field : type.getFields()) {
if (field.isSynthetic() || isStatic(field.getModifiers())) {
continue;
}

if (field.isAnnotationPresent(annotation)) {
result.add(field);
}
}

return result;<end>
}"
6580,"private static List<String> getParameterNames(Executable executable)
{
requireNonNull(executable, ""executable is null"");

if (executable.getParameterCount() == 0) {
return emptyList();
}

//comment
<start>List<Optional<String>> parameterNamesFromThriftField = Arrays.stream(executable.getParameters())
.map(ReflectionHelper::getThriftFieldParameterName)
.collect(toImmutableList());<end>
if (parameterNamesFromThriftField.stream().allMatch(Optional::isPresent)) {
return parameterNamesFromThriftField.stream()
.map(Optional::get)
.collect(toImmutableList());
}

//comment
List<String> parameterNamesFromClass = ParameterNames.getParameterNames(executable);
ImmutableList.Builder<String> parameterNames = ImmutableList.builder();
for (int i = 0; i < parameterNamesFromThriftField.size(); i++) {
parameterNames.add(parameterNamesFromThriftField.get(i).orElse(parameterNamesFromClass.get(i)));
}
return parameterNames.build();
}","private static List<String> getParameterNames(Executable executable)
{
requireNonNull(executable, ""executable is null"");

if (executable.getParameterCount() == 0) {
return emptyList();
}

//comment
<start>List<Optional<String>> parameterNamesFromThriftField = Arrays.stream(executable.getParameters())
.map(ReflectionHelper::getThriftFieldParameterName)
.collect(toImmutableList());
if (parameterNamesFromThriftField.stream().allMatch(Optional::isPresent)) {
return parameterNamesFromThriftField.stream()
.map(Optional::get)
.collect(toImmutableList());
}<end>

//comment
List<String> parameterNamesFromClass = ParameterNames.getParameterNames(executable);
ImmutableList.Builder<String> parameterNames = ImmutableList.builder();
for (int i = 0; i < parameterNamesFromThriftField.size(); i++) {
parameterNames.add(parameterNamesFromThriftField.get(i).orElse(parameterNamesFromClass.get(i)));
}
return parameterNames.build();
}"
6581,"private static List<String> getParameterNames(Executable executable)
{
requireNonNull(executable, ""executable is null"");

if (executable.getParameterCount() == 0) {
return emptyList();
}

//comment
List<Optional<String>> parameterNamesFromThriftField = Arrays.stream(executable.getParameters())
.map(ReflectionHelper::getThriftFieldParameterName)
.collect(toImmutableList());
if (parameterNamesFromThriftField.stream().allMatch(Optional::isPresent)) {
return parameterNamesFromThriftField.stream()
.map(Optional::get)
.collect(toImmutableList());
}

//comment
<start>List<String> parameterNamesFromClass = ParameterNames.getParameterNames(executable);
ImmutableList.Builder<String> parameterNames = ImmutableList.builder();
for (int i = 0; i < parameterNamesFromThriftField.size(); i++) {
parameterNames.add(parameterNamesFromThriftField.get(i).orElse(parameterNamesFromClass.get(i)));
}<end>
return parameterNames.build();
}","private static List<String> getParameterNames(Executable executable)
{
requireNonNull(executable, ""executable is null"");

if (executable.getParameterCount() == 0) {
return emptyList();
}

//comment
List<Optional<String>> parameterNamesFromThriftField = Arrays.stream(executable.getParameters())
.map(ReflectionHelper::getThriftFieldParameterName)
.collect(toImmutableList());
if (parameterNamesFromThriftField.stream().allMatch(Optional::isPresent)) {
return parameterNamesFromThriftField.stream()
.map(Optional::get)
.collect(toImmutableList());
}

//comment
<start>List<String> parameterNamesFromClass = ParameterNames.getParameterNames(executable);
ImmutableList.Builder<String> parameterNames = ImmutableList.builder();
for (int i = 0; i < parameterNamesFromThriftField.size(); i++) {
parameterNames.add(parameterNamesFromThriftField.get(i).orElse(parameterNamesFromClass.get(i)));
}<end>
return parameterNames.build();
}"
953,"    public String generate(Iterable<String> inputs)
{
for (String className : inputs) {
Object result = convertToThrift(load(className));
if (result instanceof ThriftType) {
thriftTypes.add((ThriftType) result);
}
<start>else {<end>
thriftServices.add((ThriftServiceMetadata) result);
}
//comment
<start>includes.remove(result);<end>
}

if (!verify()) {
throw new ThriftIdlGeneratorException(""Errors found during verification."");
}

return generate();
}","    public String generate(Iterable<String> inputs)
{
for (String className : inputs) {
Object result = convertToThrift(load(className));
if (result instanceof ThriftType) {
thriftTypes.add((ThriftType) result);
}
else {
thriftServices.add((ThriftServiceMetadata) result);
}
//comment
<start>includes.remove(result);<end>
}

if (!verify()) {
throw new ThriftIdlGeneratorException(""Errors found during verification."");
}

return generate();
}"
954,"<start>    @SuppressWarnings(""NonShortCircuitBooleanExpression"")<end>
@SuppressFBWarnings(""NS_DANGEROUS_NON_SHORT_CIRCUIT"")
private boolean verify()
{
if (recursive) {
//comment
//comment
//comment
while (true) {
<start>int size = thriftTypes.size();
for (ThriftType type : thriftTypes) {
verifyStruct(type, true);
}<end>
if (size == thriftTypes.size()) {
break;
}
}

while (true) {
int size = thriftServices.size();
for (ThriftServiceMetadata service : thriftServices) {
verifyService(service, true);
}
if (size == thriftServices.size()) {
break;
}
}

recursive = false;
usedIncludedTypes.clear();
knownTypes = new HashSet<>(BUILT_IN_TYPES);
}
return verifyTypes() & verifyServices();
}","    @SuppressWarnings(""NonShortCircuitBooleanExpression"")
@SuppressFBWarnings(""NS_DANGEROUS_NON_SHORT_CIRCUIT"")
private boolean verify()
{
if (recursive) {
//comment
//comment
//comment
<start>while (true) {
int size = thriftTypes.size();
for (ThriftType type : thriftTypes) {
verifyStruct(type, true);
}
if (size == thriftTypes.size()) {
break;
}
}

while (true) {
int size = thriftServices.size();
for (ThriftServiceMetadata service : thriftServices) {
verifyService(service, true);
}
if (size == thriftServices.size()) {
break;
}<end>
}

recursive = false;
usedIncludedTypes.clear();
knownTypes = new HashSet<>(BUILT_IN_TYPES);
}
return verifyTypes() & verifyServices();
}"
955,"    @SuppressWarnings(""NonShortCircuitBooleanExpression"")
@SuppressFBWarnings(""NS_DANGEROUS_NON_SHORT_CIRCUIT"")
private boolean verifyField(ThriftType type)
{
ThriftProtocolType proto = type.getProtocolType();
if (proto == ThriftProtocolType.SET || proto == ThriftProtocolType.LIST) {
return verifyElementType(type.getValueTypeReference());
}
if (proto == ThriftProtocolType.MAP) {
return verifyElementType(type.getKeyTypeReference()) & verifyElementType(type.getValueTypeReference());
}

if (knownTypes.contains(type)) {
<start>return true;<end>
}

if (includes.containsKey(type)) {
usedIncludedTypes.add(type);
return true;
}

<start>if (recursive) {
//comment
thriftTypes.add(type);
return verifyStruct(type, true);
}
return false;<end>
}","    @SuppressWarnings(""NonShortCircuitBooleanExpression"")
@SuppressFBWarnings(""NS_DANGEROUS_NON_SHORT_CIRCUIT"")
private boolean verifyField(ThriftType type)
{
ThriftProtocolType proto = type.getProtocolType();
if (proto == ThriftProtocolType.SET || proto == ThriftProtocolType.LIST) {
return verifyElementType(type.getValueTypeReference());
}
if (proto == ThriftProtocolType.MAP) {
return verifyElementType(type.getKeyTypeReference()) & verifyElementType(type.getValueTypeReference());
}

if (knownTypes.contains(type)) {
return true;
}

if (includes.containsKey(type)) {
usedIncludedTypes.add(type);
return true;
}

<start>if (recursive) {
//comment
thriftTypes.add(type);
return verifyStruct(type, true);
}<end>
return false;
}"
1363,"    @Override
public void writeBool(boolean value)
throws TException
{
if (booleanField != null) {
//comment
writeFieldBeginInternal(booleanField, value ? Types.BOOLEAN_TRUE : Types.BOOLEAN_FALSE);
booleanField = null;
}
else {
//comment
<start>writeByteDirect(value ? Types.BOOLEAN_TRUE : Types.BOOLEAN_FALSE);<end>
}
}","    @Override
public void writeBool(boolean value)
throws TException
{
<start>if (booleanField != null) {<end>
//comment
writeFieldBeginInternal(booleanField, value ? Types.BOOLEAN_TRUE : Types.BOOLEAN_FALSE);
booleanField = null;
<start>}
else {
//comment
writeByteDirect(value ? Types.BOOLEAN_TRUE : Types.BOOLEAN_FALSE);
}<end>
}"
1364,"    @Override
public void readStructEnd()
{
//comment
<start>lastFieldId = lastField.pop();<end>
}","    @Override
public void readStructEnd()
{
//comment
<start>lastFieldId = lastField.pop();<end>
}"
1365,"@Override
public TField readFieldBegin()
throws TException
{
byte type = readByte();

//comment
<start>if (type == TType.STOP) {
return TSTOP;
}<end>

short fieldId;

//comment
short modifier = (short) ((type & 0xf0) >> 4);
if (modifier == 0) {
//comment
fieldId = readI16();
}
else {
//comment
fieldId = (short) (lastFieldId + modifier);
}

TField field = new TField("""", getTType((byte) (type & 0x0f)), fieldId);

//comment
if (isBoolType(type)) {
//comment
booleanValue = (byte) (type & 0x0f) == Types.BOOLEAN_TRUE ? Boolean.TRUE : Boolean.FALSE;
}

//comment
lastFieldId = field.getId();
return field;
}","@Override
public TField readFieldBegin()
throws TException
{
<start>byte type = readByte();<end>

//comment
<start>if (type == TType.STOP) {
return TSTOP;
}<end>

short fieldId;

//comment
short modifier = (short) ((type & 0xf0) >> 4);
if (modifier == 0) {
//comment
fieldId = readI16();
}
else {
//comment
fieldId = (short) (lastFieldId + modifier);
}

TField field = new TField("""", getTType((byte) (type & 0x0f)), fieldId);

//comment
if (isBoolType(type)) {
//comment
booleanValue = (byte) (type & 0x0f) == Types.BOOLEAN_TRUE ? Boolean.TRUE : Boolean.FALSE;
}

//comment
lastFieldId = field.getId();
return field;
}"
1366,"@Override
public TField readFieldBegin()
throws TException
{
byte type = readByte();

//comment
if (type == TType.STOP) {
return TSTOP;
}

short fieldId;

//comment
<start>short modifier = (short) ((type & 0xf0) >> 4);<end>
if (modifier == 0) {
//comment
<start>fieldId = readI16();<end>
}
<start>else {<end>
//comment
fieldId = (short) (lastFieldId + modifier);
}

TField field = new TField("""", getTType((byte) (type & 0x0f)), fieldId);

//comment
if (isBoolType(type)) {
//comment
booleanValue = (byte) (type & 0x0f) == Types.BOOLEAN_TRUE ? Boolean.TRUE : Boolean.FALSE;
}

//comment
lastFieldId = field.getId();
return field;
}","@Override
public TField readFieldBegin()
throws TException
{
byte type = readByte();

//comment
if (type == TType.STOP) {
return TSTOP;
}

short fieldId;

//comment
<start>short modifier = (short) ((type & 0xf0) >> 4);<end>
if (modifier == 0) {
//comment
fieldId = readI16();
}
else {
//comment
fieldId = (short) (lastFieldId + modifier);
}

TField field = new TField("""", getTType((byte) (type & 0x0f)), fieldId);

//comment
if (isBoolType(type)) {
//comment
booleanValue = (byte) (type & 0x0f) == Types.BOOLEAN_TRUE ? Boolean.TRUE : Boolean.FALSE;
}

//comment
lastFieldId = field.getId();
return field;
}"
1367,"@Override
public TField readFieldBegin()
throws TException
{
byte type = readByte();

//comment
if (type == TType.STOP) {
return TSTOP;
}

short fieldId;

//comment
short modifier = (short) ((type & 0xf0) >> 4);
if (modifier == 0) {
//comment
fieldId = readI16();
}
else {
//comment
fieldId = (short) (lastFieldId + modifier);
}

TField field = new TField("""", getTType((byte) (type & 0x0f)), fieldId);

//comment
<start>if (isBoolType(type)) {
//comment
booleanValue = (byte) (type & 0x0f) == Types.BOOLEAN_TRUE ? Boolean.TRUE : Boolean.FALSE;
}<end>

//comment
lastFieldId = field.getId();
return field;
}","@Override
public TField readFieldBegin()
throws TException
{
byte type = readByte();

//comment
if (type == TType.STOP) {
return TSTOP;
}

short fieldId;

//comment
short modifier = (short) ((type & 0xf0) >> 4);
if (modifier == 0) {
//comment
fieldId = readI16();
}
else {
//comment
fieldId = (short) (lastFieldId + modifier);
}

<start>TField field = new TField("""", getTType((byte) (type & 0x0f)), fieldId);<end>

//comment
<start>if (isBoolType(type)) {
//comment
booleanValue = (byte) (type & 0x0f) == Types.BOOLEAN_TRUE ? Boolean.TRUE : Boolean.FALSE;
}<end>

//comment
lastFieldId = field.getId();
return field;
}"
1368,"@Override
public TField readFieldBegin()
throws TException
{
byte type = readByte();

//comment
if (type == TType.STOP) {
return TSTOP;
}

short fieldId;

//comment
short modifier = (short) ((type & 0xf0) >> 4);
if (modifier == 0) {
//comment
fieldId = readI16();
}
else {
//comment
fieldId = (short) (lastFieldId + modifier);
}

TField field = new TField("""", getTType((byte) (type & 0x0f)), fieldId);

//comment
<start>if (isBoolType(type)) {
//comment
booleanValue = (byte) (type & 0x0f) == Types.BOOLEAN_TRUE ? Boolean.TRUE : Boolean.FALSE;
}<end>

//comment
lastFieldId = field.getId();
return field;
}","@Override
public TField readFieldBegin()
throws TException
{
byte type = readByte();

//comment
if (type == TType.STOP) {
return TSTOP;
}

short fieldId;

//comment
short modifier = (short) ((type & 0xf0) >> 4);
if (modifier == 0) {
//comment
fieldId = readI16();
}
else {
//comment
fieldId = (short) (lastFieldId + modifier);
}

TField field = new TField("""", getTType((byte) (type & 0x0f)), fieldId);

//comment
if (isBoolType(type)) {
//comment
<start>booleanValue = (byte) (type & 0x0f) == Types.BOOLEAN_TRUE ? Boolean.TRUE : Boolean.FALSE;<end>
}

//comment
lastFieldId = field.getId();
return field;
}"
328,"private void detectNotificationIds(Context context)
{
NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(context)
.setSmallIcon(R.drawable.dummy_icon)
.setContentTitle(""1"")
.setContentText(""2"")
.setContentInfo(""3"")
.setSubText(""4"");

android.app.Notification n = mBuilder.build();

LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
ViewGroup localView;

//comment
<start>localView = (ViewGroup) inflater.inflate(n.contentView.getLayoutId(), null);<end>
n.contentView.reapply(context, localView);
<start>recursiveDetectNotificationsIds(localView);<end>

//comment
//comment
//comment
NotificationCompat.BigTextStyle bigtextstyle = new NotificationCompat.BigTextStyle();
bigtextstyle.setSummaryText(""5"");
bigtextstyle.setBigContentTitle(""6"");
bigtextstyle.bigText(""7"");
mBuilder.setContentTitle(""8"");
mBuilder.setStyle(bigtextstyle);
detectExpandedNotificationsIds(mBuilder.build(), context);

NotificationCompat.InboxStyle inboxStyle =
new NotificationCompat.InboxStyle();
String[] events = {""10"",""11"",""12"",""13"",""14"",""15"",""16"",""17"",""18"",""19""};
inboxStyle.setBigContentTitle(""6"");
mBuilder.setContentTitle(""9"");
inboxStyle.setSummaryText(""5"");

for (int i=0; i < events.length; i++)
{
inboxStyle.addLine(events[i]);
}
mBuilder.setStyle(inboxStyle);

detectExpandedNotificationsIds(mBuilder.build(), context);
//comment
}","private void detectNotificationIds(Context context)
{
NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(context)
.setSmallIcon(R.drawable.dummy_icon)
.setContentTitle(""1"")
.setContentText(""2"")
.setContentInfo(""3"")
.setSubText(""4"");

android.app.Notification n = mBuilder.build();

LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
ViewGroup localView;

//comment
<start>localView = (ViewGroup) inflater.inflate(n.contentView.getLayoutId(), null);
n.contentView.reapply(context, localView);
recursiveDetectNotificationsIds(localView);<end>

//comment
//comment
//comment
NotificationCompat.BigTextStyle bigtextstyle = new NotificationCompat.BigTextStyle();
bigtextstyle.setSummaryText(""5"");
bigtextstyle.setBigContentTitle(""6"");
bigtextstyle.bigText(""7"");
mBuilder.setContentTitle(""8"");
mBuilder.setStyle(bigtextstyle);
detectExpandedNotificationsIds(mBuilder.build(), context);

NotificationCompat.InboxStyle inboxStyle =
new NotificationCompat.InboxStyle();
String[] events = {""10"",""11"",""12"",""13"",""14"",""15"",""16"",""17"",""18"",""19""};
inboxStyle.setBigContentTitle(""6"");
mBuilder.setContentTitle(""9"");
inboxStyle.setSummaryText(""5"");

for (int i=0; i < events.length; i++)
{
inboxStyle.addLine(events[i]);
}
mBuilder.setStyle(inboxStyle);

detectExpandedNotificationsIds(mBuilder.build(), context);
//comment
}"
329,"private void detectNotificationIds(Context context)
{
NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(context)
.setSmallIcon(R.drawable.dummy_icon)
.setContentTitle(""1"")
.setContentText(""2"")
.setContentInfo(""3"")
.setSubText(""4"");

android.app.Notification n = mBuilder.build();

LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
ViewGroup localView;

//comment
localView = (ViewGroup) inflater.inflate(n.contentView.getLayoutId(), null);
n.contentView.reapply(context, localView);
<start>recursiveDetectNotificationsIds(localView);<end>

//comment
//comment
//comment
NotificationCompat.BigTextStyle bigtextstyle = new NotificationCompat.BigTextStyle();
bigtextstyle.setSummaryText(""5"");
<start>bigtextstyle.setBigContentTitle(""6"");<end>
bigtextstyle.bigText(""7"");
mBuilder.setContentTitle(""8"");
mBuilder.setStyle(bigtextstyle);
detectExpandedNotificationsIds(mBuilder.build(), context);

NotificationCompat.InboxStyle inboxStyle =
new NotificationCompat.InboxStyle();
String[] events = {""10"",""11"",""12"",""13"",""14"",""15"",""16"",""17"",""18"",""19""};
inboxStyle.setBigContentTitle(""6"");
mBuilder.setContentTitle(""9"");
inboxStyle.setSummaryText(""5"");

for (int i=0; i < events.length; i++)
{
inboxStyle.addLine(events[i]);
}
mBuilder.setStyle(inboxStyle);

detectExpandedNotificationsIds(mBuilder.build(), context);
//comment
}","private void detectNotificationIds(Context context)
{
NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(context)
.setSmallIcon(R.drawable.dummy_icon)
.setContentTitle(""1"")
.setContentText(""2"")
.setContentInfo(""3"")
.setSubText(""4"");

android.app.Notification n = mBuilder.build();

LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
ViewGroup localView;

//comment
localView = (ViewGroup) inflater.inflate(n.contentView.getLayoutId(), null);
n.contentView.reapply(context, localView);
recursiveDetectNotificationsIds(localView);

//comment
//comment
//comment
<start>NotificationCompat.BigTextStyle bigtextstyle = new NotificationCompat.BigTextStyle();
bigtextstyle.setSummaryText(""5"");
bigtextstyle.setBigContentTitle(""6"");
bigtextstyle.bigText(""7"");
mBuilder.setContentTitle(""8"");
mBuilder.setStyle(bigtextstyle);
detectExpandedNotificationsIds(mBuilder.build(), context);<end>

NotificationCompat.InboxStyle inboxStyle =
new NotificationCompat.InboxStyle();
String[] events = {""10"",""11"",""12"",""13"",""14"",""15"",""16"",""17"",""18"",""19""};
inboxStyle.setBigContentTitle(""6"");
mBuilder.setContentTitle(""9"");
inboxStyle.setSummaryText(""5"");

for (int i=0; i < events.length; i++)
{
inboxStyle.addLine(events[i]);
}
mBuilder.setStyle(inboxStyle);

detectExpandedNotificationsIds(mBuilder.build(), context);
//comment
}"
6814,"public static NotificationData getMapNotification(Context context, StatusBarNotification statusBarNotification) {

Logger.debug(""getMapNotification package: {} key: {}"", statusBarNotification.getPackageName(), statusBarNotification.getKey());

NotificationData notificationData = null;

if(Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {
notificationData = fromStatusBarNotification(context, statusBarNotification);

RemoteViews rmv = getContentView(context, statusBarNotification.getNotification());
RemoteViews brmv = getBigContentView(context, statusBarNotification.getNotification());

if (rmv == null) {
rmv = brmv;
Logger.debug(""using BigContentView"");
} else {
Logger.debug(""using ContentView"");
}

if (rmv != null) {

//comment
<start>List<String> txt = extractText(rmv);<end>
if ((txt.size() > 0) && (!(txt.get(0).isEmpty()))) {

//comment
try {
LayoutInflater inflater = (LayoutInflater) context.getSystemService(LAYOUT_INFLATER_SERVICE);
View layout = inflater.inflate(R.layout.nav_layout, null);
ViewGroup frame = layout.findViewById(R.id.layout_navi);
frame.removeAllViews();
View newView = rmv.apply(context, frame);
frame.addView(newView);
View viewImage = ((ViewGroup) newView).getChildAt(0);
//comment
viewImage.measure(View.MeasureSpec.UNSPECIFIED, View.MeasureSpec.UNSPECIFIED);
Bitmap bitmap = Bitmap.createBitmap(viewImage.getMeasuredWidth(), viewImage.getMeasuredHeight(), Bitmap.Config.ARGB_8888);
Canvas canvas = new Canvas(bitmap);
viewImage.layout(0, 0, viewImage.getMeasuredWidth(), viewImage.getMeasuredHeight());
viewImage.draw(canvas);
bitmap = Bitmap.createScaledBitmap(bitmap, 48, 48, true);

int width = bitmap.getWidth();
int height = bitmap.getHeight();
int[] intArray = new int[width * height];
bitmap.getPixels(intArray, 0, width, 0, 0, width, height);
Logger.info(""bitmap dimensions: "" + width + "" x "" + height);

notificationData.setIcon(intArray);
notificationData.setIconWidth(width);
notificationData.setIconHeight(height);
} catch (Exception e) {
notificationData.setIcon(new int[]{});
Logger.error(e, ""failed to get bitmap with exception: {}"", e.getMessage());
}

notificationData.setTitle(txt.get(0));
if (txt.size() > 1)
notificationData.setText(txt.get(1));
else
notificationData.setText("""");
notificationData.setHideReplies(true);
notificationData.setHideButtons(false);
notificationData.setForceCustom(true);
}
return notificationData;

} else {
Logger.warn(""null remoteView"");
return null;
}

} else {
isNormalNotification = false;
notificationData = fromStatusBarNotification(context, statusBarNotification);
notificationData.setHideReplies(true);
notificationData.setHideButtons(false);
notificationData.setForceCustom(true);
isNormalNotification = true;
return notificationData;
}
}","public static NotificationData getMapNotification(Context context, StatusBarNotification statusBarNotification) {

Logger.debug(""getMapNotification package: {} key: {}"", statusBarNotification.getPackageName(), statusBarNotification.getKey());

NotificationData notificationData = null;

if(Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {
notificationData = fromStatusBarNotification(context, statusBarNotification);

RemoteViews rmv = getContentView(context, statusBarNotification.getNotification());
RemoteViews brmv = getBigContentView(context, statusBarNotification.getNotification());

if (rmv == null) {
rmv = brmv;
Logger.debug(""using BigContentView"");
} else {
Logger.debug(""using ContentView"");
}

if (rmv != null) {

//comment
<start>List<String> txt = extractText(rmv);
if ((txt.size() > 0) && (!(txt.get(0).isEmpty()))) {

//comment
try {
LayoutInflater inflater = (LayoutInflater) context.getSystemService(LAYOUT_INFLATER_SERVICE);
View layout = inflater.inflate(R.layout.nav_layout, null);
ViewGroup frame = layout.findViewById(R.id.layout_navi);
frame.removeAllViews();
View newView = rmv.apply(context, frame);
frame.addView(newView);
View viewImage = ((ViewGroup) newView).getChildAt(0);
//comment
viewImage.measure(View.MeasureSpec.UNSPECIFIED, View.MeasureSpec.UNSPECIFIED);
Bitmap bitmap = Bitmap.createBitmap(viewImage.getMeasuredWidth(), viewImage.getMeasuredHeight(), Bitmap.Config.ARGB_8888);
Canvas canvas = new Canvas(bitmap);
viewImage.layout(0, 0, viewImage.getMeasuredWidth(), viewImage.getMeasuredHeight());
viewImage.draw(canvas);
bitmap = Bitmap.createScaledBitmap(bitmap, 48, 48, true);

int width = bitmap.getWidth();
int height = bitmap.getHeight();
int[] intArray = new int[width * height];
bitmap.getPixels(intArray, 0, width, 0, 0, width, height);
Logger.info(""bitmap dimensions: "" + width + "" x "" + height);

notificationData.setIcon(intArray);
notificationData.setIconWidth(width);
notificationData.setIconHeight(height);
} catch (Exception e) {
notificationData.setIcon(new int[]{});
Logger.error(e, ""failed to get bitmap with exception: {}"", e.getMessage());
}

notificationData.setTitle(txt.get(0));
if (txt.size() > 1)
notificationData.setText(txt.get(1));
else
notificationData.setText("""");
notificationData.setHideReplies(true);
notificationData.setHideButtons(false);
notificationData.setForceCustom(true);
}
return notificationData;

} else {<end>
Logger.warn(""null remoteView"");
return null;
}

} else {
isNormalNotification = false;
notificationData = fromStatusBarNotification(context, statusBarNotification);
notificationData.setHideReplies(true);
notificationData.setHideButtons(false);
notificationData.setForceCustom(true);
isNormalNotification = true;
return notificationData;
}
}"
6817,"private static List<String> extractText(RemoteViews views) {
//comment
List<String> text = new ArrayList<>();
try {
Field field = views.getClass().getDeclaredField(""mActions"");
field.setAccessible(true);
//comment

@SuppressWarnings(""unchecked"")
ArrayList<Parcelable> actions = (ArrayList<Parcelable>) field.get(views);

//comment
for (Parcelable p : actions) {
Parcel parcel = Parcel.obtain();
p.writeToParcel(parcel, 0);
parcel.setDataPosition(0);

//comment
int tag = parcel.readInt();
if (tag != 2) continue;

//comment
parcel.readInt();

String methodName = parcel.readString();
if (methodName == null)
continue;
//comment
else {

if (methodName.equals(""setText"")) {
//comment
parcel.readInt();

//comment
String t = TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(parcel).toString().trim();
text.add(t);
//comment
//comment
}
}
parcel.recycle();
}
}
//comment
catch (Exception e) {
Logger.error(e, ""extractText exception: {}"", e.getMessage());
text.add(""ERROR"");
}
return text;
}","private static List<String> extractText(RemoteViews views) {
//comment
List<String> text = new ArrayList<>();
try {
Field field = views.getClass().getDeclaredField(""mActions"");
field.setAccessible(true);
//comment

@SuppressWarnings(""unchecked"")
ArrayList<Parcelable> actions = (ArrayList<Parcelable>) field.get(views);

//comment
<start>for (Parcelable p : actions) {
Parcel parcel = Parcel.obtain();
p.writeToParcel(parcel, 0);
parcel.setDataPosition(0);

//comment
int tag = parcel.readInt();
if (tag != 2) continue;

//comment
parcel.readInt();

String methodName = parcel.readString();
if (methodName == null)
continue;
//comment
else {

if (methodName.equals(""setText"")) {
//comment
parcel.readInt();

//comment
String t = TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(parcel).toString().trim();
text.add(t);
//comment
//comment
}
}
parcel.recycle();
}<end>
}
//comment
catch (Exception e) {
Logger.error(e, ""extractText exception: {}"", e.getMessage());
text.add(""ERROR"");
}
return text;
}"
6712,"    @Override
public void onCreate() {
super.onCreate();

Logger.debug(""onCreate is now running..."");

//comment
<start>startPersistentNotification();<end>
tryReconnectNotificationService();

transportListener = new TransportListener(this);
EventBus.getDefault().register(transportListener);

Logger.trace(""connecting transporters..."");
//comment
transporterAmazMod = TransporterClassic.get(this, Transport.NAME);
if (!transporterAmazMod.isTransportServiceConnected()) {
transporterAmazMod.addDataListener(this);
transporterAmazMod.connectTransportService();
AmazModApplication.setWatchConnected(false);
}
//comment
transporterNotifications = TransporterClassic.get(this, Transport.NAME_NOTIFICATION);
if (!transporterNotifications.isTransportServiceConnected()) {
transporterNotifications.connectTransportService();
AmazModApplication.setWatchConnected(false);
}
//comment
transporterHuami = TransporterClassic.get(this, ""com.huami.action.notification"");
if (!transporterHuami.isTransportServiceConnected()) {
transporterHuami.connectTransportService();
AmazModApplication.setWatchConnected(false);
}
//comment
transporterCompanion = TransporterClassic.get(this, ""com.huami.watch.companion"");
if (!transporterCompanion.isTransportServiceConnected()) {
transporterCompanion.addDataListener(this);
transporterCompanion.connectTransportService();
AmazModApplication.setWatchConnected(false);
}
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

//comment
if (PreferenceManager.getDefaultSharedPreferences(this).getBoolean(Constants.PREF_ENABLE_INTERNET_COMPANION, false))
startInternetCompanion(getApplicationContext());
if (PreferenceManager.getDefaultSharedPreferences(this).getBoolean(Constants.PREF_ENABLE_SLEEP_AS_ANDROID, false))
sleepListener.register(this);
}","    @Override
public void onCreate() {
super.onCreate();

Logger.debug(""onCreate is now running..."");

//comment
<start>startPersistentNotification();
tryReconnectNotificationService();<end>

transportListener = new TransportListener(this);
EventBus.getDefault().register(transportListener);

Logger.trace(""connecting transporters..."");
//comment
transporterAmazMod = TransporterClassic.get(this, Transport.NAME);
if (!transporterAmazMod.isTransportServiceConnected()) {
transporterAmazMod.addDataListener(this);
transporterAmazMod.connectTransportService();
AmazModApplication.setWatchConnected(false);
}
//comment
transporterNotifications = TransporterClassic.get(this, Transport.NAME_NOTIFICATION);
if (!transporterNotifications.isTransportServiceConnected()) {
transporterNotifications.connectTransportService();
AmazModApplication.setWatchConnected(false);
}
//comment
transporterHuami = TransporterClassic.get(this, ""com.huami.action.notification"");
if (!transporterHuami.isTransportServiceConnected()) {
transporterHuami.connectTransportService();
AmazModApplication.setWatchConnected(false);
}
//comment
transporterCompanion = TransporterClassic.get(this, ""com.huami.watch.companion"");
if (!transporterCompanion.isTransportServiceConnected()) {
transporterCompanion.addDataListener(this);
transporterCompanion.connectTransportService();
AmazModApplication.setWatchConnected(false);
}
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

//comment
if (PreferenceManager.getDefaultSharedPreferences(this).getBoolean(Constants.PREF_ENABLE_INTERNET_COMPANION, false))
startInternetCompanion(getApplicationContext());
if (PreferenceManager.getDefaultSharedPreferences(this).getBoolean(Constants.PREF_ENABLE_SLEEP_AS_ANDROID, false))
sleepListener.register(this);
}"
6713,"    @Override
public void onCreate() {
super.onCreate();

Logger.debug(""onCreate is now running..."");

//comment
startPersistentNotification();
tryReconnectNotificationService();

transportListener = new TransportListener(this);
EventBus.getDefault().register(transportListener);

Logger.trace(""connecting transporters..."");
//comment
transporterAmazMod = TransporterClassic.get(this, Transport.NAME);
if (!transporterAmazMod.isTransportServiceConnected()) {
<start>transporterAmazMod.addDataListener(this);
transporterAmazMod.connectTransportService();
AmazModApplication.setWatchConnected(false);<end>
}
//comment
transporterNotifications = TransporterClassic.get(this, Transport.NAME_NOTIFICATION);
if (!transporterNotifications.isTransportServiceConnected()) {
transporterNotifications.connectTransportService();
AmazModApplication.setWatchConnected(false);
}
//comment
transporterHuami = TransporterClassic.get(this, ""com.huami.action.notification"");
if (!transporterHuami.isTransportServiceConnected()) {
transporterHuami.connectTransportService();
AmazModApplication.setWatchConnected(false);
}
//comment
transporterCompanion = TransporterClassic.get(this, ""com.huami.watch.companion"");
if (!transporterCompanion.isTransportServiceConnected()) {
transporterCompanion.addDataListener(this);
transporterCompanion.connectTransportService();
AmazModApplication.setWatchConnected(false);
}
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

//comment
if (PreferenceManager.getDefaultSharedPreferences(this).getBoolean(Constants.PREF_ENABLE_INTERNET_COMPANION, false))
startInternetCompanion(getApplicationContext());
if (PreferenceManager.getDefaultSharedPreferences(this).getBoolean(Constants.PREF_ENABLE_SLEEP_AS_ANDROID, false))
sleepListener.register(this);
}","    @Override
public void onCreate() {
super.onCreate();

Logger.debug(""onCreate is now running..."");

//comment
startPersistentNotification();
tryReconnectNotificationService();

transportListener = new TransportListener(this);
EventBus.getDefault().register(transportListener);

Logger.trace(""connecting transporters..."");
//comment
transporterAmazMod = TransporterClassic.get(this, Transport.NAME);
if (!transporterAmazMod.isTransportServiceConnected()) {
<start>transporterAmazMod.addDataListener(this);<end>
transporterAmazMod.connectTransportService();
AmazModApplication.setWatchConnected(false);
}
//comment
transporterNotifications = TransporterClassic.get(this, Transport.NAME_NOTIFICATION);
if (!transporterNotifications.isTransportServiceConnected()) {
transporterNotifications.connectTransportService();
AmazModApplication.setWatchConnected(false);
}
//comment
transporterHuami = TransporterClassic.get(this, ""com.huami.action.notification"");
if (!transporterHuami.isTransportServiceConnected()) {
transporterHuami.connectTransportService();
AmazModApplication.setWatchConnected(false);
}
//comment
transporterCompanion = TransporterClassic.get(this, ""com.huami.watch.companion"");
if (!transporterCompanion.isTransportServiceConnected()) {
transporterCompanion.addDataListener(this);
transporterCompanion.connectTransportService();
AmazModApplication.setWatchConnected(false);
}
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

//comment
if (PreferenceManager.getDefaultSharedPreferences(this).getBoolean(Constants.PREF_ENABLE_INTERNET_COMPANION, false))
startInternetCompanion(getApplicationContext());
if (PreferenceManager.getDefaultSharedPreferences(this).getBoolean(Constants.PREF_ENABLE_SLEEP_AS_ANDROID, false))
sleepListener.register(this);
}"
6714,"    @Override
public void onCreate() {
super.onCreate();

Logger.debug(""onCreate is now running..."");

//comment
startPersistentNotification();
tryReconnectNotificationService();

transportListener = new TransportListener(this);
EventBus.getDefault().register(transportListener);

Logger.trace(""connecting transporters..."");
//comment
transporterAmazMod = TransporterClassic.get(this, Transport.NAME);
if (!transporterAmazMod.isTransportServiceConnected()) {
transporterAmazMod.addDataListener(this);
transporterAmazMod.connectTransportService();
AmazModApplication.setWatchConnected(false);
}
//comment
transporterNotifications = TransporterClassic.get(this, Transport.NAME_NOTIFICATION);
if (!transporterNotifications.isTransportServiceConnected()) {
transporterNotifications.connectTransportService();
AmazModApplication.setWatchConnected(false);
}
//comment
transporterHuami = TransporterClassic.get(this, ""com.huami.action.notification"");
if (!transporterHuami.isTransportServiceConnected()) {
transporterHuami.connectTransportService();
AmazModApplication.setWatchConnected(false);
}
//comment
transporterCompanion = TransporterClassic.get(this, ""com.huami.watch.companion"");
if (!transporterCompanion.isTransportServiceConnected()) {
<start>transporterCompanion.addDataListener(this);<end>
transporterCompanion.connectTransportService();
<start>AmazModApplication.setWatchConnected(false);<end>
}
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

//comment
if (PreferenceManager.getDefaultSharedPreferences(this).getBoolean(Constants.PREF_ENABLE_INTERNET_COMPANION, false))
startInternetCompanion(getApplicationContext());
if (PreferenceManager.getDefaultSharedPreferences(this).getBoolean(Constants.PREF_ENABLE_SLEEP_AS_ANDROID, false))
sleepListener.register(this);
}","    @Override
public void onCreate() {
super.onCreate();

Logger.debug(""onCreate is now running..."");

//comment
startPersistentNotification();
tryReconnectNotificationService();

transportListener = new TransportListener(this);
EventBus.getDefault().register(transportListener);

Logger.trace(""connecting transporters..."");
//comment
transporterAmazMod = TransporterClassic.get(this, Transport.NAME);
if (!transporterAmazMod.isTransportServiceConnected()) {
transporterAmazMod.addDataListener(this);
transporterAmazMod.connectTransportService();
AmazModApplication.setWatchConnected(false);
}
//comment
transporterNotifications = TransporterClassic.get(this, Transport.NAME_NOTIFICATION);
if (!transporterNotifications.isTransportServiceConnected()) {
transporterNotifications.connectTransportService();
AmazModApplication.setWatchConnected(false);
}
//comment
transporterHuami = TransporterClassic.get(this, ""com.huami.action.notification"");
if (!transporterHuami.isTransportServiceConnected()) {
transporterHuami.connectTransportService();
AmazModApplication.setWatchConnected(false);
}
//comment
transporterCompanion = TransporterClassic.get(this, ""com.huami.watch.companion"");
if (!transporterCompanion.isTransportServiceConnected()) {
<start>transporterCompanion.addDataListener(this);<end>
transporterCompanion.connectTransportService();
AmazModApplication.setWatchConnected(false);
}
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

//comment
if (PreferenceManager.getDefaultSharedPreferences(this).getBoolean(Constants.PREF_ENABLE_INTERNET_COMPANION, false))
startInternetCompanion(getApplicationContext());
if (PreferenceManager.getDefaultSharedPreferences(this).getBoolean(Constants.PREF_ENABLE_SLEEP_AS_ANDROID, false))
sleepListener.register(this);
}"
6715,"    @Override
public void onDataReceived(TransportDataItem transportDataItem) {
//comment
String action = transportDataItem.getAction();
Logger.debug(""Watch replied with action: {} (full reply: {})"", action, transportDataItem.toString());

//comment
<start>Object event = dataToClass(transportDataItem);<end>

if (action != null) {
//comment
TaskCompletionSource<Object> taskCompletionSourcePendingResult = (TaskCompletionSource<Object>) pendingResults.get(action);
if (taskCompletionSourcePendingResult != null) {
pendingResults.remove(action);
//comment
taskCompletionSourcePendingResult.setResult(event);
} else {
//comment
if( event != null ) {
Logger.trace(""Sending EventBus event: ""+event);
EventBus.getDefault().post(event);
}else{
Logger.trace(""EventBus event is null"");
}
}
} else {
//comment
Logger.error(""TransportService onDataReceived null action!"");
}
}","    @Override
public void onDataReceived(TransportDataItem transportDataItem) {
//comment
String action = transportDataItem.getAction();
Logger.debug(""Watch replied with action: {} (full reply: {})"", action, transportDataItem.toString());

//comment
<start>Object event = dataToClass(transportDataItem);<end>

if (action != null) {
//comment
TaskCompletionSource<Object> taskCompletionSourcePendingResult = (TaskCompletionSource<Object>) pendingResults.get(action);
if (taskCompletionSourcePendingResult != null) {
pendingResults.remove(action);
//comment
taskCompletionSourcePendingResult.setResult(event);
} else {
//comment
if( event != null ) {
Logger.trace(""Sending EventBus event: ""+event);
EventBus.getDefault().post(event);
}else{
Logger.trace(""EventBus event is null"");
}
}
} else {
//comment
Logger.error(""TransportService onDataReceived null action!"");
}
}"
6716,"    @Override
public void onDataReceived(TransportDataItem transportDataItem) {
//comment
String action = transportDataItem.getAction();
Logger.debug(""Watch replied with action: {} (full reply: {})"", action, transportDataItem.toString());

//comment
Object event = dataToClass(transportDataItem);

if (action != null) {
//comment
<start>TaskCompletionSource<Object> taskCompletionSourcePendingResult = (TaskCompletionSource<Object>) pendingResults.get(action);<end>
if (taskCompletionSourcePendingResult != null) {
pendingResults.remove(action);
//comment
taskCompletionSourcePendingResult.setResult(event);
<start>} else {<end>
//comment
if( event != null ) {
Logger.trace(""Sending EventBus event: ""+event);
EventBus.getDefault().post(event);
}else{
Logger.trace(""EventBus event is null"");
}
}
} else {
//comment
Logger.error(""TransportService onDataReceived null action!"");
}
}","    @Override
public void onDataReceived(TransportDataItem transportDataItem) {
//comment
String action = transportDataItem.getAction();
Logger.debug(""Watch replied with action: {} (full reply: {})"", action, transportDataItem.toString());

//comment
Object event = dataToClass(transportDataItem);

if (action != null) {
//comment
<start>TaskCompletionSource<Object> taskCompletionSourcePendingResult = (TaskCompletionSource<Object>) pendingResults.get(action);
if (taskCompletionSourcePendingResult != null) {<end>
pendingResults.remove(action);
//comment
taskCompletionSourcePendingResult.setResult(event);
} else {
//comment
if( event != null ) {
Logger.trace(""Sending EventBus event: ""+event);
EventBus.getDefault().post(event);
}else{
Logger.trace(""EventBus event is null"");
}
}
} else {
//comment
Logger.error(""TransportService onDataReceived null action!"");
}
}"
6717,"    public void send(char mode, final String action, Transportable transportable, final TaskCompletionSource<Void> waiter) {
//comment
Transporter transporter = getTransporter(mode, action);

if (transporter == null)
return;

boolean isTransportConnected = transporter.isTransportServiceConnected();
if (!isTransportConnected) {
if (AmazModApplication.isWatchConnected() || (EventBus.getDefault().getStickyEvent(IsWatchConnectedLocal.class) == null)) {
AmazModApplication.setWatchConnected(false);
EventBus.getDefault().removeAllStickyEvents();
EventBus.getDefault().postSticky(new IsWatchConnectedLocal(AmazModApplication.isWatchConnected()));
persistentNotification.updatePersistentNotification(AmazModApplication.isWatchConnected());
}
Logger.warn(""Transporter is not connected"");
return;
}

if(!BluetoothAdapter.getDefaultAdapter().isEnabled()){
if (AmazModApplication.isWatchConnected() || (EventBus.getDefault().getStickyEvent(IsWatchConnectedLocal.class) == null)) {
AmazModApplication.setWatchConnected(false);
EventBus.getDefault().removeAllStickyEvents();
EventBus.getDefault().postSticky(new IsWatchConnectedLocal(AmazModApplication.isWatchConnected()));
persistentNotification.updatePersistentNotification(AmazModApplication.isWatchConnected());
}
Logger.warn(""Bluetooth is not enabled"");
return;
}

DataBundle dataBundle = new DataBundle();
if (transportable != null)
transportable.toDataBundle(dataBundle);

Logger.debug(""Send action: {}"", action);
transporter.send(action, dataBundle, new Transporter.DataSendResultCallback() {
@Override
public void onResultBack(DataTransportResult dataTransportResult) {
Logger.info(""Send result: {}"", dataTransportResult.toString());

switch (dataTransportResult.getResultCode()) {
case (DataTransportResult.RESULT_FAILED_TRANSPORT_SERVICE_UNCONNECTED):
case (DataTransportResult.RESULT_FAILED_CHANNEL_UNAVAILABLE):
case (DataTransportResult.RESULT_FAILED_IWDS_CRASH):
case (DataTransportResult.RESULT_FAILED_LINK_DISCONNECTED): {
TaskCompletionSource<Object> taskCompletionSourcePendingResult = (TaskCompletionSource<Object>) pendingResults.get(action);
if (taskCompletionSourcePendingResult != null) {
taskCompletionSourcePendingResult.setException(new RuntimeException(""TransporterError: "" + dataTransportResult.toString()));
pendingResults.remove(action);
}

if (waiter != null)
waiter.setException(new RuntimeException(""TransporterError: "" + dataTransportResult.toString()));
<start>break;<end>
}
case (DataTransportResult.RESULT_OK): {
//comment
if (waiter != null)
waiter.setResult(null);

//comment
if (EventBus.getDefault().getStickyEvent(IsWatchConnectedLocal.class) == null) {
AmazModApplication.setWatchConnected(true);
EventBus.getDefault().removeAllStickyEvents();
EventBus.getDefault().postSticky(new IsWatchConnectedLocal(true));
persistentNotification.updatePersistentNotification(true);
}

//comment
break;
}
default:
Logger.warn(""Send status result is an unknown getResultCode: {}"", dataTransportResult.getResultCode());
}
}
});
}","    public void send(char mode, final String action, Transportable transportable, final TaskCompletionSource<Void> waiter) {
//comment
Transporter transporter = getTransporter(mode, action);

if (transporter == null)
return;

boolean isTransportConnected = transporter.isTransportServiceConnected();
if (!isTransportConnected) {
if (AmazModApplication.isWatchConnected() || (EventBus.getDefault().getStickyEvent(IsWatchConnectedLocal.class) == null)) {
AmazModApplication.setWatchConnected(false);
EventBus.getDefault().removeAllStickyEvents();
EventBus.getDefault().postSticky(new IsWatchConnectedLocal(AmazModApplication.isWatchConnected()));
persistentNotification.updatePersistentNotification(AmazModApplication.isWatchConnected());
}
Logger.warn(""Transporter is not connected"");
return;
}

if(!BluetoothAdapter.getDefaultAdapter().isEnabled()){
if (AmazModApplication.isWatchConnected() || (EventBus.getDefault().getStickyEvent(IsWatchConnectedLocal.class) == null)) {
AmazModApplication.setWatchConnected(false);
EventBus.getDefault().removeAllStickyEvents();
EventBus.getDefault().postSticky(new IsWatchConnectedLocal(AmazModApplication.isWatchConnected()));
persistentNotification.updatePersistentNotification(AmazModApplication.isWatchConnected());
}
Logger.warn(""Bluetooth is not enabled"");
return;
}

DataBundle dataBundle = new DataBundle();
if (transportable != null)
transportable.toDataBundle(dataBundle);

Logger.debug(""Send action: {}"", action);
transporter.send(action, dataBundle, new Transporter.DataSendResultCallback() {
@Override
public void onResultBack(DataTransportResult dataTransportResult) {
Logger.info(""Send result: {}"", dataTransportResult.toString());

<start>switch (dataTransportResult.getResultCode()) {<end>
case (DataTransportResult.RESULT_FAILED_TRANSPORT_SERVICE_UNCONNECTED):
case (DataTransportResult.RESULT_FAILED_CHANNEL_UNAVAILABLE):
case (DataTransportResult.RESULT_FAILED_IWDS_CRASH):
case (DataTransportResult.RESULT_FAILED_LINK_DISCONNECTED): {
TaskCompletionSource<Object> taskCompletionSourcePendingResult = (TaskCompletionSource<Object>) pendingResults.get(action);
if (taskCompletionSourcePendingResult != null) {
taskCompletionSourcePendingResult.setException(new RuntimeException(""TransporterError: "" + dataTransportResult.toString()));
pendingResults.remove(action);
}

if (waiter != null)
waiter.setException(new RuntimeException(""TransporterError: "" + dataTransportResult.toString()));
break;
}
<start>case (DataTransportResult.RESULT_OK): {<end>
//comment
if (waiter != null)
waiter.setResult(null);

//comment
if (EventBus.getDefault().getStickyEvent(IsWatchConnectedLocal.class) == null) {
AmazModApplication.setWatchConnected(true);
EventBus.getDefault().removeAllStickyEvents();
EventBus.getDefault().postSticky(new IsWatchConnectedLocal(true));
persistentNotification.updatePersistentNotification(true);
}

//comment
break;
}
default:
Logger.warn(""Send status result is an unknown getResultCode: {}"", dataTransportResult.getResultCode());
<start>}
}<end>
});
}"
6718,"    public void send(char mode, final String action, Transportable transportable, final TaskCompletionSource<Void> waiter) {
//comment
Transporter transporter = getTransporter(mode, action);

if (transporter == null)
return;

boolean isTransportConnected = transporter.isTransportServiceConnected();
if (!isTransportConnected) {
if (AmazModApplication.isWatchConnected() || (EventBus.getDefault().getStickyEvent(IsWatchConnectedLocal.class) == null)) {
AmazModApplication.setWatchConnected(false);
EventBus.getDefault().removeAllStickyEvents();
EventBus.getDefault().postSticky(new IsWatchConnectedLocal(AmazModApplication.isWatchConnected()));
persistentNotification.updatePersistentNotification(AmazModApplication.isWatchConnected());
}
Logger.warn(""Transporter is not connected"");
return;
}

if(!BluetoothAdapter.getDefaultAdapter().isEnabled()){
if (AmazModApplication.isWatchConnected() || (EventBus.getDefault().getStickyEvent(IsWatchConnectedLocal.class) == null)) {
AmazModApplication.setWatchConnected(false);
EventBus.getDefault().removeAllStickyEvents();
EventBus.getDefault().postSticky(new IsWatchConnectedLocal(AmazModApplication.isWatchConnected()));
persistentNotification.updatePersistentNotification(AmazModApplication.isWatchConnected());
}
Logger.warn(""Bluetooth is not enabled"");
return;
}

DataBundle dataBundle = new DataBundle();
if (transportable != null)
transportable.toDataBundle(dataBundle);

Logger.debug(""Send action: {}"", action);
transporter.send(action, dataBundle, new Transporter.DataSendResultCallback() {
@Override
public void onResultBack(DataTransportResult dataTransportResult) {
Logger.info(""Send result: {}"", dataTransportResult.toString());

switch (dataTransportResult.getResultCode()) {
case (DataTransportResult.RESULT_FAILED_TRANSPORT_SERVICE_UNCONNECTED):
case (DataTransportResult.RESULT_FAILED_CHANNEL_UNAVAILABLE):
case (DataTransportResult.RESULT_FAILED_IWDS_CRASH):
case (DataTransportResult.RESULT_FAILED_LINK_DISCONNECTED): {
TaskCompletionSource<Object> taskCompletionSourcePendingResult = (TaskCompletionSource<Object>) pendingResults.get(action);
if (taskCompletionSourcePendingResult != null) {
taskCompletionSourcePendingResult.setException(new RuntimeException(""TransporterError: "" + dataTransportResult.toString()));
pendingResults.remove(action);
}

if (waiter != null)
waiter.setException(new RuntimeException(""TransporterError: "" + dataTransportResult.toString()));
break;
}
case (DataTransportResult.RESULT_OK): {
//comment
if (waiter != null)
waiter.setResult(null);

//comment
if (EventBus.getDefault().getStickyEvent(IsWatchConnectedLocal.class) == null) {
AmazModApplication.setWatchConnected(true);
EventBus.getDefault().removeAllStickyEvents();
EventBus.getDefault().postSticky(new IsWatchConnectedLocal(true));
persistentNotification.updatePersistentNotification(true);
}

//comment
break;
}
default:
Logger.warn(""Send status result is an unknown getResultCode: {}"", dataTransportResult.getResultCode());
}
}
});
}","    public void send(char mode, final String action, Transportable transportable, final TaskCompletionSource<Void> waiter) {
//comment
Transporter transporter = getTransporter(mode, action);

if (transporter == null)
return;

boolean isTransportConnected = transporter.isTransportServiceConnected();
if (!isTransportConnected) {
if (AmazModApplication.isWatchConnected() || (EventBus.getDefault().getStickyEvent(IsWatchConnectedLocal.class) == null)) {
AmazModApplication.setWatchConnected(false);
EventBus.getDefault().removeAllStickyEvents();
EventBus.getDefault().postSticky(new IsWatchConnectedLocal(AmazModApplication.isWatchConnected()));
persistentNotification.updatePersistentNotification(AmazModApplication.isWatchConnected());
}
Logger.warn(""Transporter is not connected"");
return;
}

if(!BluetoothAdapter.getDefaultAdapter().isEnabled()){
if (AmazModApplication.isWatchConnected() || (EventBus.getDefault().getStickyEvent(IsWatchConnectedLocal.class) == null)) {
AmazModApplication.setWatchConnected(false);
EventBus.getDefault().removeAllStickyEvents();
EventBus.getDefault().postSticky(new IsWatchConnectedLocal(AmazModApplication.isWatchConnected()));
persistentNotification.updatePersistentNotification(AmazModApplication.isWatchConnected());
}
Logger.warn(""Bluetooth is not enabled"");
return;
}

DataBundle dataBundle = new DataBundle();
if (transportable != null)
transportable.toDataBundle(dataBundle);

Logger.debug(""Send action: {}"", action);
transporter.send(action, dataBundle, new Transporter.DataSendResultCallback() {
@Override
public void onResultBack(DataTransportResult dataTransportResult) {
Logger.info(""Send result: {}"", dataTransportResult.toString());

switch (dataTransportResult.getResultCode()) {
case (DataTransportResult.RESULT_FAILED_TRANSPORT_SERVICE_UNCONNECTED):
case (DataTransportResult.RESULT_FAILED_CHANNEL_UNAVAILABLE):
case (DataTransportResult.RESULT_FAILED_IWDS_CRASH):
case (DataTransportResult.RESULT_FAILED_LINK_DISCONNECTED): {
TaskCompletionSource<Object> taskCompletionSourcePendingResult = (TaskCompletionSource<Object>) pendingResults.get(action);
if (taskCompletionSourcePendingResult != null) {
taskCompletionSourcePendingResult.setException(new RuntimeException(""TransporterError: "" + dataTransportResult.toString()));
pendingResults.remove(action);
}

if (waiter != null)
waiter.setException(new RuntimeException(""TransporterError: "" + dataTransportResult.toString()));
break;
}
case (DataTransportResult.RESULT_OK): {
//comment
if (waiter != null)
waiter.setResult(null);

//comment
<start>if (EventBus.getDefault().getStickyEvent(IsWatchConnectedLocal.class) == null) {
AmazModApplication.setWatchConnected(true);
EventBus.getDefault().removeAllStickyEvents();
EventBus.getDefault().postSticky(new IsWatchConnectedLocal(true));
persistentNotification.updatePersistentNotification(true);
}<end>

//comment
break;
}
default:
Logger.warn(""Send status result is an unknown getResultCode: {}"", dataTransportResult.getResultCode());
}
}
});
}"
6719,"    private Object dataToClass(TransportDataItem transportDataItem) {
String action = transportDataItem.getAction();

//comment

//comment
<start>Class messageClass = messages.get(action);<end>
Class[] args = {DataBundle.class};

//comment
if (messageClass == null)
messageClass = OtherData.class;

try {
Constructor eventConstructor = messageClass.getDeclaredConstructor(args);
Object event = eventConstructor.newInstance(transportDataItem.getData());
Logger.debug(""Watch data to class: {} -> {}"", action, event.toString());

return event;
} catch (NoSuchMethodException e) {
Logger.debug(""Transport event mapped with action \""{}\"" doesn't have constructor with DataBundle as parameter"", action);
e.printStackTrace();
return null;
} catch (IllegalAccessException | InstantiationException | InvocationTargetException e) {
e.printStackTrace();
return null;
}
}","    private Object dataToClass(TransportDataItem transportDataItem) {
String action = transportDataItem.getAction();

//comment

//comment
<start>Class messageClass = messages.get(action);
Class[] args = {DataBundle.class};<end>

//comment
if (messageClass == null)
messageClass = OtherData.class;

try {
Constructor eventConstructor = messageClass.getDeclaredConstructor(args);
Object event = eventConstructor.newInstance(transportDataItem.getData());
Logger.debug(""Watch data to class: {} -> {}"", action, event.toString());

return event;
} catch (NoSuchMethodException e) {
Logger.debug(""Transport event mapped with action \""{}\"" doesn't have constructor with DataBundle as parameter"", action);
e.printStackTrace();
return null;
} catch (IllegalAccessException | InstantiationException | InvocationTargetException e) {
e.printStackTrace();
return null;
}
}"
6720,"    private Object dataToClass(TransportDataItem transportDataItem) {
String action = transportDataItem.getAction();

//comment

//comment
Class messageClass = messages.get(action);
Class[] args = {DataBundle.class};

//comment
<start>if (messageClass == null)
messageClass = OtherData.class;<end>

try {
Constructor eventConstructor = messageClass.getDeclaredConstructor(args);
Object event = eventConstructor.newInstance(transportDataItem.getData());
Logger.debug(""Watch data to class: {} -> {}"", action, event.toString());

return event;
} catch (NoSuchMethodException e) {
Logger.debug(""Transport event mapped with action \""{}\"" doesn't have constructor with DataBundle as parameter"", action);
e.printStackTrace();
return null;
} catch (IllegalAccessException | InstantiationException | InvocationTargetException e) {
e.printStackTrace();
return null;
}
}","    private Object dataToClass(TransportDataItem transportDataItem) {
String action = transportDataItem.getAction();

//comment

//comment
Class messageClass = messages.get(action);
Class[] args = {DataBundle.class};

//comment
<start>if (messageClass == null)
messageClass = OtherData.class;<end>

try {
Constructor eventConstructor = messageClass.getDeclaredConstructor(args);
Object event = eventConstructor.newInstance(transportDataItem.getData());
Logger.debug(""Watch data to class: {} -> {}"", action, event.toString());

return event;
} catch (NoSuchMethodException e) {
Logger.debug(""Transport event mapped with action \""{}\"" doesn't have constructor with DataBundle as parameter"", action);
e.printStackTrace();
return null;
} catch (IllegalAccessException | InstantiationException | InvocationTargetException e) {
e.printStackTrace();
return null;
}
}"
6721,"public static void startInternetCompanion(Context context) {
Logger.trace(""start"");
transporter = Transporter.get(context, Transport.NAME_INTERNET);
internetListener = new Transporter.DataListener() {
@Override
public void onDataReceived(TransportDataItem item) {
Logger.debug(""AmazfitInternetCompanion onDataReceived"");
if (Transport.HTTP_REQUEST.equals(item.getAction())) {
//comment
if (""Huami"".equals(Build.BRAND)) return;
//comment
transporter.send(Transport.HTTP_PINGBACK, item.getData());
//comment
<start>DataBundle dataBundle = item.getData();<end>
try {
HttpURLConnection httpURLConnection = (HttpURLConnection) new URL(dataBundle.getString(""url"")).openConnection();
httpURLConnection.setInstanceFollowRedirects(dataBundle.getBoolean(""followRedirects""));
httpURLConnection.setRequestMethod(dataBundle.getString(""requestMethod""));
httpURLConnection.setUseCaches(dataBundle.getBoolean(""useCaches""));
httpURLConnection.setDoInput(dataBundle.getBoolean(""doInput""));
httpURLConnection.setDoOutput(dataBundle.getBoolean(""doOutput""));
try {
JSONArray headers = new JSONArray(dataBundle.getString(""requestHeaders""));
for (int x = 0; x < headers.length(); x++) {
JSONObject header = headers.getJSONObject(x);
httpURLConnection.setRequestProperty(header.getString(""key""), header.getString(""value""));
}
} catch (JSONException e) {
Logger.error(e, ""exception: {}"", e.getMessage());
}
httpURLConnection.connect();
if (httpURLConnection.getInputStream() != null) {
byte[] inputStream = IOUtils.toByteArray(httpURLConnection.getInputStream());
if (inputStream != null)
dataBundle.putByteArray(""inputStream"", inputStream);
}
if (httpURLConnection.getErrorStream() != null) {
byte[] errorStream = IOUtils.toByteArray(httpURLConnection.getErrorStream());
if (errorStream != null)
dataBundle.putByteArray(""errorStream"", errorStream);
}
dataBundle.putString(""responseMessage"", httpURLConnection.getResponseMessage());
dataBundle.putInt(""responseCode"", httpURLConnection.getResponseCode());
<start>dataBundle.putString(""responseHeaders"", mapToJSON(httpURLConnection.getHeaderFields()).toString());<end>
//comment
transporter.send(Transport.HTTP_RESULT, dataBundle);
httpURLConnection.disconnect();
} catch (IOException e) {
Logger.error(e, ""exception: {}"", e.getMessage());
}
}
}
};
transporter.addDataListener(internetListener);
transporter.connectTransportService();
}","public static void startInternetCompanion(Context context) {
Logger.trace(""start"");
transporter = Transporter.get(context, Transport.NAME_INTERNET);
internetListener = new Transporter.DataListener() {
@Override
public void onDataReceived(TransportDataItem item) {
Logger.debug(""AmazfitInternetCompanion onDataReceived"");
if (Transport.HTTP_REQUEST.equals(item.getAction())) {
//comment
if (""Huami"".equals(Build.BRAND)) return;
//comment
<start>transporter.send(Transport.HTTP_PINGBACK, item.getData());<end>
//comment
DataBundle dataBundle = item.getData();
try {
HttpURLConnection httpURLConnection = (HttpURLConnection) new URL(dataBundle.getString(""url"")).openConnection();
httpURLConnection.setInstanceFollowRedirects(dataBundle.getBoolean(""followRedirects""));
httpURLConnection.setRequestMethod(dataBundle.getString(""requestMethod""));
httpURLConnection.setUseCaches(dataBundle.getBoolean(""useCaches""));
httpURLConnection.setDoInput(dataBundle.getBoolean(""doInput""));
httpURLConnection.setDoOutput(dataBundle.getBoolean(""doOutput""));
try {
JSONArray headers = new JSONArray(dataBundle.getString(""requestHeaders""));
for (int x = 0; x < headers.length(); x++) {
JSONObject header = headers.getJSONObject(x);
httpURLConnection.setRequestProperty(header.getString(""key""), header.getString(""value""));
}
} catch (JSONException e) {
Logger.error(e, ""exception: {}"", e.getMessage());
}
httpURLConnection.connect();
if (httpURLConnection.getInputStream() != null) {
byte[] inputStream = IOUtils.toByteArray(httpURLConnection.getInputStream());
if (inputStream != null)
dataBundle.putByteArray(""inputStream"", inputStream);
}
if (httpURLConnection.getErrorStream() != null) {
byte[] errorStream = IOUtils.toByteArray(httpURLConnection.getErrorStream());
if (errorStream != null)
dataBundle.putByteArray(""errorStream"", errorStream);
}
dataBundle.putString(""responseMessage"", httpURLConnection.getResponseMessage());
dataBundle.putInt(""responseCode"", httpURLConnection.getResponseCode());
dataBundle.putString(""responseHeaders"", mapToJSON(httpURLConnection.getHeaderFields()).toString());
//comment
transporter.send(Transport.HTTP_RESULT, dataBundle);
httpURLConnection.disconnect();
} catch (IOException e) {
Logger.error(e, ""exception: {}"", e.getMessage());
}
}
}
};
transporter.addDataListener(internetListener);
transporter.connectTransportService();
}"
6722,"public static void startInternetCompanion(Context context) {
Logger.trace(""start"");
transporter = Transporter.get(context, Transport.NAME_INTERNET);
internetListener = new Transporter.DataListener() {
@Override
public void onDataReceived(TransportDataItem item) {
Logger.debug(""AmazfitInternetCompanion onDataReceived"");
if (Transport.HTTP_REQUEST.equals(item.getAction())) {
//comment
if (""Huami"".equals(Build.BRAND)) return;
//comment
<start>transporter.send(Transport.HTTP_PINGBACK, item.getData());
//comment
DataBundle dataBundle = item.getData();<end>
try {
<start>HttpURLConnection httpURLConnection = (HttpURLConnection) new URL(dataBundle.getString(""url"")).openConnection();
httpURLConnection.setInstanceFollowRedirects(dataBundle.getBoolean(""followRedirects""));
httpURLConnection.setRequestMethod(dataBundle.getString(""requestMethod""));<end>
httpURLConnection.setUseCaches(dataBundle.getBoolean(""useCaches""));
httpURLConnection.setDoInput(dataBundle.getBoolean(""doInput""));
httpURLConnection.setDoOutput(dataBundle.getBoolean(""doOutput""));
try {
JSONArray headers = new JSONArray(dataBundle.getString(""requestHeaders""));
for (int x = 0; x < headers.length(); x++) {
JSONObject header = headers.getJSONObject(x);
httpURLConnection.setRequestProperty(header.getString(""key""), header.getString(""value""));
}
} catch (JSONException e) {
Logger.error(e, ""exception: {}"", e.getMessage());
}
httpURLConnection.connect();
if (httpURLConnection.getInputStream() != null) {
byte[] inputStream = IOUtils.toByteArray(httpURLConnection.getInputStream());
if (inputStream != null)
dataBundle.putByteArray(""inputStream"", inputStream);
}
if (httpURLConnection.getErrorStream() != null) {
byte[] errorStream = IOUtils.toByteArray(httpURLConnection.getErrorStream());
if (errorStream != null)
dataBundle.putByteArray(""errorStream"", errorStream);
}
dataBundle.putString(""responseMessage"", httpURLConnection.getResponseMessage());
dataBundle.putInt(""responseCode"", httpURLConnection.getResponseCode());
dataBundle.putString(""responseHeaders"", mapToJSON(httpURLConnection.getHeaderFields()).toString());
//comment
transporter.send(Transport.HTTP_RESULT, dataBundle);
httpURLConnection.disconnect();
} catch (IOException e) {
Logger.error(e, ""exception: {}"", e.getMessage());
}
}
}
};
transporter.addDataListener(internetListener);
transporter.connectTransportService();
}","public static void startInternetCompanion(Context context) {
Logger.trace(""start"");
transporter = Transporter.get(context, Transport.NAME_INTERNET);
internetListener = new Transporter.DataListener() {
@Override
public void onDataReceived(TransportDataItem item) {
Logger.debug(""AmazfitInternetCompanion onDataReceived"");
if (Transport.HTTP_REQUEST.equals(item.getAction())) {
//comment
if (""Huami"".equals(Build.BRAND)) return;
//comment
transporter.send(Transport.HTTP_PINGBACK, item.getData());
//comment
<start>DataBundle dataBundle = item.getData();<end>
try {
HttpURLConnection httpURLConnection = (HttpURLConnection) new URL(dataBundle.getString(""url"")).openConnection();
httpURLConnection.setInstanceFollowRedirects(dataBundle.getBoolean(""followRedirects""));
httpURLConnection.setRequestMethod(dataBundle.getString(""requestMethod""));
httpURLConnection.setUseCaches(dataBundle.getBoolean(""useCaches""));
httpURLConnection.setDoInput(dataBundle.getBoolean(""doInput""));
httpURLConnection.setDoOutput(dataBundle.getBoolean(""doOutput""));
try {
JSONArray headers = new JSONArray(dataBundle.getString(""requestHeaders""));
for (int x = 0; x < headers.length(); x++) {
JSONObject header = headers.getJSONObject(x);
httpURLConnection.setRequestProperty(header.getString(""key""), header.getString(""value""));
}
} catch (JSONException e) {
Logger.error(e, ""exception: {}"", e.getMessage());
}
httpURLConnection.connect();
if (httpURLConnection.getInputStream() != null) {
byte[] inputStream = IOUtils.toByteArray(httpURLConnection.getInputStream());
if (inputStream != null)
dataBundle.putByteArray(""inputStream"", inputStream);
}
if (httpURLConnection.getErrorStream() != null) {
byte[] errorStream = IOUtils.toByteArray(httpURLConnection.getErrorStream());
if (errorStream != null)
dataBundle.putByteArray(""errorStream"", errorStream);
}
dataBundle.putString(""responseMessage"", httpURLConnection.getResponseMessage());
dataBundle.putInt(""responseCode"", httpURLConnection.getResponseCode());
dataBundle.putString(""responseHeaders"", mapToJSON(httpURLConnection.getHeaderFields()).toString());
//comment
transporter.send(Transport.HTTP_RESULT, dataBundle);
httpURLConnection.disconnect();
} catch (IOException e) {
Logger.error(e, ""exception: {}"", e.getMessage());
}
}
}
};
transporter.addDataListener(internetListener);
transporter.connectTransportService();
}"
6723,"public static void startInternetCompanion(Context context) {
Logger.trace(""start"");
transporter = Transporter.get(context, Transport.NAME_INTERNET);
internetListener = new Transporter.DataListener() {
@Override
public void onDataReceived(TransportDataItem item) {
Logger.debug(""AmazfitInternetCompanion onDataReceived"");
if (Transport.HTTP_REQUEST.equals(item.getAction())) {
//comment
if (""Huami"".equals(Build.BRAND)) return;
//comment
transporter.send(Transport.HTTP_PINGBACK, item.getData());
//comment
DataBundle dataBundle = item.getData();
try {
HttpURLConnection httpURLConnection = (HttpURLConnection) new URL(dataBundle.getString(""url"")).openConnection();
httpURLConnection.setInstanceFollowRedirects(dataBundle.getBoolean(""followRedirects""));
httpURLConnection.setRequestMethod(dataBundle.getString(""requestMethod""));
httpURLConnection.setUseCaches(dataBundle.getBoolean(""useCaches""));
httpURLConnection.setDoInput(dataBundle.getBoolean(""doInput""));
httpURLConnection.setDoOutput(dataBundle.getBoolean(""doOutput""));
try {
JSONArray headers = new JSONArray(dataBundle.getString(""requestHeaders""));
for (int x = 0; x < headers.length(); x++) {
JSONObject header = headers.getJSONObject(x);
httpURLConnection.setRequestProperty(header.getString(""key""), header.getString(""value""));
}
} catch (JSONException e) {
Logger.error(e, ""exception: {}"", e.getMessage());
}
httpURLConnection.connect();
if (httpURLConnection.getInputStream() != null) {
byte[] inputStream = IOUtils.toByteArray(httpURLConnection.getInputStream());
if (inputStream != null)
dataBundle.putByteArray(""inputStream"", inputStream);
}
if (httpURLConnection.getErrorStream() != null) {
byte[] errorStream = IOUtils.toByteArray(httpURLConnection.getErrorStream());
<start>if (errorStream != null)
dataBundle.putByteArray(""errorStream"", errorStream);<end>
}
dataBundle.putString(""responseMessage"", httpURLConnection.getResponseMessage());
dataBundle.putInt(""responseCode"", httpURLConnection.getResponseCode());
dataBundle.putString(""responseHeaders"", mapToJSON(httpURLConnection.getHeaderFields()).toString());
//comment
transporter.send(Transport.HTTP_RESULT, dataBundle);
httpURLConnection.disconnect();
} catch (IOException e) {
Logger.error(e, ""exception: {}"", e.getMessage());
}
}
}
};
transporter.addDataListener(internetListener);
transporter.connectTransportService();
}","public static void startInternetCompanion(Context context) {
Logger.trace(""start"");
transporter = Transporter.get(context, Transport.NAME_INTERNET);
internetListener = new Transporter.DataListener() {
@Override
public void onDataReceived(TransportDataItem item) {
Logger.debug(""AmazfitInternetCompanion onDataReceived"");
if (Transport.HTTP_REQUEST.equals(item.getAction())) {
//comment
if (""Huami"".equals(Build.BRAND)) return;
//comment
transporter.send(Transport.HTTP_PINGBACK, item.getData());
//comment
DataBundle dataBundle = item.getData();
try {
HttpURLConnection httpURLConnection = (HttpURLConnection) new URL(dataBundle.getString(""url"")).openConnection();
httpURLConnection.setInstanceFollowRedirects(dataBundle.getBoolean(""followRedirects""));
httpURLConnection.setRequestMethod(dataBundle.getString(""requestMethod""));
httpURLConnection.setUseCaches(dataBundle.getBoolean(""useCaches""));
httpURLConnection.setDoInput(dataBundle.getBoolean(""doInput""));
httpURLConnection.setDoOutput(dataBundle.getBoolean(""doOutput""));
try {
JSONArray headers = new JSONArray(dataBundle.getString(""requestHeaders""));
for (int x = 0; x < headers.length(); x++) {
JSONObject header = headers.getJSONObject(x);
httpURLConnection.setRequestProperty(header.getString(""key""), header.getString(""value""));
}
} catch (JSONException e) {
Logger.error(e, ""exception: {}"", e.getMessage());
}
httpURLConnection.connect();
if (httpURLConnection.getInputStream() != null) {
byte[] inputStream = IOUtils.toByteArray(httpURLConnection.getInputStream());
if (inputStream != null)
dataBundle.putByteArray(""inputStream"", inputStream);
}
if (httpURLConnection.getErrorStream() != null) {
byte[] errorStream = IOUtils.toByteArray(httpURLConnection.getErrorStream());
if (errorStream != null)
dataBundle.putByteArray(""errorStream"", errorStream);
}
dataBundle.putString(""responseMessage"", httpURLConnection.getResponseMessage());
dataBundle.putInt(""responseCode"", httpURLConnection.getResponseCode());
dataBundle.putString(""responseHeaders"", mapToJSON(httpURLConnection.getHeaderFields()).toString());
//comment
<start>transporter.send(Transport.HTTP_RESULT, dataBundle);<end>
httpURLConnection.disconnect();
} catch (IOException e) {
Logger.error(e, ""exception: {}"", e.getMessage());
}
}
}
};
transporter.addDataListener(internetListener);
transporter.connectTransportService();
}"
6724,"@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
super.onCreate(savedInstanceState);

<start>Intent intent = getIntent();<end>
if (intent.hasExtra(PATH)) {
currentPath = intent.getStringExtra(PATH);
} else {
currentPath = Constants.INITIAL_PATH;
}

Logger.debug(""currentPath = {} source = {}"", currentPath, intent.getStringExtra(SOURCE));

setContentView(R.layout.activity_file_explorer);

try {
getSupportActionBar().setDisplayHomeAsUpEnabled(true);
getSupportActionBar().setTitle(R.string.file_explorer);
} catch (NullPointerException ex) {
Logger.error(""onCreate exception: "" + ex.getMessage());
}

ButterKnife.bind(this);

fileExplorerAdapter = new FileExplorerAdapter(this, R.layout.row_file_explorer, new ArrayList<>());
listView.setAdapter(fileExplorerAdapter);

loadPath(currentPath);

registerForContextMenu(listView);

snackProgressBarManager = new SnackProgressBarManager(findViewById(android.R.id.content))
//comment
//comment
//comment
.setProgressBarColor(ThemeHelper.getThemeColorAccentId(this))
.setActionTextColor(ThemeHelper.getThemeColorAccentId(this))
//comment
.setBackgroundColor(SnackProgressBarManager.BACKGROUND_COLOR_DEFAULT)
//comment
.setTextSize(14)
//comment
.setMessageMaxLines(4)
//comment
.setOnDisplayListener(new SnackProgressBarManager.OnDisplayListener() {
@Override
public void onShown(@NonNull SnackProgressBar snackProgressBar, int onDisplayId) {
//comment
}

@Override
public void onDismissed(@NonNull SnackProgressBar snackProgressBar, int onDisplayId) {
//comment
}
});

listView.setOnScrollListener(new AbsListView.OnScrollListener() {
private int lastFirstVisibleItem = 0;

@Override
public void onScrollStateChanged(AbsListView view, int scrollState) {

}

@Override
public void onScroll(AbsListView view, int firstVisibleItem,
int visibleItemCount, int totalItemCount) {

int topRowVerticalPosition = (listView == null || listView.getChildCount() == 0) ?
0 : listView.getChildAt(0).getTop();
swipeRefreshLayout.setEnabled((topRowVerticalPosition >= 0));

if (lastFirstVisibleItem < firstVisibleItem) {
fabMain.hide();
}
if (lastFirstVisibleItem > firstVisibleItem) {
fabMain.show();
}
lastFirstVisibleItem = firstVisibleItem;

}
});

swipeRefreshLayout.setColorSchemeColors(ThemeHelper.getThemeColorAccent(this));

swipeRefreshLayout.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() {
@Override
public void onRefresh() {
Logger.debug(""onRefresh"");
loadPath(currentPath);
}
});

//comment
ftpTransporterConnect();
}","@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
super.onCreate(savedInstanceState);

<start>Intent intent = getIntent();<end>
if (intent.hasExtra(PATH)) {
currentPath = intent.getStringExtra(PATH);
} else {
currentPath = Constants.INITIAL_PATH;
}

Logger.debug(""currentPath = {} source = {}"", currentPath, intent.getStringExtra(SOURCE));

setContentView(R.layout.activity_file_explorer);

try {
getSupportActionBar().setDisplayHomeAsUpEnabled(true);
getSupportActionBar().setTitle(R.string.file_explorer);
} catch (NullPointerException ex) {
Logger.error(""onCreate exception: "" + ex.getMessage());
}

ButterKnife.bind(this);

fileExplorerAdapter = new FileExplorerAdapter(this, R.layout.row_file_explorer, new ArrayList<>());
listView.setAdapter(fileExplorerAdapter);

loadPath(currentPath);

registerForContextMenu(listView);

snackProgressBarManager = new SnackProgressBarManager(findViewById(android.R.id.content))
//comment
//comment
//comment
.setProgressBarColor(ThemeHelper.getThemeColorAccentId(this))
.setActionTextColor(ThemeHelper.getThemeColorAccentId(this))
//comment
.setBackgroundColor(SnackProgressBarManager.BACKGROUND_COLOR_DEFAULT)
//comment
.setTextSize(14)
//comment
.setMessageMaxLines(4)
//comment
.setOnDisplayListener(new SnackProgressBarManager.OnDisplayListener() {
@Override
public void onShown(@NonNull SnackProgressBar snackProgressBar, int onDisplayId) {
//comment
}

@Override
public void onDismissed(@NonNull SnackProgressBar snackProgressBar, int onDisplayId) {
//comment
}
});

listView.setOnScrollListener(new AbsListView.OnScrollListener() {
private int lastFirstVisibleItem = 0;

@Override
public void onScrollStateChanged(AbsListView view, int scrollState) {

}

@Override
public void onScroll(AbsListView view, int firstVisibleItem,
int visibleItemCount, int totalItemCount) {

int topRowVerticalPosition = (listView == null || listView.getChildCount() == 0) ?
0 : listView.getChildAt(0).getTop();
swipeRefreshLayout.setEnabled((topRowVerticalPosition >= 0));

if (lastFirstVisibleItem < firstVisibleItem) {
fabMain.hide();
}
if (lastFirstVisibleItem > firstVisibleItem) {
fabMain.show();
}
lastFirstVisibleItem = firstVisibleItem;

}
});

swipeRefreshLayout.setColorSchemeColors(ThemeHelper.getThemeColorAccent(this));

swipeRefreshLayout.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() {
@Override
public void onRefresh() {
Logger.debug(""onRefresh"");
loadPath(currentPath);
}
});

//comment
ftpTransporterConnect();
}"
6725,"@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
super.onCreate(savedInstanceState);

Intent intent = getIntent();
if (intent.hasExtra(PATH)) {
currentPath = intent.getStringExtra(PATH);
} else {
currentPath = Constants.INITIAL_PATH;
}

Logger.debug(""currentPath = {} source = {}"", currentPath, intent.getStringExtra(SOURCE));

setContentView(R.layout.activity_file_explorer);

try {
getSupportActionBar().setDisplayHomeAsUpEnabled(true);
getSupportActionBar().setTitle(R.string.file_explorer);
} catch (NullPointerException ex) {
Logger.error(""onCreate exception: "" + ex.getMessage());
}

ButterKnife.bind(this);

fileExplorerAdapter = new FileExplorerAdapter(this, R.layout.row_file_explorer, new ArrayList<>());
listView.setAdapter(fileExplorerAdapter);

loadPath(currentPath);

registerForContextMenu(listView);

snackProgressBarManager = new SnackProgressBarManager(findViewById(android.R.id.content))
//comment
//comment
//comment
.setProgressBarColor(ThemeHelper.getThemeColorAccentId(this))
.setActionTextColor(ThemeHelper.getThemeColorAccentId(this))
//comment
.setBackgroundColor(SnackProgressBarManager.BACKGROUND_COLOR_DEFAULT)
//comment
.setTextSize(14)
//comment
.setMessageMaxLines(4)
//comment
.setOnDisplayListener(new SnackProgressBarManager.OnDisplayListener() {
@Override
public void onShown(@NonNull SnackProgressBar snackProgressBar, int onDisplayId) {
//comment
}

@Override
public void onDismissed(@NonNull SnackProgressBar snackProgressBar, int onDisplayId) {
//comment
}
});

listView.setOnScrollListener(new AbsListView.OnScrollListener() {
private int lastFirstVisibleItem = 0;

@Override
public void onScrollStateChanged(AbsListView view, int scrollState) {

}

@Override
public void onScroll(AbsListView view, int firstVisibleItem,
int visibleItemCount, int totalItemCount) {

int topRowVerticalPosition = (listView == null || listView.getChildCount() == 0) ?
0 : listView.getChildAt(0).getTop();
swipeRefreshLayout.setEnabled((topRowVerticalPosition >= 0));

if (lastFirstVisibleItem < firstVisibleItem) {
fabMain.hide();
}
if (lastFirstVisibleItem > firstVisibleItem) {
fabMain.show();
}
lastFirstVisibleItem = firstVisibleItem;

}
});

swipeRefreshLayout.setColorSchemeColors(ThemeHelper.getThemeColorAccent(this));

swipeRefreshLayout.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() {
@Override
public void onRefresh() {
Logger.debug(""onRefresh"");
loadPath(currentPath);
}
});

//comment
<start>ftpTransporterConnect();<end>
}","@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
super.onCreate(savedInstanceState);

Intent intent = getIntent();
if (intent.hasExtra(PATH)) {
currentPath = intent.getStringExtra(PATH);
} else {
currentPath = Constants.INITIAL_PATH;
}

Logger.debug(""currentPath = {} source = {}"", currentPath, intent.getStringExtra(SOURCE));

setContentView(R.layout.activity_file_explorer);

try {
getSupportActionBar().setDisplayHomeAsUpEnabled(true);
getSupportActionBar().setTitle(R.string.file_explorer);
} catch (NullPointerException ex) {
Logger.error(""onCreate exception: "" + ex.getMessage());
}

ButterKnife.bind(this);

fileExplorerAdapter = new FileExplorerAdapter(this, R.layout.row_file_explorer, new ArrayList<>());
listView.setAdapter(fileExplorerAdapter);

loadPath(currentPath);

registerForContextMenu(listView);

snackProgressBarManager = new SnackProgressBarManager(findViewById(android.R.id.content))
//comment
//comment
//comment
.setProgressBarColor(ThemeHelper.getThemeColorAccentId(this))
.setActionTextColor(ThemeHelper.getThemeColorAccentId(this))
//comment
.setBackgroundColor(SnackProgressBarManager.BACKGROUND_COLOR_DEFAULT)
//comment
.setTextSize(14)
//comment
.setMessageMaxLines(4)
//comment
.setOnDisplayListener(new SnackProgressBarManager.OnDisplayListener() {
@Override
public void onShown(@NonNull SnackProgressBar snackProgressBar, int onDisplayId) {
//comment
}

@Override
public void onDismissed(@NonNull SnackProgressBar snackProgressBar, int onDisplayId) {
//comment
}
});

listView.setOnScrollListener(new AbsListView.OnScrollListener() {
private int lastFirstVisibleItem = 0;

@Override
public void onScrollStateChanged(AbsListView view, int scrollState) {

}

@Override
public void onScroll(AbsListView view, int firstVisibleItem,
int visibleItemCount, int totalItemCount) {

int topRowVerticalPosition = (listView == null || listView.getChildCount() == 0) ?
0 : listView.getChildAt(0).getTop();
swipeRefreshLayout.setEnabled((topRowVerticalPosition >= 0));

if (lastFirstVisibleItem < firstVisibleItem) {
fabMain.hide();
}
if (lastFirstVisibleItem > firstVisibleItem) {
fabMain.show();
}
lastFirstVisibleItem = firstVisibleItem;

}
});

swipeRefreshLayout.setColorSchemeColors(ThemeHelper.getThemeColorAccent(this));

swipeRefreshLayout.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() {
@Override
public void onRefresh() {
Logger.debug(""onRefresh"");
loadPath(currentPath);
}
});

//comment
<start>ftpTransporterConnect();<end>
}"
6727,"private void uploadFTPFiles(final ArrayList<File> files, final String uploadPath) {
wifiManualEnabled = false;
mWifiManager = (WifiManager) getApplicationContext().getSystemService(Context.WIFI_SERVICE);
if (mWifiManager == null) {
updateSnackBarOnUIthreat(getString(R.string.error), SnackProgressBarManager.LENGTH_LONG, SnackProgressBar.TYPE_HORIZONTAL);
return;
} else if (!mWifiManager.isWifiEnabled()) {
updateSnackBarOnUIthreat(getString(R.string.turn_on_wifi), SnackProgressBarManager.LENGTH_LONG, SnackProgressBar.TYPE_HORIZONTAL);
return;
//comment
//comment
//comment
}

if (!(files.size() > 0)) {
transferring = false;
return;
}

transferring = true;
FTP_files = files;
FTP_file = files.get(0);
//comment

if (!FTP_file.exists()) {
fileNotExists();
return;
}
if (FTP_file.isDirectory()) {
fileIsDirectory();
return;
}

FTP_destPath = uploadPath + ""/"";
//comment

createNotification(getString(R.string.watch_connecting) + "", "" + getString(R.string.wait), ""\"""" + FTP_file.getName() + ""\"""", R.drawable.ic_wifi_tethering_white_24dp, false);

updateSnackBarOnUIthreat(getString(R.string.watch_connecting), SnackProgressBarManager.LENGTH_LONG, SnackProgressBar.TYPE_CIRCULAR);

//comment
<start>getTransferringMethod();<end>
updateSnackBarOnUIthreat(getString(R.string.wifi_transfer_method), SnackProgressBarManager.LENGTH_LONG, SnackProgressBar.TYPE_CIRCULAR);

}","private void uploadFTPFiles(final ArrayList<File> files, final String uploadPath) {
wifiManualEnabled = false;
mWifiManager = (WifiManager) getApplicationContext().getSystemService(Context.WIFI_SERVICE);
if (mWifiManager == null) {
updateSnackBarOnUIthreat(getString(R.string.error), SnackProgressBarManager.LENGTH_LONG, SnackProgressBar.TYPE_HORIZONTAL);
return;
} else if (!mWifiManager.isWifiEnabled()) {
updateSnackBarOnUIthreat(getString(R.string.turn_on_wifi), SnackProgressBarManager.LENGTH_LONG, SnackProgressBar.TYPE_HORIZONTAL);
return;
//comment
//comment
//comment
}

if (!(files.size() > 0)) {
transferring = false;
return;
}

transferring = true;
FTP_files = files;
FTP_file = files.get(0);
//comment

if (!FTP_file.exists()) {
fileNotExists();
return;
}
if (FTP_file.isDirectory()) {
fileIsDirectory();
return;
}

FTP_destPath = uploadPath + ""/"";
//comment

createNotification(getString(R.string.watch_connecting) + "", "" + getString(R.string.wait), ""\"""" + FTP_file.getName() + ""\"""", R.drawable.ic_wifi_tethering_white_24dp, false);

updateSnackBarOnUIthreat(getString(R.string.watch_connecting), SnackProgressBarManager.LENGTH_LONG, SnackProgressBar.TYPE_CIRCULAR);

//comment
<start>getTransferringMethod();<end>
updateSnackBarOnUIthreat(getString(R.string.wifi_transfer_method), SnackProgressBarManager.LENGTH_LONG, SnackProgressBar.TYPE_CIRCULAR);

}"
6752,"    private void chooseCalendars() {
Map<String, List<CalendarInfo>> calendarsInfo =
WatchfaceReceiver.getCalendarsInfo(this);

List<CheckableAdapter.Item> items = new ArrayList<>();
final Set<String> selectedCalendarIds = Prefs.getStringSet(
Constants.PREF_WATCHFACE_CALENDARS_IDS, new HashSet<>());

//comment
<start>boolean selectAll = selectedCalendarIds.isEmpty();<end>

//comment
for (Map.Entry<String, List<CalendarInfo>> entry : calendarsInfo.entrySet()) {
items.add(new CheckableAdapter.Item(entry.getKey(),
getResources().getColor(R.color.calendar_chooser_account, getTheme())));
for (final CalendarInfo info : entry.getValue()) {
if (selectAll) {
selectedCalendarIds.add(info.id());
}

items.add(new CheckableAdapter.CheckableItem(info.name(), info.color()) {

@Override
public void setChecked(boolean checked) {
if (checked) {
selectedCalendarIds.add(info.id());
} else {
selectedCalendarIds.remove(info.id());
}
}

@Override
public boolean isChecked() {
return selectedCalendarIds.contains(info.id());
}
});
}
}


new AlertDialog.Builder(this)
.setAdapter(new CheckableAdapter(items), null)
.setOnDismissListener(dialog -> {
Prefs.putStringSet(Constants.PREF_WATCHFACE_CALENDARS_IDS,
selectedCalendarIds);
showFoundBuildInCalendarEvents();})
.create().show();
}","    private void chooseCalendars() {
Map<String, List<CalendarInfo>> calendarsInfo =
WatchfaceReceiver.getCalendarsInfo(this);

List<CheckableAdapter.Item> items = new ArrayList<>();
final Set<String> selectedCalendarIds = Prefs.getStringSet(
Constants.PREF_WATCHFACE_CALENDARS_IDS, new HashSet<>());

//comment
<start>boolean selectAll = selectedCalendarIds.isEmpty();<end>

//comment
for (Map.Entry<String, List<CalendarInfo>> entry : calendarsInfo.entrySet()) {
items.add(new CheckableAdapter.Item(entry.getKey(),
getResources().getColor(R.color.calendar_chooser_account, getTheme())));
for (final CalendarInfo info : entry.getValue()) {
if (selectAll) {
selectedCalendarIds.add(info.id());
}

items.add(new CheckableAdapter.CheckableItem(info.name(), info.color()) {

@Override
public void setChecked(boolean checked) {
if (checked) {
selectedCalendarIds.add(info.id());
} else {
selectedCalendarIds.remove(info.id());
}
}

@Override
public boolean isChecked() {
return selectedCalendarIds.contains(info.id());
}
});
}
}


new AlertDialog.Builder(this)
.setAdapter(new CheckableAdapter(items), null)
.setOnDismissListener(dialog -> {
Prefs.putStringSet(Constants.PREF_WATCHFACE_CALENDARS_IDS,
selectedCalendarIds);
showFoundBuildInCalendarEvents();})
.create().show();
}"
6753,"    private void chooseCalendars() {
Map<String, List<CalendarInfo>> calendarsInfo =
WatchfaceReceiver.getCalendarsInfo(this);

List<CheckableAdapter.Item> items = new ArrayList<>();
final Set<String> selectedCalendarIds = Prefs.getStringSet(
Constants.PREF_WATCHFACE_CALENDARS_IDS, new HashSet<>());

//comment
boolean selectAll = selectedCalendarIds.isEmpty();

//comment
for (Map.Entry<String, List<CalendarInfo>> entry : calendarsInfo.entrySet()) {
<start>items.add(new CheckableAdapter.Item(entry.getKey(),
getResources().getColor(R.color.calendar_chooser_account, getTheme())));<end>
for (final CalendarInfo info : entry.getValue()) {
if (selectAll) {
selectedCalendarIds.add(info.id());
}

items.add(new CheckableAdapter.CheckableItem(info.name(), info.color()) {

@Override
public void setChecked(boolean checked) {
if (checked) {
selectedCalendarIds.add(info.id());
} else {
selectedCalendarIds.remove(info.id());
}
}

@Override
public boolean isChecked() {
return selectedCalendarIds.contains(info.id());
}
});
}
}


new AlertDialog.Builder(this)
.setAdapter(new CheckableAdapter(items), null)
.setOnDismissListener(dialog -> {
Prefs.putStringSet(Constants.PREF_WATCHFACE_CALENDARS_IDS,
selectedCalendarIds);
showFoundBuildInCalendarEvents();})
.create().show();
}","    private void chooseCalendars() {
Map<String, List<CalendarInfo>> calendarsInfo =
WatchfaceReceiver.getCalendarsInfo(this);

List<CheckableAdapter.Item> items = new ArrayList<>();
final Set<String> selectedCalendarIds = Prefs.getStringSet(
Constants.PREF_WATCHFACE_CALENDARS_IDS, new HashSet<>());

//comment
boolean selectAll = selectedCalendarIds.isEmpty();

//comment
<start>for (Map.Entry<String, List<CalendarInfo>> entry : calendarsInfo.entrySet()) {
items.add(new CheckableAdapter.Item(entry.getKey(),
getResources().getColor(R.color.calendar_chooser_account, getTheme())));
for (final CalendarInfo info : entry.getValue()) {
if (selectAll) {
selectedCalendarIds.add(info.id());
}

items.add(new CheckableAdapter.CheckableItem(info.name(), info.color()) {

@Override
public void setChecked(boolean checked) {
if (checked) {
selectedCalendarIds.add(info.id());
} else {
selectedCalendarIds.remove(info.id());
}
}

@Override
public boolean isChecked() {
return selectedCalendarIds.contains(info.id());
}
});
}
}<end>


new AlertDialog.Builder(this)
.setAdapter(new CheckableAdapter(items), null)
.setOnDismissListener(dialog -> {
Prefs.putStringSet(Constants.PREF_WATCHFACE_CALENDARS_IDS,
selectedCalendarIds);
showFoundBuildInCalendarEvents();})
.create().show();
}"
757,"    public static boolean isDeviceLocked(Context context) {

boolean isLocked = false;

//comment
try {
<start>KeyguardManager keyguardManager = (KeyguardManager) context.getSystemService(Context.KEYGUARD_SERVICE);<end>
boolean inKeyguardRestrictedInputMode = keyguardManager != null && keyguardManager.inKeyguardRestrictedInputMode();

if (inKeyguardRestrictedInputMode) {
isLocked = true;

} else {
//comment
//comment
PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
if (powerManager != null) isLocked = !powerManager.isInteractive();
}
} catch (NullPointerException e) {
Logger.error(""iDeviceLocked exception: "" + e.toString());
}

Logger.info(TAG_LOCAL+""isDeviceLocked: "" + isLocked);
return isLocked;
}","    public static boolean isDeviceLocked(Context context) {

boolean isLocked = false;

//comment
try {
<start>KeyguardManager keyguardManager = (KeyguardManager) context.getSystemService(Context.KEYGUARD_SERVICE);
boolean inKeyguardRestrictedInputMode = keyguardManager != null && keyguardManager.inKeyguardRestrictedInputMode();

if (inKeyguardRestrictedInputMode) {
isLocked = true;

} else {<end>
//comment
//comment
PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
if (powerManager != null) isLocked = !powerManager.isInteractive();
}
} catch (NullPointerException e) {
Logger.error(""iDeviceLocked exception: "" + e.toString());
}

Logger.info(TAG_LOCAL+""isDeviceLocked: "" + isLocked);
return isLocked;
}"
843,"<start>    private void loadEmoji() {<end>
//comment
EmojiCompat.Config config = new BundledEmojiCompatConfig(getContext());
<start>config.setReplaceAll(true);<end>
EmojiCompat.init(config);
}","    private void loadEmoji() {
//comment
<start>EmojiCompat.Config config = new BundledEmojiCompatConfig(getContext());
config.setReplaceAll(true);
EmojiCompat.init(config);<end>
}"
6819,"private void updateCharge() {

widgetSettings.reload();
IntentFilter ifilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);
Intent batteryStatus = mContext.registerReceiver(null, ifilter);

if (batteryStatus != null) {

int level = batteryStatus.getIntExtra(BatteryManager.EXTRA_LEVEL, -1);
int scale = batteryStatus.getIntExtra(BatteryManager.EXTRA_SCALE, -1);
<start>int batteryIconId = batteryStatus.getIntExtra(BatteryManager.EXTRA_ICON_SMALL, 0);<end>

//comment
<start>int battery = Math.round((level / (float) scale) * 100f);
String msg;<end>
if (battery != 0) {
String battlvl = battery + ""%"";
msg = battlvl;
widgetSettings.set(Constants.PREF_BATT_LEVEL, battlvl);
} else {
msg = ""N/A%"";
}

LevelListDrawable batteryLevel = (LevelListDrawable) mContext.getResources().getDrawable(batteryIconId);
batteryLevel.setLevel(level);

getHost().runTaskOnUI(AmazModLauncher.this, new Runnable() {
@Override
public void run() {
if (battValueTV != null)
battValueTV.setText(msg);
if (battIconImg != null)
battIconImg.setImageDrawable(batteryLevel);
}
});

} else
Logger.error(""AmazModLauncher updateCharge error: null batteryStatus!"");

}","private void updateCharge() {

widgetSettings.reload();
IntentFilter ifilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);
Intent batteryStatus = mContext.registerReceiver(null, ifilter);

if (batteryStatus != null) {

int level = batteryStatus.getIntExtra(BatteryManager.EXTRA_LEVEL, -1);
int scale = batteryStatus.getIntExtra(BatteryManager.EXTRA_SCALE, -1);
int batteryIconId = batteryStatus.getIntExtra(BatteryManager.EXTRA_ICON_SMALL, 0);

//comment
<start>int battery = Math.round((level / (float) scale) * 100f);
String msg;
if (battery != 0) {
String battlvl = battery + ""%"";
msg = battlvl;
widgetSettings.set(Constants.PREF_BATT_LEVEL, battlvl);
} else {
msg = ""N/A%"";
}<end>

LevelListDrawable batteryLevel = (LevelListDrawable) mContext.getResources().getDrawable(batteryIconId);
batteryLevel.setLevel(level);

getHost().runTaskOnUI(AmazModLauncher.this, new Runnable() {
@Override
public void run() {
if (battValueTV != null)
battValueTV.setText(msg);
if (battIconImg != null)
battIconImg.setImageDrawable(batteryLevel);
}
});

} else
Logger.error(""AmazModLauncher updateCharge error: null batteryStatus!"");

}"
6820,"@Override
public void onAbsoluteScrollChange(int i) {
//comment
//comment
if (i > 0) {
mHeader.setY(-i);
}
}","@Override
public void onAbsoluteScrollChange(int i) {
//comment
//comment
<start>if (i > 0) {
mHeader.setY(-i);
}<end>
}"
6821,"    private void onShow() {
//comment
<start>if (this.view != null && !this.isActive) {
//comment
//comment
this.refreshView();
}<end>

//comment
this.isActive = true;
}","    private void onShow() {
//comment
<start>if (this.view != null && !this.isActive) {<end>
//comment
//comment
this.refreshView();
}

//comment
this.isActive = true;
}"
6822,"    private void onShow() {
//comment
<start>if (this.view != null && !this.isActive) {
//comment
//comment
this.refreshView();
}<end>

//comment
this.isActive = true;
}","    private void onShow() {
//comment
<start>if (this.view != null && !this.isActive) {
//comment
//comment
this.refreshView();
}<end>

//comment
this.isActive = true;
}"
6823,"    private void onShow() {
//comment
if (this.view != null && !this.isActive) {
//comment
//comment
this.refreshView();
}

//comment
this.isActive = true;
}","    private void onShow() {
//comment
if (this.view != null && !this.isActive) {
//comment
//comment
this.refreshView();
}

//comment
<start>this.isActive = true;<end>
}"
1704,"@NonNull
@Override
public SpringboardWidgetAdapter.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
LayoutInflater layoutInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);

if (layoutInflater != null) {
//comment
if (viewType == 0) {
//comment
<start>return new ViewHolder(layoutInflater.inflate(R.layout.springboard_item_header, parent, false));<end>
} else if (viewType == 1) {
//comment
return new ViewHolder(layoutInflater.inflate(R.layout.springboard_item_preference_icon, parent, false));
} else if (viewType == 2) {
//comment
return new ViewHolder(layoutInflater.inflate(R.layout.springboard_item_preference_switch, parent, false));
} else if (viewType == 3) {
//comment
return new ViewHolder(layoutInflater.inflate(R.layout.springboard_item_preference_text, parent, false));
} else if (viewType == 4) {
//comment
return new ViewHolder(layoutInflater.inflate(R.layout.springboard_item_preference_button, parent, false));
}
} else
Logger.error(""SpringboardWidgetAdapter onCreateViewHolder: null layoutInflater!"");

return new ViewHolder(Objects.requireNonNull(layoutInflater).inflate(R.layout.springboard_item_preference_text, parent, false));
}","@NonNull
@Override
public SpringboardWidgetAdapter.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
LayoutInflater layoutInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);

if (layoutInflater != null) {
//comment
<start>if (viewType == 0) {<end>
//comment
return new ViewHolder(layoutInflater.inflate(R.layout.springboard_item_header, parent, false));
<start>} else if (viewType == 1) {<end>
//comment
return new ViewHolder(layoutInflater.inflate(R.layout.springboard_item_preference_icon, parent, false));
<start>} else if (viewType == 2) {<end>
//comment
return new ViewHolder(layoutInflater.inflate(R.layout.springboard_item_preference_switch, parent, false));
<start>} else if (viewType == 3) {<end>
//comment
return new ViewHolder(layoutInflater.inflate(R.layout.springboard_item_preference_text, parent, false));
<start>} else if (viewType == 4) {<end>
//comment
return new ViewHolder(layoutInflater.inflate(R.layout.springboard_item_preference_button, parent, false));
}
} else
Logger.error(""SpringboardWidgetAdapter onCreateViewHolder: null layoutInflater!"");

return new ViewHolder(Objects.requireNonNull(layoutInflater).inflate(R.layout.springboard_item_preference_text, parent, false));
}"
1705,"@Override
public int getItemViewType(int position) {
//comment
BaseSetting setting = settings.get(position);
if (setting instanceof HeaderSetting) return 0;
if (setting instanceof IconSetting) return 1;
if (setting instanceof SwitchSetting) return 2;
if (setting instanceof ButtonSetting) return 4;
else return 3;
}","@Override
public int getItemViewType(int position) {
//comment
<start>BaseSetting setting = settings.get(position);
if (setting instanceof HeaderSetting) return 0;
if (setting instanceof IconSetting) return 1;
if (setting instanceof SwitchSetting) return 2;
if (setting instanceof ButtonSetting) return 4;
else return 3;<end>
}"
1706,"    @Override
public void onBindViewHolder(@NonNull final SpringboardWidgetAdapter.ViewHolder holder, int position) {
//comment
<start>BaseSetting setting = settings.get(position);<end>
if (setting instanceof HeaderSetting) {
//comment
<start>holder.title.setText(((HeaderSetting) setting).title);<end>
//comment
final HeaderSetting headerSetting = (HeaderSetting) setting;
if (headerSetting.onLongClickListener != null)
holder.root.setOnLongClickListener(headerSetting.onLongClickListener);
} else if (setting instanceof SwitchSetting) {
//comment
final SwitchSetting switchSetting = (SwitchSetting) setting;

//comment
CompoundButton.OnCheckedChangeListener mOnCheckedListener = new CompoundButton.OnCheckedChangeListener() {
@Override
public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
switchSetting.isChecked = isChecked;
Logger.debug(""SpringboardWidgetAdapter mOnCheckedListener isChecked: "" + isChecked);
}
};

CompoundButton.OnCheckedChangeListener mListener = new CompositeListener(switchSetting.changeListener, mOnCheckedListener);
holder.sw.setOnCheckedChangeListener(mListener);

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

//comment
holder.sw.setChecked(switchSetting.isChecked);
//comment
holder.title.setText(switchSetting.title);
holder.title.setSelected(true);
//comment
if (switchSetting.subtitle != null) {
holder.subtitle.setText(switchSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
holder.subtitle.setSelected(true);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
} else if(setting instanceof TextSetting) {
//comment
TextSetting textSetting = (TextSetting) setting;
holder.subtitle.setText(textSetting.text);
//comment
holder.root.setOnClickListener(textSetting.onClickListener);
} else if(setting instanceof ButtonSetting) {
//comment
ButtonSetting buttonSetting = (ButtonSetting) setting;
holder.button.setText(buttonSetting.text);
//comment
holder.root.setOnClickListener(buttonSetting.onClickListener);
} else {
//comment
IconSetting iconSetting = (IconSetting) setting;
holder.icon.setImageDrawable(iconSetting.icon);
holder.root.setOnClickListener(iconSetting.onClickListener);
holder.title.setText(iconSetting.title);
//comment
if (iconSetting.subtitle != null) {
holder.subtitle.setText(iconSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
}
}","    @Override
public void onBindViewHolder(@NonNull final SpringboardWidgetAdapter.ViewHolder holder, int position) {
//comment
<start>BaseSetting setting = settings.get(position);<end>
if (setting instanceof HeaderSetting) {
//comment
holder.title.setText(((HeaderSetting) setting).title);
//comment
final HeaderSetting headerSetting = (HeaderSetting) setting;
if (headerSetting.onLongClickListener != null)
holder.root.setOnLongClickListener(headerSetting.onLongClickListener);
} else if (setting instanceof SwitchSetting) {
//comment
final SwitchSetting switchSetting = (SwitchSetting) setting;

//comment
CompoundButton.OnCheckedChangeListener mOnCheckedListener = new CompoundButton.OnCheckedChangeListener() {
@Override
public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
switchSetting.isChecked = isChecked;
Logger.debug(""SpringboardWidgetAdapter mOnCheckedListener isChecked: "" + isChecked);
}
};

CompoundButton.OnCheckedChangeListener mListener = new CompositeListener(switchSetting.changeListener, mOnCheckedListener);
holder.sw.setOnCheckedChangeListener(mListener);

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

//comment
holder.sw.setChecked(switchSetting.isChecked);
//comment
holder.title.setText(switchSetting.title);
holder.title.setSelected(true);
//comment
if (switchSetting.subtitle != null) {
holder.subtitle.setText(switchSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
holder.subtitle.setSelected(true);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
} else if(setting instanceof TextSetting) {
//comment
TextSetting textSetting = (TextSetting) setting;
holder.subtitle.setText(textSetting.text);
//comment
holder.root.setOnClickListener(textSetting.onClickListener);
} else if(setting instanceof ButtonSetting) {
//comment
ButtonSetting buttonSetting = (ButtonSetting) setting;
holder.button.setText(buttonSetting.text);
//comment
holder.root.setOnClickListener(buttonSetting.onClickListener);
} else {
//comment
IconSetting iconSetting = (IconSetting) setting;
holder.icon.setImageDrawable(iconSetting.icon);
holder.root.setOnClickListener(iconSetting.onClickListener);
holder.title.setText(iconSetting.title);
//comment
if (iconSetting.subtitle != null) {
holder.subtitle.setText(iconSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
}
}"
1707,"    @Override
public void onBindViewHolder(@NonNull final SpringboardWidgetAdapter.ViewHolder holder, int position) {
//comment
BaseSetting setting = settings.get(position);
if (setting instanceof HeaderSetting) {
//comment
<start>holder.title.setText(((HeaderSetting) setting).title);
//comment
final HeaderSetting headerSetting = (HeaderSetting) setting;<end>
if (headerSetting.onLongClickListener != null)
holder.root.setOnLongClickListener(headerSetting.onLongClickListener);
} else if (setting instanceof SwitchSetting) {
//comment
final SwitchSetting switchSetting = (SwitchSetting) setting;

//comment
CompoundButton.OnCheckedChangeListener mOnCheckedListener = new CompoundButton.OnCheckedChangeListener() {
@Override
public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
switchSetting.isChecked = isChecked;
Logger.debug(""SpringboardWidgetAdapter mOnCheckedListener isChecked: "" + isChecked);
}
};

CompoundButton.OnCheckedChangeListener mListener = new CompositeListener(switchSetting.changeListener, mOnCheckedListener);
holder.sw.setOnCheckedChangeListener(mListener);

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

//comment
holder.sw.setChecked(switchSetting.isChecked);
//comment
holder.title.setText(switchSetting.title);
holder.title.setSelected(true);
//comment
if (switchSetting.subtitle != null) {
holder.subtitle.setText(switchSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
holder.subtitle.setSelected(true);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
} else if(setting instanceof TextSetting) {
//comment
TextSetting textSetting = (TextSetting) setting;
holder.subtitle.setText(textSetting.text);
//comment
holder.root.setOnClickListener(textSetting.onClickListener);
} else if(setting instanceof ButtonSetting) {
//comment
ButtonSetting buttonSetting = (ButtonSetting) setting;
holder.button.setText(buttonSetting.text);
//comment
holder.root.setOnClickListener(buttonSetting.onClickListener);
} else {
//comment
IconSetting iconSetting = (IconSetting) setting;
holder.icon.setImageDrawable(iconSetting.icon);
holder.root.setOnClickListener(iconSetting.onClickListener);
holder.title.setText(iconSetting.title);
//comment
if (iconSetting.subtitle != null) {
holder.subtitle.setText(iconSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
}
}","    @Override
public void onBindViewHolder(@NonNull final SpringboardWidgetAdapter.ViewHolder holder, int position) {
//comment
BaseSetting setting = settings.get(position);
if (setting instanceof HeaderSetting) {
//comment
<start>holder.title.setText(((HeaderSetting) setting).title);<end>
//comment
final HeaderSetting headerSetting = (HeaderSetting) setting;
if (headerSetting.onLongClickListener != null)
holder.root.setOnLongClickListener(headerSetting.onLongClickListener);
} else if (setting instanceof SwitchSetting) {
//comment
final SwitchSetting switchSetting = (SwitchSetting) setting;

//comment
CompoundButton.OnCheckedChangeListener mOnCheckedListener = new CompoundButton.OnCheckedChangeListener() {
@Override
public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
switchSetting.isChecked = isChecked;
Logger.debug(""SpringboardWidgetAdapter mOnCheckedListener isChecked: "" + isChecked);
}
};

CompoundButton.OnCheckedChangeListener mListener = new CompositeListener(switchSetting.changeListener, mOnCheckedListener);
holder.sw.setOnCheckedChangeListener(mListener);

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

//comment
holder.sw.setChecked(switchSetting.isChecked);
//comment
holder.title.setText(switchSetting.title);
holder.title.setSelected(true);
//comment
if (switchSetting.subtitle != null) {
holder.subtitle.setText(switchSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
holder.subtitle.setSelected(true);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
} else if(setting instanceof TextSetting) {
//comment
TextSetting textSetting = (TextSetting) setting;
holder.subtitle.setText(textSetting.text);
//comment
holder.root.setOnClickListener(textSetting.onClickListener);
} else if(setting instanceof ButtonSetting) {
//comment
ButtonSetting buttonSetting = (ButtonSetting) setting;
holder.button.setText(buttonSetting.text);
//comment
holder.root.setOnClickListener(buttonSetting.onClickListener);
} else {
//comment
IconSetting iconSetting = (IconSetting) setting;
holder.icon.setImageDrawable(iconSetting.icon);
holder.root.setOnClickListener(iconSetting.onClickListener);
holder.title.setText(iconSetting.title);
//comment
if (iconSetting.subtitle != null) {
holder.subtitle.setText(iconSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
}
}"
1708,"    @Override
public void onBindViewHolder(@NonNull final SpringboardWidgetAdapter.ViewHolder holder, int position) {
//comment
BaseSetting setting = settings.get(position);
if (setting instanceof HeaderSetting) {
//comment
holder.title.setText(((HeaderSetting) setting).title);
//comment
final HeaderSetting headerSetting = (HeaderSetting) setting;
if (headerSetting.onLongClickListener != null)
<start>holder.root.setOnLongClickListener(headerSetting.onLongClickListener);<end>
} else if (setting instanceof SwitchSetting) {
//comment
final SwitchSetting switchSetting = (SwitchSetting) setting;

//comment
CompoundButton.OnCheckedChangeListener mOnCheckedListener = new CompoundButton.OnCheckedChangeListener() {
@Override
public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
switchSetting.isChecked = isChecked;
Logger.debug(""SpringboardWidgetAdapter mOnCheckedListener isChecked: "" + isChecked);
}
};

CompoundButton.OnCheckedChangeListener mListener = new CompositeListener(switchSetting.changeListener, mOnCheckedListener);
holder.sw.setOnCheckedChangeListener(mListener);

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

//comment
holder.sw.setChecked(switchSetting.isChecked);
//comment
holder.title.setText(switchSetting.title);
holder.title.setSelected(true);
//comment
if (switchSetting.subtitle != null) {
holder.subtitle.setText(switchSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
holder.subtitle.setSelected(true);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
} else if(setting instanceof TextSetting) {
//comment
TextSetting textSetting = (TextSetting) setting;
holder.subtitle.setText(textSetting.text);
//comment
holder.root.setOnClickListener(textSetting.onClickListener);
<start>} else if(setting instanceof ButtonSetting) {<end>
//comment
ButtonSetting buttonSetting = (ButtonSetting) setting;
holder.button.setText(buttonSetting.text);
//comment
holder.root.setOnClickListener(buttonSetting.onClickListener);
} else {
//comment
IconSetting iconSetting = (IconSetting) setting;
holder.icon.setImageDrawable(iconSetting.icon);
holder.root.setOnClickListener(iconSetting.onClickListener);
holder.title.setText(iconSetting.title);
//comment
if (iconSetting.subtitle != null) {
holder.subtitle.setText(iconSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
}
}","    @Override
public void onBindViewHolder(@NonNull final SpringboardWidgetAdapter.ViewHolder holder, int position) {
//comment
BaseSetting setting = settings.get(position);
if (setting instanceof HeaderSetting) {
//comment
holder.title.setText(((HeaderSetting) setting).title);
//comment
<start>final HeaderSetting headerSetting = (HeaderSetting) setting;
if (headerSetting.onLongClickListener != null)
holder.root.setOnLongClickListener(headerSetting.onLongClickListener);<end>
} else if (setting instanceof SwitchSetting) {
//comment
final SwitchSetting switchSetting = (SwitchSetting) setting;

//comment
CompoundButton.OnCheckedChangeListener mOnCheckedListener = new CompoundButton.OnCheckedChangeListener() {
@Override
public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
switchSetting.isChecked = isChecked;
Logger.debug(""SpringboardWidgetAdapter mOnCheckedListener isChecked: "" + isChecked);
}
};

CompoundButton.OnCheckedChangeListener mListener = new CompositeListener(switchSetting.changeListener, mOnCheckedListener);
holder.sw.setOnCheckedChangeListener(mListener);

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

//comment
holder.sw.setChecked(switchSetting.isChecked);
//comment
holder.title.setText(switchSetting.title);
holder.title.setSelected(true);
//comment
if (switchSetting.subtitle != null) {
holder.subtitle.setText(switchSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
holder.subtitle.setSelected(true);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
} else if(setting instanceof TextSetting) {
//comment
TextSetting textSetting = (TextSetting) setting;
holder.subtitle.setText(textSetting.text);
//comment
holder.root.setOnClickListener(textSetting.onClickListener);
} else if(setting instanceof ButtonSetting) {
//comment
ButtonSetting buttonSetting = (ButtonSetting) setting;
holder.button.setText(buttonSetting.text);
//comment
holder.root.setOnClickListener(buttonSetting.onClickListener);
} else {
//comment
IconSetting iconSetting = (IconSetting) setting;
holder.icon.setImageDrawable(iconSetting.icon);
holder.root.setOnClickListener(iconSetting.onClickListener);
holder.title.setText(iconSetting.title);
//comment
if (iconSetting.subtitle != null) {
holder.subtitle.setText(iconSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
}
}"
1709,"    @Override
public void onBindViewHolder(@NonNull final SpringboardWidgetAdapter.ViewHolder holder, int position) {
//comment
BaseSetting setting = settings.get(position);
if (setting instanceof HeaderSetting) {
//comment
holder.title.setText(((HeaderSetting) setting).title);
//comment
final HeaderSetting headerSetting = (HeaderSetting) setting;
if (headerSetting.onLongClickListener != null)
holder.root.setOnLongClickListener(headerSetting.onLongClickListener);
<start>} else if (setting instanceof SwitchSetting) {
//comment
final SwitchSetting switchSetting = (SwitchSetting) setting;<end>

//comment
CompoundButton.OnCheckedChangeListener mOnCheckedListener = new CompoundButton.OnCheckedChangeListener() {
@Override
public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
switchSetting.isChecked = isChecked;
Logger.debug(""SpringboardWidgetAdapter mOnCheckedListener isChecked: "" + isChecked);
}
};

CompoundButton.OnCheckedChangeListener mListener = new CompositeListener(switchSetting.changeListener, mOnCheckedListener);
holder.sw.setOnCheckedChangeListener(mListener);

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

//comment
holder.sw.setChecked(switchSetting.isChecked);
//comment
holder.title.setText(switchSetting.title);
holder.title.setSelected(true);
//comment
if (switchSetting.subtitle != null) {
holder.subtitle.setText(switchSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
holder.subtitle.setSelected(true);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
} else if(setting instanceof TextSetting) {
//comment
TextSetting textSetting = (TextSetting) setting;
holder.subtitle.setText(textSetting.text);
//comment
holder.root.setOnClickListener(textSetting.onClickListener);
} else if(setting instanceof ButtonSetting) {
//comment
ButtonSetting buttonSetting = (ButtonSetting) setting;
holder.button.setText(buttonSetting.text);
//comment
holder.root.setOnClickListener(buttonSetting.onClickListener);
} else {
//comment
IconSetting iconSetting = (IconSetting) setting;
holder.icon.setImageDrawable(iconSetting.icon);
holder.root.setOnClickListener(iconSetting.onClickListener);
holder.title.setText(iconSetting.title);
//comment
if (iconSetting.subtitle != null) {
holder.subtitle.setText(iconSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
}
}","    @Override
public void onBindViewHolder(@NonNull final SpringboardWidgetAdapter.ViewHolder holder, int position) {
//comment
BaseSetting setting = settings.get(position);
if (setting instanceof HeaderSetting) {
//comment
holder.title.setText(((HeaderSetting) setting).title);
//comment
final HeaderSetting headerSetting = (HeaderSetting) setting;
if (headerSetting.onLongClickListener != null)
holder.root.setOnLongClickListener(headerSetting.onLongClickListener);
} else if (setting instanceof SwitchSetting) {
//comment
<start>final SwitchSetting switchSetting = (SwitchSetting) setting;<end>

//comment
CompoundButton.OnCheckedChangeListener mOnCheckedListener = new CompoundButton.OnCheckedChangeListener() {
@Override
public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
switchSetting.isChecked = isChecked;
Logger.debug(""SpringboardWidgetAdapter mOnCheckedListener isChecked: "" + isChecked);
}
};

CompoundButton.OnCheckedChangeListener mListener = new CompositeListener(switchSetting.changeListener, mOnCheckedListener);
holder.sw.setOnCheckedChangeListener(mListener);

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

//comment
holder.sw.setChecked(switchSetting.isChecked);
//comment
holder.title.setText(switchSetting.title);
holder.title.setSelected(true);
//comment
if (switchSetting.subtitle != null) {
holder.subtitle.setText(switchSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
holder.subtitle.setSelected(true);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
} else if(setting instanceof TextSetting) {
//comment
TextSetting textSetting = (TextSetting) setting;
holder.subtitle.setText(textSetting.text);
//comment
holder.root.setOnClickListener(textSetting.onClickListener);
} else if(setting instanceof ButtonSetting) {
//comment
ButtonSetting buttonSetting = (ButtonSetting) setting;
holder.button.setText(buttonSetting.text);
//comment
holder.root.setOnClickListener(buttonSetting.onClickListener);
} else {
//comment
IconSetting iconSetting = (IconSetting) setting;
holder.icon.setImageDrawable(iconSetting.icon);
holder.root.setOnClickListener(iconSetting.onClickListener);
holder.title.setText(iconSetting.title);
//comment
if (iconSetting.subtitle != null) {
holder.subtitle.setText(iconSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
}
}"
1710,"    @Override
public void onBindViewHolder(@NonNull final SpringboardWidgetAdapter.ViewHolder holder, int position) {
//comment
BaseSetting setting = settings.get(position);
if (setting instanceof HeaderSetting) {
//comment
holder.title.setText(((HeaderSetting) setting).title);
//comment
final HeaderSetting headerSetting = (HeaderSetting) setting;
if (headerSetting.onLongClickListener != null)
holder.root.setOnLongClickListener(headerSetting.onLongClickListener);
<start>} else if (setting instanceof SwitchSetting) {<end>
//comment
final SwitchSetting switchSetting = (SwitchSetting) setting;

//comment
<start>CompoundButton.OnCheckedChangeListener mOnCheckedListener = new CompoundButton.OnCheckedChangeListener() {
@Override
public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
switchSetting.isChecked = isChecked;
Logger.debug(""SpringboardWidgetAdapter mOnCheckedListener isChecked: "" + isChecked);
}
};<end>

CompoundButton.OnCheckedChangeListener mListener = new CompositeListener(switchSetting.changeListener, mOnCheckedListener);
holder.sw.setOnCheckedChangeListener(mListener);

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

//comment
holder.sw.setChecked(switchSetting.isChecked);
//comment
holder.title.setText(switchSetting.title);
holder.title.setSelected(true);
//comment
if (switchSetting.subtitle != null) {
holder.subtitle.setText(switchSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
holder.subtitle.setSelected(true);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
} else if(setting instanceof TextSetting) {
//comment
TextSetting textSetting = (TextSetting) setting;
holder.subtitle.setText(textSetting.text);
//comment
holder.root.setOnClickListener(textSetting.onClickListener);
} else if(setting instanceof ButtonSetting) {
//comment
ButtonSetting buttonSetting = (ButtonSetting) setting;
holder.button.setText(buttonSetting.text);
//comment
holder.root.setOnClickListener(buttonSetting.onClickListener);
} else {
//comment
IconSetting iconSetting = (IconSetting) setting;
holder.icon.setImageDrawable(iconSetting.icon);
holder.root.setOnClickListener(iconSetting.onClickListener);
holder.title.setText(iconSetting.title);
//comment
if (iconSetting.subtitle != null) {
holder.subtitle.setText(iconSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
}
}","    @Override
public void onBindViewHolder(@NonNull final SpringboardWidgetAdapter.ViewHolder holder, int position) {
//comment
BaseSetting setting = settings.get(position);
if (setting instanceof HeaderSetting) {
//comment
holder.title.setText(((HeaderSetting) setting).title);
//comment
final HeaderSetting headerSetting = (HeaderSetting) setting;
if (headerSetting.onLongClickListener != null)
holder.root.setOnLongClickListener(headerSetting.onLongClickListener);
} else if (setting instanceof SwitchSetting) {
//comment
final SwitchSetting switchSetting = (SwitchSetting) setting;

//comment
<start>CompoundButton.OnCheckedChangeListener mOnCheckedListener = new CompoundButton.OnCheckedChangeListener() {
@Override
public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
switchSetting.isChecked = isChecked;
Logger.debug(""SpringboardWidgetAdapter mOnCheckedListener isChecked: "" + isChecked);
}
};<end>

CompoundButton.OnCheckedChangeListener mListener = new CompositeListener(switchSetting.changeListener, mOnCheckedListener);
holder.sw.setOnCheckedChangeListener(mListener);

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

//comment
holder.sw.setChecked(switchSetting.isChecked);
//comment
holder.title.setText(switchSetting.title);
holder.title.setSelected(true);
//comment
if (switchSetting.subtitle != null) {
holder.subtitle.setText(switchSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
holder.subtitle.setSelected(true);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
} else if(setting instanceof TextSetting) {
//comment
TextSetting textSetting = (TextSetting) setting;
holder.subtitle.setText(textSetting.text);
//comment
holder.root.setOnClickListener(textSetting.onClickListener);
} else if(setting instanceof ButtonSetting) {
//comment
ButtonSetting buttonSetting = (ButtonSetting) setting;
holder.button.setText(buttonSetting.text);
//comment
holder.root.setOnClickListener(buttonSetting.onClickListener);
} else {
//comment
IconSetting iconSetting = (IconSetting) setting;
holder.icon.setImageDrawable(iconSetting.icon);
holder.root.setOnClickListener(iconSetting.onClickListener);
holder.title.setText(iconSetting.title);
//comment
if (iconSetting.subtitle != null) {
holder.subtitle.setText(iconSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
}
}"
1711,"    @Override
public void onBindViewHolder(@NonNull final SpringboardWidgetAdapter.ViewHolder holder, int position) {
//comment
BaseSetting setting = settings.get(position);
if (setting instanceof HeaderSetting) {
//comment
holder.title.setText(((HeaderSetting) setting).title);
//comment
final HeaderSetting headerSetting = (HeaderSetting) setting;
if (headerSetting.onLongClickListener != null)
holder.root.setOnLongClickListener(headerSetting.onLongClickListener);
} else if (setting instanceof SwitchSetting) {
//comment
final SwitchSetting switchSetting = (SwitchSetting) setting;

//comment
CompoundButton.OnCheckedChangeListener mOnCheckedListener = new CompoundButton.OnCheckedChangeListener() {
@Override
public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
switchSetting.isChecked = isChecked;
Logger.debug(""SpringboardWidgetAdapter mOnCheckedListener isChecked: "" + isChecked);
}
};

CompoundButton.OnCheckedChangeListener mListener = new CompositeListener(switchSetting.changeListener, mOnCheckedListener);
holder.sw.setOnCheckedChangeListener(mListener);

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

//comment
<start>holder.sw.setChecked(switchSetting.isChecked);
//comment
holder.title.setText(switchSetting.title);<end>
holder.title.setSelected(true);
//comment
if (switchSetting.subtitle != null) {
<start>holder.subtitle.setText(switchSetting.subtitle);<end>
holder.subtitle.setVisibility(View.VISIBLE);
holder.subtitle.setSelected(true);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
} else if(setting instanceof TextSetting) {
//comment
TextSetting textSetting = (TextSetting) setting;
holder.subtitle.setText(textSetting.text);
//comment
holder.root.setOnClickListener(textSetting.onClickListener);
} else if(setting instanceof ButtonSetting) {
//comment
ButtonSetting buttonSetting = (ButtonSetting) setting;
holder.button.setText(buttonSetting.text);
//comment
holder.root.setOnClickListener(buttonSetting.onClickListener);
} else {
//comment
IconSetting iconSetting = (IconSetting) setting;
holder.icon.setImageDrawable(iconSetting.icon);
holder.root.setOnClickListener(iconSetting.onClickListener);
holder.title.setText(iconSetting.title);
//comment
if (iconSetting.subtitle != null) {
holder.subtitle.setText(iconSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
}
}","    @Override
public void onBindViewHolder(@NonNull final SpringboardWidgetAdapter.ViewHolder holder, int position) {
//comment
BaseSetting setting = settings.get(position);
if (setting instanceof HeaderSetting) {
//comment
holder.title.setText(((HeaderSetting) setting).title);
//comment
final HeaderSetting headerSetting = (HeaderSetting) setting;
if (headerSetting.onLongClickListener != null)
holder.root.setOnLongClickListener(headerSetting.onLongClickListener);
} else if (setting instanceof SwitchSetting) {
//comment
final SwitchSetting switchSetting = (SwitchSetting) setting;

//comment
CompoundButton.OnCheckedChangeListener mOnCheckedListener = new CompoundButton.OnCheckedChangeListener() {
@Override
public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
switchSetting.isChecked = isChecked;
Logger.debug(""SpringboardWidgetAdapter mOnCheckedListener isChecked: "" + isChecked);
}
};

CompoundButton.OnCheckedChangeListener mListener = new CompositeListener(switchSetting.changeListener, mOnCheckedListener);
holder.sw.setOnCheckedChangeListener(mListener);

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

//comment
<start>holder.sw.setChecked(switchSetting.isChecked);<end>
//comment
holder.title.setText(switchSetting.title);
holder.title.setSelected(true);
//comment
if (switchSetting.subtitle != null) {
holder.subtitle.setText(switchSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
holder.subtitle.setSelected(true);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
} else if(setting instanceof TextSetting) {
//comment
TextSetting textSetting = (TextSetting) setting;
holder.subtitle.setText(textSetting.text);
//comment
holder.root.setOnClickListener(textSetting.onClickListener);
} else if(setting instanceof ButtonSetting) {
//comment
ButtonSetting buttonSetting = (ButtonSetting) setting;
holder.button.setText(buttonSetting.text);
//comment
holder.root.setOnClickListener(buttonSetting.onClickListener);
} else {
//comment
IconSetting iconSetting = (IconSetting) setting;
holder.icon.setImageDrawable(iconSetting.icon);
holder.root.setOnClickListener(iconSetting.onClickListener);
holder.title.setText(iconSetting.title);
//comment
if (iconSetting.subtitle != null) {
holder.subtitle.setText(iconSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
}
}"
1712,"    @Override
public void onBindViewHolder(@NonNull final SpringboardWidgetAdapter.ViewHolder holder, int position) {
//comment
BaseSetting setting = settings.get(position);
if (setting instanceof HeaderSetting) {
//comment
holder.title.setText(((HeaderSetting) setting).title);
//comment
final HeaderSetting headerSetting = (HeaderSetting) setting;
if (headerSetting.onLongClickListener != null)
holder.root.setOnLongClickListener(headerSetting.onLongClickListener);
} else if (setting instanceof SwitchSetting) {
//comment
final SwitchSetting switchSetting = (SwitchSetting) setting;

//comment
CompoundButton.OnCheckedChangeListener mOnCheckedListener = new CompoundButton.OnCheckedChangeListener() {
@Override
public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
switchSetting.isChecked = isChecked;
Logger.debug(""SpringboardWidgetAdapter mOnCheckedListener isChecked: "" + isChecked);
}
};

CompoundButton.OnCheckedChangeListener mListener = new CompositeListener(switchSetting.changeListener, mOnCheckedListener);
holder.sw.setOnCheckedChangeListener(mListener);

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

//comment
<start>holder.sw.setChecked(switchSetting.isChecked);
//comment
holder.title.setText(switchSetting.title);
holder.title.setSelected(true);<end>
//comment
if (switchSetting.subtitle != null) {
holder.subtitle.setText(switchSetting.subtitle);
<start>holder.subtitle.setVisibility(View.VISIBLE);<end>
holder.subtitle.setSelected(true);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
} else if(setting instanceof TextSetting) {
//comment
TextSetting textSetting = (TextSetting) setting;
holder.subtitle.setText(textSetting.text);
//comment
holder.root.setOnClickListener(textSetting.onClickListener);
} else if(setting instanceof ButtonSetting) {
//comment
ButtonSetting buttonSetting = (ButtonSetting) setting;
holder.button.setText(buttonSetting.text);
//comment
holder.root.setOnClickListener(buttonSetting.onClickListener);
} else {
//comment
IconSetting iconSetting = (IconSetting) setting;
holder.icon.setImageDrawable(iconSetting.icon);
holder.root.setOnClickListener(iconSetting.onClickListener);
holder.title.setText(iconSetting.title);
//comment
if (iconSetting.subtitle != null) {
holder.subtitle.setText(iconSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
}
}","    @Override
public void onBindViewHolder(@NonNull final SpringboardWidgetAdapter.ViewHolder holder, int position) {
//comment
BaseSetting setting = settings.get(position);
if (setting instanceof HeaderSetting) {
//comment
holder.title.setText(((HeaderSetting) setting).title);
//comment
final HeaderSetting headerSetting = (HeaderSetting) setting;
if (headerSetting.onLongClickListener != null)
holder.root.setOnLongClickListener(headerSetting.onLongClickListener);
} else if (setting instanceof SwitchSetting) {
//comment
final SwitchSetting switchSetting = (SwitchSetting) setting;

//comment
CompoundButton.OnCheckedChangeListener mOnCheckedListener = new CompoundButton.OnCheckedChangeListener() {
@Override
public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
switchSetting.isChecked = isChecked;
Logger.debug(""SpringboardWidgetAdapter mOnCheckedListener isChecked: "" + isChecked);
}
};

CompoundButton.OnCheckedChangeListener mListener = new CompositeListener(switchSetting.changeListener, mOnCheckedListener);
holder.sw.setOnCheckedChangeListener(mListener);

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

//comment
holder.sw.setChecked(switchSetting.isChecked);
//comment
<start>holder.title.setText(switchSetting.title);
holder.title.setSelected(true);<end>
//comment
if (switchSetting.subtitle != null) {
holder.subtitle.setText(switchSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
holder.subtitle.setSelected(true);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
} else if(setting instanceof TextSetting) {
//comment
TextSetting textSetting = (TextSetting) setting;
holder.subtitle.setText(textSetting.text);
//comment
holder.root.setOnClickListener(textSetting.onClickListener);
} else if(setting instanceof ButtonSetting) {
//comment
ButtonSetting buttonSetting = (ButtonSetting) setting;
holder.button.setText(buttonSetting.text);
//comment
holder.root.setOnClickListener(buttonSetting.onClickListener);
} else {
//comment
IconSetting iconSetting = (IconSetting) setting;
holder.icon.setImageDrawable(iconSetting.icon);
holder.root.setOnClickListener(iconSetting.onClickListener);
holder.title.setText(iconSetting.title);
//comment
if (iconSetting.subtitle != null) {
holder.subtitle.setText(iconSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
}
}"
1713,"    @Override
public void onBindViewHolder(@NonNull final SpringboardWidgetAdapter.ViewHolder holder, int position) {
//comment
BaseSetting setting = settings.get(position);
if (setting instanceof HeaderSetting) {
//comment
holder.title.setText(((HeaderSetting) setting).title);
//comment
final HeaderSetting headerSetting = (HeaderSetting) setting;
if (headerSetting.onLongClickListener != null)
holder.root.setOnLongClickListener(headerSetting.onLongClickListener);
} else if (setting instanceof SwitchSetting) {
//comment
final SwitchSetting switchSetting = (SwitchSetting) setting;

//comment
CompoundButton.OnCheckedChangeListener mOnCheckedListener = new CompoundButton.OnCheckedChangeListener() {
@Override
public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
switchSetting.isChecked = isChecked;
Logger.debug(""SpringboardWidgetAdapter mOnCheckedListener isChecked: "" + isChecked);
}
};

CompoundButton.OnCheckedChangeListener mListener = new CompositeListener(switchSetting.changeListener, mOnCheckedListener);
holder.sw.setOnCheckedChangeListener(mListener);

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

//comment
holder.sw.setChecked(switchSetting.isChecked);
//comment
holder.title.setText(switchSetting.title);
<start>holder.title.setSelected(true);<end>
//comment
if (switchSetting.subtitle != null) {
<start>holder.subtitle.setText(switchSetting.subtitle);<end>
holder.subtitle.setVisibility(View.VISIBLE);
holder.subtitle.setSelected(true);
<start>} else {<end>
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
} else if(setting instanceof TextSetting) {
//comment
TextSetting textSetting = (TextSetting) setting;
holder.subtitle.setText(textSetting.text);
//comment
holder.root.setOnClickListener(textSetting.onClickListener);
} else if(setting instanceof ButtonSetting) {
//comment
ButtonSetting buttonSetting = (ButtonSetting) setting;
holder.button.setText(buttonSetting.text);
//comment
holder.root.setOnClickListener(buttonSetting.onClickListener);
} else {
//comment
IconSetting iconSetting = (IconSetting) setting;
holder.icon.setImageDrawable(iconSetting.icon);
holder.root.setOnClickListener(iconSetting.onClickListener);
holder.title.setText(iconSetting.title);
//comment
if (iconSetting.subtitle != null) {
holder.subtitle.setText(iconSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
}
}","    @Override
public void onBindViewHolder(@NonNull final SpringboardWidgetAdapter.ViewHolder holder, int position) {
//comment
BaseSetting setting = settings.get(position);
if (setting instanceof HeaderSetting) {
//comment
holder.title.setText(((HeaderSetting) setting).title);
//comment
final HeaderSetting headerSetting = (HeaderSetting) setting;
if (headerSetting.onLongClickListener != null)
holder.root.setOnLongClickListener(headerSetting.onLongClickListener);
} else if (setting instanceof SwitchSetting) {
//comment
final SwitchSetting switchSetting = (SwitchSetting) setting;

//comment
CompoundButton.OnCheckedChangeListener mOnCheckedListener = new CompoundButton.OnCheckedChangeListener() {
@Override
public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
switchSetting.isChecked = isChecked;
Logger.debug(""SpringboardWidgetAdapter mOnCheckedListener isChecked: "" + isChecked);
}
};

CompoundButton.OnCheckedChangeListener mListener = new CompositeListener(switchSetting.changeListener, mOnCheckedListener);
holder.sw.setOnCheckedChangeListener(mListener);

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

//comment
holder.sw.setChecked(switchSetting.isChecked);
//comment
holder.title.setText(switchSetting.title);
holder.title.setSelected(true);
//comment
<start>if (switchSetting.subtitle != null) {
holder.subtitle.setText(switchSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
holder.subtitle.setSelected(true);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}<end>
} else if(setting instanceof TextSetting) {
//comment
TextSetting textSetting = (TextSetting) setting;
holder.subtitle.setText(textSetting.text);
//comment
holder.root.setOnClickListener(textSetting.onClickListener);
} else if(setting instanceof ButtonSetting) {
//comment
ButtonSetting buttonSetting = (ButtonSetting) setting;
holder.button.setText(buttonSetting.text);
//comment
holder.root.setOnClickListener(buttonSetting.onClickListener);
} else {
//comment
IconSetting iconSetting = (IconSetting) setting;
holder.icon.setImageDrawable(iconSetting.icon);
holder.root.setOnClickListener(iconSetting.onClickListener);
holder.title.setText(iconSetting.title);
//comment
if (iconSetting.subtitle != null) {
holder.subtitle.setText(iconSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
}
}"
1714,"    @Override
public void onBindViewHolder(@NonNull final SpringboardWidgetAdapter.ViewHolder holder, int position) {
//comment
BaseSetting setting = settings.get(position);
if (setting instanceof HeaderSetting) {
//comment
holder.title.setText(((HeaderSetting) setting).title);
//comment
final HeaderSetting headerSetting = (HeaderSetting) setting;
if (headerSetting.onLongClickListener != null)
holder.root.setOnLongClickListener(headerSetting.onLongClickListener);
} else if (setting instanceof SwitchSetting) {
//comment
final SwitchSetting switchSetting = (SwitchSetting) setting;

//comment
CompoundButton.OnCheckedChangeListener mOnCheckedListener = new CompoundButton.OnCheckedChangeListener() {
@Override
public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
switchSetting.isChecked = isChecked;
Logger.debug(""SpringboardWidgetAdapter mOnCheckedListener isChecked: "" + isChecked);
}
};

CompoundButton.OnCheckedChangeListener mListener = new CompositeListener(switchSetting.changeListener, mOnCheckedListener);
holder.sw.setOnCheckedChangeListener(mListener);

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

//comment
holder.sw.setChecked(switchSetting.isChecked);
//comment
holder.title.setText(switchSetting.title);
holder.title.setSelected(true);
//comment
if (switchSetting.subtitle != null) {
holder.subtitle.setText(switchSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
holder.subtitle.setSelected(true);
} else {
<start>holder.subtitle.setText("""");<end>
holder.subtitle.setVisibility(View.GONE);
}
<start>} else if(setting instanceof TextSetting) {
//comment
TextSetting textSetting = (TextSetting) setting;
holder.subtitle.setText(textSetting.text);
//comment
holder.root.setOnClickListener(textSetting.onClickListener);<end>
} else if(setting instanceof ButtonSetting) {
//comment
ButtonSetting buttonSetting = (ButtonSetting) setting;
<start>holder.button.setText(buttonSetting.text);<end>
//comment
holder.root.setOnClickListener(buttonSetting.onClickListener);
} else {
//comment
IconSetting iconSetting = (IconSetting) setting;
holder.icon.setImageDrawable(iconSetting.icon);
holder.root.setOnClickListener(iconSetting.onClickListener);
holder.title.setText(iconSetting.title);
//comment
if (iconSetting.subtitle != null) {
holder.subtitle.setText(iconSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
}
}","    @Override
public void onBindViewHolder(@NonNull final SpringboardWidgetAdapter.ViewHolder holder, int position) {
//comment
BaseSetting setting = settings.get(position);
if (setting instanceof HeaderSetting) {
//comment
holder.title.setText(((HeaderSetting) setting).title);
//comment
final HeaderSetting headerSetting = (HeaderSetting) setting;
if (headerSetting.onLongClickListener != null)
holder.root.setOnLongClickListener(headerSetting.onLongClickListener);
} else if (setting instanceof SwitchSetting) {
//comment
final SwitchSetting switchSetting = (SwitchSetting) setting;

//comment
CompoundButton.OnCheckedChangeListener mOnCheckedListener = new CompoundButton.OnCheckedChangeListener() {
@Override
public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
switchSetting.isChecked = isChecked;
Logger.debug(""SpringboardWidgetAdapter mOnCheckedListener isChecked: "" + isChecked);
}
};

CompoundButton.OnCheckedChangeListener mListener = new CompositeListener(switchSetting.changeListener, mOnCheckedListener);
holder.sw.setOnCheckedChangeListener(mListener);

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

//comment
holder.sw.setChecked(switchSetting.isChecked);
//comment
holder.title.setText(switchSetting.title);
holder.title.setSelected(true);
//comment
if (switchSetting.subtitle != null) {
holder.subtitle.setText(switchSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
holder.subtitle.setSelected(true);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
<start>} else if(setting instanceof TextSetting) {
//comment
TextSetting textSetting = (TextSetting) setting;
holder.subtitle.setText(textSetting.text);<end>
//comment
holder.root.setOnClickListener(textSetting.onClickListener);
<start>} else if(setting instanceof ButtonSetting) {<end>
//comment
ButtonSetting buttonSetting = (ButtonSetting) setting;
holder.button.setText(buttonSetting.text);
//comment
holder.root.setOnClickListener(buttonSetting.onClickListener);
} else {
//comment
IconSetting iconSetting = (IconSetting) setting;
holder.icon.setImageDrawable(iconSetting.icon);
holder.root.setOnClickListener(iconSetting.onClickListener);
holder.title.setText(iconSetting.title);
//comment
if (iconSetting.subtitle != null) {
holder.subtitle.setText(iconSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
}
}"
1715,"    @Override
public void onBindViewHolder(@NonNull final SpringboardWidgetAdapter.ViewHolder holder, int position) {
//comment
BaseSetting setting = settings.get(position);
if (setting instanceof HeaderSetting) {
//comment
holder.title.setText(((HeaderSetting) setting).title);
//comment
final HeaderSetting headerSetting = (HeaderSetting) setting;
if (headerSetting.onLongClickListener != null)
holder.root.setOnLongClickListener(headerSetting.onLongClickListener);
} else if (setting instanceof SwitchSetting) {
//comment
final SwitchSetting switchSetting = (SwitchSetting) setting;

//comment
CompoundButton.OnCheckedChangeListener mOnCheckedListener = new CompoundButton.OnCheckedChangeListener() {
@Override
public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
switchSetting.isChecked = isChecked;
Logger.debug(""SpringboardWidgetAdapter mOnCheckedListener isChecked: "" + isChecked);
}
};

CompoundButton.OnCheckedChangeListener mListener = new CompositeListener(switchSetting.changeListener, mOnCheckedListener);
holder.sw.setOnCheckedChangeListener(mListener);

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

//comment
holder.sw.setChecked(switchSetting.isChecked);
//comment
holder.title.setText(switchSetting.title);
holder.title.setSelected(true);
//comment
if (switchSetting.subtitle != null) {
holder.subtitle.setText(switchSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
holder.subtitle.setSelected(true);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
} else if(setting instanceof TextSetting) {
//comment
TextSetting textSetting = (TextSetting) setting;
holder.subtitle.setText(textSetting.text);
//comment
holder.root.setOnClickListener(textSetting.onClickListener);
} else if(setting instanceof ButtonSetting) {
//comment
<start>ButtonSetting buttonSetting = (ButtonSetting) setting;
holder.button.setText(buttonSetting.text);
//comment
holder.root.setOnClickListener(buttonSetting.onClickListener);
} else {<end>
//comment
IconSetting iconSetting = (IconSetting) setting;
holder.icon.setImageDrawable(iconSetting.icon);
holder.root.setOnClickListener(iconSetting.onClickListener);
holder.title.setText(iconSetting.title);
//comment
if (iconSetting.subtitle != null) {
holder.subtitle.setText(iconSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
}
}","    @Override
public void onBindViewHolder(@NonNull final SpringboardWidgetAdapter.ViewHolder holder, int position) {
//comment
BaseSetting setting = settings.get(position);
if (setting instanceof HeaderSetting) {
//comment
holder.title.setText(((HeaderSetting) setting).title);
//comment
final HeaderSetting headerSetting = (HeaderSetting) setting;
if (headerSetting.onLongClickListener != null)
holder.root.setOnLongClickListener(headerSetting.onLongClickListener);
} else if (setting instanceof SwitchSetting) {
//comment
final SwitchSetting switchSetting = (SwitchSetting) setting;

//comment
CompoundButton.OnCheckedChangeListener mOnCheckedListener = new CompoundButton.OnCheckedChangeListener() {
@Override
public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
switchSetting.isChecked = isChecked;
Logger.debug(""SpringboardWidgetAdapter mOnCheckedListener isChecked: "" + isChecked);
}
};

CompoundButton.OnCheckedChangeListener mListener = new CompositeListener(switchSetting.changeListener, mOnCheckedListener);
holder.sw.setOnCheckedChangeListener(mListener);

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

//comment
holder.sw.setChecked(switchSetting.isChecked);
//comment
holder.title.setText(switchSetting.title);
holder.title.setSelected(true);
//comment
if (switchSetting.subtitle != null) {
holder.subtitle.setText(switchSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
holder.subtitle.setSelected(true);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
} else if(setting instanceof TextSetting) {
//comment
TextSetting textSetting = (TextSetting) setting;
holder.subtitle.setText(textSetting.text);
//comment
holder.root.setOnClickListener(textSetting.onClickListener);
<start>} else if(setting instanceof ButtonSetting) {
//comment
ButtonSetting buttonSetting = (ButtonSetting) setting;
holder.button.setText(buttonSetting.text);<end>
//comment
holder.root.setOnClickListener(buttonSetting.onClickListener);
<start>} else {<end>
//comment
IconSetting iconSetting = (IconSetting) setting;
holder.icon.setImageDrawable(iconSetting.icon);
holder.root.setOnClickListener(iconSetting.onClickListener);
holder.title.setText(iconSetting.title);
//comment
if (iconSetting.subtitle != null) {
holder.subtitle.setText(iconSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
}
}"
1716,"    @Override
public void onBindViewHolder(@NonNull final SpringboardWidgetAdapter.ViewHolder holder, int position) {
//comment
BaseSetting setting = settings.get(position);
if (setting instanceof HeaderSetting) {
//comment
holder.title.setText(((HeaderSetting) setting).title);
//comment
final HeaderSetting headerSetting = (HeaderSetting) setting;
if (headerSetting.onLongClickListener != null)
holder.root.setOnLongClickListener(headerSetting.onLongClickListener);
} else if (setting instanceof SwitchSetting) {
//comment
final SwitchSetting switchSetting = (SwitchSetting) setting;

//comment
CompoundButton.OnCheckedChangeListener mOnCheckedListener = new CompoundButton.OnCheckedChangeListener() {
@Override
public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
switchSetting.isChecked = isChecked;
Logger.debug(""SpringboardWidgetAdapter mOnCheckedListener isChecked: "" + isChecked);
}
};

CompoundButton.OnCheckedChangeListener mListener = new CompositeListener(switchSetting.changeListener, mOnCheckedListener);
holder.sw.setOnCheckedChangeListener(mListener);

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

//comment
holder.sw.setChecked(switchSetting.isChecked);
//comment
holder.title.setText(switchSetting.title);
holder.title.setSelected(true);
//comment
if (switchSetting.subtitle != null) {
holder.subtitle.setText(switchSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
holder.subtitle.setSelected(true);
} else {
<start>holder.subtitle.setText("""");<end>
holder.subtitle.setVisibility(View.GONE);
}
} else if(setting instanceof TextSetting) {
//comment
TextSetting textSetting = (TextSetting) setting;
holder.subtitle.setText(textSetting.text);
//comment
holder.root.setOnClickListener(textSetting.onClickListener);
} else if(setting instanceof ButtonSetting) {
//comment
ButtonSetting buttonSetting = (ButtonSetting) setting;
holder.button.setText(buttonSetting.text);
//comment
holder.root.setOnClickListener(buttonSetting.onClickListener);
} else {
//comment
<start>IconSetting iconSetting = (IconSetting) setting;
holder.icon.setImageDrawable(iconSetting.icon);
holder.root.setOnClickListener(iconSetting.onClickListener);
holder.title.setText(iconSetting.title);<end>
//comment
if (iconSetting.subtitle != null) {
holder.subtitle.setText(iconSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
}
}","    @Override
public void onBindViewHolder(@NonNull final SpringboardWidgetAdapter.ViewHolder holder, int position) {
//comment
BaseSetting setting = settings.get(position);
if (setting instanceof HeaderSetting) {
//comment
holder.title.setText(((HeaderSetting) setting).title);
//comment
final HeaderSetting headerSetting = (HeaderSetting) setting;
if (headerSetting.onLongClickListener != null)
holder.root.setOnLongClickListener(headerSetting.onLongClickListener);
} else if (setting instanceof SwitchSetting) {
//comment
final SwitchSetting switchSetting = (SwitchSetting) setting;

//comment
CompoundButton.OnCheckedChangeListener mOnCheckedListener = new CompoundButton.OnCheckedChangeListener() {
@Override
public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
switchSetting.isChecked = isChecked;
Logger.debug(""SpringboardWidgetAdapter mOnCheckedListener isChecked: "" + isChecked);
}
};

CompoundButton.OnCheckedChangeListener mListener = new CompositeListener(switchSetting.changeListener, mOnCheckedListener);
holder.sw.setOnCheckedChangeListener(mListener);

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

//comment
holder.sw.setChecked(switchSetting.isChecked);
//comment
holder.title.setText(switchSetting.title);
holder.title.setSelected(true);
//comment
if (switchSetting.subtitle != null) {
holder.subtitle.setText(switchSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
holder.subtitle.setSelected(true);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
} else if(setting instanceof TextSetting) {
//comment
TextSetting textSetting = (TextSetting) setting;
holder.subtitle.setText(textSetting.text);
//comment
holder.root.setOnClickListener(textSetting.onClickListener);
} else if(setting instanceof ButtonSetting) {
//comment
ButtonSetting buttonSetting = (ButtonSetting) setting;
holder.button.setText(buttonSetting.text);
//comment
holder.root.setOnClickListener(buttonSetting.onClickListener);
} else {
//comment
<start>IconSetting iconSetting = (IconSetting) setting;
holder.icon.setImageDrawable(iconSetting.icon);
holder.root.setOnClickListener(iconSetting.onClickListener);
holder.title.setText(iconSetting.title);<end>
//comment
if (iconSetting.subtitle != null) {
holder.subtitle.setText(iconSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
}
}"
1717,"    @Override
public void onBindViewHolder(@NonNull final SpringboardWidgetAdapter.ViewHolder holder, int position) {
//comment
BaseSetting setting = settings.get(position);
if (setting instanceof HeaderSetting) {
//comment
holder.title.setText(((HeaderSetting) setting).title);
//comment
final HeaderSetting headerSetting = (HeaderSetting) setting;
if (headerSetting.onLongClickListener != null)
holder.root.setOnLongClickListener(headerSetting.onLongClickListener);
} else if (setting instanceof SwitchSetting) {
//comment
final SwitchSetting switchSetting = (SwitchSetting) setting;

//comment
CompoundButton.OnCheckedChangeListener mOnCheckedListener = new CompoundButton.OnCheckedChangeListener() {
@Override
public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
switchSetting.isChecked = isChecked;
Logger.debug(""SpringboardWidgetAdapter mOnCheckedListener isChecked: "" + isChecked);
}
};

CompoundButton.OnCheckedChangeListener mListener = new CompositeListener(switchSetting.changeListener, mOnCheckedListener);
holder.sw.setOnCheckedChangeListener(mListener);

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

//comment
holder.sw.setChecked(switchSetting.isChecked);
//comment
holder.title.setText(switchSetting.title);
holder.title.setSelected(true);
//comment
if (switchSetting.subtitle != null) {
holder.subtitle.setText(switchSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
holder.subtitle.setSelected(true);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
} else if(setting instanceof TextSetting) {
//comment
TextSetting textSetting = (TextSetting) setting;
holder.subtitle.setText(textSetting.text);
//comment
holder.root.setOnClickListener(textSetting.onClickListener);
} else if(setting instanceof ButtonSetting) {
//comment
ButtonSetting buttonSetting = (ButtonSetting) setting;
holder.button.setText(buttonSetting.text);
//comment
holder.root.setOnClickListener(buttonSetting.onClickListener);
} else {
//comment
IconSetting iconSetting = (IconSetting) setting;
holder.icon.setImageDrawable(iconSetting.icon);
holder.root.setOnClickListener(iconSetting.onClickListener);
<start>holder.title.setText(iconSetting.title);<end>
//comment
if (iconSetting.subtitle != null) {
<start>holder.subtitle.setText(iconSetting.subtitle);<end>
holder.subtitle.setVisibility(View.VISIBLE);
} else {
holder.subtitle.setText("""");
<start>holder.subtitle.setVisibility(View.GONE);<end>
}
}
}","    @Override
public void onBindViewHolder(@NonNull final SpringboardWidgetAdapter.ViewHolder holder, int position) {
//comment
BaseSetting setting = settings.get(position);
if (setting instanceof HeaderSetting) {
//comment
holder.title.setText(((HeaderSetting) setting).title);
//comment
final HeaderSetting headerSetting = (HeaderSetting) setting;
if (headerSetting.onLongClickListener != null)
holder.root.setOnLongClickListener(headerSetting.onLongClickListener);
} else if (setting instanceof SwitchSetting) {
//comment
final SwitchSetting switchSetting = (SwitchSetting) setting;

//comment
CompoundButton.OnCheckedChangeListener mOnCheckedListener = new CompoundButton.OnCheckedChangeListener() {
@Override
public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
switchSetting.isChecked = isChecked;
Logger.debug(""SpringboardWidgetAdapter mOnCheckedListener isChecked: "" + isChecked);
}
};

CompoundButton.OnCheckedChangeListener mListener = new CompositeListener(switchSetting.changeListener, mOnCheckedListener);
holder.sw.setOnCheckedChangeListener(mListener);

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

//comment
holder.sw.setChecked(switchSetting.isChecked);
//comment
holder.title.setText(switchSetting.title);
holder.title.setSelected(true);
//comment
if (switchSetting.subtitle != null) {
holder.subtitle.setText(switchSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
holder.subtitle.setSelected(true);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}
} else if(setting instanceof TextSetting) {
//comment
TextSetting textSetting = (TextSetting) setting;
holder.subtitle.setText(textSetting.text);
//comment
holder.root.setOnClickListener(textSetting.onClickListener);
} else if(setting instanceof ButtonSetting) {
//comment
ButtonSetting buttonSetting = (ButtonSetting) setting;
holder.button.setText(buttonSetting.text);
//comment
holder.root.setOnClickListener(buttonSetting.onClickListener);
} else {
//comment
IconSetting iconSetting = (IconSetting) setting;
holder.icon.setImageDrawable(iconSetting.icon);
holder.root.setOnClickListener(iconSetting.onClickListener);
holder.title.setText(iconSetting.title);
//comment
<start>if (iconSetting.subtitle != null) {
holder.subtitle.setText(iconSetting.subtitle);
holder.subtitle.setVisibility(View.VISIBLE);
} else {
holder.subtitle.setText("""");
holder.subtitle.setVisibility(View.GONE);
}<end>
}
}"
6754,"public static void removeCustomNotification(String key, Context context) {
<start>NotificationData notificationData = NotificationStore.getCustomNotification(key);<end>
//comment
if (notificationData == null)
<start>DeviceUtil.notificationCounter(context, -1,""NotificationWearActivity notification is null (del action will not be send)"");<end>
else{
//comment
sendRequestDeleteNotification(key, notificationData);
<start>customNotifications.remove(key);<end>
keyMap.remove(key);
}
}","public static void removeCustomNotification(String key, Context context) {
NotificationData notificationData = NotificationStore.getCustomNotification(key);
//comment
<start>if (notificationData == null)
DeviceUtil.notificationCounter(context, -1,""NotificationWearActivity notification is null (del action will not be send)"");<end>
else{
//comment
sendRequestDeleteNotification(key, notificationData);
customNotifications.remove(key);
keyMap.remove(key);
}
}"
6755,"public static void removeCustomNotification(String key, Context context) {
NotificationData notificationData = NotificationStore.getCustomNotification(key);
//comment
if (notificationData == null)
DeviceUtil.notificationCounter(context, -1,""NotificationWearActivity notification is null (del action will not be send)"");
else{
//comment
<start>sendRequestDeleteNotification(key, notificationData);
customNotifications.remove(key);<end>
keyMap.remove(key);
}
}","public static void removeCustomNotification(String key, Context context) {
NotificationData notificationData = NotificationStore.getCustomNotification(key);
//comment
if (notificationData == null)
DeviceUtil.notificationCounter(context, -1,""NotificationWearActivity notification is null (del action will not be send)"");
else{
//comment
<start>sendRequestDeleteNotification(key, notificationData);
customNotifications.remove(key);
keyMap.remove(key);<end>
}
}"
2853,"private void showTimeSinceLastCharge() {
widgetSettings.reload();
//comment
<start>long lastChargeDate = widgetSettings.get(Constants.PREF_DATE_LAST_CHARGE, 0L);<end>

StringBuilder dateDiff = new StringBuilder("""");
if (lastChargeDate != 0L) {
long diffInMillies = System.currentTimeMillis() - lastChargeDate;
List<TimeUnit> units = new ArrayList<>(EnumSet.allOf(TimeUnit.class));
Collections.reverse(units);
long millisRest = diffInMillies;
for (TimeUnit unit : units) {
long diff = unit.convert(millisRest, TimeUnit.MILLISECONDS);
long diffInMilliesForUnit = unit.toMillis(diff);
millisRest = millisRest - diffInMilliesForUnit;
if (unit.equals(TimeUnit.DAYS) && diff != 0) {
dateDiff.append(diff).append(""d : "");
} else if (unit.equals(TimeUnit.HOURS) && diff != 0) {
dateDiff.append(diff).append(""h : "");
} else if (unit.equals(TimeUnit.MINUTES)) {
dateDiff.append(diff).append(""min"");
break;
}
}
dateDiff.append(""\n"").append(mContext.getResources().getText(R.string.last_charge));
} else dateDiff.append(mContext.getResources().getText(R.string.last_charge_no_info));

final String timeSLC = dateDiff.toString();
Toast.makeText(mContext, timeSLC, Toast.LENGTH_LONG).show();
}","private void showTimeSinceLastCharge() {
widgetSettings.reload();
//comment
<start>long lastChargeDate = widgetSettings.get(Constants.PREF_DATE_LAST_CHARGE, 0L);<end>

StringBuilder dateDiff = new StringBuilder("""");
if (lastChargeDate != 0L) {
long diffInMillies = System.currentTimeMillis() - lastChargeDate;
List<TimeUnit> units = new ArrayList<>(EnumSet.allOf(TimeUnit.class));
Collections.reverse(units);
long millisRest = diffInMillies;
for (TimeUnit unit : units) {
long diff = unit.convert(millisRest, TimeUnit.MILLISECONDS);
long diffInMilliesForUnit = unit.toMillis(diff);
millisRest = millisRest - diffInMilliesForUnit;
if (unit.equals(TimeUnit.DAYS) && diff != 0) {
dateDiff.append(diff).append(""d : "");
} else if (unit.equals(TimeUnit.HOURS) && diff != 0) {
dateDiff.append(diff).append(""h : "");
} else if (unit.equals(TimeUnit.MINUTES)) {
dateDiff.append(diff).append(""min"");
break;
}
}
dateDiff.append(""\n"").append(mContext.getResources().getText(R.string.last_charge));
} else dateDiff.append(mContext.getResources().getText(R.string.last_charge_no_info));

final String timeSLC = dateDiff.toString();
Toast.makeText(mContext, timeSLC, Toast.LENGTH_LONG).show();
}"
2984,"private void showAppInfo(final int itemChosen) {
setButtonTheme(buttonClose, getResources().getString(R.string.close));
setButtonTheme(buttonClear, getResources().getString(R.string.clear_data));
setButtonTheme(buttonUninstall, getResources().getString(R.string.uninstall));
setButtonTheme(buttonQuickLaunch, getResources().getString(R.string.quick_launch));
listView.setGreedyTouchMode(false);

final String pkgName = appInfoList.get(itemChosen).getPackageName();
appChosen = itemChosen;

appIcon.setImageDrawable(appInfoList.get(itemChosen).getIcon());
appName.setText(appInfoList.get(itemChosen).getAppName());
appPackage.setText(pkgName);
appVersion.setText(appInfoList.get(itemChosen).getVersionName());
appSize.setText(appInfoList.get(itemChosen).getSize());

buttonClose.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
Logger.info(""WearAppsFragment showAppInfo buttonClose"");
scrollView.post(new Runnable() {
public void run() {
Logger.debug(""WearAppsFragment showAppInfo scrollToTop"");
//comment
scrollView.scrollTo(0, scrollView.getTop());
}
});
infoView.setVisibility(View.GONE);
wearAppsFrameLayout.setVisibility(View.VISIBLE);
listView.setVisibility(View.VISIBLE);
}
});

buttonUninstall.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
Logger.info(""WearAppsFragment showAppInfo buttonUninstall"");
uninstallPackage(mContext, pkgName);
}
});

buttonClear.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
Logger.info(""WearAppsFragment showAppInfo buttonClear"");
clearPackage(mContext, pkgName);
}
});

//comment
if((isStratos || isStratos3) && quickLaunchApk.contains(pkgName)) {
//comment
<start>buttonQuickLaunch.setVisibility(View.VISIBLE);
buttonQuickLaunch.setOnClickListener(new View.OnClickListener() {<end>
@Override
public void onClick(View v) {
Logger.info(""WearAppsFragment showAppInfo buttonClear"");
quickLaunchPackage(mContext, pkgName);
}
});
}else{
//comment
buttonQuickLaunch.setVisibility(View.GONE);
}

wearAppsFrameLayout.setVisibility(View.GONE);
listView.setVisibility(View.GONE);
infoView.setVisibility(View.VISIBLE);
}","private void showAppInfo(final int itemChosen) {
setButtonTheme(buttonClose, getResources().getString(R.string.close));
setButtonTheme(buttonClear, getResources().getString(R.string.clear_data));
setButtonTheme(buttonUninstall, getResources().getString(R.string.uninstall));
setButtonTheme(buttonQuickLaunch, getResources().getString(R.string.quick_launch));
listView.setGreedyTouchMode(false);

final String pkgName = appInfoList.get(itemChosen).getPackageName();
appChosen = itemChosen;

appIcon.setImageDrawable(appInfoList.get(itemChosen).getIcon());
appName.setText(appInfoList.get(itemChosen).getAppName());
appPackage.setText(pkgName);
appVersion.setText(appInfoList.get(itemChosen).getVersionName());
appSize.setText(appInfoList.get(itemChosen).getSize());

buttonClose.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
Logger.info(""WearAppsFragment showAppInfo buttonClose"");
scrollView.post(new Runnable() {
public void run() {
Logger.debug(""WearAppsFragment showAppInfo scrollToTop"");
//comment
scrollView.scrollTo(0, scrollView.getTop());
}
});
infoView.setVisibility(View.GONE);
wearAppsFrameLayout.setVisibility(View.VISIBLE);
listView.setVisibility(View.VISIBLE);
}
});

buttonUninstall.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
Logger.info(""WearAppsFragment showAppInfo buttonUninstall"");
uninstallPackage(mContext, pkgName);
}
});

buttonClear.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
Logger.info(""WearAppsFragment showAppInfo buttonClear"");
clearPackage(mContext, pkgName);
}
});

//comment
<start>if((isStratos || isStratos3) && quickLaunchApk.contains(pkgName)) {<end>
//comment
buttonQuickLaunch.setVisibility(View.VISIBLE);
buttonQuickLaunch.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
Logger.info(""WearAppsFragment showAppInfo buttonClear"");
quickLaunchPackage(mContext, pkgName);
}
});
}else{
//comment
buttonQuickLaunch.setVisibility(View.GONE);
}

wearAppsFrameLayout.setVisibility(View.GONE);
listView.setVisibility(View.GONE);
infoView.setVisibility(View.VISIBLE);
}"
2985,"private void showAppInfo(final int itemChosen) {
setButtonTheme(buttonClose, getResources().getString(R.string.close));
setButtonTheme(buttonClear, getResources().getString(R.string.clear_data));
setButtonTheme(buttonUninstall, getResources().getString(R.string.uninstall));
setButtonTheme(buttonQuickLaunch, getResources().getString(R.string.quick_launch));
listView.setGreedyTouchMode(false);

final String pkgName = appInfoList.get(itemChosen).getPackageName();
appChosen = itemChosen;

appIcon.setImageDrawable(appInfoList.get(itemChosen).getIcon());
appName.setText(appInfoList.get(itemChosen).getAppName());
appPackage.setText(pkgName);
appVersion.setText(appInfoList.get(itemChosen).getVersionName());
appSize.setText(appInfoList.get(itemChosen).getSize());

buttonClose.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
Logger.info(""WearAppsFragment showAppInfo buttonClose"");
scrollView.post(new Runnable() {
public void run() {
Logger.debug(""WearAppsFragment showAppInfo scrollToTop"");
//comment
scrollView.scrollTo(0, scrollView.getTop());
}
});
infoView.setVisibility(View.GONE);
wearAppsFrameLayout.setVisibility(View.VISIBLE);
listView.setVisibility(View.VISIBLE);
}
});

buttonUninstall.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
Logger.info(""WearAppsFragment showAppInfo buttonUninstall"");
uninstallPackage(mContext, pkgName);
}
});

buttonClear.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
Logger.info(""WearAppsFragment showAppInfo buttonClear"");
clearPackage(mContext, pkgName);
}
});

//comment
if((isStratos || isStratos3) && quickLaunchApk.contains(pkgName)) {
//comment
<start>buttonQuickLaunch.setVisibility(View.VISIBLE);
buttonQuickLaunch.setOnClickListener(new View.OnClickListener() {<end>
@Override
public void onClick(View v) {
Logger.info(""WearAppsFragment showAppInfo buttonClear"");
quickLaunchPackage(mContext, pkgName);
}
});
}else{
//comment
buttonQuickLaunch.setVisibility(View.GONE);
}

wearAppsFrameLayout.setVisibility(View.GONE);
listView.setVisibility(View.GONE);
infoView.setVisibility(View.VISIBLE);
}","private void showAppInfo(final int itemChosen) {
setButtonTheme(buttonClose, getResources().getString(R.string.close));
setButtonTheme(buttonClear, getResources().getString(R.string.clear_data));
setButtonTheme(buttonUninstall, getResources().getString(R.string.uninstall));
setButtonTheme(buttonQuickLaunch, getResources().getString(R.string.quick_launch));
listView.setGreedyTouchMode(false);

final String pkgName = appInfoList.get(itemChosen).getPackageName();
appChosen = itemChosen;

appIcon.setImageDrawable(appInfoList.get(itemChosen).getIcon());
appName.setText(appInfoList.get(itemChosen).getAppName());
appPackage.setText(pkgName);
appVersion.setText(appInfoList.get(itemChosen).getVersionName());
appSize.setText(appInfoList.get(itemChosen).getSize());

buttonClose.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
Logger.info(""WearAppsFragment showAppInfo buttonClose"");
scrollView.post(new Runnable() {
public void run() {
Logger.debug(""WearAppsFragment showAppInfo scrollToTop"");
//comment
scrollView.scrollTo(0, scrollView.getTop());
}
});
infoView.setVisibility(View.GONE);
wearAppsFrameLayout.setVisibility(View.VISIBLE);
listView.setVisibility(View.VISIBLE);
}
});

buttonUninstall.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
Logger.info(""WearAppsFragment showAppInfo buttonUninstall"");
uninstallPackage(mContext, pkgName);
}
});

buttonClear.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
Logger.info(""WearAppsFragment showAppInfo buttonClear"");
clearPackage(mContext, pkgName);
}
});

//comment
if((isStratos || isStratos3) && quickLaunchApk.contains(pkgName)) {
//comment
<start>buttonQuickLaunch.setVisibility(View.VISIBLE);
buttonQuickLaunch.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
Logger.info(""WearAppsFragment showAppInfo buttonClear"");
quickLaunchPackage(mContext, pkgName);
}
});<end>
}else{
//comment
buttonQuickLaunch.setVisibility(View.GONE);
}

wearAppsFrameLayout.setVisibility(View.GONE);
listView.setVisibility(View.GONE);
infoView.setVisibility(View.VISIBLE);
}"
2986,"private void showAppInfo(final int itemChosen) {
setButtonTheme(buttonClose, getResources().getString(R.string.close));
setButtonTheme(buttonClear, getResources().getString(R.string.clear_data));
setButtonTheme(buttonUninstall, getResources().getString(R.string.uninstall));
setButtonTheme(buttonQuickLaunch, getResources().getString(R.string.quick_launch));
listView.setGreedyTouchMode(false);

final String pkgName = appInfoList.get(itemChosen).getPackageName();
appChosen = itemChosen;

appIcon.setImageDrawable(appInfoList.get(itemChosen).getIcon());
appName.setText(appInfoList.get(itemChosen).getAppName());
appPackage.setText(pkgName);
appVersion.setText(appInfoList.get(itemChosen).getVersionName());
appSize.setText(appInfoList.get(itemChosen).getSize());

buttonClose.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
Logger.info(""WearAppsFragment showAppInfo buttonClose"");
scrollView.post(new Runnable() {
public void run() {
Logger.debug(""WearAppsFragment showAppInfo scrollToTop"");
//comment
scrollView.scrollTo(0, scrollView.getTop());
}
});
infoView.setVisibility(View.GONE);
wearAppsFrameLayout.setVisibility(View.VISIBLE);
listView.setVisibility(View.VISIBLE);
}
});

buttonUninstall.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
Logger.info(""WearAppsFragment showAppInfo buttonUninstall"");
uninstallPackage(mContext, pkgName);
}
});

buttonClear.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
Logger.info(""WearAppsFragment showAppInfo buttonClear"");
clearPackage(mContext, pkgName);
}
});

//comment
if((isStratos || isStratos3) && quickLaunchApk.contains(pkgName)) {
//comment
buttonQuickLaunch.setVisibility(View.VISIBLE);
buttonQuickLaunch.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
Logger.info(""WearAppsFragment showAppInfo buttonClear"");
quickLaunchPackage(mContext, pkgName);
}
});
}else{
//comment
<start>buttonQuickLaunch.setVisibility(View.GONE);<end>
}

wearAppsFrameLayout.setVisibility(View.GONE);
listView.setVisibility(View.GONE);
infoView.setVisibility(View.VISIBLE);
}","private void showAppInfo(final int itemChosen) {
setButtonTheme(buttonClose, getResources().getString(R.string.close));
setButtonTheme(buttonClear, getResources().getString(R.string.clear_data));
setButtonTheme(buttonUninstall, getResources().getString(R.string.uninstall));
setButtonTheme(buttonQuickLaunch, getResources().getString(R.string.quick_launch));
listView.setGreedyTouchMode(false);

final String pkgName = appInfoList.get(itemChosen).getPackageName();
appChosen = itemChosen;

appIcon.setImageDrawable(appInfoList.get(itemChosen).getIcon());
appName.setText(appInfoList.get(itemChosen).getAppName());
appPackage.setText(pkgName);
appVersion.setText(appInfoList.get(itemChosen).getVersionName());
appSize.setText(appInfoList.get(itemChosen).getSize());

buttonClose.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
Logger.info(""WearAppsFragment showAppInfo buttonClose"");
scrollView.post(new Runnable() {
public void run() {
Logger.debug(""WearAppsFragment showAppInfo scrollToTop"");
//comment
scrollView.scrollTo(0, scrollView.getTop());
}
});
infoView.setVisibility(View.GONE);
wearAppsFrameLayout.setVisibility(View.VISIBLE);
listView.setVisibility(View.VISIBLE);
}
});

buttonUninstall.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
Logger.info(""WearAppsFragment showAppInfo buttonUninstall"");
uninstallPackage(mContext, pkgName);
}
});

buttonClear.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
Logger.info(""WearAppsFragment showAppInfo buttonClear"");
clearPackage(mContext, pkgName);
}
});

//comment
if((isStratos || isStratos3) && quickLaunchApk.contains(pkgName)) {
//comment
buttonQuickLaunch.setVisibility(View.VISIBLE);
buttonQuickLaunch.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
Logger.info(""WearAppsFragment showAppInfo buttonClear"");
quickLaunchPackage(mContext, pkgName);
}
});
}else{
//comment
<start>buttonQuickLaunch.setVisibility(View.GONE);<end>
}

wearAppsFrameLayout.setVisibility(View.GONE);
listView.setVisibility(View.GONE);
infoView.setVisibility(View.VISIBLE);
}"
2987,"public void uninstallPackage(Context context, String packageName) {

Logger.info(""WearAppsFragment uninstallPackage packageName: "" + packageName);

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

//comment
<start>if (packageName.equals(""com.amazmod.service""))
isAmazModUninstall = true;<end>

Intent intent = new Intent(Intent.ACTION_UNINSTALL_PACKAGE);
intent.setData(Uri.parse(""package:"" + packageName));
intent.putExtra(Intent.EXTRA_RETURN_RESULT, true);
startActivityForResult(intent, UNINSTALL_REQUEST_CODE);
}","public void uninstallPackage(Context context, String packageName) {

Logger.info(""WearAppsFragment uninstallPackage packageName: "" + packageName);

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

//comment
<start>if (packageName.equals(""com.amazmod.service""))
isAmazModUninstall = true;<end>

Intent intent = new Intent(Intent.ACTION_UNINSTALL_PACKAGE);
intent.setData(Uri.parse(""package:"" + packageName));
intent.putExtra(Intent.EXTRA_RETURN_RESULT, true);
startActivityForResult(intent, UNINSTALL_REQUEST_CODE);
}"
2988,"    public void quickLaunchPackage(Context context, String packageName) {
Logger.info(""WearAppsFragment quickLaunchPackage packageName: "" + packageName);
//comment
<start>int pos = quickLaunchApk.indexOf(packageName);<end>
//comment
final String command = quickLaunchCommands.get(pos);

new AlertDialog.Builder(getActivity())
.setTitle(getResources().getString(R.string.quick_launch))
.setMessage(getResources().getString(R.string.confirmation))
.setPositiveButton(android.R.string.yes, new DialogInterface.OnClickListener() {
public void onClick(DialogInterface dialog, int whichButton) {
//comment
Settings.System.putString(context.getContentResolver(), LONG_KEY_SETTINGS, command);
Toast.makeText(mContext, mContext.getResources().getString(R.string.quick_launch_description), Toast.LENGTH_SHORT).show();
}})
.setNegativeButton(android.R.string.no, null).show();
}","    public void quickLaunchPackage(Context context, String packageName) {
Logger.info(""WearAppsFragment quickLaunchPackage packageName: "" + packageName);
//comment
<start>int pos = quickLaunchApk.indexOf(packageName);<end>
//comment
final String command = quickLaunchCommands.get(pos);

new AlertDialog.Builder(getActivity())
.setTitle(getResources().getString(R.string.quick_launch))
.setMessage(getResources().getString(R.string.confirmation))
.setPositiveButton(android.R.string.yes, new DialogInterface.OnClickListener() {
public void onClick(DialogInterface dialog, int whichButton) {
//comment
Settings.System.putString(context.getContentResolver(), LONG_KEY_SETTINGS, command);
Toast.makeText(mContext, mContext.getResources().getString(R.string.quick_launch_description), Toast.LENGTH_SHORT).show();
}})
.setNegativeButton(android.R.string.no, null).show();
}"
2989,"    public void quickLaunchPackage(Context context, String packageName) {
Logger.info(""WearAppsFragment quickLaunchPackage packageName: "" + packageName);
//comment
int pos = quickLaunchApk.indexOf(packageName);
//comment
<start>final String command = quickLaunchCommands.get(pos);<end>

new AlertDialog.Builder(getActivity())
.setTitle(getResources().getString(R.string.quick_launch))
.setMessage(getResources().getString(R.string.confirmation))
.setPositiveButton(android.R.string.yes, new DialogInterface.OnClickListener() {
public void onClick(DialogInterface dialog, int whichButton) {
//comment
Settings.System.putString(context.getContentResolver(), LONG_KEY_SETTINGS, command);
Toast.makeText(mContext, mContext.getResources().getString(R.string.quick_launch_description), Toast.LENGTH_SHORT).show();
}})
.setNegativeButton(android.R.string.no, null).show();
}","    public void quickLaunchPackage(Context context, String packageName) {
Logger.info(""WearAppsFragment quickLaunchPackage packageName: "" + packageName);
//comment
int pos = quickLaunchApk.indexOf(packageName);
//comment
<start>final String command = quickLaunchCommands.get(pos);<end>

new AlertDialog.Builder(getActivity())
.setTitle(getResources().getString(R.string.quick_launch))
.setMessage(getResources().getString(R.string.confirmation))
.setPositiveButton(android.R.string.yes, new DialogInterface.OnClickListener() {
public void onClick(DialogInterface dialog, int whichButton) {
//comment
Settings.System.putString(context.getContentResolver(), LONG_KEY_SETTINGS, command);
Toast.makeText(mContext, mContext.getResources().getString(R.string.quick_launch_description), Toast.LENGTH_SHORT).show();
}})
.setNegativeButton(android.R.string.no, null).show();
}"
6824,"@Override
public void onListenerConnected() {
super.onListenerConnected();
Logger.debug(""onListenerConnected"");

startPersistentNotification();

//comment
<start>cancelPendingJobs(0);<end>
scheduleJob(0, 0, null);
}","@Override
public void onListenerConnected() {
super.onListenerConnected();
Logger.debug(""onListenerConnected"");

startPersistentNotification();

//comment
<start>cancelPendingJobs(0);
scheduleJob(0, 0, null);<end>
}"
6825,"@Override
public void onNotificationPosted(StatusBarNotification statusBarNotification) {

String notificationPackage = statusBarNotification.getPackageName();

String notificationTxt = """";
CharSequence charSequence = statusBarNotification.getNotification().extras.getCharSequence(Notification.EXTRA_TEXT);
if (charSequence != null) {
notificationTxt = charSequence.toString();
}

if (!isPackageAllowed(notificationPackage)) {
//comment
Logger.debug(""[Notification Blocked] Notifications from {} are blocked."", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_PACKAGE);
return;
}else if (isPackageSilenced(notificationPackage)) {
//comment
Logger.debug(""[Notification Blocked] Notifications from {} are currently silenced."",notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_SILENCE);
return;
}else if (isPackageFiltered(statusBarNotification)) {
//comment
Logger.debug(""[Notification Blocked] Notifications from {} was blocked because of content filters."", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_TEXT);
return;
}else if (isNotificationsDisabled()) {
Logger.debug(""[Notification Blocked] All notifications are disabled (disabled, DND, Driving etc). {}"", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_NOTIFICATIONS_DISABLED);
return;
}else if (isNotificationsDisabledWhenScreenOn()) {
if (!Screen.isDeviceLocked(this)) {
Logger.debug(""[Notification Blocked] Device is unlocked. {}"", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_SCREENON);
return;
} else if (!isNotificationsEnabledWhenScreenLocked()) {
Logger.debug(""[Notification Blocked] Device is in lock-screen. {}"", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_SCREENLOCKED);
return;
}
}

Logger.debug(""[New Notification] Notification is posted: "" + statusBarNotification.getKey());

byte filterResult = filter(statusBarNotification);

Logger.debug(""[New Notification] pkg: {}, filterResult: {}"", notificationPackage, ((char) (byte) filterResult));

//comment
if (filterResult == Constants.FILTER_CONTINUE || filterResult == Constants.FILTER_UNGROUP || filterResult == Constants.FILTER_LOCALOK) {

StatusBarNotification sbn = null;

//comment
if (filterResult == Constants.FILTER_UNGROUP && Prefs.getBoolean(Constants.PREF_NOTIFICATIONS_ENABLE_UNGROUP, false)) {
//comment
int nextId = statusBarNotification.getId() + newUID();
sbn = new StatusBarNotification(notificationPackage, """", nextId,
statusBarNotification.getTag(), 0, 0, 0,
statusBarNotification.getNotification(), statusBarNotification.getUser(),
statusBarNotification.getPostTime());

if (grouped_notifications.containsKey(statusBarNotification.getId())) {
//comment
//comment
int[] grouped = grouped_notifications.get(statusBarNotification.getId());
//comment
if (grouped != null) {
int[] newArray = new int[grouped.length + 1];
//comment
System.arraycopy(grouped, 0, newArray, 0, grouped.length);
newArray[newArray.length - 1] = nextId;
grouped_notifications.put(statusBarNotification.getId(), newArray);
//comment
} else
Logger.error(""grouped: could not create array"");
} else {
//comment
//comment
grouped_notifications.put(statusBarNotification.getId(), new int[]{nextId});
}
}

if (sbn == null)
sbn = statusBarNotification;

//comment
if (isCustomUIEnabled())
sendNotificationWithCustomUI(filterResult, sbn);
else
sendNotificationWithStandardUI(filterResult, sbn);

//comment
storeForStats(notificationPackage, filterResult);

} else {
if (isRingingNotification(filterResult, notificationPackage)) {
Logger.debug(""[Ringing Notification] New notifications is a ringing notification: "" + ((char) (byte) filterResult));
handleCall(statusBarNotification, notificationPackage);

} else if (isMapsNotification(filterResult, notificationPackage)) {
Logger.debug(""[Maps Notification] New notifications is a MapsNotification: "" + ((char) (byte) filterResult));
mapNotification(statusBarNotification);

} else {
Logger.debug(""[New Notification] New notifications is blocked. (pkg: {}, marked as: {})"",notificationPackage, ((char) (byte) filterResult));
checkAndLog(notificationPackage, notificationTxt, filterResult);
}
}
}","@Override
public void onNotificationPosted(StatusBarNotification statusBarNotification) {

String notificationPackage = statusBarNotification.getPackageName();

String notificationTxt = """";
CharSequence charSequence = statusBarNotification.getNotification().extras.getCharSequence(Notification.EXTRA_TEXT);
if (charSequence != null) {
notificationTxt = charSequence.toString();
}

if (!isPackageAllowed(notificationPackage)) {
//comment
Logger.debug(""[Notification Blocked] Notifications from {} are blocked."", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_PACKAGE);
return;
}else if (isPackageSilenced(notificationPackage)) {
//comment
Logger.debug(""[Notification Blocked] Notifications from {} are currently silenced."",notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_SILENCE);
return;
}else if (isPackageFiltered(statusBarNotification)) {
//comment
Logger.debug(""[Notification Blocked] Notifications from {} was blocked because of content filters."", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_TEXT);
return;
}else if (isNotificationsDisabled()) {
Logger.debug(""[Notification Blocked] All notifications are disabled (disabled, DND, Driving etc). {}"", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_NOTIFICATIONS_DISABLED);
return;
}else if (isNotificationsDisabledWhenScreenOn()) {
if (!Screen.isDeviceLocked(this)) {
Logger.debug(""[Notification Blocked] Device is unlocked. {}"", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_SCREENON);
return;
} else if (!isNotificationsEnabledWhenScreenLocked()) {
Logger.debug(""[Notification Blocked] Device is in lock-screen. {}"", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_SCREENLOCKED);
return;
}
}

Logger.debug(""[New Notification] Notification is posted: "" + statusBarNotification.getKey());

byte filterResult = filter(statusBarNotification);

Logger.debug(""[New Notification] pkg: {}, filterResult: {}"", notificationPackage, ((char) (byte) filterResult));

//comment
if (filterResult == Constants.FILTER_CONTINUE || filterResult == Constants.FILTER_UNGROUP || filterResult == Constants.FILTER_LOCALOK) {

StatusBarNotification sbn = null;

//comment
<start>if (filterResult == Constants.FILTER_UNGROUP && Prefs.getBoolean(Constants.PREF_NOTIFICATIONS_ENABLE_UNGROUP, false)) {<end>
//comment
int nextId = statusBarNotification.getId() + newUID();
sbn = new StatusBarNotification(notificationPackage, """", nextId,
statusBarNotification.getTag(), 0, 0, 0,
statusBarNotification.getNotification(), statusBarNotification.getUser(),
statusBarNotification.getPostTime());

if (grouped_notifications.containsKey(statusBarNotification.getId())) {
//comment
//comment
int[] grouped = grouped_notifications.get(statusBarNotification.getId());
//comment
if (grouped != null) {
int[] newArray = new int[grouped.length + 1];
//comment
System.arraycopy(grouped, 0, newArray, 0, grouped.length);
newArray[newArray.length - 1] = nextId;
grouped_notifications.put(statusBarNotification.getId(), newArray);
//comment
} else
Logger.error(""grouped: could not create array"");
} else {
//comment
//comment
grouped_notifications.put(statusBarNotification.getId(), new int[]{nextId});
}
}

if (sbn == null)
sbn = statusBarNotification;

//comment
if (isCustomUIEnabled())
sendNotificationWithCustomUI(filterResult, sbn);
else
sendNotificationWithStandardUI(filterResult, sbn);

//comment
storeForStats(notificationPackage, filterResult);

} else {
if (isRingingNotification(filterResult, notificationPackage)) {
Logger.debug(""[Ringing Notification] New notifications is a ringing notification: "" + ((char) (byte) filterResult));
handleCall(statusBarNotification, notificationPackage);

} else if (isMapsNotification(filterResult, notificationPackage)) {
Logger.debug(""[Maps Notification] New notifications is a MapsNotification: "" + ((char) (byte) filterResult));
mapNotification(statusBarNotification);

} else {
Logger.debug(""[New Notification] New notifications is blocked. (pkg: {}, marked as: {})"",notificationPackage, ((char) (byte) filterResult));
checkAndLog(notificationPackage, notificationTxt, filterResult);
}
}
}"
6826,"@Override
public void onNotificationPosted(StatusBarNotification statusBarNotification) {

String notificationPackage = statusBarNotification.getPackageName();

String notificationTxt = """";
CharSequence charSequence = statusBarNotification.getNotification().extras.getCharSequence(Notification.EXTRA_TEXT);
if (charSequence != null) {
notificationTxt = charSequence.toString();
}

if (!isPackageAllowed(notificationPackage)) {
//comment
Logger.debug(""[Notification Blocked] Notifications from {} are blocked."", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_PACKAGE);
return;
}else if (isPackageSilenced(notificationPackage)) {
//comment
Logger.debug(""[Notification Blocked] Notifications from {} are currently silenced."",notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_SILENCE);
return;
}else if (isPackageFiltered(statusBarNotification)) {
//comment
Logger.debug(""[Notification Blocked] Notifications from {} was blocked because of content filters."", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_TEXT);
return;
}else if (isNotificationsDisabled()) {
Logger.debug(""[Notification Blocked] All notifications are disabled (disabled, DND, Driving etc). {}"", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_NOTIFICATIONS_DISABLED);
return;
}else if (isNotificationsDisabledWhenScreenOn()) {
if (!Screen.isDeviceLocked(this)) {
Logger.debug(""[Notification Blocked] Device is unlocked. {}"", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_SCREENON);
return;
} else if (!isNotificationsEnabledWhenScreenLocked()) {
Logger.debug(""[Notification Blocked] Device is in lock-screen. {}"", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_SCREENLOCKED);
return;
}
}

Logger.debug(""[New Notification] Notification is posted: "" + statusBarNotification.getKey());

byte filterResult = filter(statusBarNotification);

Logger.debug(""[New Notification] pkg: {}, filterResult: {}"", notificationPackage, ((char) (byte) filterResult));

//comment
if (filterResult == Constants.FILTER_CONTINUE || filterResult == Constants.FILTER_UNGROUP || filterResult == Constants.FILTER_LOCALOK) {

StatusBarNotification sbn = null;

//comment
if (filterResult == Constants.FILTER_UNGROUP && Prefs.getBoolean(Constants.PREF_NOTIFICATIONS_ENABLE_UNGROUP, false)) {
//comment
int nextId = statusBarNotification.getId() + newUID();
sbn = new StatusBarNotification(notificationPackage, """", nextId,
statusBarNotification.getTag(), 0, 0, 0,
statusBarNotification.getNotification(), statusBarNotification.getUser(),
statusBarNotification.getPostTime());

if (grouped_notifications.containsKey(statusBarNotification.getId())) {
//comment
//comment
<start>int[] grouped = grouped_notifications.get(statusBarNotification.getId());
//comment
if (grouped != null) {
int[] newArray = new int[grouped.length + 1];
//comment
System.arraycopy(grouped, 0, newArray, 0, grouped.length);
newArray[newArray.length - 1] = nextId;
grouped_notifications.put(statusBarNotification.getId(), newArray);
//comment
} else
Logger.error(""grouped: could not create array"");<end>
} else {
//comment
//comment
grouped_notifications.put(statusBarNotification.getId(), new int[]{nextId});
}
}

if (sbn == null)
sbn = statusBarNotification;

//comment
if (isCustomUIEnabled())
sendNotificationWithCustomUI(filterResult, sbn);
else
sendNotificationWithStandardUI(filterResult, sbn);

//comment
storeForStats(notificationPackage, filterResult);

} else {
if (isRingingNotification(filterResult, notificationPackage)) {
Logger.debug(""[Ringing Notification] New notifications is a ringing notification: "" + ((char) (byte) filterResult));
handleCall(statusBarNotification, notificationPackage);

} else if (isMapsNotification(filterResult, notificationPackage)) {
Logger.debug(""[Maps Notification] New notifications is a MapsNotification: "" + ((char) (byte) filterResult));
mapNotification(statusBarNotification);

} else {
Logger.debug(""[New Notification] New notifications is blocked. (pkg: {}, marked as: {})"",notificationPackage, ((char) (byte) filterResult));
checkAndLog(notificationPackage, notificationTxt, filterResult);
}
}
}","@Override
public void onNotificationPosted(StatusBarNotification statusBarNotification) {

String notificationPackage = statusBarNotification.getPackageName();

String notificationTxt = """";
CharSequence charSequence = statusBarNotification.getNotification().extras.getCharSequence(Notification.EXTRA_TEXT);
if (charSequence != null) {
notificationTxt = charSequence.toString();
}

if (!isPackageAllowed(notificationPackage)) {
//comment
Logger.debug(""[Notification Blocked] Notifications from {} are blocked."", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_PACKAGE);
return;
}else if (isPackageSilenced(notificationPackage)) {
//comment
Logger.debug(""[Notification Blocked] Notifications from {} are currently silenced."",notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_SILENCE);
return;
}else if (isPackageFiltered(statusBarNotification)) {
//comment
Logger.debug(""[Notification Blocked] Notifications from {} was blocked because of content filters."", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_TEXT);
return;
}else if (isNotificationsDisabled()) {
Logger.debug(""[Notification Blocked] All notifications are disabled (disabled, DND, Driving etc). {}"", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_NOTIFICATIONS_DISABLED);
return;
}else if (isNotificationsDisabledWhenScreenOn()) {
if (!Screen.isDeviceLocked(this)) {
Logger.debug(""[Notification Blocked] Device is unlocked. {}"", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_SCREENON);
return;
} else if (!isNotificationsEnabledWhenScreenLocked()) {
Logger.debug(""[Notification Blocked] Device is in lock-screen. {}"", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_SCREENLOCKED);
return;
}
}

Logger.debug(""[New Notification] Notification is posted: "" + statusBarNotification.getKey());

byte filterResult = filter(statusBarNotification);

Logger.debug(""[New Notification] pkg: {}, filterResult: {}"", notificationPackage, ((char) (byte) filterResult));

//comment
if (filterResult == Constants.FILTER_CONTINUE || filterResult == Constants.FILTER_UNGROUP || filterResult == Constants.FILTER_LOCALOK) {

StatusBarNotification sbn = null;

//comment
if (filterResult == Constants.FILTER_UNGROUP && Prefs.getBoolean(Constants.PREF_NOTIFICATIONS_ENABLE_UNGROUP, false)) {
//comment
int nextId = statusBarNotification.getId() + newUID();
sbn = new StatusBarNotification(notificationPackage, """", nextId,
statusBarNotification.getTag(), 0, 0, 0,
statusBarNotification.getNotification(), statusBarNotification.getUser(),
statusBarNotification.getPostTime());

if (grouped_notifications.containsKey(statusBarNotification.getId())) {
//comment
//comment
<start>int[] grouped = grouped_notifications.get(statusBarNotification.getId());<end>
//comment
if (grouped != null) {
int[] newArray = new int[grouped.length + 1];
//comment
System.arraycopy(grouped, 0, newArray, 0, grouped.length);
newArray[newArray.length - 1] = nextId;
grouped_notifications.put(statusBarNotification.getId(), newArray);
//comment
} else
Logger.error(""grouped: could not create array"");
} else {
//comment
//comment
grouped_notifications.put(statusBarNotification.getId(), new int[]{nextId});
}
}

if (sbn == null)
sbn = statusBarNotification;

//comment
if (isCustomUIEnabled())
sendNotificationWithCustomUI(filterResult, sbn);
else
sendNotificationWithStandardUI(filterResult, sbn);

//comment
storeForStats(notificationPackage, filterResult);

} else {
if (isRingingNotification(filterResult, notificationPackage)) {
Logger.debug(""[Ringing Notification] New notifications is a ringing notification: "" + ((char) (byte) filterResult));
handleCall(statusBarNotification, notificationPackage);

} else if (isMapsNotification(filterResult, notificationPackage)) {
Logger.debug(""[Maps Notification] New notifications is a MapsNotification: "" + ((char) (byte) filterResult));
mapNotification(statusBarNotification);

} else {
Logger.debug(""[New Notification] New notifications is blocked. (pkg: {}, marked as: {})"",notificationPackage, ((char) (byte) filterResult));
checkAndLog(notificationPackage, notificationTxt, filterResult);
}
}
}"
6827,"@Override
public void onNotificationPosted(StatusBarNotification statusBarNotification) {

String notificationPackage = statusBarNotification.getPackageName();

String notificationTxt = """";
CharSequence charSequence = statusBarNotification.getNotification().extras.getCharSequence(Notification.EXTRA_TEXT);
if (charSequence != null) {
notificationTxt = charSequence.toString();
}

if (!isPackageAllowed(notificationPackage)) {
//comment
Logger.debug(""[Notification Blocked] Notifications from {} are blocked."", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_PACKAGE);
return;
}else if (isPackageSilenced(notificationPackage)) {
//comment
Logger.debug(""[Notification Blocked] Notifications from {} are currently silenced."",notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_SILENCE);
return;
}else if (isPackageFiltered(statusBarNotification)) {
//comment
Logger.debug(""[Notification Blocked] Notifications from {} was blocked because of content filters."", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_TEXT);
return;
}else if (isNotificationsDisabled()) {
Logger.debug(""[Notification Blocked] All notifications are disabled (disabled, DND, Driving etc). {}"", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_NOTIFICATIONS_DISABLED);
return;
}else if (isNotificationsDisabledWhenScreenOn()) {
if (!Screen.isDeviceLocked(this)) {
Logger.debug(""[Notification Blocked] Device is unlocked. {}"", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_SCREENON);
return;
} else if (!isNotificationsEnabledWhenScreenLocked()) {
Logger.debug(""[Notification Blocked] Device is in lock-screen. {}"", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_SCREENLOCKED);
return;
}
}

Logger.debug(""[New Notification] Notification is posted: "" + statusBarNotification.getKey());

byte filterResult = filter(statusBarNotification);

Logger.debug(""[New Notification] pkg: {}, filterResult: {}"", notificationPackage, ((char) (byte) filterResult));

//comment
if (filterResult == Constants.FILTER_CONTINUE || filterResult == Constants.FILTER_UNGROUP || filterResult == Constants.FILTER_LOCALOK) {

StatusBarNotification sbn = null;

//comment
if (filterResult == Constants.FILTER_UNGROUP && Prefs.getBoolean(Constants.PREF_NOTIFICATIONS_ENABLE_UNGROUP, false)) {
//comment
int nextId = statusBarNotification.getId() + newUID();
sbn = new StatusBarNotification(notificationPackage, """", nextId,
statusBarNotification.getTag(), 0, 0, 0,
statusBarNotification.getNotification(), statusBarNotification.getUser(),
statusBarNotification.getPostTime());

if (grouped_notifications.containsKey(statusBarNotification.getId())) {
//comment
//comment
int[] grouped = grouped_notifications.get(statusBarNotification.getId());
//comment
if (grouped != null) {
<start>int[] newArray = new int[grouped.length + 1];
//comment
System.arraycopy(grouped, 0, newArray, 0, grouped.length);
newArray[newArray.length - 1] = nextId;<end>
grouped_notifications.put(statusBarNotification.getId(), newArray);
//comment
} else
Logger.error(""grouped: could not create array"");
} else {
//comment
//comment
grouped_notifications.put(statusBarNotification.getId(), new int[]{nextId});
}
}

if (sbn == null)
sbn = statusBarNotification;

//comment
if (isCustomUIEnabled())
sendNotificationWithCustomUI(filterResult, sbn);
else
sendNotificationWithStandardUI(filterResult, sbn);

//comment
storeForStats(notificationPackage, filterResult);

} else {
if (isRingingNotification(filterResult, notificationPackage)) {
Logger.debug(""[Ringing Notification] New notifications is a ringing notification: "" + ((char) (byte) filterResult));
handleCall(statusBarNotification, notificationPackage);

} else if (isMapsNotification(filterResult, notificationPackage)) {
Logger.debug(""[Maps Notification] New notifications is a MapsNotification: "" + ((char) (byte) filterResult));
mapNotification(statusBarNotification);

} else {
Logger.debug(""[New Notification] New notifications is blocked. (pkg: {}, marked as: {})"",notificationPackage, ((char) (byte) filterResult));
checkAndLog(notificationPackage, notificationTxt, filterResult);
}
}
}","@Override
public void onNotificationPosted(StatusBarNotification statusBarNotification) {

String notificationPackage = statusBarNotification.getPackageName();

String notificationTxt = """";
CharSequence charSequence = statusBarNotification.getNotification().extras.getCharSequence(Notification.EXTRA_TEXT);
if (charSequence != null) {
notificationTxt = charSequence.toString();
}

if (!isPackageAllowed(notificationPackage)) {
//comment
Logger.debug(""[Notification Blocked] Notifications from {} are blocked."", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_PACKAGE);
return;
}else if (isPackageSilenced(notificationPackage)) {
//comment
Logger.debug(""[Notification Blocked] Notifications from {} are currently silenced."",notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_SILENCE);
return;
}else if (isPackageFiltered(statusBarNotification)) {
//comment
Logger.debug(""[Notification Blocked] Notifications from {} was blocked because of content filters."", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_TEXT);
return;
}else if (isNotificationsDisabled()) {
Logger.debug(""[Notification Blocked] All notifications are disabled (disabled, DND, Driving etc). {}"", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_NOTIFICATIONS_DISABLED);
return;
}else if (isNotificationsDisabledWhenScreenOn()) {
if (!Screen.isDeviceLocked(this)) {
Logger.debug(""[Notification Blocked] Device is unlocked. {}"", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_SCREENON);
return;
} else if (!isNotificationsEnabledWhenScreenLocked()) {
Logger.debug(""[Notification Blocked] Device is in lock-screen. {}"", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_SCREENLOCKED);
return;
}
}

Logger.debug(""[New Notification] Notification is posted: "" + statusBarNotification.getKey());

byte filterResult = filter(statusBarNotification);

Logger.debug(""[New Notification] pkg: {}, filterResult: {}"", notificationPackage, ((char) (byte) filterResult));

//comment
if (filterResult == Constants.FILTER_CONTINUE || filterResult == Constants.FILTER_UNGROUP || filterResult == Constants.FILTER_LOCALOK) {

StatusBarNotification sbn = null;

//comment
if (filterResult == Constants.FILTER_UNGROUP && Prefs.getBoolean(Constants.PREF_NOTIFICATIONS_ENABLE_UNGROUP, false)) {
//comment
int nextId = statusBarNotification.getId() + newUID();
sbn = new StatusBarNotification(notificationPackage, """", nextId,
statusBarNotification.getTag(), 0, 0, 0,
statusBarNotification.getNotification(), statusBarNotification.getUser(),
statusBarNotification.getPostTime());

if (grouped_notifications.containsKey(statusBarNotification.getId())) {
//comment
//comment
int[] grouped = grouped_notifications.get(statusBarNotification.getId());
//comment
if (grouped != null) {
<start>int[] newArray = new int[grouped.length + 1];<end>
//comment
System.arraycopy(grouped, 0, newArray, 0, grouped.length);
newArray[newArray.length - 1] = nextId;
grouped_notifications.put(statusBarNotification.getId(), newArray);
//comment
} else
Logger.error(""grouped: could not create array"");
} else {
//comment
//comment
grouped_notifications.put(statusBarNotification.getId(), new int[]{nextId});
}
}

if (sbn == null)
sbn = statusBarNotification;

//comment
if (isCustomUIEnabled())
sendNotificationWithCustomUI(filterResult, sbn);
else
sendNotificationWithStandardUI(filterResult, sbn);

//comment
storeForStats(notificationPackage, filterResult);

} else {
if (isRingingNotification(filterResult, notificationPackage)) {
Logger.debug(""[Ringing Notification] New notifications is a ringing notification: "" + ((char) (byte) filterResult));
handleCall(statusBarNotification, notificationPackage);

} else if (isMapsNotification(filterResult, notificationPackage)) {
Logger.debug(""[Maps Notification] New notifications is a MapsNotification: "" + ((char) (byte) filterResult));
mapNotification(statusBarNotification);

} else {
Logger.debug(""[New Notification] New notifications is blocked. (pkg: {}, marked as: {})"",notificationPackage, ((char) (byte) filterResult));
checkAndLog(notificationPackage, notificationTxt, filterResult);
}
}
}"
6828,"@Override
public void onNotificationPosted(StatusBarNotification statusBarNotification) {

String notificationPackage = statusBarNotification.getPackageName();

String notificationTxt = """";
CharSequence charSequence = statusBarNotification.getNotification().extras.getCharSequence(Notification.EXTRA_TEXT);
if (charSequence != null) {
notificationTxt = charSequence.toString();
}

if (!isPackageAllowed(notificationPackage)) {
//comment
Logger.debug(""[Notification Blocked] Notifications from {} are blocked."", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_PACKAGE);
return;
}else if (isPackageSilenced(notificationPackage)) {
//comment
Logger.debug(""[Notification Blocked] Notifications from {} are currently silenced."",notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_SILENCE);
return;
}else if (isPackageFiltered(statusBarNotification)) {
//comment
Logger.debug(""[Notification Blocked] Notifications from {} was blocked because of content filters."", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_TEXT);
return;
}else if (isNotificationsDisabled()) {
Logger.debug(""[Notification Blocked] All notifications are disabled (disabled, DND, Driving etc). {}"", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_NOTIFICATIONS_DISABLED);
return;
}else if (isNotificationsDisabledWhenScreenOn()) {
if (!Screen.isDeviceLocked(this)) {
Logger.debug(""[Notification Blocked] Device is unlocked. {}"", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_SCREENON);
return;
} else if (!isNotificationsEnabledWhenScreenLocked()) {
Logger.debug(""[Notification Blocked] Device is in lock-screen. {}"", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_SCREENLOCKED);
return;
}
}

Logger.debug(""[New Notification] Notification is posted: "" + statusBarNotification.getKey());

byte filterResult = filter(statusBarNotification);

Logger.debug(""[New Notification] pkg: {}, filterResult: {}"", notificationPackage, ((char) (byte) filterResult));

//comment
if (filterResult == Constants.FILTER_CONTINUE || filterResult == Constants.FILTER_UNGROUP || filterResult == Constants.FILTER_LOCALOK) {

StatusBarNotification sbn = null;

//comment
if (filterResult == Constants.FILTER_UNGROUP && Prefs.getBoolean(Constants.PREF_NOTIFICATIONS_ENABLE_UNGROUP, false)) {
//comment
int nextId = statusBarNotification.getId() + newUID();
sbn = new StatusBarNotification(notificationPackage, """", nextId,
statusBarNotification.getTag(), 0, 0, 0,
statusBarNotification.getNotification(), statusBarNotification.getUser(),
statusBarNotification.getPostTime());

if (grouped_notifications.containsKey(statusBarNotification.getId())) {
//comment
//comment
int[] grouped = grouped_notifications.get(statusBarNotification.getId());
//comment
if (grouped != null) {
<start>int[] newArray = new int[grouped.length + 1];
//comment
System.arraycopy(grouped, 0, newArray, 0, grouped.length);
newArray[newArray.length - 1] = nextId;
grouped_notifications.put(statusBarNotification.getId(), newArray);<end>
//comment
} else
Logger.error(""grouped: could not create array"");
} else {
//comment
//comment
grouped_notifications.put(statusBarNotification.getId(), new int[]{nextId});
}
}

if (sbn == null)
sbn = statusBarNotification;

//comment
if (isCustomUIEnabled())
sendNotificationWithCustomUI(filterResult, sbn);
else
sendNotificationWithStandardUI(filterResult, sbn);

//comment
storeForStats(notificationPackage, filterResult);

} else {
if (isRingingNotification(filterResult, notificationPackage)) {
Logger.debug(""[Ringing Notification] New notifications is a ringing notification: "" + ((char) (byte) filterResult));
handleCall(statusBarNotification, notificationPackage);

} else if (isMapsNotification(filterResult, notificationPackage)) {
Logger.debug(""[Maps Notification] New notifications is a MapsNotification: "" + ((char) (byte) filterResult));
mapNotification(statusBarNotification);

} else {
Logger.debug(""[New Notification] New notifications is blocked. (pkg: {}, marked as: {})"",notificationPackage, ((char) (byte) filterResult));
checkAndLog(notificationPackage, notificationTxt, filterResult);
}
}
}","@Override
public void onNotificationPosted(StatusBarNotification statusBarNotification) {

String notificationPackage = statusBarNotification.getPackageName();

String notificationTxt = """";
CharSequence charSequence = statusBarNotification.getNotification().extras.getCharSequence(Notification.EXTRA_TEXT);
if (charSequence != null) {
notificationTxt = charSequence.toString();
}

if (!isPackageAllowed(notificationPackage)) {
//comment
Logger.debug(""[Notification Blocked] Notifications from {} are blocked."", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_PACKAGE);
return;
}else if (isPackageSilenced(notificationPackage)) {
//comment
Logger.debug(""[Notification Blocked] Notifications from {} are currently silenced."",notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_SILENCE);
return;
}else if (isPackageFiltered(statusBarNotification)) {
//comment
Logger.debug(""[Notification Blocked] Notifications from {} was blocked because of content filters."", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_TEXT);
return;
}else if (isNotificationsDisabled()) {
Logger.debug(""[Notification Blocked] All notifications are disabled (disabled, DND, Driving etc). {}"", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_NOTIFICATIONS_DISABLED);
return;
}else if (isNotificationsDisabledWhenScreenOn()) {
if (!Screen.isDeviceLocked(this)) {
Logger.debug(""[Notification Blocked] Device is unlocked. {}"", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_SCREENON);
return;
} else if (!isNotificationsEnabledWhenScreenLocked()) {
Logger.debug(""[Notification Blocked] Device is in lock-screen. {}"", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_SCREENLOCKED);
return;
}
}

Logger.debug(""[New Notification] Notification is posted: "" + statusBarNotification.getKey());

byte filterResult = filter(statusBarNotification);

Logger.debug(""[New Notification] pkg: {}, filterResult: {}"", notificationPackage, ((char) (byte) filterResult));

//comment
if (filterResult == Constants.FILTER_CONTINUE || filterResult == Constants.FILTER_UNGROUP || filterResult == Constants.FILTER_LOCALOK) {

StatusBarNotification sbn = null;

//comment
if (filterResult == Constants.FILTER_UNGROUP && Prefs.getBoolean(Constants.PREF_NOTIFICATIONS_ENABLE_UNGROUP, false)) {
//comment
int nextId = statusBarNotification.getId() + newUID();
sbn = new StatusBarNotification(notificationPackage, """", nextId,
statusBarNotification.getTag(), 0, 0, 0,
statusBarNotification.getNotification(), statusBarNotification.getUser(),
statusBarNotification.getPostTime());

if (grouped_notifications.containsKey(statusBarNotification.getId())) {
//comment
//comment
int[] grouped = grouped_notifications.get(statusBarNotification.getId());
//comment
if (grouped != null) {
int[] newArray = new int[grouped.length + 1];
//comment
<start>System.arraycopy(grouped, 0, newArray, 0, grouped.length);<end>
newArray[newArray.length - 1] = nextId;
grouped_notifications.put(statusBarNotification.getId(), newArray);
//comment
} else
Logger.error(""grouped: could not create array"");
} else {
//comment
//comment
grouped_notifications.put(statusBarNotification.getId(), new int[]{nextId});
}
}

if (sbn == null)
sbn = statusBarNotification;

//comment
if (isCustomUIEnabled())
sendNotificationWithCustomUI(filterResult, sbn);
else
sendNotificationWithStandardUI(filterResult, sbn);

//comment
storeForStats(notificationPackage, filterResult);

} else {
if (isRingingNotification(filterResult, notificationPackage)) {
Logger.debug(""[Ringing Notification] New notifications is a ringing notification: "" + ((char) (byte) filterResult));
handleCall(statusBarNotification, notificationPackage);

} else if (isMapsNotification(filterResult, notificationPackage)) {
Logger.debug(""[Maps Notification] New notifications is a MapsNotification: "" + ((char) (byte) filterResult));
mapNotification(statusBarNotification);

} else {
Logger.debug(""[New Notification] New notifications is blocked. (pkg: {}, marked as: {})"",notificationPackage, ((char) (byte) filterResult));
checkAndLog(notificationPackage, notificationTxt, filterResult);
}
}
}"
6829,"@Override
public void onNotificationPosted(StatusBarNotification statusBarNotification) {

String notificationPackage = statusBarNotification.getPackageName();

String notificationTxt = """";
CharSequence charSequence = statusBarNotification.getNotification().extras.getCharSequence(Notification.EXTRA_TEXT);
if (charSequence != null) {
notificationTxt = charSequence.toString();
}

if (!isPackageAllowed(notificationPackage)) {
//comment
Logger.debug(""[Notification Blocked] Notifications from {} are blocked."", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_PACKAGE);
return;
}else if (isPackageSilenced(notificationPackage)) {
//comment
Logger.debug(""[Notification Blocked] Notifications from {} are currently silenced."",notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_SILENCE);
return;
}else if (isPackageFiltered(statusBarNotification)) {
//comment
Logger.debug(""[Notification Blocked] Notifications from {} was blocked because of content filters."", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_TEXT);
return;
}else if (isNotificationsDisabled()) {
Logger.debug(""[Notification Blocked] All notifications are disabled (disabled, DND, Driving etc). {}"", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_NOTIFICATIONS_DISABLED);
return;
}else if (isNotificationsDisabledWhenScreenOn()) {
if (!Screen.isDeviceLocked(this)) {
Logger.debug(""[Notification Blocked] Device is unlocked. {}"", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_SCREENON);
return;
} else if (!isNotificationsEnabledWhenScreenLocked()) {
Logger.debug(""[Notification Blocked] Device is in lock-screen. {}"", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_SCREENLOCKED);
return;
}
}

Logger.debug(""[New Notification] Notification is posted: "" + statusBarNotification.getKey());

byte filterResult = filter(statusBarNotification);

Logger.debug(""[New Notification] pkg: {}, filterResult: {}"", notificationPackage, ((char) (byte) filterResult));

//comment
if (filterResult == Constants.FILTER_CONTINUE || filterResult == Constants.FILTER_UNGROUP || filterResult == Constants.FILTER_LOCALOK) {

StatusBarNotification sbn = null;

//comment
if (filterResult == Constants.FILTER_UNGROUP && Prefs.getBoolean(Constants.PREF_NOTIFICATIONS_ENABLE_UNGROUP, false)) {
//comment
int nextId = statusBarNotification.getId() + newUID();
sbn = new StatusBarNotification(notificationPackage, """", nextId,
statusBarNotification.getTag(), 0, 0, 0,
statusBarNotification.getNotification(), statusBarNotification.getUser(),
statusBarNotification.getPostTime());

if (grouped_notifications.containsKey(statusBarNotification.getId())) {
//comment
//comment
int[] grouped = grouped_notifications.get(statusBarNotification.getId());
//comment
if (grouped != null) {
int[] newArray = new int[grouped.length + 1];
//comment
System.arraycopy(grouped, 0, newArray, 0, grouped.length);
<start>newArray[newArray.length - 1] = nextId;<end>
grouped_notifications.put(statusBarNotification.getId(), newArray);
//comment
} else
Logger.error(""grouped: could not create array"");
} else {
//comment
//comment
<start>grouped_notifications.put(statusBarNotification.getId(), new int[]{nextId});<end>
}
}

if (sbn == null)
sbn = statusBarNotification;

//comment
if (isCustomUIEnabled())
sendNotificationWithCustomUI(filterResult, sbn);
else
sendNotificationWithStandardUI(filterResult, sbn);

//comment
storeForStats(notificationPackage, filterResult);

} else {
if (isRingingNotification(filterResult, notificationPackage)) {
Logger.debug(""[Ringing Notification] New notifications is a ringing notification: "" + ((char) (byte) filterResult));
handleCall(statusBarNotification, notificationPackage);

} else if (isMapsNotification(filterResult, notificationPackage)) {
Logger.debug(""[Maps Notification] New notifications is a MapsNotification: "" + ((char) (byte) filterResult));
mapNotification(statusBarNotification);

} else {
Logger.debug(""[New Notification] New notifications is blocked. (pkg: {}, marked as: {})"",notificationPackage, ((char) (byte) filterResult));
checkAndLog(notificationPackage, notificationTxt, filterResult);
}
}
}","@Override
public void onNotificationPosted(StatusBarNotification statusBarNotification) {

String notificationPackage = statusBarNotification.getPackageName();

String notificationTxt = """";
CharSequence charSequence = statusBarNotification.getNotification().extras.getCharSequence(Notification.EXTRA_TEXT);
if (charSequence != null) {
notificationTxt = charSequence.toString();
}

if (!isPackageAllowed(notificationPackage)) {
//comment
Logger.debug(""[Notification Blocked] Notifications from {} are blocked."", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_PACKAGE);
return;
}else if (isPackageSilenced(notificationPackage)) {
//comment
Logger.debug(""[Notification Blocked] Notifications from {} are currently silenced."",notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_SILENCE);
return;
}else if (isPackageFiltered(statusBarNotification)) {
//comment
Logger.debug(""[Notification Blocked] Notifications from {} was blocked because of content filters."", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_TEXT);
return;
}else if (isNotificationsDisabled()) {
Logger.debug(""[Notification Blocked] All notifications are disabled (disabled, DND, Driving etc). {}"", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_NOTIFICATIONS_DISABLED);
return;
}else if (isNotificationsDisabledWhenScreenOn()) {
if (!Screen.isDeviceLocked(this)) {
Logger.debug(""[Notification Blocked] Device is unlocked. {}"", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_SCREENON);
return;
} else if (!isNotificationsEnabledWhenScreenLocked()) {
Logger.debug(""[Notification Blocked] Device is in lock-screen. {}"", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_SCREENLOCKED);
return;
}
}

Logger.debug(""[New Notification] Notification is posted: "" + statusBarNotification.getKey());

byte filterResult = filter(statusBarNotification);

Logger.debug(""[New Notification] pkg: {}, filterResult: {}"", notificationPackage, ((char) (byte) filterResult));

//comment
if (filterResult == Constants.FILTER_CONTINUE || filterResult == Constants.FILTER_UNGROUP || filterResult == Constants.FILTER_LOCALOK) {

StatusBarNotification sbn = null;

//comment
if (filterResult == Constants.FILTER_UNGROUP && Prefs.getBoolean(Constants.PREF_NOTIFICATIONS_ENABLE_UNGROUP, false)) {
//comment
int nextId = statusBarNotification.getId() + newUID();
sbn = new StatusBarNotification(notificationPackage, """", nextId,
statusBarNotification.getTag(), 0, 0, 0,
statusBarNotification.getNotification(), statusBarNotification.getUser(),
statusBarNotification.getPostTime());

if (grouped_notifications.containsKey(statusBarNotification.getId())) {
//comment
//comment
int[] grouped = grouped_notifications.get(statusBarNotification.getId());
//comment
if (grouped != null) {
int[] newArray = new int[grouped.length + 1];
//comment
System.arraycopy(grouped, 0, newArray, 0, grouped.length);
newArray[newArray.length - 1] = nextId;
grouped_notifications.put(statusBarNotification.getId(), newArray);
//comment
} else
Logger.error(""grouped: could not create array"");
} else {
//comment
//comment
<start>grouped_notifications.put(statusBarNotification.getId(), new int[]{nextId});<end>
}
}

if (sbn == null)
sbn = statusBarNotification;

//comment
if (isCustomUIEnabled())
sendNotificationWithCustomUI(filterResult, sbn);
else
sendNotificationWithStandardUI(filterResult, sbn);

//comment
storeForStats(notificationPackage, filterResult);

} else {
if (isRingingNotification(filterResult, notificationPackage)) {
Logger.debug(""[Ringing Notification] New notifications is a ringing notification: "" + ((char) (byte) filterResult));
handleCall(statusBarNotification, notificationPackage);

} else if (isMapsNotification(filterResult, notificationPackage)) {
Logger.debug(""[Maps Notification] New notifications is a MapsNotification: "" + ((char) (byte) filterResult));
mapNotification(statusBarNotification);

} else {
Logger.debug(""[New Notification] New notifications is blocked. (pkg: {}, marked as: {})"",notificationPackage, ((char) (byte) filterResult));
checkAndLog(notificationPackage, notificationTxt, filterResult);
}
}
}"
6830,"@Override
public void onNotificationPosted(StatusBarNotification statusBarNotification) {

String notificationPackage = statusBarNotification.getPackageName();

String notificationTxt = """";
CharSequence charSequence = statusBarNotification.getNotification().extras.getCharSequence(Notification.EXTRA_TEXT);
if (charSequence != null) {
notificationTxt = charSequence.toString();
}

if (!isPackageAllowed(notificationPackage)) {
//comment
Logger.debug(""[Notification Blocked] Notifications from {} are blocked."", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_PACKAGE);
return;
}else if (isPackageSilenced(notificationPackage)) {
//comment
Logger.debug(""[Notification Blocked] Notifications from {} are currently silenced."",notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_SILENCE);
return;
}else if (isPackageFiltered(statusBarNotification)) {
//comment
Logger.debug(""[Notification Blocked] Notifications from {} was blocked because of content filters."", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_TEXT);
return;
}else if (isNotificationsDisabled()) {
Logger.debug(""[Notification Blocked] All notifications are disabled (disabled, DND, Driving etc). {}"", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_NOTIFICATIONS_DISABLED);
return;
}else if (isNotificationsDisabledWhenScreenOn()) {
if (!Screen.isDeviceLocked(this)) {
Logger.debug(""[Notification Blocked] Device is unlocked. {}"", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_SCREENON);
return;
} else if (!isNotificationsEnabledWhenScreenLocked()) {
Logger.debug(""[Notification Blocked] Device is in lock-screen. {}"", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_SCREENLOCKED);
return;
}
}

Logger.debug(""[New Notification] Notification is posted: "" + statusBarNotification.getKey());

byte filterResult = filter(statusBarNotification);

Logger.debug(""[New Notification] pkg: {}, filterResult: {}"", notificationPackage, ((char) (byte) filterResult));

//comment
if (filterResult == Constants.FILTER_CONTINUE || filterResult == Constants.FILTER_UNGROUP || filterResult == Constants.FILTER_LOCALOK) {

StatusBarNotification sbn = null;

//comment
if (filterResult == Constants.FILTER_UNGROUP && Prefs.getBoolean(Constants.PREF_NOTIFICATIONS_ENABLE_UNGROUP, false)) {
//comment
int nextId = statusBarNotification.getId() + newUID();
sbn = new StatusBarNotification(notificationPackage, """", nextId,
statusBarNotification.getTag(), 0, 0, 0,
statusBarNotification.getNotification(), statusBarNotification.getUser(),
statusBarNotification.getPostTime());

if (grouped_notifications.containsKey(statusBarNotification.getId())) {
//comment
//comment
int[] grouped = grouped_notifications.get(statusBarNotification.getId());
//comment
if (grouped != null) {
int[] newArray = new int[grouped.length + 1];
//comment
System.arraycopy(grouped, 0, newArray, 0, grouped.length);
newArray[newArray.length - 1] = nextId;
grouped_notifications.put(statusBarNotification.getId(), newArray);
//comment
} else
Logger.error(""grouped: could not create array"");
} else {
//comment
//comment
grouped_notifications.put(statusBarNotification.getId(), new int[]{nextId});
}
}

if (sbn == null)
sbn = statusBarNotification;

//comment
<start>if (isCustomUIEnabled())
sendNotificationWithCustomUI(filterResult, sbn);
else
sendNotificationWithStandardUI(filterResult, sbn);<end>

//comment
storeForStats(notificationPackage, filterResult);

} else {
if (isRingingNotification(filterResult, notificationPackage)) {
Logger.debug(""[Ringing Notification] New notifications is a ringing notification: "" + ((char) (byte) filterResult));
handleCall(statusBarNotification, notificationPackage);

} else if (isMapsNotification(filterResult, notificationPackage)) {
Logger.debug(""[Maps Notification] New notifications is a MapsNotification: "" + ((char) (byte) filterResult));
mapNotification(statusBarNotification);

} else {
Logger.debug(""[New Notification] New notifications is blocked. (pkg: {}, marked as: {})"",notificationPackage, ((char) (byte) filterResult));
checkAndLog(notificationPackage, notificationTxt, filterResult);
}
}
}","@Override
public void onNotificationPosted(StatusBarNotification statusBarNotification) {

String notificationPackage = statusBarNotification.getPackageName();

String notificationTxt = """";
CharSequence charSequence = statusBarNotification.getNotification().extras.getCharSequence(Notification.EXTRA_TEXT);
if (charSequence != null) {
notificationTxt = charSequence.toString();
}

if (!isPackageAllowed(notificationPackage)) {
//comment
Logger.debug(""[Notification Blocked] Notifications from {} are blocked."", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_PACKAGE);
return;
}else if (isPackageSilenced(notificationPackage)) {
//comment
Logger.debug(""[Notification Blocked] Notifications from {} are currently silenced."",notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_SILENCE);
return;
}else if (isPackageFiltered(statusBarNotification)) {
//comment
Logger.debug(""[Notification Blocked] Notifications from {} was blocked because of content filters."", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_TEXT);
return;
}else if (isNotificationsDisabled()) {
Logger.debug(""[Notification Blocked] All notifications are disabled (disabled, DND, Driving etc). {}"", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_NOTIFICATIONS_DISABLED);
return;
}else if (isNotificationsDisabledWhenScreenOn()) {
if (!Screen.isDeviceLocked(this)) {
Logger.debug(""[Notification Blocked] Device is unlocked. {}"", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_SCREENON);
return;
} else if (!isNotificationsEnabledWhenScreenLocked()) {
Logger.debug(""[Notification Blocked] Device is in lock-screen. {}"", notificationPackage);
checkAndLog(notificationPackage, notificationTxt, Constants.FILTER_SCREENLOCKED);
return;
}
}

Logger.debug(""[New Notification] Notification is posted: "" + statusBarNotification.getKey());

byte filterResult = filter(statusBarNotification);

Logger.debug(""[New Notification] pkg: {}, filterResult: {}"", notificationPackage, ((char) (byte) filterResult));

//comment
if (filterResult == Constants.FILTER_CONTINUE || filterResult == Constants.FILTER_UNGROUP || filterResult == Constants.FILTER_LOCALOK) {

StatusBarNotification sbn = null;

//comment
if (filterResult == Constants.FILTER_UNGROUP && Prefs.getBoolean(Constants.PREF_NOTIFICATIONS_ENABLE_UNGROUP, false)) {
//comment
int nextId = statusBarNotification.getId() + newUID();
sbn = new StatusBarNotification(notificationPackage, """", nextId,
statusBarNotification.getTag(), 0, 0, 0,
statusBarNotification.getNotification(), statusBarNotification.getUser(),
statusBarNotification.getPostTime());

if (grouped_notifications.containsKey(statusBarNotification.getId())) {
//comment
//comment
int[] grouped = grouped_notifications.get(statusBarNotification.getId());
//comment
if (grouped != null) {
int[] newArray = new int[grouped.length + 1];
//comment
System.arraycopy(grouped, 0, newArray, 0, grouped.length);
newArray[newArray.length - 1] = nextId;
grouped_notifications.put(statusBarNotification.getId(), newArray);
//comment
} else
Logger.error(""grouped: could not create array"");
} else {
//comment
//comment
grouped_notifications.put(statusBarNotification.getId(), new int[]{nextId});
}
}

if (sbn == null)
sbn = statusBarNotification;

//comment
<start>if (isCustomUIEnabled())
sendNotificationWithCustomUI(filterResult, sbn);
else
sendNotificationWithStandardUI(filterResult, sbn);<end>

//comment
storeForStats(notificationPackage, filterResult);

} else {
if (isRingingNotification(filterResult, notificationPackage)) {
Logger.debug(""[Ringing Notification] New notifications is a ringing notification: "" + ((char) (byte) filterResult));
handleCall(statusBarNotification, notificationPackage);

} else if (isMapsNotification(filterResult, notificationPackage)) {
Logger.debug(""[Maps Notification] New notifications is a MapsNotification: "" + ((char) (byte) filterResult));
mapNotification(statusBarNotification);

} else {
Logger.debug(""[New Notification] New notifications is blocked. (pkg: {}, marked as: {})"",notificationPackage, ((char) (byte) filterResult));
checkAndLog(notificationPackage, notificationTxt, filterResult);
}
}
}"
6831,"@Override
public void onNotificationRemoved(final StatusBarNotification statusBarNotification) {
if (statusBarNotification == null)
return;

String key = statusBarNotification.getKey();

//comment
<start>if (!Prefs.getBoolean(Constants.PREF_ENABLE_NOTIFICATIONS, Constants.PREF_DEFAULT_ENABLE_NOTIFICATIONS)
|| (Prefs.getBoolean(Constants.PREF_DISABLE_REMOVE_NOTIFICATIONS, false))) {
Logger.debug(""[Notification Remove] Notification wont be removed due to current settings. (key: {})"", key);
return;
}<end>


if (!(isPackageAllowed(statusBarNotification.getPackageName())
//comment
&& ((statusBarNotification.getNotification().flags & Notification.FLAG_ONGOING_EVENT) != Notification.FLAG_ONGOING_EVENT))) {
Logger.debug(""[Notification Remove] App {} is ignored: P || G || O"", statusBarNotification.getPackageName());
return;
}

//comment

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

DataBundle dataBundle = new DataBundle();
dataBundle.putParcelable(""data"", StatusBarNotificationData.from(this, statusBarNotification, false));

String uuid = newKey(key);
NotificationStore.addRemovedNotification(uuid, dataBundle);
int id = NotificationJobService.NOTIFICATION_REMOVED;
int jobId = statusBarNotification.getId() + newUID();

scheduleJob(id, jobId, uuid);

Logger.debug(""[Notification Remove] Remove scheduled. key {}, jobId: {}, uuid: {}"", key, jobId, uuid);
//comment

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

//comment
if (grouped_notifications.containsKey(statusBarNotification.getId())) {
//comment
//comment
int[] grouped = grouped_notifications.get(statusBarNotification.getId());
//comment

//comment
assert grouped != null;
for (int groupedId : grouped) {
//comment
jobId = groupedId + newUID();
//comment

dataBundle = new DataBundle();
StatusBarNotification sbn = new StatusBarNotification(statusBarNotification.getPackageName(), """",
groupedId, statusBarNotification.getTag(), 0, 0, 0,
statusBarNotification.getNotification(), statusBarNotification.getUser(),
statusBarNotification.getPostTime());
dataBundle.putParcelable(""data"", StatusBarNotificationData.from(this, sbn, false));

uuid = newKey(statusBarNotification.getKey());
NotificationStore.addRemovedNotification(uuid, dataBundle);

scheduleJob(id, jobId, uuid);

Logger.info(""onNotificationRemoved ungroup jobScheduled: "" + jobId + "" \\ uuid: "" + uuid);

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
}
grouped_notifications.remove(statusBarNotification.getId());
}

//comment
//comment
//comment
//comment
//comment
//comment

//comment
if (lastTimeNotificationArrived > 0) {
lastTimeNotificationArrived = 0;
}
if (lastTimeNotificationSent > 0) {
lastTimeNotificationSent = 0;
}
}","@Override
public void onNotificationRemoved(final StatusBarNotification statusBarNotification) {
if (statusBarNotification == null)
return;

String key = statusBarNotification.getKey();

//comment
<start>if (!Prefs.getBoolean(Constants.PREF_ENABLE_NOTIFICATIONS, Constants.PREF_DEFAULT_ENABLE_NOTIFICATIONS)
|| (Prefs.getBoolean(Constants.PREF_DISABLE_REMOVE_NOTIFICATIONS, false))) {<end>
Logger.debug(""[Notification Remove] Notification wont be removed due to current settings. (key: {})"", key);
return;
}


if (!(isPackageAllowed(statusBarNotification.getPackageName())
//comment
&& ((statusBarNotification.getNotification().flags & Notification.FLAG_ONGOING_EVENT) != Notification.FLAG_ONGOING_EVENT))) {
Logger.debug(""[Notification Remove] App {} is ignored: P || G || O"", statusBarNotification.getPackageName());
return;
}

//comment

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

DataBundle dataBundle = new DataBundle();
dataBundle.putParcelable(""data"", StatusBarNotificationData.from(this, statusBarNotification, false));

String uuid = newKey(key);
NotificationStore.addRemovedNotification(uuid, dataBundle);
int id = NotificationJobService.NOTIFICATION_REMOVED;
int jobId = statusBarNotification.getId() + newUID();

scheduleJob(id, jobId, uuid);

Logger.debug(""[Notification Remove] Remove scheduled. key {}, jobId: {}, uuid: {}"", key, jobId, uuid);
//comment

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

//comment
if (grouped_notifications.containsKey(statusBarNotification.getId())) {
//comment
//comment
int[] grouped = grouped_notifications.get(statusBarNotification.getId());
//comment

//comment
assert grouped != null;
for (int groupedId : grouped) {
//comment
jobId = groupedId + newUID();
//comment

dataBundle = new DataBundle();
StatusBarNotification sbn = new StatusBarNotification(statusBarNotification.getPackageName(), """",
groupedId, statusBarNotification.getTag(), 0, 0, 0,
statusBarNotification.getNotification(), statusBarNotification.getUser(),
statusBarNotification.getPostTime());
dataBundle.putParcelable(""data"", StatusBarNotificationData.from(this, sbn, false));

uuid = newKey(statusBarNotification.getKey());
NotificationStore.addRemovedNotification(uuid, dataBundle);

scheduleJob(id, jobId, uuid);

Logger.info(""onNotificationRemoved ungroup jobScheduled: "" + jobId + "" \\ uuid: "" + uuid);

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
}
grouped_notifications.remove(statusBarNotification.getId());
}

//comment
//comment
//comment
//comment
//comment
//comment

//comment
if (lastTimeNotificationArrived > 0) {
lastTimeNotificationArrived = 0;
}
if (lastTimeNotificationSent > 0) {
lastTimeNotificationSent = 0;
}
}"
6832,"@Override
public void onNotificationRemoved(final StatusBarNotification statusBarNotification) {
if (statusBarNotification == null)
return;

String key = statusBarNotification.getKey();

//comment
if (!Prefs.getBoolean(Constants.PREF_ENABLE_NOTIFICATIONS, Constants.PREF_DEFAULT_ENABLE_NOTIFICATIONS)
|| (Prefs.getBoolean(Constants.PREF_DISABLE_REMOVE_NOTIFICATIONS, false))) {
Logger.debug(""[Notification Remove] Notification wont be removed due to current settings. (key: {})"", key);
return;
}


if (!(isPackageAllowed(statusBarNotification.getPackageName())
//comment
&& ((statusBarNotification.getNotification().flags & Notification.FLAG_ONGOING_EVENT) != Notification.FLAG_ONGOING_EVENT))) {
Logger.debug(""[Notification Remove] App {} is ignored: P || G || O"", statusBarNotification.getPackageName());
return;
}

//comment

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

DataBundle dataBundle = new DataBundle();
dataBundle.putParcelable(""data"", StatusBarNotificationData.from(this, statusBarNotification, false));

String uuid = newKey(key);
NotificationStore.addRemovedNotification(uuid, dataBundle);
int id = NotificationJobService.NOTIFICATION_REMOVED;
int jobId = statusBarNotification.getId() + newUID();

scheduleJob(id, jobId, uuid);

Logger.debug(""[Notification Remove] Remove scheduled. key {}, jobId: {}, uuid: {}"", key, jobId, uuid);
//comment

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

//comment
if (grouped_notifications.containsKey(statusBarNotification.getId())) {
//comment
//comment
int[] grouped = grouped_notifications.get(statusBarNotification.getId());
//comment

//comment
assert grouped != null;
for (int groupedId : grouped) {
//comment
jobId = groupedId + newUID();
//comment

dataBundle = new DataBundle();
StatusBarNotification sbn = new StatusBarNotification(statusBarNotification.getPackageName(), """",
groupedId, statusBarNotification.getTag(), 0, 0, 0,
statusBarNotification.getNotification(), statusBarNotification.getUser(),
statusBarNotification.getPostTime());
dataBundle.putParcelable(""data"", StatusBarNotificationData.from(this, sbn, false));

uuid = newKey(statusBarNotification.getKey());
NotificationStore.addRemovedNotification(uuid, dataBundle);

scheduleJob(id, jobId, uuid);

Logger.info(""onNotificationRemoved ungroup jobScheduled: "" + jobId + "" \\ uuid: "" + uuid);

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
}
grouped_notifications.remove(statusBarNotification.getId());
}

//comment
//comment
//comment
//comment
//comment
//comment

//comment
if (lastTimeNotificationArrived > 0) {
lastTimeNotificationArrived = 0;
}
if (lastTimeNotificationSent > 0) {
lastTimeNotificationSent = 0;
}
}","@Override
public void onNotificationRemoved(final StatusBarNotification statusBarNotification) {
if (statusBarNotification == null)
return;

String key = statusBarNotification.getKey();

//comment
if (!Prefs.getBoolean(Constants.PREF_ENABLE_NOTIFICATIONS, Constants.PREF_DEFAULT_ENABLE_NOTIFICATIONS)
|| (Prefs.getBoolean(Constants.PREF_DISABLE_REMOVE_NOTIFICATIONS, false))) {
Logger.debug(""[Notification Remove] Notification wont be removed due to current settings. (key: {})"", key);
return;
}


if (!(isPackageAllowed(statusBarNotification.getPackageName())
//comment
&& ((statusBarNotification.getNotification().flags & Notification.FLAG_ONGOING_EVENT) != Notification.FLAG_ONGOING_EVENT))) {
Logger.debug(""[Notification Remove] App {} is ignored: P || G || O"", statusBarNotification.getPackageName());
return;
}

//comment

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

DataBundle dataBundle = new DataBundle();
dataBundle.putParcelable(""data"", StatusBarNotificationData.from(this, statusBarNotification, false));

String uuid = newKey(key);
NotificationStore.addRemovedNotification(uuid, dataBundle);
int id = NotificationJobService.NOTIFICATION_REMOVED;
int jobId = statusBarNotification.getId() + newUID();

scheduleJob(id, jobId, uuid);

Logger.debug(""[Notification Remove] Remove scheduled. key {}, jobId: {}, uuid: {}"", key, jobId, uuid);
//comment

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

//comment
<start>if (grouped_notifications.containsKey(statusBarNotification.getId())) {<end>
//comment
//comment
int[] grouped = grouped_notifications.get(statusBarNotification.getId());
//comment

//comment
assert grouped != null;
for (int groupedId : grouped) {
//comment
jobId = groupedId + newUID();
//comment

dataBundle = new DataBundle();
StatusBarNotification sbn = new StatusBarNotification(statusBarNotification.getPackageName(), """",
groupedId, statusBarNotification.getTag(), 0, 0, 0,
statusBarNotification.getNotification(), statusBarNotification.getUser(),
statusBarNotification.getPostTime());
dataBundle.putParcelable(""data"", StatusBarNotificationData.from(this, sbn, false));

uuid = newKey(statusBarNotification.getKey());
NotificationStore.addRemovedNotification(uuid, dataBundle);

scheduleJob(id, jobId, uuid);

Logger.info(""onNotificationRemoved ungroup jobScheduled: "" + jobId + "" \\ uuid: "" + uuid);

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
}
grouped_notifications.remove(statusBarNotification.getId());
}

//comment
//comment
//comment
//comment
//comment
//comment

//comment
if (lastTimeNotificationArrived > 0) {
lastTimeNotificationArrived = 0;
}
if (lastTimeNotificationSent > 0) {
lastTimeNotificationSent = 0;
}
}"
6833,"@Override
public void onNotificationRemoved(final StatusBarNotification statusBarNotification) {
if (statusBarNotification == null)
return;

String key = statusBarNotification.getKey();

//comment
if (!Prefs.getBoolean(Constants.PREF_ENABLE_NOTIFICATIONS, Constants.PREF_DEFAULT_ENABLE_NOTIFICATIONS)
|| (Prefs.getBoolean(Constants.PREF_DISABLE_REMOVE_NOTIFICATIONS, false))) {
Logger.debug(""[Notification Remove] Notification wont be removed due to current settings. (key: {})"", key);
return;
}


if (!(isPackageAllowed(statusBarNotification.getPackageName())
//comment
&& ((statusBarNotification.getNotification().flags & Notification.FLAG_ONGOING_EVENT) != Notification.FLAG_ONGOING_EVENT))) {
Logger.debug(""[Notification Remove] App {} is ignored: P || G || O"", statusBarNotification.getPackageName());
return;
}

//comment

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

DataBundle dataBundle = new DataBundle();
dataBundle.putParcelable(""data"", StatusBarNotificationData.from(this, statusBarNotification, false));

String uuid = newKey(key);
NotificationStore.addRemovedNotification(uuid, dataBundle);
int id = NotificationJobService.NOTIFICATION_REMOVED;
int jobId = statusBarNotification.getId() + newUID();

scheduleJob(id, jobId, uuid);

Logger.debug(""[Notification Remove] Remove scheduled. key {}, jobId: {}, uuid: {}"", key, jobId, uuid);
//comment

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

//comment
if (grouped_notifications.containsKey(statusBarNotification.getId())) {
//comment
//comment
int[] grouped = grouped_notifications.get(statusBarNotification.getId());
//comment

//comment
<start>assert grouped != null;<end>
for (int groupedId : grouped) {
//comment
jobId = groupedId + newUID();
//comment

dataBundle = new DataBundle();
StatusBarNotification sbn = new StatusBarNotification(statusBarNotification.getPackageName(), """",
groupedId, statusBarNotification.getTag(), 0, 0, 0,
statusBarNotification.getNotification(), statusBarNotification.getUser(),
statusBarNotification.getPostTime());
dataBundle.putParcelable(""data"", StatusBarNotificationData.from(this, sbn, false));

uuid = newKey(statusBarNotification.getKey());
NotificationStore.addRemovedNotification(uuid, dataBundle);

scheduleJob(id, jobId, uuid);

Logger.info(""onNotificationRemoved ungroup jobScheduled: "" + jobId + "" \\ uuid: "" + uuid);

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
}
grouped_notifications.remove(statusBarNotification.getId());
}

//comment
//comment
//comment
//comment
//comment
//comment

//comment
if (lastTimeNotificationArrived > 0) {
lastTimeNotificationArrived = 0;
}
if (lastTimeNotificationSent > 0) {
lastTimeNotificationSent = 0;
}
}","@Override
public void onNotificationRemoved(final StatusBarNotification statusBarNotification) {
if (statusBarNotification == null)
return;

String key = statusBarNotification.getKey();

//comment
if (!Prefs.getBoolean(Constants.PREF_ENABLE_NOTIFICATIONS, Constants.PREF_DEFAULT_ENABLE_NOTIFICATIONS)
|| (Prefs.getBoolean(Constants.PREF_DISABLE_REMOVE_NOTIFICATIONS, false))) {
Logger.debug(""[Notification Remove] Notification wont be removed due to current settings. (key: {})"", key);
return;
}


if (!(isPackageAllowed(statusBarNotification.getPackageName())
//comment
&& ((statusBarNotification.getNotification().flags & Notification.FLAG_ONGOING_EVENT) != Notification.FLAG_ONGOING_EVENT))) {
Logger.debug(""[Notification Remove] App {} is ignored: P || G || O"", statusBarNotification.getPackageName());
return;
}

//comment

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

DataBundle dataBundle = new DataBundle();
dataBundle.putParcelable(""data"", StatusBarNotificationData.from(this, statusBarNotification, false));

String uuid = newKey(key);
NotificationStore.addRemovedNotification(uuid, dataBundle);
int id = NotificationJobService.NOTIFICATION_REMOVED;
int jobId = statusBarNotification.getId() + newUID();

scheduleJob(id, jobId, uuid);

Logger.debug(""[Notification Remove] Remove scheduled. key {}, jobId: {}, uuid: {}"", key, jobId, uuid);
//comment

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

//comment
if (grouped_notifications.containsKey(statusBarNotification.getId())) {
//comment
//comment
int[] grouped = grouped_notifications.get(statusBarNotification.getId());
//comment

//comment
assert grouped != null;
<start>for (int groupedId : grouped) {<end>
//comment
jobId = groupedId + newUID();
//comment

dataBundle = new DataBundle();
StatusBarNotification sbn = new StatusBarNotification(statusBarNotification.getPackageName(), """",
groupedId, statusBarNotification.getTag(), 0, 0, 0,
statusBarNotification.getNotification(), statusBarNotification.getUser(),
statusBarNotification.getPostTime());
dataBundle.putParcelable(""data"", StatusBarNotificationData.from(this, sbn, false));

uuid = newKey(statusBarNotification.getKey());
NotificationStore.addRemovedNotification(uuid, dataBundle);

scheduleJob(id, jobId, uuid);

Logger.info(""onNotificationRemoved ungroup jobScheduled: "" + jobId + "" \\ uuid: "" + uuid);

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
}
grouped_notifications.remove(statusBarNotification.getId());
}

//comment
//comment
//comment
//comment
//comment
//comment

//comment
if (lastTimeNotificationArrived > 0) {
lastTimeNotificationArrived = 0;
}
if (lastTimeNotificationSent > 0) {
lastTimeNotificationSent = 0;
}
}"
6834,"@Override
public void onNotificationRemoved(final StatusBarNotification statusBarNotification) {
if (statusBarNotification == null)
return;

String key = statusBarNotification.getKey();

//comment
if (!Prefs.getBoolean(Constants.PREF_ENABLE_NOTIFICATIONS, Constants.PREF_DEFAULT_ENABLE_NOTIFICATIONS)
|| (Prefs.getBoolean(Constants.PREF_DISABLE_REMOVE_NOTIFICATIONS, false))) {
Logger.debug(""[Notification Remove] Notification wont be removed due to current settings. (key: {})"", key);
return;
}


if (!(isPackageAllowed(statusBarNotification.getPackageName())
//comment
&& ((statusBarNotification.getNotification().flags & Notification.FLAG_ONGOING_EVENT) != Notification.FLAG_ONGOING_EVENT))) {
Logger.debug(""[Notification Remove] App {} is ignored: P || G || O"", statusBarNotification.getPackageName());
return;
}

//comment

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

DataBundle dataBundle = new DataBundle();
dataBundle.putParcelable(""data"", StatusBarNotificationData.from(this, statusBarNotification, false));

String uuid = newKey(key);
NotificationStore.addRemovedNotification(uuid, dataBundle);
int id = NotificationJobService.NOTIFICATION_REMOVED;
int jobId = statusBarNotification.getId() + newUID();

scheduleJob(id, jobId, uuid);

Logger.debug(""[Notification Remove] Remove scheduled. key {}, jobId: {}, uuid: {}"", key, jobId, uuid);
//comment

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

//comment
if (grouped_notifications.containsKey(statusBarNotification.getId())) {
//comment
//comment
int[] grouped = grouped_notifications.get(statusBarNotification.getId());
//comment

//comment
assert grouped != null;
for (int groupedId : grouped) {
//comment
jobId = groupedId + newUID();
//comment

dataBundle = new DataBundle();
StatusBarNotification sbn = new StatusBarNotification(statusBarNotification.getPackageName(), """",
groupedId, statusBarNotification.getTag(), 0, 0, 0,
statusBarNotification.getNotification(), statusBarNotification.getUser(),
statusBarNotification.getPostTime());
dataBundle.putParcelable(""data"", StatusBarNotificationData.from(this, sbn, false));

uuid = newKey(statusBarNotification.getKey());
NotificationStore.addRemovedNotification(uuid, dataBundle);

scheduleJob(id, jobId, uuid);

Logger.info(""onNotificationRemoved ungroup jobScheduled: "" + jobId + "" \\ uuid: "" + uuid);

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
}
grouped_notifications.remove(statusBarNotification.getId());
}

//comment
//comment
//comment
//comment
//comment
//comment

//comment
<start>if (lastTimeNotificationArrived > 0) {
lastTimeNotificationArrived = 0;
}
if (lastTimeNotificationSent > 0) {
lastTimeNotificationSent = 0;
}<end>
}","@Override
public void onNotificationRemoved(final StatusBarNotification statusBarNotification) {
if (statusBarNotification == null)
return;

String key = statusBarNotification.getKey();

//comment
if (!Prefs.getBoolean(Constants.PREF_ENABLE_NOTIFICATIONS, Constants.PREF_DEFAULT_ENABLE_NOTIFICATIONS)
|| (Prefs.getBoolean(Constants.PREF_DISABLE_REMOVE_NOTIFICATIONS, false))) {
Logger.debug(""[Notification Remove] Notification wont be removed due to current settings. (key: {})"", key);
return;
}


if (!(isPackageAllowed(statusBarNotification.getPackageName())
//comment
&& ((statusBarNotification.getNotification().flags & Notification.FLAG_ONGOING_EVENT) != Notification.FLAG_ONGOING_EVENT))) {
Logger.debug(""[Notification Remove] App {} is ignored: P || G || O"", statusBarNotification.getPackageName());
return;
}

//comment

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

DataBundle dataBundle = new DataBundle();
dataBundle.putParcelable(""data"", StatusBarNotificationData.from(this, statusBarNotification, false));

String uuid = newKey(key);
NotificationStore.addRemovedNotification(uuid, dataBundle);
int id = NotificationJobService.NOTIFICATION_REMOVED;
int jobId = statusBarNotification.getId() + newUID();

scheduleJob(id, jobId, uuid);

Logger.debug(""[Notification Remove] Remove scheduled. key {}, jobId: {}, uuid: {}"", key, jobId, uuid);
//comment

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment

//comment
if (grouped_notifications.containsKey(statusBarNotification.getId())) {
//comment
//comment
int[] grouped = grouped_notifications.get(statusBarNotification.getId());
//comment

//comment
assert grouped != null;
for (int groupedId : grouped) {
//comment
jobId = groupedId + newUID();
//comment

dataBundle = new DataBundle();
StatusBarNotification sbn = new StatusBarNotification(statusBarNotification.getPackageName(), """",
groupedId, statusBarNotification.getTag(), 0, 0, 0,
statusBarNotification.getNotification(), statusBarNotification.getUser(),
statusBarNotification.getPostTime());
dataBundle.putParcelable(""data"", StatusBarNotificationData.from(this, sbn, false));

uuid = newKey(statusBarNotification.getKey());
NotificationStore.addRemovedNotification(uuid, dataBundle);

scheduleJob(id, jobId, uuid);

Logger.info(""onNotificationRemoved ungroup jobScheduled: "" + jobId + "" \\ uuid: "" + uuid);

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
}
grouped_notifications.remove(statusBarNotification.getId());
}

//comment
//comment
//comment
//comment
//comment
//comment

//comment
<start>if (lastTimeNotificationArrived > 0) {
lastTimeNotificationArrived = 0;
}
if (lastTimeNotificationSent > 0) {
lastTimeNotificationSent = 0;
}<end>
}"
6835,"    private void sendNotificationWithStandardUI(byte filterResult, StatusBarNotification statusBarNotification) {
DataBundle dataBundle = new DataBundle();
dataBundle.putParcelable(""data"", StatusBarNotificationData.from(this, statusBarNotification, false));

if (isJobSchedulerEnabled()) {
//comment
<start>String uuid = newKey(statusBarNotification.getKey());
//comment
int notificationId = statusBarNotification.getId();<end>
int id = NotificationJobService.NOTIFICATION_POSTED_STANDARD_UI;
int jobId = notificationId + newUID();
<start>NotificationStore.addStandardNotification(uuid, dataBundle);<end>
scheduleJob(id, jobId, uuid);
Logger.info(""sendNotificationWithStandardUI jobScheduled: "" + jobId + "" \\ uuid: "" + uuid);

} else {
//comment
TransportService.sendWithTransporterHuami(""add"", dataBundle);
Logger.info(""sendNotificationWithStandardUI: "" + dataBundle.toString());
}
}","    private void sendNotificationWithStandardUI(byte filterResult, StatusBarNotification statusBarNotification) {
DataBundle dataBundle = new DataBundle();
dataBundle.putParcelable(""data"", StatusBarNotificationData.from(this, statusBarNotification, false));

<start>if (isJobSchedulerEnabled()) {<end>
//comment
String uuid = newKey(statusBarNotification.getKey());
//comment
int notificationId = statusBarNotification.getId();
int id = NotificationJobService.NOTIFICATION_POSTED_STANDARD_UI;
int jobId = notificationId + newUID();
NotificationStore.addStandardNotification(uuid, dataBundle);
scheduleJob(id, jobId, uuid);
Logger.info(""sendNotificationWithStandardUI jobScheduled: "" + jobId + "" \\ uuid: "" + uuid);

} else {
//comment
TransportService.sendWithTransporterHuami(""add"", dataBundle);
Logger.info(""sendNotificationWithStandardUI: "" + dataBundle.toString());
}
}"
6836,"    private void sendNotificationWithStandardUI(byte filterResult, StatusBarNotification statusBarNotification) {
DataBundle dataBundle = new DataBundle();
dataBundle.putParcelable(""data"", StatusBarNotificationData.from(this, statusBarNotification, false));

if (isJobSchedulerEnabled()) {
//comment
String uuid = newKey(statusBarNotification.getKey());
//comment
int notificationId = statusBarNotification.getId();
int id = NotificationJobService.NOTIFICATION_POSTED_STANDARD_UI;
int jobId = notificationId + newUID();
NotificationStore.addStandardNotification(uuid, dataBundle);
scheduleJob(id, jobId, uuid);
Logger.info(""sendNotificationWithStandardUI jobScheduled: "" + jobId + "" \\ uuid: "" + uuid);

} else {
//comment
<start>TransportService.sendWithTransporterHuami(""add"", dataBundle);<end>
Logger.info(""sendNotificationWithStandardUI: "" + dataBundle.toString());
}
}","    private void sendNotificationWithStandardUI(byte filterResult, StatusBarNotification statusBarNotification) {
DataBundle dataBundle = new DataBundle();
dataBundle.putParcelable(""data"", StatusBarNotificationData.from(this, statusBarNotification, false));

if (isJobSchedulerEnabled()) {
//comment
String uuid = newKey(statusBarNotification.getKey());
//comment
int notificationId = statusBarNotification.getId();
int id = NotificationJobService.NOTIFICATION_POSTED_STANDARD_UI;
int jobId = notificationId + newUID();
NotificationStore.addStandardNotification(uuid, dataBundle);
scheduleJob(id, jobId, uuid);
Logger.info(""sendNotificationWithStandardUI jobScheduled: "" + jobId + "" \\ uuid: "" + uuid);

} else {
//comment
<start>TransportService.sendWithTransporterHuami(""add"", dataBundle);<end>
Logger.info(""sendNotificationWithStandardUI: "" + dataBundle.toString());
}
}"
6757,"public static NotificationData getMapNotification(Context context, StatusBarNotification statusBarNotification) {

Logger.debug(""getMapNotification package: {} key: {}"", statusBarNotification.getPackageName(), statusBarNotification.getKey());

NotificationData notificationData = null;

if(Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {
notificationData = fromStatusBarNotification(context, statusBarNotification);

RemoteViews rmv = getContentView(context, statusBarNotification.getNotification());
RemoteViews brmv = getBigContentView(context, statusBarNotification.getNotification());

if (rmv == null) {
rmv = brmv;
Logger.debug(""using BigContentView"");
} else {
Logger.debug(""using ContentView"");
}

if (rmv != null) {

//comment
List<String> txt = extractText(rmv);
if ((txt.size() > 0) && (!(txt.get(0).isEmpty()))) {

//comment
try {
<start>LayoutInflater inflater = (LayoutInflater) context.getSystemService(LAYOUT_INFLATER_SERVICE);<end>
View layout = inflater.inflate(R.layout.nav_layout, null);
ViewGroup frame = layout.findViewById(R.id.layout_navi);
frame.removeAllViews();
View newView = rmv.apply(context, frame);
frame.addView(newView);
View viewImage = ((ViewGroup) newView).getChildAt(0);
//comment
<start>viewImage.measure(View.MeasureSpec.UNSPECIFIED, View.MeasureSpec.UNSPECIFIED);<end>
Bitmap bitmap = Bitmap.createBitmap(viewImage.getMeasuredWidth(), viewImage.getMeasuredHeight(), Bitmap.Config.ARGB_8888);
Canvas canvas = new Canvas(bitmap);
viewImage.layout(0, 0, viewImage.getMeasuredWidth(), viewImage.getMeasuredHeight());
viewImage.draw(canvas);
bitmap = Bitmap.createScaledBitmap(bitmap, 48, 48, true);

int width = bitmap.getWidth();
int height = bitmap.getHeight();
int[] intArray = new int[width * height];
bitmap.getPixels(intArray, 0, width, 0, 0, width, height);
Logger.info(""bitmap dimensions: "" + width + "" x "" + height);

notificationData.setIcon(intArray);
notificationData.setIconWidth(width);
notificationData.setIconHeight(height);
} catch (Exception e) {
notificationData.setIcon(new int[]{});
Logger.error(e, ""failed to get bitmap with exception: {}"", e.getMessage());
}

notificationData.setTitle(txt.get(0));
if (txt.size() > 1)
notificationData.setText(txt.get(1));
else
notificationData.setText("""");
notificationData.setHideReplies(true);
notificationData.setHideButtons(false);
notificationData.setForceCustom(true);
}
return notificationData;

} else {
Logger.warn(""null remoteView"");
return null;
}

} else {
isNormalNotification = false;
notificationData = fromStatusBarNotification(context, statusBarNotification);
notificationData.setHideReplies(true);
notificationData.setHideButtons(false);
notificationData.setForceCustom(true);
isNormalNotification = true;
return notificationData;
}
}","public static NotificationData getMapNotification(Context context, StatusBarNotification statusBarNotification) {

Logger.debug(""getMapNotification package: {} key: {}"", statusBarNotification.getPackageName(), statusBarNotification.getKey());

NotificationData notificationData = null;

if(Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {
notificationData = fromStatusBarNotification(context, statusBarNotification);

RemoteViews rmv = getContentView(context, statusBarNotification.getNotification());
RemoteViews brmv = getBigContentView(context, statusBarNotification.getNotification());

if (rmv == null) {
rmv = brmv;
Logger.debug(""using BigContentView"");
} else {
Logger.debug(""using ContentView"");
}

if (rmv != null) {

//comment
List<String> txt = extractText(rmv);
if ((txt.size() > 0) && (!(txt.get(0).isEmpty()))) {

//comment
<start>try {
LayoutInflater inflater = (LayoutInflater) context.getSystemService(LAYOUT_INFLATER_SERVICE);
View layout = inflater.inflate(R.layout.nav_layout, null);
ViewGroup frame = layout.findViewById(R.id.layout_navi);
frame.removeAllViews();
View newView = rmv.apply(context, frame);
frame.addView(newView);
View viewImage = ((ViewGroup) newView).getChildAt(0);
//comment
viewImage.measure(View.MeasureSpec.UNSPECIFIED, View.MeasureSpec.UNSPECIFIED);
Bitmap bitmap = Bitmap.createBitmap(viewImage.getMeasuredWidth(), viewImage.getMeasuredHeight(), Bitmap.Config.ARGB_8888);
Canvas canvas = new Canvas(bitmap);
viewImage.layout(0, 0, viewImage.getMeasuredWidth(), viewImage.getMeasuredHeight());
viewImage.draw(canvas);
bitmap = Bitmap.createScaledBitmap(bitmap, 48, 48, true);

int width = bitmap.getWidth();
int height = bitmap.getHeight();
int[] intArray = new int[width * height];
bitmap.getPixels(intArray, 0, width, 0, 0, width, height);
Logger.info(""bitmap dimensions: "" + width + "" x "" + height);

notificationData.setIcon(intArray);
notificationData.setIconWidth(width);
notificationData.setIconHeight(height);
} catch (Exception e) {<end>
notificationData.setIcon(new int[]{});
Logger.error(e, ""failed to get bitmap with exception: {}"", e.getMessage());
}

notificationData.setTitle(txt.get(0));
if (txt.size() > 1)
notificationData.setText(txt.get(1));
else
notificationData.setText("""");
notificationData.setHideReplies(true);
notificationData.setHideButtons(false);
notificationData.setForceCustom(true);
}
return notificationData;

} else {
Logger.warn(""null remoteView"");
return null;
}

} else {
isNormalNotification = false;
notificationData = fromStatusBarNotification(context, statusBarNotification);
notificationData.setHideReplies(true);
notificationData.setHideButtons(false);
notificationData.setForceCustom(true);
isNormalNotification = true;
return notificationData;
}
}"
6758,"<start>private static List<String> extractText(RemoteViews views) {
//comment
List<String> text = new ArrayList<>();<end>
try {
Field field = views.getClass().getDeclaredField(""mActions"");
field.setAccessible(true);
//comment

@SuppressWarnings(""unchecked"")
ArrayList<Parcelable> actions = (ArrayList<Parcelable>) field.get(views);

//comment
for (Parcelable p : actions) {
Parcel parcel = Parcel.obtain();
p.writeToParcel(parcel, 0);
parcel.setDataPosition(0);

//comment
int tag = parcel.readInt();
if (tag != 2) continue;

//comment
parcel.readInt();

String methodName = parcel.readString();
if (methodName == null)
continue;
//comment
else {

if (methodName.equals(""setText"")) {
//comment
parcel.readInt();

//comment
String t = TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(parcel).toString().trim();
text.add(t);
//comment
//comment
}
}
parcel.recycle();
}
}
//comment
catch (Exception e) {
Logger.error(e, ""extractText exception: {}"", e.getMessage());
text.add(""ERROR"");
}
return text;
}","private static List<String> extractText(RemoteViews views) {
//comment
<start>List<String> text = new ArrayList<>();
try {
Field field = views.getClass().getDeclaredField(""mActions"");
field.setAccessible(true);
//comment

@SuppressWarnings(""unchecked"")
ArrayList<Parcelable> actions = (ArrayList<Parcelable>) field.get(views);

//comment
for (Parcelable p : actions) {
Parcel parcel = Parcel.obtain();
p.writeToParcel(parcel, 0);
parcel.setDataPosition(0);

//comment
int tag = parcel.readInt();
if (tag != 2) continue;

//comment
parcel.readInt();

String methodName = parcel.readString();
if (methodName == null)
continue;
//comment
else {

if (methodName.equals(""setText"")) {
//comment
parcel.readInt();

//comment
String t = TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(parcel).toString().trim();
text.add(t);
//comment
//comment
}
}
parcel.recycle();
}
}
//comment
catch (Exception e) {
Logger.error(e, ""extractText exception: {}"", e.getMessage());
text.add(""ERROR"");
}<end>
return text;
}"
6759,"private static List<String> extractText(RemoteViews views) {
//comment
List<String> text = new ArrayList<>();
try {
Field field = views.getClass().getDeclaredField(""mActions"");
field.setAccessible(true);
//comment

@SuppressWarnings(""unchecked"")
ArrayList<Parcelable> actions = (ArrayList<Parcelable>) field.get(views);

//comment
for (Parcelable p : actions) {
Parcel parcel = Parcel.obtain();
p.writeToParcel(parcel, 0);
parcel.setDataPosition(0);

//comment
int tag = parcel.readInt();
if (tag != 2) continue;

//comment
parcel.readInt();

String methodName = parcel.readString();
if (methodName == null)
continue;
//comment
else {

if (methodName.equals(""setText"")) {
//comment
parcel.readInt();

//comment
<start>String t = TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(parcel).toString().trim();<end>
text.add(t);
//comment
//comment
}
}
parcel.recycle();
}
}
//comment
catch (Exception e) {
Logger.error(e, ""extractText exception: {}"", e.getMessage());
text.add(""ERROR"");
}
return text;
}","private static List<String> extractText(RemoteViews views) {
//comment
List<String> text = new ArrayList<>();
try {
Field field = views.getClass().getDeclaredField(""mActions"");
field.setAccessible(true);
//comment

@SuppressWarnings(""unchecked"")
ArrayList<Parcelable> actions = (ArrayList<Parcelable>) field.get(views);

//comment
for (Parcelable p : actions) {
Parcel parcel = Parcel.obtain();
p.writeToParcel(parcel, 0);
parcel.setDataPosition(0);

//comment
int tag = parcel.readInt();
if (tag != 2) continue;

//comment
parcel.readInt();

String methodName = parcel.readString();
if (methodName == null)
continue;
//comment
else {

if (methodName.equals(""setText"")) {
//comment
parcel.readInt();

//comment
<start>String t = TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(parcel).toString().trim();
text.add(t);<end>
//comment
//comment
}
}
parcel.recycle();
}
}
//comment
catch (Exception e) {
Logger.error(e, ""extractText exception: {}"", e.getMessage());
text.add(""ERROR"");
}
return text;
}"
1005,"@SuppressLint(""ClickableViewAccessibility"")
@Override
public void onCreate(@Nullable Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
binding = ActivityStatsBinding.inflate(getLayoutInflater());
setContentView(binding.getRoot());
logFile = this.getExternalFilesDir(null) + File.separator + Constants.LOGFILE;
Logger.debug(""logFile: {}"", logFile);

try {
getSupportActionBar().setDisplayHomeAsUpEnabled(true);
getSupportActionBar().setTitle(R.string.stats);
<start>} catch (NullPointerException exception) {
Logger.error(exception.getMessage());<end>
//comment
}

snackProgressBarManager = new SnackProgressBarManager(findViewById(android.R.id.content))
//comment
//comment
//comment
.setProgressBarColor(ThemeHelper.getThemeColorAccentId(this))
<start>.setActionTextColor(ThemeHelper.getThemeColorAccentId(this))
//comment
.setBackgroundColor(SnackProgressBarManager.BACKGROUND_COLOR_DEFAULT)<end>
//comment
.setTextSize(14)
//comment
.setMessageMaxLines(2)
//comment
<start>.setOnDisplayListener(new SnackProgressBarManager.OnDisplayListener() {<end>
@Override
public void onShown(@NonNull SnackProgressBar snackProgressBar, int onDisplayId) {
//comment
}

@Override
public void onDismissed(@NonNull SnackProgressBar snackProgressBar, int onDisplayId) {
//comment
}
});

//comment
binding.activityStatsLogsContent.setMovementMethod(new ScrollingMovementMethod());
binding.activityStatsRootLayout.setOnTouchListener((v, event) -> {
binding.activityStatsLogsContent.getParent().requestDisallowInterceptTouchEvent(false);
//comment
return false;
});

binding.activityStatsLogsContent.setOnTouchListener((v, event) -> {
binding.activityStatsLogsContent.getParent().requestDisallowInterceptTouchEvent(true);
return false;
});
//comment
//comment
//comment
//comment
//comment
//comment
//comment
binding.activityStatsOpenNotificationsLog.setOnClickListener(v -> {
startActivity(new Intent(this, NotificationsLogActivity.class));
});


binding.activityStatsGenerateBundle.setOnClickListener(v -> {
String generateBundleCmd = ShellCommandHelper.getLogBundleCommand();
generateLogBundle(generateBundleCmd);
});

binding.activityStatsClearLogs.setOnClickListener(v -> {
try {
binding.activityStatsLogsContent.setText("""");
FileWriter fw = new FileWriter(logFile, false);
} catch (IOException e) {
Logger.error(e, ""clearLogs: can't empty file: {}"", logFile);
}
});


binding.activityStatsSendLogs.setOnClickListener(v -> {
sendLogs();
});
}","@SuppressLint(""ClickableViewAccessibility"")
@Override
public void onCreate(@Nullable Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
binding = ActivityStatsBinding.inflate(getLayoutInflater());
setContentView(binding.getRoot());
logFile = this.getExternalFilesDir(null) + File.separator + Constants.LOGFILE;
Logger.debug(""logFile: {}"", logFile);

try {
getSupportActionBar().setDisplayHomeAsUpEnabled(true);
getSupportActionBar().setTitle(R.string.stats);
} catch (NullPointerException exception) {
Logger.error(exception.getMessage());
//comment
}

snackProgressBarManager = new SnackProgressBarManager(findViewById(android.R.id.content))
//comment
//comment
//comment
.setProgressBarColor(ThemeHelper.getThemeColorAccentId(this))
.setActionTextColor(ThemeHelper.getThemeColorAccentId(this))
//comment
<start>.setBackgroundColor(SnackProgressBarManager.BACKGROUND_COLOR_DEFAULT)<end>
//comment
.setTextSize(14)
//comment
.setMessageMaxLines(2)
//comment
.setOnDisplayListener(new SnackProgressBarManager.OnDisplayListener() {
@Override
public void onShown(@NonNull SnackProgressBar snackProgressBar, int onDisplayId) {
//comment
}

@Override
public void onDismissed(@NonNull SnackProgressBar snackProgressBar, int onDisplayId) {
//comment
}
});

//comment
binding.activityStatsLogsContent.setMovementMethod(new ScrollingMovementMethod());
binding.activityStatsRootLayout.setOnTouchListener((v, event) -> {
binding.activityStatsLogsContent.getParent().requestDisallowInterceptTouchEvent(false);
//comment
return false;
});

binding.activityStatsLogsContent.setOnTouchListener((v, event) -> {
binding.activityStatsLogsContent.getParent().requestDisallowInterceptTouchEvent(true);
return false;
});
//comment
//comment
//comment
//comment
//comment
//comment
//comment
binding.activityStatsOpenNotificationsLog.setOnClickListener(v -> {
startActivity(new Intent(this, NotificationsLogActivity.class));
});


binding.activityStatsGenerateBundle.setOnClickListener(v -> {
String generateBundleCmd = ShellCommandHelper.getLogBundleCommand();
generateLogBundle(generateBundleCmd);
});

binding.activityStatsClearLogs.setOnClickListener(v -> {
try {
binding.activityStatsLogsContent.setText("""");
FileWriter fw = new FileWriter(logFile, false);
} catch (IOException e) {
Logger.error(e, ""clearLogs: can't empty file: {}"", logFile);
}
});


binding.activityStatsSendLogs.setOnClickListener(v -> {
sendLogs();
});
}"
1006,"@SuppressLint(""ClickableViewAccessibility"")
@Override
public void onCreate(@Nullable Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
binding = ActivityStatsBinding.inflate(getLayoutInflater());
setContentView(binding.getRoot());
logFile = this.getExternalFilesDir(null) + File.separator + Constants.LOGFILE;
Logger.debug(""logFile: {}"", logFile);

try {
getSupportActionBar().setDisplayHomeAsUpEnabled(true);
getSupportActionBar().setTitle(R.string.stats);
} catch (NullPointerException exception) {
Logger.error(exception.getMessage());
//comment
}

snackProgressBarManager = new SnackProgressBarManager(findViewById(android.R.id.content))
//comment
//comment
//comment
.setProgressBarColor(ThemeHelper.getThemeColorAccentId(this))
.setActionTextColor(ThemeHelper.getThemeColorAccentId(this))
//comment
<start>.setBackgroundColor(SnackProgressBarManager.BACKGROUND_COLOR_DEFAULT)<end>
//comment
.setTextSize(14)
//comment
<start>.setMessageMaxLines(2)<end>
//comment
.setOnDisplayListener(new SnackProgressBarManager.OnDisplayListener() {
@Override
public void onShown(@NonNull SnackProgressBar snackProgressBar, int onDisplayId) {
//comment
}

@Override
public void onDismissed(@NonNull SnackProgressBar snackProgressBar, int onDisplayId) {
//comment
}
});

//comment
binding.activityStatsLogsContent.setMovementMethod(new ScrollingMovementMethod());
binding.activityStatsRootLayout.setOnTouchListener((v, event) -> {
binding.activityStatsLogsContent.getParent().requestDisallowInterceptTouchEvent(false);
//comment
return false;
});

binding.activityStatsLogsContent.setOnTouchListener((v, event) -> {
binding.activityStatsLogsContent.getParent().requestDisallowInterceptTouchEvent(true);
return false;
});
//comment
//comment
//comment
//comment
//comment
//comment
//comment
binding.activityStatsOpenNotificationsLog.setOnClickListener(v -> {
startActivity(new Intent(this, NotificationsLogActivity.class));
});


binding.activityStatsGenerateBundle.setOnClickListener(v -> {
String generateBundleCmd = ShellCommandHelper.getLogBundleCommand();
generateLogBundle(generateBundleCmd);
});

binding.activityStatsClearLogs.setOnClickListener(v -> {
try {
binding.activityStatsLogsContent.setText("""");
FileWriter fw = new FileWriter(logFile, false);
} catch (IOException e) {
Logger.error(e, ""clearLogs: can't empty file: {}"", logFile);
}
});


binding.activityStatsSendLogs.setOnClickListener(v -> {
sendLogs();
});
}","@SuppressLint(""ClickableViewAccessibility"")
@Override
public void onCreate(@Nullable Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
binding = ActivityStatsBinding.inflate(getLayoutInflater());
setContentView(binding.getRoot());
logFile = this.getExternalFilesDir(null) + File.separator + Constants.LOGFILE;
Logger.debug(""logFile: {}"", logFile);

try {
getSupportActionBar().setDisplayHomeAsUpEnabled(true);
getSupportActionBar().setTitle(R.string.stats);
} catch (NullPointerException exception) {
Logger.error(exception.getMessage());
//comment
}

snackProgressBarManager = new SnackProgressBarManager(findViewById(android.R.id.content))
//comment
//comment
//comment
.setProgressBarColor(ThemeHelper.getThemeColorAccentId(this))
.setActionTextColor(ThemeHelper.getThemeColorAccentId(this))
//comment
.setBackgroundColor(SnackProgressBarManager.BACKGROUND_COLOR_DEFAULT)
//comment
<start>.setTextSize(14)<end>
//comment
.setMessageMaxLines(2)
//comment
.setOnDisplayListener(new SnackProgressBarManager.OnDisplayListener() {
@Override
public void onShown(@NonNull SnackProgressBar snackProgressBar, int onDisplayId) {
//comment
}

@Override
public void onDismissed(@NonNull SnackProgressBar snackProgressBar, int onDisplayId) {
//comment
}
});

//comment
binding.activityStatsLogsContent.setMovementMethod(new ScrollingMovementMethod());
binding.activityStatsRootLayout.setOnTouchListener((v, event) -> {
binding.activityStatsLogsContent.getParent().requestDisallowInterceptTouchEvent(false);
//comment
return false;
});

binding.activityStatsLogsContent.setOnTouchListener((v, event) -> {
binding.activityStatsLogsContent.getParent().requestDisallowInterceptTouchEvent(true);
return false;
});
//comment
//comment
//comment
//comment
//comment
//comment
//comment
binding.activityStatsOpenNotificationsLog.setOnClickListener(v -> {
startActivity(new Intent(this, NotificationsLogActivity.class));
});


binding.activityStatsGenerateBundle.setOnClickListener(v -> {
String generateBundleCmd = ShellCommandHelper.getLogBundleCommand();
generateLogBundle(generateBundleCmd);
});

binding.activityStatsClearLogs.setOnClickListener(v -> {
try {
binding.activityStatsLogsContent.setText("""");
FileWriter fw = new FileWriter(logFile, false);
} catch (IOException e) {
Logger.error(e, ""clearLogs: can't empty file: {}"", logFile);
}
});


binding.activityStatsSendLogs.setOnClickListener(v -> {
sendLogs();
});
}"
1007,"@SuppressLint(""ClickableViewAccessibility"")
@Override
public void onCreate(@Nullable Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
binding = ActivityStatsBinding.inflate(getLayoutInflater());
setContentView(binding.getRoot());
logFile = this.getExternalFilesDir(null) + File.separator + Constants.LOGFILE;
Logger.debug(""logFile: {}"", logFile);

try {
getSupportActionBar().setDisplayHomeAsUpEnabled(true);
getSupportActionBar().setTitle(R.string.stats);
} catch (NullPointerException exception) {
Logger.error(exception.getMessage());
//comment
}

snackProgressBarManager = new SnackProgressBarManager(findViewById(android.R.id.content))
//comment
//comment
//comment
.setProgressBarColor(ThemeHelper.getThemeColorAccentId(this))
.setActionTextColor(ThemeHelper.getThemeColorAccentId(this))
//comment
.setBackgroundColor(SnackProgressBarManager.BACKGROUND_COLOR_DEFAULT)
//comment
.setTextSize(14)
//comment
<start>.setMessageMaxLines(2)<end>
//comment
.setOnDisplayListener(new SnackProgressBarManager.OnDisplayListener() {
@Override
public void onShown(@NonNull SnackProgressBar snackProgressBar, int onDisplayId) {
//comment
}

@Override
public void onDismissed(@NonNull SnackProgressBar snackProgressBar, int onDisplayId) {
//comment
}
});

//comment
binding.activityStatsLogsContent.setMovementMethod(new ScrollingMovementMethod());
binding.activityStatsRootLayout.setOnTouchListener((v, event) -> {
binding.activityStatsLogsContent.getParent().requestDisallowInterceptTouchEvent(false);
//comment
return false;
});

binding.activityStatsLogsContent.setOnTouchListener((v, event) -> {
binding.activityStatsLogsContent.getParent().requestDisallowInterceptTouchEvent(true);
return false;
});
//comment
//comment
//comment
//comment
//comment
//comment
//comment
binding.activityStatsOpenNotificationsLog.setOnClickListener(v -> {
startActivity(new Intent(this, NotificationsLogActivity.class));
});


binding.activityStatsGenerateBundle.setOnClickListener(v -> {
String generateBundleCmd = ShellCommandHelper.getLogBundleCommand();
generateLogBundle(generateBundleCmd);
});

binding.activityStatsClearLogs.setOnClickListener(v -> {
try {
binding.activityStatsLogsContent.setText("""");
FileWriter fw = new FileWriter(logFile, false);
} catch (IOException e) {
Logger.error(e, ""clearLogs: can't empty file: {}"", logFile);
}
});


binding.activityStatsSendLogs.setOnClickListener(v -> {
sendLogs();
});
}","@SuppressLint(""ClickableViewAccessibility"")
@Override
public void onCreate(@Nullable Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
binding = ActivityStatsBinding.inflate(getLayoutInflater());
setContentView(binding.getRoot());
logFile = this.getExternalFilesDir(null) + File.separator + Constants.LOGFILE;
Logger.debug(""logFile: {}"", logFile);

try {
getSupportActionBar().setDisplayHomeAsUpEnabled(true);
getSupportActionBar().setTitle(R.string.stats);
} catch (NullPointerException exception) {
Logger.error(exception.getMessage());
//comment
}

snackProgressBarManager = new SnackProgressBarManager(findViewById(android.R.id.content))
//comment
//comment
//comment
.setProgressBarColor(ThemeHelper.getThemeColorAccentId(this))
.setActionTextColor(ThemeHelper.getThemeColorAccentId(this))
//comment
.setBackgroundColor(SnackProgressBarManager.BACKGROUND_COLOR_DEFAULT)
//comment
.setTextSize(14)
//comment
<start>.setMessageMaxLines(2)<end>
//comment
.setOnDisplayListener(new SnackProgressBarManager.OnDisplayListener() {
@Override
public void onShown(@NonNull SnackProgressBar snackProgressBar, int onDisplayId) {
//comment
}

@Override
public void onDismissed(@NonNull SnackProgressBar snackProgressBar, int onDisplayId) {
//comment
}
});

//comment
binding.activityStatsLogsContent.setMovementMethod(new ScrollingMovementMethod());
binding.activityStatsRootLayout.setOnTouchListener((v, event) -> {
binding.activityStatsLogsContent.getParent().requestDisallowInterceptTouchEvent(false);
//comment
return false;
});

binding.activityStatsLogsContent.setOnTouchListener((v, event) -> {
binding.activityStatsLogsContent.getParent().requestDisallowInterceptTouchEvent(true);
return false;
});
//comment
//comment
//comment
//comment
//comment
//comment
//comment
binding.activityStatsOpenNotificationsLog.setOnClickListener(v -> {
startActivity(new Intent(this, NotificationsLogActivity.class));
});


binding.activityStatsGenerateBundle.setOnClickListener(v -> {
String generateBundleCmd = ShellCommandHelper.getLogBundleCommand();
generateLogBundle(generateBundleCmd);
});

binding.activityStatsClearLogs.setOnClickListener(v -> {
try {
binding.activityStatsLogsContent.setText("""");
FileWriter fw = new FileWriter(logFile, false);
} catch (IOException e) {
Logger.error(e, ""clearLogs: can't empty file: {}"", logFile);
}
});


binding.activityStatsSendLogs.setOnClickListener(v -> {
sendLogs();
});
}"
1008,"@SuppressLint(""ClickableViewAccessibility"")
@Override
public void onCreate(@Nullable Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
binding = ActivityStatsBinding.inflate(getLayoutInflater());
setContentView(binding.getRoot());
logFile = this.getExternalFilesDir(null) + File.separator + Constants.LOGFILE;
Logger.debug(""logFile: {}"", logFile);

try {
getSupportActionBar().setDisplayHomeAsUpEnabled(true);
getSupportActionBar().setTitle(R.string.stats);
} catch (NullPointerException exception) {
Logger.error(exception.getMessage());
//comment
}

snackProgressBarManager = new SnackProgressBarManager(findViewById(android.R.id.content))
//comment
//comment
//comment
.setProgressBarColor(ThemeHelper.getThemeColorAccentId(this))
.setActionTextColor(ThemeHelper.getThemeColorAccentId(this))
//comment
.setBackgroundColor(SnackProgressBarManager.BACKGROUND_COLOR_DEFAULT)
//comment
.setTextSize(14)
//comment
<start>.setMessageMaxLines(2)
//comment
.setOnDisplayListener(new SnackProgressBarManager.OnDisplayListener() {<end>
@Override
public void onShown(@NonNull SnackProgressBar snackProgressBar, int onDisplayId) {
//comment
}

@Override
public void onDismissed(@NonNull SnackProgressBar snackProgressBar, int onDisplayId) {
//comment
}
});

//comment
binding.activityStatsLogsContent.setMovementMethod(new ScrollingMovementMethod());
binding.activityStatsRootLayout.setOnTouchListener((v, event) -> {
binding.activityStatsLogsContent.getParent().requestDisallowInterceptTouchEvent(false);
//comment
return false;
});

binding.activityStatsLogsContent.setOnTouchListener((v, event) -> {
binding.activityStatsLogsContent.getParent().requestDisallowInterceptTouchEvent(true);
return false;
});
//comment
//comment
//comment
//comment
//comment
//comment
//comment
binding.activityStatsOpenNotificationsLog.setOnClickListener(v -> {
startActivity(new Intent(this, NotificationsLogActivity.class));
});


binding.activityStatsGenerateBundle.setOnClickListener(v -> {
String generateBundleCmd = ShellCommandHelper.getLogBundleCommand();
generateLogBundle(generateBundleCmd);
});

binding.activityStatsClearLogs.setOnClickListener(v -> {
try {
binding.activityStatsLogsContent.setText("""");
FileWriter fw = new FileWriter(logFile, false);
} catch (IOException e) {
Logger.error(e, ""clearLogs: can't empty file: {}"", logFile);
}
});


binding.activityStatsSendLogs.setOnClickListener(v -> {
sendLogs();
});
}","@SuppressLint(""ClickableViewAccessibility"")
@Override
public void onCreate(@Nullable Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
binding = ActivityStatsBinding.inflate(getLayoutInflater());
setContentView(binding.getRoot());
logFile = this.getExternalFilesDir(null) + File.separator + Constants.LOGFILE;
Logger.debug(""logFile: {}"", logFile);

try {
getSupportActionBar().setDisplayHomeAsUpEnabled(true);
getSupportActionBar().setTitle(R.string.stats);
} catch (NullPointerException exception) {
Logger.error(exception.getMessage());
//comment
}

snackProgressBarManager = new SnackProgressBarManager(findViewById(android.R.id.content))
//comment
//comment
//comment
.setProgressBarColor(ThemeHelper.getThemeColorAccentId(this))
.setActionTextColor(ThemeHelper.getThemeColorAccentId(this))
//comment
.setBackgroundColor(SnackProgressBarManager.BACKGROUND_COLOR_DEFAULT)
//comment
.setTextSize(14)
//comment
.setMessageMaxLines(2)
//comment
<start>.setOnDisplayListener(new SnackProgressBarManager.OnDisplayListener() {
@Override
public void onShown(@NonNull SnackProgressBar snackProgressBar, int onDisplayId) {
//comment
}

@Override
public void onDismissed(@NonNull SnackProgressBar snackProgressBar, int onDisplayId) {
//comment
}
});<end>

//comment
binding.activityStatsLogsContent.setMovementMethod(new ScrollingMovementMethod());
binding.activityStatsRootLayout.setOnTouchListener((v, event) -> {
binding.activityStatsLogsContent.getParent().requestDisallowInterceptTouchEvent(false);
//comment
return false;
});

binding.activityStatsLogsContent.setOnTouchListener((v, event) -> {
binding.activityStatsLogsContent.getParent().requestDisallowInterceptTouchEvent(true);
return false;
});
//comment
//comment
//comment
//comment
//comment
//comment
//comment
binding.activityStatsOpenNotificationsLog.setOnClickListener(v -> {
startActivity(new Intent(this, NotificationsLogActivity.class));
});


binding.activityStatsGenerateBundle.setOnClickListener(v -> {
String generateBundleCmd = ShellCommandHelper.getLogBundleCommand();
generateLogBundle(generateBundleCmd);
});

binding.activityStatsClearLogs.setOnClickListener(v -> {
try {
binding.activityStatsLogsContent.setText("""");
FileWriter fw = new FileWriter(logFile, false);
} catch (IOException e) {
Logger.error(e, ""clearLogs: can't empty file: {}"", logFile);
}
});


binding.activityStatsSendLogs.setOnClickListener(v -> {
sendLogs();
});
}"
1009,"@SuppressLint(""ClickableViewAccessibility"")
@Override
public void onCreate(@Nullable Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
binding = ActivityStatsBinding.inflate(getLayoutInflater());
setContentView(binding.getRoot());
logFile = this.getExternalFilesDir(null) + File.separator + Constants.LOGFILE;
Logger.debug(""logFile: {}"", logFile);

try {
getSupportActionBar().setDisplayHomeAsUpEnabled(true);
getSupportActionBar().setTitle(R.string.stats);
} catch (NullPointerException exception) {
Logger.error(exception.getMessage());
//comment
}

snackProgressBarManager = new SnackProgressBarManager(findViewById(android.R.id.content))
//comment
//comment
//comment
.setProgressBarColor(ThemeHelper.getThemeColorAccentId(this))
.setActionTextColor(ThemeHelper.getThemeColorAccentId(this))
//comment
.setBackgroundColor(SnackProgressBarManager.BACKGROUND_COLOR_DEFAULT)
//comment
.setTextSize(14)
//comment
.setMessageMaxLines(2)
//comment
.setOnDisplayListener(new SnackProgressBarManager.OnDisplayListener() {
@Override
public void onShown(@NonNull SnackProgressBar snackProgressBar, int onDisplayId) {
//comment
}

@Override
public void onDismissed(@NonNull SnackProgressBar snackProgressBar, int onDisplayId) {
//comment
}
});

//comment
<start>binding.activityStatsLogsContent.setMovementMethod(new ScrollingMovementMethod());<end>
binding.activityStatsRootLayout.setOnTouchListener((v, event) -> {
<start>binding.activityStatsLogsContent.getParent().requestDisallowInterceptTouchEvent(false);<end>
//comment
return false;
});

binding.activityStatsLogsContent.setOnTouchListener((v, event) -> {
binding.activityStatsLogsContent.getParent().requestDisallowInterceptTouchEvent(true);
return false;
});
//comment
//comment
//comment
//comment
//comment
//comment
//comment
binding.activityStatsOpenNotificationsLog.setOnClickListener(v -> {
startActivity(new Intent(this, NotificationsLogActivity.class));
});


binding.activityStatsGenerateBundle.setOnClickListener(v -> {
String generateBundleCmd = ShellCommandHelper.getLogBundleCommand();
generateLogBundle(generateBundleCmd);
});

binding.activityStatsClearLogs.setOnClickListener(v -> {
try {
binding.activityStatsLogsContent.setText("""");
FileWriter fw = new FileWriter(logFile, false);
} catch (IOException e) {
Logger.error(e, ""clearLogs: can't empty file: {}"", logFile);
}
});


binding.activityStatsSendLogs.setOnClickListener(v -> {
sendLogs();
});
}","@SuppressLint(""ClickableViewAccessibility"")
@Override
public void onCreate(@Nullable Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
binding = ActivityStatsBinding.inflate(getLayoutInflater());
setContentView(binding.getRoot());
logFile = this.getExternalFilesDir(null) + File.separator + Constants.LOGFILE;
Logger.debug(""logFile: {}"", logFile);

try {
getSupportActionBar().setDisplayHomeAsUpEnabled(true);
getSupportActionBar().setTitle(R.string.stats);
} catch (NullPointerException exception) {
Logger.error(exception.getMessage());
//comment
}

snackProgressBarManager = new SnackProgressBarManager(findViewById(android.R.id.content))
//comment
//comment
//comment
.setProgressBarColor(ThemeHelper.getThemeColorAccentId(this))
.setActionTextColor(ThemeHelper.getThemeColorAccentId(this))
//comment
.setBackgroundColor(SnackProgressBarManager.BACKGROUND_COLOR_DEFAULT)
//comment
.setTextSize(14)
//comment
.setMessageMaxLines(2)
//comment
.setOnDisplayListener(new SnackProgressBarManager.OnDisplayListener() {
@Override
public void onShown(@NonNull SnackProgressBar snackProgressBar, int onDisplayId) {
//comment
}

@Override
public void onDismissed(@NonNull SnackProgressBar snackProgressBar, int onDisplayId) {
//comment
}
});

//comment
<start>binding.activityStatsLogsContent.setMovementMethod(new ScrollingMovementMethod());<end>
binding.activityStatsRootLayout.setOnTouchListener((v, event) -> {
binding.activityStatsLogsContent.getParent().requestDisallowInterceptTouchEvent(false);
//comment
return false;
});

binding.activityStatsLogsContent.setOnTouchListener((v, event) -> {
binding.activityStatsLogsContent.getParent().requestDisallowInterceptTouchEvent(true);
return false;
});
//comment
//comment
//comment
//comment
//comment
//comment
//comment
binding.activityStatsOpenNotificationsLog.setOnClickListener(v -> {
startActivity(new Intent(this, NotificationsLogActivity.class));
});


binding.activityStatsGenerateBundle.setOnClickListener(v -> {
String generateBundleCmd = ShellCommandHelper.getLogBundleCommand();
generateLogBundle(generateBundleCmd);
});

binding.activityStatsClearLogs.setOnClickListener(v -> {
try {
binding.activityStatsLogsContent.setText("""");
FileWriter fw = new FileWriter(logFile, false);
} catch (IOException e) {
Logger.error(e, ""clearLogs: can't empty file: {}"", logFile);
}
});


binding.activityStatsSendLogs.setOnClickListener(v -> {
sendLogs();
});
}"
1010,"private void sendLogs() {
final String logContent = binding.activityStatsLogsContent.getText().toString();
Logger.trace(""logTextView: {} logFile: {}"", logContent.substring(0, Math.min(logContent.length(), 48)), logFile);

//comment
//comment
//comment
//comment
//comment
//comment

<start>File file = new File(logFile);<end>
if (file.exists()) {
<start>Uri path = Build.VERSION.SDK_INT >= Build.VERSION_CODES.N ?
FileProvider.getUriForFile(this, Constants.FILE_PROVIDER, file)
: Uri.fromFile(file);<end>
Intent sendIntent = new Intent(Intent.ACTION_SEND);
sendIntent.putExtra(Intent.EXTRA_TEXT, ""AmazMod Phone Logs"");
sendIntent.putExtra(Intent.EXTRA_STREAM, path);
sendIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
sendIntent.setType(""plain/*"");
startActivity(Intent.createChooser(sendIntent, getString(R.string.send_log)));
} else
Toast.makeText(this, getString(R.string.file_not_found), Toast.LENGTH_LONG).show();

}","private void sendLogs() {
final String logContent = binding.activityStatsLogsContent.getText().toString();
Logger.trace(""logTextView: {} logFile: {}"", logContent.substring(0, Math.min(logContent.length(), 48)), logFile);

//comment
//comment
//comment
//comment
//comment
//comment

<start>File file = new File(logFile);<end>
if (file.exists()) {
Uri path = Build.VERSION.SDK_INT >= Build.VERSION_CODES.N ?
FileProvider.getUriForFile(this, Constants.FILE_PROVIDER, file)
: Uri.fromFile(file);
<start>Intent sendIntent = new Intent(Intent.ACTION_SEND);
sendIntent.putExtra(Intent.EXTRA_TEXT, ""AmazMod Phone Logs"");
sendIntent.putExtra(Intent.EXTRA_STREAM, path);
sendIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
sendIntent.setType(""plain/*"");
startActivity(Intent.createChooser(sendIntent, getString(R.string.send_log)));<end>
} else
Toast.makeText(this, getString(R.string.file_not_found), Toast.LENGTH_LONG).show();

}"
3386,"public void run() {
notificationManager.post(notificationData);
//comment
//comment
if (!DeviceUtil.isDNDActive(context)) {
<start>final Vibrator vibrator = (Vibrator) getSystemService(VIBRATOR_SERVICE);<end>
if (vibrator == null) return;

try {
vibrator.vibrate(new long[]{1000 , vibrate}, -1);
} catch (Exception e) {
Logger.error(""vibrator exception: {}"", e.getMessage());
}
}

isRunning = false;
}","public void run() {
notificationManager.post(notificationData);
//comment
//comment
<start>if (!DeviceUtil.isDNDActive(context)) {
final Vibrator vibrator = (Vibrator) getSystemService(VIBRATOR_SERVICE);
if (vibrator == null) return;<end>

try {
vibrator.vibrate(new long[]{1000 , vibrate}, -1);
} catch (Exception e) {
Logger.error(""vibrator exception: {}"", e.getMessage());
}
}

isRunning = false;
}"
3406,"@Subscribe(threadMode = ThreadMode.BACKGROUND)
public void deleteNotification(DeleteNotificationEvent deleteNotificationEvent) {
boolean enableCustomUI = settingsManager.getBoolean(Constants.PREF_NOTIFICATIONS_ENABLE_CUSTOM_UI, false);
StatusBarNotificationData statusBarNotificationData = deleteNotificationEvent.getDataBundle().getParcelable(""data"");
String key = statusBarNotificationData.key;
Logger.warn(""deleteNotification enableCustomUI: {} \\ key: {}"", enableCustomUI, key);

//comment
<start>DeviceUtil.notificationCounter(context, -1);<end>

//comment
if (!enableCustomUI) return;

if (key != null) {
if (NotificationStore.getCustomNotificationCount() > 0)
for (ArrayMap.Entry<String, String> pair : NotificationStore.keyMap.entrySet()) {
//comment

if (key.equals(pair.getValue())) {
Logger.warn(""deleteNotification removing: {}"", pair.getKey());
NotificationStore.removeCustomNotification(pair.getKey(), context);
}
}
else
Logger.warn(""deleteNotification empty NotificationStore"");
}
}","@Subscribe(threadMode = ThreadMode.BACKGROUND)
public void deleteNotification(DeleteNotificationEvent deleteNotificationEvent) {
boolean enableCustomUI = settingsManager.getBoolean(Constants.PREF_NOTIFICATIONS_ENABLE_CUSTOM_UI, false);
StatusBarNotificationData statusBarNotificationData = deleteNotificationEvent.getDataBundle().getParcelable(""data"");
String key = statusBarNotificationData.key;
Logger.warn(""deleteNotification enableCustomUI: {} \\ key: {}"", enableCustomUI, key);

//comment
<start>DeviceUtil.notificationCounter(context, -1);<end>

//comment
if (!enableCustomUI) return;

if (key != null) {
if (NotificationStore.getCustomNotificationCount() > 0)
for (ArrayMap.Entry<String, String> pair : NotificationStore.keyMap.entrySet()) {
//comment

if (key.equals(pair.getValue())) {
Logger.warn(""deleteNotification removing: {}"", pair.getKey());
NotificationStore.removeCustomNotification(pair.getKey(), context);
}
}
else
Logger.warn(""deleteNotification empty NotificationStore"");
}
}"
3407,"@Subscribe(threadMode = ThreadMode.BACKGROUND)
public void deleteNotification(DeleteNotificationEvent deleteNotificationEvent) {
boolean enableCustomUI = settingsManager.getBoolean(Constants.PREF_NOTIFICATIONS_ENABLE_CUSTOM_UI, false);
StatusBarNotificationData statusBarNotificationData = deleteNotificationEvent.getDataBundle().getParcelable(""data"");
String key = statusBarNotificationData.key;
Logger.warn(""deleteNotification enableCustomUI: {} \\ key: {}"", enableCustomUI, key);

//comment
DeviceUtil.notificationCounter(context, -1);

//comment
<start>if (!enableCustomUI) return;<end>

if (key != null) {
if (NotificationStore.getCustomNotificationCount() > 0)
for (ArrayMap.Entry<String, String> pair : NotificationStore.keyMap.entrySet()) {
//comment

if (key.equals(pair.getValue())) {
Logger.warn(""deleteNotification removing: {}"", pair.getKey());
NotificationStore.removeCustomNotification(pair.getKey(), context);
}
}
else
Logger.warn(""deleteNotification empty NotificationStore"");
}
}","@Subscribe(threadMode = ThreadMode.BACKGROUND)
public void deleteNotification(DeleteNotificationEvent deleteNotificationEvent) {
boolean enableCustomUI = settingsManager.getBoolean(Constants.PREF_NOTIFICATIONS_ENABLE_CUSTOM_UI, false);
StatusBarNotificationData statusBarNotificationData = deleteNotificationEvent.getDataBundle().getParcelable(""data"");
String key = statusBarNotificationData.key;
Logger.warn(""deleteNotification enableCustomUI: {} \\ key: {}"", enableCustomUI, key);

//comment
DeviceUtil.notificationCounter(context, -1);

//comment
<start>if (!enableCustomUI) return;<end>

if (key != null) {
if (NotificationStore.getCustomNotificationCount() > 0)
for (ArrayMap.Entry<String, String> pair : NotificationStore.keyMap.entrySet()) {
//comment

if (key.equals(pair.getValue())) {
Logger.warn(""deleteNotification removing: {}"", pair.getKey());
NotificationStore.removeCustomNotification(pair.getKey(), context);
}
}
else
Logger.warn(""deleteNotification empty NotificationStore"");
}
}"
2903,"public void onSensorChanged(SensorEvent sensorEvent) {
if (sleepStore.isSuspended()) return;
float x = sensorEvent.values[0];
float y = sensorEvent.values[1];
float z = sensorEvent.values[2];

//comment
float max = abs(x - lastX) + abs(y - lastY) + abs(z - lastZ);
if (max > current_max_data) current_max_data = max;
float max_raw = (float) sqrt((x * x) + (y * y) + (z * z));
if (max_raw > current_max_raw_data) current_max_raw_data = max_raw;
lastX = x;
lastY = y;
lastZ = z;

int tsMillis = (int) (sensorEvent.timestamp / 1_000_000L);

<start>if (latestSaveBatch == 0) latestSaveBatch = tsMillis;<end>
//comment
if (tsMillis - latestSaveBatch >= sleepConstants.SECS_PER_MAX_VALUE * 1000 ) {
<start>Logger.debug(new SimpleDateFormat(""hh:mm:ss"", Locale.US).format(new Date()) + ""- Added accelerometer values to batch"");<end>
sleepStore.addMaxData(current_max_data, current_max_raw_data);
current_max_data = 0;
current_max_raw_data = 0;
latestSaveBatch = tsMillis;
checkAndSendBatch();
}
}","public void onSensorChanged(SensorEvent sensorEvent) {
if (sleepStore.isSuspended()) return;
float x = sensorEvent.values[0];
float y = sensorEvent.values[1];
float z = sensorEvent.values[2];

//comment
float max = abs(x - lastX) + abs(y - lastY) + abs(z - lastZ);
if (max > current_max_data) current_max_data = max;
float max_raw = (float) sqrt((x * x) + (y * y) + (z * z));
if (max_raw > current_max_raw_data) current_max_raw_data = max_raw;
lastX = x;
lastY = y;
lastZ = z;

int tsMillis = (int) (sensorEvent.timestamp / 1_000_000L);

if (latestSaveBatch == 0) latestSaveBatch = tsMillis;
//comment
<start>if (tsMillis - latestSaveBatch >= sleepConstants.SECS_PER_MAX_VALUE * 1000 ) {<end>
Logger.debug(new SimpleDateFormat(""hh:mm:ss"", Locale.US).format(new Date()) + ""- Added accelerometer values to batch"");
sleepStore.addMaxData(current_max_data, current_max_raw_data);
current_max_data = 0;
current_max_raw_data = 0;
latestSaveBatch = tsMillis;
checkAndSendBatch();
}
}"
2904,"<start>    private void checkAndSendBatch() {<end>
//comment
if (sleepStore.getMaxData().size() >= sleepStore.getBatchSize()) {
<start>SleepData sleepData = new SleepData();
sleepData.setAction(SleepData.actions.ACTION_DATA_UPDATE);
sleepData.setMax_data(sleepUtils.linkedToArray(sleepStore.getMaxData()));<end>
sleepData.setMax_raw_data(sleepUtils.linkedToArray(sleepStore.getMaxRawData()));
sleepStore.resetMaxData();
Logger.debug(""Sending sleep batch to phone..."");
sleepService.send(sleepData.toDataBundle(new DataBundle()));
}
}","    private void checkAndSendBatch() {
//comment
<start>if (sleepStore.getMaxData().size() >= sleepStore.getBatchSize()) {
SleepData sleepData = new SleepData();
sleepData.setAction(SleepData.actions.ACTION_DATA_UPDATE);
sleepData.setMax_data(sleepUtils.linkedToArray(sleepStore.getMaxData()));
sleepData.setMax_raw_data(sleepUtils.linkedToArray(sleepStore.getMaxRawData()));
sleepStore.resetMaxData();
Logger.debug(""Sending sleep batch to phone..."");
sleepService.send(sleepData.toDataBundle(new DataBundle()));
}<end>
}"
2905,"        @Override
public void onSensorChanged(SensorEvent event) {
accelerometer.this.onSensorChanged(event);
}","        @Override
public void onSensorChanged(SensorEvent event) {
<start>accelerometer.this.onSensorChanged(event);<end>
}"
2018,"<start>    private boolean setString(String key, String value) {<end>
//comment
try {
<start>if (this.data.getString(key).equals(value)) {
//comment
return true;
}<end>
} catch (JSONException e) {
Logger.debug(""WidgetSettings setString exception: "" + e.toString());
}

try {
this.data.put(key, value);
this.save();
} catch (JSONException e) {
Logger.debug(""WidgetSettings setString exception: "" + e.toString());
return false;
}
return true;
}","    private boolean setString(String key, String value) {
//comment
try {
<start>if (this.data.getString(key).equals(value)) {<end>
//comment
return true;
}
} catch (JSONException e) {
Logger.debug(""WidgetSettings setString exception: "" + e.toString());
}

try {
this.data.put(key, value);
this.save();
} catch (JSONException e) {
Logger.debug(""WidgetSettings setString exception: "" + e.toString());
return false;
}
return true;
}"
2019,"<start>    private boolean setInt(String key, int value) {<end>
//comment
try {
<start>if (this.data.getInt(key) == value) {
//comment
return true;
}<end>
} catch (JSONException e) {
Logger.debug(""WidgetSettings setInt exception: "" + e.toString());
}

try {
this.data.put(key, value);
this.save();
} catch (JSONException e) {
Logger.debug(""WidgetSettings setInt exception: "" + e.toString());
return false;
}
return true;
}","    private boolean setInt(String key, int value) {
//comment
try {
<start>if (this.data.getInt(key) == value) {<end>
//comment
return true;
}
} catch (JSONException e) {
Logger.debug(""WidgetSettings setInt exception: "" + e.toString());
}

try {
this.data.put(key, value);
this.save();
} catch (JSONException e) {
Logger.debug(""WidgetSettings setInt exception: "" + e.toString());
return false;
}
return true;
}"
2020,"<start>    private boolean setBoolean(String key, boolean value) {<end>
//comment
try {
<start>if (this.data.getBoolean(key) == value) {
//comment
return true;
}<end>
} catch (JSONException e) {
Logger.debug(""WidgetSettings setBoolean exception: "" + e.toString());
}

try {
this.data.put(key, value);
this.save();
} catch (JSONException e) {
Logger.debug(""WidgetSettings setBoolean exception: "" + e.toString());
return false;
}
return true;
}","    private boolean setBoolean(String key, boolean value) {
//comment
try {
<start>if (this.data.getBoolean(key) == value) {<end>
//comment
return true;
}
} catch (JSONException e) {
Logger.debug(""WidgetSettings setBoolean exception: "" + e.toString());
}

try {
this.data.put(key, value);
this.save();
} catch (JSONException e) {
Logger.debug(""WidgetSettings setBoolean exception: "" + e.toString());
return false;
}
return true;
}"
2021,"<start>    private boolean setLong(String key, long value) {<end>
//comment
try {
<start>if (this.data.getLong(key) == value) {
//comment
return true;
}<end>
} catch (JSONException e) {
Logger.debug(""WidgetSettings setLong exception: "" + e.toString());
}

try {
this.data.put(key, value);
this.save();
} catch (JSONException e) {
Logger.debug(""WidgetSettings setLong exception: "" + e.toString());
return false;
}
return true;
}","    private boolean setLong(String key, long value) {
//comment
try {
<start>if (this.data.getLong(key) == value) {<end>
//comment
return true;
}
} catch (JSONException e) {
Logger.debug(""WidgetSettings setLong exception: "" + e.toString());
}

try {
this.data.put(key, value);
this.save();
} catch (JSONException e) {
Logger.debug(""WidgetSettings setLong exception: "" + e.toString());
return false;
}
return true;
}"
6849,"    private void updateContent() {
try {
util = new FragmentUtil(mContext);
disableDelay = util.getDisableDelay();

//comment
boolean disableNotificationText = util.getDisableNotificationText();
final boolean notificationHasHideReplies = NotificationStore.getHideReplies(key);
final boolean notificationHasForceCustom = NotificationStore.getForceCustom(key);
enableInvertedTheme = util.getInvertedTheme();

Logger.info(""NotificationFragment updateContent key: {} dt: {} hr: {} fc: {}"",
key, disableNotificationText, notificationHasHideReplies, notificationHasForceCustom);

initView();
setTheme();

if (notificationHasHideReplies) {

replyButton.setVisibility(View.GONE);

} else {
//comment
replyButton.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
Logger.debug(""NotificationFragment updateContent: replyButton clicked!"");
if (repliesListView.getVisibility() == View.VISIBLE) {
repliesListView.setVisibility(View.GONE);
focusOnViewBottom(scrollView, replyButton);
} else {
//comment
<start>repliesListView.setVisibility(View.VISIBLE);
muteListView.setVisibility(View.GONE);<end>
focusOnView(scrollView, replyButton);
}
}
});
loadReplies();
}

if (notificationHasForceCustom && notificationHasHideReplies) {

muteButton.setVisibility(View.GONE);
deleteButton.setVisibility(View.GONE);

} else {
//comment
deleteButton.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
Logger.debug(""NotificationFragment updateContent: deleteButton clicked!"");
muteListView.setVisibility(View.GONE);
repliesListView.setVisibility(View.GONE);
sendDeleteCommand(v);
}
});

//comment
muteButton.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
Logger.debug(""NotificationFragment updateContent: muteButton clicked!"");
if (muteListView.getVisibility() == View.VISIBLE) {
muteListView.setVisibility(View.GONE);
} else {
//comment
muteListView.setVisibility(View.VISIBLE);
repliesListView.setVisibility(View.GONE);
focusOnView(scrollView, muteButton);
}
}
});
loadMuteOptions();
}

populateNotificationIcon(icon, iconBadge, notificationData);

if (hasPicture(notificationData)) {
populateNotificationPicture(picture, notificationData);
Logger.trace(""hasPicture = true"");
title.setText(String.format(""%s - %s"", notificationData.getTitle(), notificationData.getTime()));
time.setVisibility(View.GONE);
text.setVisibility(View.GONE);

} else {
Logger.trace(""hasPicture = false"");
title.setText(notificationData.getTitle());
time.setText(notificationData.getTime());
text.setText(notificationData.getText());
}

if (disableNotificationText)
hideContent();

doVibration(notificationData.getVibration());

} catch (NullPointerException exception) {
Logger.error(exception, exception.getMessage());
}
}","    private void updateContent() {
try {
util = new FragmentUtil(mContext);
disableDelay = util.getDisableDelay();

//comment
boolean disableNotificationText = util.getDisableNotificationText();
final boolean notificationHasHideReplies = NotificationStore.getHideReplies(key);
final boolean notificationHasForceCustom = NotificationStore.getForceCustom(key);
enableInvertedTheme = util.getInvertedTheme();

Logger.info(""NotificationFragment updateContent key: {} dt: {} hr: {} fc: {}"",
key, disableNotificationText, notificationHasHideReplies, notificationHasForceCustom);

initView();
setTheme();

if (notificationHasHideReplies) {

replyButton.setVisibility(View.GONE);

} else {
//comment
replyButton.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
Logger.debug(""NotificationFragment updateContent: replyButton clicked!"");
if (repliesListView.getVisibility() == View.VISIBLE) {
repliesListView.setVisibility(View.GONE);
focusOnViewBottom(scrollView, replyButton);
} else {
//comment
<start>repliesListView.setVisibility(View.VISIBLE);
muteListView.setVisibility(View.GONE);
focusOnView(scrollView, replyButton);<end>
}
}
});
loadReplies();
}

if (notificationHasForceCustom && notificationHasHideReplies) {

muteButton.setVisibility(View.GONE);
deleteButton.setVisibility(View.GONE);

} else {
//comment
deleteButton.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
Logger.debug(""NotificationFragment updateContent: deleteButton clicked!"");
muteListView.setVisibility(View.GONE);
repliesListView.setVisibility(View.GONE);
sendDeleteCommand(v);
}
});

//comment
muteButton.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
Logger.debug(""NotificationFragment updateContent: muteButton clicked!"");
if (muteListView.getVisibility() == View.VISIBLE) {
muteListView.setVisibility(View.GONE);
} else {
//comment
muteListView.setVisibility(View.VISIBLE);
repliesListView.setVisibility(View.GONE);
focusOnView(scrollView, muteButton);
}
}
});
loadMuteOptions();
}

populateNotificationIcon(icon, iconBadge, notificationData);

if (hasPicture(notificationData)) {
populateNotificationPicture(picture, notificationData);
Logger.trace(""hasPicture = true"");
title.setText(String.format(""%s - %s"", notificationData.getTitle(), notificationData.getTime()));
time.setVisibility(View.GONE);
text.setVisibility(View.GONE);

} else {
Logger.trace(""hasPicture = false"");
title.setText(notificationData.getTitle());
time.setText(notificationData.getTime());
text.setText(notificationData.getText());
}

if (disableNotificationText)
hideContent();

doVibration(notificationData.getVibration());

} catch (NullPointerException exception) {
Logger.error(exception, exception.getMessage());
}
}"
6850,"    private void updateContent() {
try {
util = new FragmentUtil(mContext);
disableDelay = util.getDisableDelay();

//comment
boolean disableNotificationText = util.getDisableNotificationText();
final boolean notificationHasHideReplies = NotificationStore.getHideReplies(key);
final boolean notificationHasForceCustom = NotificationStore.getForceCustom(key);
enableInvertedTheme = util.getInvertedTheme();

Logger.info(""NotificationFragment updateContent key: {} dt: {} hr: {} fc: {}"",
key, disableNotificationText, notificationHasHideReplies, notificationHasForceCustom);

initView();
setTheme();

if (notificationHasHideReplies) {

replyButton.setVisibility(View.GONE);

} else {
//comment
replyButton.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
Logger.debug(""NotificationFragment updateContent: replyButton clicked!"");
if (repliesListView.getVisibility() == View.VISIBLE) {
repliesListView.setVisibility(View.GONE);
focusOnViewBottom(scrollView, replyButton);
} else {
//comment
repliesListView.setVisibility(View.VISIBLE);
muteListView.setVisibility(View.GONE);
focusOnView(scrollView, replyButton);
}
}
});
loadReplies();
}

if (notificationHasForceCustom && notificationHasHideReplies) {

muteButton.setVisibility(View.GONE);
deleteButton.setVisibility(View.GONE);

} else {
//comment
deleteButton.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
Logger.debug(""NotificationFragment updateContent: deleteButton clicked!"");
muteListView.setVisibility(View.GONE);
repliesListView.setVisibility(View.GONE);
sendDeleteCommand(v);
}
});

//comment
muteButton.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
Logger.debug(""NotificationFragment updateContent: muteButton clicked!"");
if (muteListView.getVisibility() == View.VISIBLE) {
muteListView.setVisibility(View.GONE);
} else {
//comment
muteListView.setVisibility(View.VISIBLE);
<start>repliesListView.setVisibility(View.GONE);<end>
focusOnView(scrollView, muteButton);
}
}
});
loadMuteOptions();
}

populateNotificationIcon(icon, iconBadge, notificationData);

if (hasPicture(notificationData)) {
populateNotificationPicture(picture, notificationData);
Logger.trace(""hasPicture = true"");
title.setText(String.format(""%s - %s"", notificationData.getTitle(), notificationData.getTime()));
time.setVisibility(View.GONE);
text.setVisibility(View.GONE);

} else {
Logger.trace(""hasPicture = false"");
title.setText(notificationData.getTitle());
time.setText(notificationData.getTime());
text.setText(notificationData.getText());
}

if (disableNotificationText)
hideContent();

doVibration(notificationData.getVibration());

} catch (NullPointerException exception) {
Logger.error(exception, exception.getMessage());
}
}","    private void updateContent() {
try {
util = new FragmentUtil(mContext);
disableDelay = util.getDisableDelay();

//comment
boolean disableNotificationText = util.getDisableNotificationText();
final boolean notificationHasHideReplies = NotificationStore.getHideReplies(key);
final boolean notificationHasForceCustom = NotificationStore.getForceCustom(key);
enableInvertedTheme = util.getInvertedTheme();

Logger.info(""NotificationFragment updateContent key: {} dt: {} hr: {} fc: {}"",
key, disableNotificationText, notificationHasHideReplies, notificationHasForceCustom);

initView();
setTheme();

if (notificationHasHideReplies) {

replyButton.setVisibility(View.GONE);

} else {
//comment
replyButton.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
Logger.debug(""NotificationFragment updateContent: replyButton clicked!"");
if (repliesListView.getVisibility() == View.VISIBLE) {
repliesListView.setVisibility(View.GONE);
focusOnViewBottom(scrollView, replyButton);
} else {
//comment
repliesListView.setVisibility(View.VISIBLE);
muteListView.setVisibility(View.GONE);
focusOnView(scrollView, replyButton);
}
}
});
loadReplies();
}

if (notificationHasForceCustom && notificationHasHideReplies) {

muteButton.setVisibility(View.GONE);
deleteButton.setVisibility(View.GONE);

} else {
//comment
deleteButton.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
Logger.debug(""NotificationFragment updateContent: deleteButton clicked!"");
muteListView.setVisibility(View.GONE);
repliesListView.setVisibility(View.GONE);
sendDeleteCommand(v);
}
});

//comment
muteButton.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
Logger.debug(""NotificationFragment updateContent: muteButton clicked!"");
if (muteListView.getVisibility() == View.VISIBLE) {
muteListView.setVisibility(View.GONE);
} else {
//comment
<start>muteListView.setVisibility(View.VISIBLE);
repliesListView.setVisibility(View.GONE);
focusOnView(scrollView, muteButton);<end>
}
}
});
loadMuteOptions();
}

populateNotificationIcon(icon, iconBadge, notificationData);

if (hasPicture(notificationData)) {
populateNotificationPicture(picture, notificationData);
Logger.trace(""hasPicture = true"");
title.setText(String.format(""%s - %s"", notificationData.getTitle(), notificationData.getTime()));
time.setVisibility(View.GONE);
text.setVisibility(View.GONE);

} else {
Logger.trace(""hasPicture = false"");
title.setText(notificationData.getTitle());
time.setText(notificationData.getTime());
text.setText(notificationData.getText());
}

if (disableNotificationText)
hideContent();

doVibration(notificationData.getVibration());

} catch (NullPointerException exception) {
Logger.error(exception, exception.getMessage());
}
}"
6851,"private void setTheme() {
//comment
if (SystemProperties.isVerge()) {
<start>int px = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 72, getResources().getDisplayMetrics());
replies_layout.setMinimumHeight(px);<end>
}else if (SystemProperties.isStratos3()) {
int px = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 48, getResources().getDisplayMetrics());
replies_layout.setMinimumHeight(px);
}

//comment
//comment
if (enableInvertedTheme) {
rootLayout.setBackgroundColor(getResources().getColor(R.color.white));
time.setTextColor(getResources().getColor(R.color.black));
title.setTextColor(getResources().getColor(R.color.black));
text.setTextColor(getResources().getColor(R.color.black));
iconBadge.setBackgroundTintList(ColorStateList.valueOf(getResources().getColor(R.color.white)));
delayedConfirmationViewTitle.setTextColor(getResources().getColor(R.color.black));
delayedConfirmationViewBottom.setTextColor(getResources().getColor(R.color.black));
} else
rootLayout.setBackgroundColor(getResources().getColor(R.color.black));

time.setTextSize(util.getFontTitleSizeSP());
title.setTextSize(util.getFontTitleSizeSP());
text.setTextSize(util.getFontSizeSP());

//comment
util.setFontLocale(title, notificationData.getTitle());
util.setFontLocale(text, notificationData.getText());
}","private void setTheme() {
//comment
<start>if (SystemProperties.isVerge()) {
int px = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 72, getResources().getDisplayMetrics());
replies_layout.setMinimumHeight(px);
}else if (SystemProperties.isStratos3()) {
int px = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 48, getResources().getDisplayMetrics());
replies_layout.setMinimumHeight(px);
}<end>

//comment
//comment
if (enableInvertedTheme) {
rootLayout.setBackgroundColor(getResources().getColor(R.color.white));
time.setTextColor(getResources().getColor(R.color.black));
title.setTextColor(getResources().getColor(R.color.black));
text.setTextColor(getResources().getColor(R.color.black));
iconBadge.setBackgroundTintList(ColorStateList.valueOf(getResources().getColor(R.color.white)));
delayedConfirmationViewTitle.setTextColor(getResources().getColor(R.color.black));
delayedConfirmationViewBottom.setTextColor(getResources().getColor(R.color.black));
} else
rootLayout.setBackgroundColor(getResources().getColor(R.color.black));

time.setTextSize(util.getFontTitleSizeSP());
title.setTextSize(util.getFontTitleSizeSP());
text.setTextSize(util.getFontSizeSP());

//comment
util.setFontLocale(title, notificationData.getTitle());
util.setFontLocale(text, notificationData.getText());
}"
6852,"private void setTheme() {
//comment
if (SystemProperties.isVerge()) {
int px = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 72, getResources().getDisplayMetrics());
replies_layout.setMinimumHeight(px);
}else if (SystemProperties.isStratos3()) {
int px = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 48, getResources().getDisplayMetrics());
replies_layout.setMinimumHeight(px);
}

//comment
//comment
if (enableInvertedTheme) {
<start>rootLayout.setBackgroundColor(getResources().getColor(R.color.white));
time.setTextColor(getResources().getColor(R.color.black));<end>
title.setTextColor(getResources().getColor(R.color.black));
text.setTextColor(getResources().getColor(R.color.black));
iconBadge.setBackgroundTintList(ColorStateList.valueOf(getResources().getColor(R.color.white)));
delayedConfirmationViewTitle.setTextColor(getResources().getColor(R.color.black));
delayedConfirmationViewBottom.setTextColor(getResources().getColor(R.color.black));
} else
rootLayout.setBackgroundColor(getResources().getColor(R.color.black));

time.setTextSize(util.getFontTitleSizeSP());
title.setTextSize(util.getFontTitleSizeSP());
text.setTextSize(util.getFontSizeSP());

//comment
util.setFontLocale(title, notificationData.getTitle());
util.setFontLocale(text, notificationData.getText());
}","private void setTheme() {
//comment
if (SystemProperties.isVerge()) {
int px = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 72, getResources().getDisplayMetrics());
replies_layout.setMinimumHeight(px);
}else if (SystemProperties.isStratos3()) {
int px = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 48, getResources().getDisplayMetrics());
replies_layout.setMinimumHeight(px);
}

//comment
//comment
<start>if (enableInvertedTheme) {
rootLayout.setBackgroundColor(getResources().getColor(R.color.white));
time.setTextColor(getResources().getColor(R.color.black));
title.setTextColor(getResources().getColor(R.color.black));
text.setTextColor(getResources().getColor(R.color.black));
iconBadge.setBackgroundTintList(ColorStateList.valueOf(getResources().getColor(R.color.white)));
delayedConfirmationViewTitle.setTextColor(getResources().getColor(R.color.black));
delayedConfirmationViewBottom.setTextColor(getResources().getColor(R.color.black));
} else
rootLayout.setBackgroundColor(getResources().getColor(R.color.black));

time.setTextSize(util.getFontTitleSizeSP());
title.setTextSize(util.getFontTitleSizeSP());
text.setTextSize(util.getFontSizeSP());<end>

//comment
util.setFontLocale(title, notificationData.getTitle());
util.setFontLocale(text, notificationData.getText());
}"
6853,"private void setIconBadge(ImageView iconView) {
int[] iconData = notificationData.getIcon();
int iconWidth = notificationData.getIconWidth();
int iconHeight = notificationData.getIconHeight();
Bitmap bitmap = Bitmap.createBitmap(iconWidth, iconHeight, Bitmap.Config.ARGB_8888);

//comment
if (enableInvertedTheme) {
<start>int[] invertedIconData = new int[iconData.length];<end>
for (int i = 0; i < iconData.length; i++) {
if (iconData[i] == 0xffffffff)
invertedIconData[i] = 0xff000000;
else
invertedIconData[i] = iconData[i];
}
bitmap.setPixels(invertedIconData, 0, iconWidth, 0, 0, iconWidth, iconHeight);

} else
bitmap.setPixels(iconData, 0, iconWidth, 0, 0, iconWidth, iconHeight);

iconView.setImageBitmap(bitmap);
}","private void setIconBadge(ImageView iconView) {
int[] iconData = notificationData.getIcon();
int iconWidth = notificationData.getIconWidth();
int iconHeight = notificationData.getIconHeight();
Bitmap bitmap = Bitmap.createBitmap(iconWidth, iconHeight, Bitmap.Config.ARGB_8888);

//comment
<start>if (enableInvertedTheme) {
int[] invertedIconData = new int[iconData.length];
for (int i = 0; i < iconData.length; i++) {
if (iconData[i] == 0xffffffff)
invertedIconData[i] = 0xff000000;
else
invertedIconData[i] = iconData[i];
}
bitmap.setPixels(invertedIconData, 0, iconWidth, 0, 0, iconWidth, iconHeight);

} else
bitmap.setPixels(iconData, 0, iconWidth, 0, 0, iconWidth, iconHeight);<end>

iconView.setImageBitmap(bitmap);
}"
6854,"@SuppressLint(""CheckResult"")
public void loadReplies() {
Logger.info(""NotificationFragment loadReplies"");
List<Reply> replyList = util.listReplies();
final LayoutInflater inflater = LayoutInflater.from(NotificationFragment.this.mContext);
for (final Reply reply : replyList) {
final View row = inflater.inflate(R.layout.row_reply, repliesListView, false);
EmojiTextView replyView = row.findViewById(R.id.row_reply_text);
replyView.setText(reply.getValue());
//comment
util.setFontLocale(replyView, reply.getValue());
if (enableInvertedTheme) {
replyView.setTextColor(getResources().getColor(R.color.black));
replyView.setCompoundDrawablesWithIntrinsicBounds(R.drawable.send, 0, 0, 0);
}
replyView.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View view) {
selectedReply = reply.getValue();
sendReply(view);
Logger.debug(""NotificationFragment replyView OnClick: "" + selectedReply);
}
});
//comment
<start>repliesListView.addView(row);<end>
}
final View row = inflater.inflate(R.layout.row_reply, repliesListView, false);
EmojiTextView replyView = row.findViewById(R.id.row_reply_text);
replyView.setText(getResources().getString(R.string.keyboard));
if (enableInvertedTheme) {
replyView.setTextColor(getResources().getColor(R.color.black));
replyView.setCompoundDrawables(getResources().getDrawable(R.drawable.send), null, null, null);
}
//comment
replyView.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View view) {
Logger.debug(""NotificationFragment replyView OnClick: KEYBOARD"");
scrollView.setVisibility(View.GONE);
repliesEditTextContainer.setVisibility(View.VISIBLE);
((NotificationWearActivity) getActivity()).stopTimerFinish();
((NotificationWearActivity) getActivity()).setKeyboardVisible(true);
keyboardIsEnable = true;
Logger.debug(""keyboard IS visible"");

replyEditSend.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
selectedReply = replyEditText.getText().toString();
repliesEditTextContainer.setVisibility(View.GONE);
sendReply(v);
}
});
//comment
replyEditClose.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
scrollView.setVisibility(View.VISIBLE);
repliesEditTextContainer.setVisibility(View.GONE);
((NotificationWearActivity) getActivity()).setKeyboardVisible(false);
keyboardIsEnable = false;
Logger.debug(""keyboard NOT visible"");
((NotificationWearActivity) getActivity()).startTimerFinish();
}
});
}
});
//comment
repliesListView.addView(row);
}","@SuppressLint(""CheckResult"")
public void loadReplies() {
Logger.info(""NotificationFragment loadReplies"");
List<Reply> replyList = util.listReplies();
final LayoutInflater inflater = LayoutInflater.from(NotificationFragment.this.mContext);
for (final Reply reply : replyList) {
final View row = inflater.inflate(R.layout.row_reply, repliesListView, false);
EmojiTextView replyView = row.findViewById(R.id.row_reply_text);
replyView.setText(reply.getValue());
//comment
util.setFontLocale(replyView, reply.getValue());
if (enableInvertedTheme) {
replyView.setTextColor(getResources().getColor(R.color.black));
replyView.setCompoundDrawablesWithIntrinsicBounds(R.drawable.send, 0, 0, 0);
}
replyView.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View view) {
selectedReply = reply.getValue();
sendReply(view);
Logger.debug(""NotificationFragment replyView OnClick: "" + selectedReply);
}
});
//comment
<start>repliesListView.addView(row);<end>
}
final View row = inflater.inflate(R.layout.row_reply, repliesListView, false);
EmojiTextView replyView = row.findViewById(R.id.row_reply_text);
replyView.setText(getResources().getString(R.string.keyboard));
if (enableInvertedTheme) {
replyView.setTextColor(getResources().getColor(R.color.black));
replyView.setCompoundDrawables(getResources().getDrawable(R.drawable.send), null, null, null);
}
//comment
replyView.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View view) {
Logger.debug(""NotificationFragment replyView OnClick: KEYBOARD"");
scrollView.setVisibility(View.GONE);
repliesEditTextContainer.setVisibility(View.VISIBLE);
((NotificationWearActivity) getActivity()).stopTimerFinish();
((NotificationWearActivity) getActivity()).setKeyboardVisible(true);
keyboardIsEnable = true;
Logger.debug(""keyboard IS visible"");

replyEditSend.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
selectedReply = replyEditText.getText().toString();
repliesEditTextContainer.setVisibility(View.GONE);
sendReply(v);
}
});
//comment
replyEditClose.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
scrollView.setVisibility(View.VISIBLE);
repliesEditTextContainer.setVisibility(View.GONE);
((NotificationWearActivity) getActivity()).setKeyboardVisible(false);
keyboardIsEnable = false;
Logger.debug(""keyboard NOT visible"");
((NotificationWearActivity) getActivity()).startTimerFinish();
}
});
}
});
//comment
repliesListView.addView(row);
}"
6855,"@SuppressLint(""CheckResult"")
public void loadReplies() {
Logger.info(""NotificationFragment loadReplies"");
List<Reply> replyList = util.listReplies();
final LayoutInflater inflater = LayoutInflater.from(NotificationFragment.this.mContext);
for (final Reply reply : replyList) {
final View row = inflater.inflate(R.layout.row_reply, repliesListView, false);
EmojiTextView replyView = row.findViewById(R.id.row_reply_text);
replyView.setText(reply.getValue());
//comment
util.setFontLocale(replyView, reply.getValue());
if (enableInvertedTheme) {
replyView.setTextColor(getResources().getColor(R.color.black));
replyView.setCompoundDrawablesWithIntrinsicBounds(R.drawable.send, 0, 0, 0);
}
replyView.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View view) {
selectedReply = reply.getValue();
sendReply(view);
Logger.debug(""NotificationFragment replyView OnClick: "" + selectedReply);
}
});
//comment
repliesListView.addView(row);
}
final View row = inflater.inflate(R.layout.row_reply, repliesListView, false);
EmojiTextView replyView = row.findViewById(R.id.row_reply_text);
replyView.setText(getResources().getString(R.string.keyboard));
if (enableInvertedTheme) {
replyView.setTextColor(getResources().getColor(R.color.black));
replyView.setCompoundDrawables(getResources().getDrawable(R.drawable.send), null, null, null);
}
//comment
replyView.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View view) {
Logger.debug(""NotificationFragment replyView OnClick: KEYBOARD"");
scrollView.setVisibility(View.GONE);
repliesEditTextContainer.setVisibility(View.VISIBLE);
((NotificationWearActivity) getActivity()).stopTimerFinish();
((NotificationWearActivity) getActivity()).setKeyboardVisible(true);
keyboardIsEnable = true;
Logger.debug(""keyboard IS visible"");

replyEditSend.setOnClickListener(new View.OnClickListener() {
<start>@Override
public void onClick(View v) {<end>
selectedReply = replyEditText.getText().toString();
repliesEditTextContainer.setVisibility(View.GONE);
sendReply(v);
}
});
//comment
<start>replyEditClose.setOnClickListener(new View.OnClickListener() {<end>
@Override
public void onClick(View v) {
scrollView.setVisibility(View.VISIBLE);
repliesEditTextContainer.setVisibility(View.GONE);
((NotificationWearActivity) getActivity()).setKeyboardVisible(false);
keyboardIsEnable = false;
Logger.debug(""keyboard NOT visible"");
((NotificationWearActivity) getActivity()).startTimerFinish();
}
});
}
});
//comment
repliesListView.addView(row);
}","@SuppressLint(""CheckResult"")
public void loadReplies() {
Logger.info(""NotificationFragment loadReplies"");
List<Reply> replyList = util.listReplies();
final LayoutInflater inflater = LayoutInflater.from(NotificationFragment.this.mContext);
for (final Reply reply : replyList) {
final View row = inflater.inflate(R.layout.row_reply, repliesListView, false);
EmojiTextView replyView = row.findViewById(R.id.row_reply_text);
replyView.setText(reply.getValue());
//comment
util.setFontLocale(replyView, reply.getValue());
if (enableInvertedTheme) {
replyView.setTextColor(getResources().getColor(R.color.black));
replyView.setCompoundDrawablesWithIntrinsicBounds(R.drawable.send, 0, 0, 0);
}
replyView.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View view) {
selectedReply = reply.getValue();
sendReply(view);
Logger.debug(""NotificationFragment replyView OnClick: "" + selectedReply);
}
});
//comment
repliesListView.addView(row);
}
final View row = inflater.inflate(R.layout.row_reply, repliesListView, false);
EmojiTextView replyView = row.findViewById(R.id.row_reply_text);
replyView.setText(getResources().getString(R.string.keyboard));
if (enableInvertedTheme) {
replyView.setTextColor(getResources().getColor(R.color.black));
replyView.setCompoundDrawables(getResources().getDrawable(R.drawable.send), null, null, null);
}
//comment
replyView.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View view) {
Logger.debug(""NotificationFragment replyView OnClick: KEYBOARD"");
scrollView.setVisibility(View.GONE);
repliesEditTextContainer.setVisibility(View.VISIBLE);
((NotificationWearActivity) getActivity()).stopTimerFinish();
((NotificationWearActivity) getActivity()).setKeyboardVisible(true);
keyboardIsEnable = true;
Logger.debug(""keyboard IS visible"");

replyEditSend.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
selectedReply = replyEditText.getText().toString();
repliesEditTextContainer.setVisibility(View.GONE);
sendReply(v);
}
});
//comment
<start>replyEditClose.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View v) {
scrollView.setVisibility(View.VISIBLE);
repliesEditTextContainer.setVisibility(View.GONE);
((NotificationWearActivity) getActivity()).setKeyboardVisible(false);
keyboardIsEnable = false;
Logger.debug(""keyboard NOT visible"");
((NotificationWearActivity) getActivity()).startTimerFinish();
}
});<end>
}
});
//comment
repliesListView.addView(row);
}"
6857,"private void loadMuteOptions() {

List<Integer> silenceList = new ArrayList<>();
<start>silenceList.add(5);<end>
silenceList.add(15);
silenceList.add(30);
silenceList.add(60);

LayoutInflater inflater = LayoutInflater.from(NotificationFragment.this.mContext);

//comment
for (final Integer silence : silenceList) {
<start>final View row = inflater.inflate(R.layout.row_mute, muteListView, false);<end>
EmojiTextView muteView = row.findViewById(R.id.row_mute_value);
muteView.setText(String.format(""%s "" + getString(R.string.minutes), silence.toString()));
if (enableInvertedTheme) {
muteView.setTextColor(getResources().getColor(R.color.black));
}
muteView.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View view) {
selectedSilenceTime = silence.toString();
sendMuteCommand(view);
Logger.debug(""NotificationFragment loadMuteOptions muteView OnClick: "" + selectedSilenceTime);
}
});
//comment
muteListView.addView(row);
}

//comment
final View row_day = inflater.inflate(R.layout.row_mute, muteListView, false);
EmojiTextView muteView = row_day.findViewById(R.id.row_mute_value);
muteView.setText(getString(R.string.one_day));
if (enableInvertedTheme) {
muteView.setTextColor(getResources().getColor(R.color.black));
}
muteView.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View view) {
selectedSilenceTime = ""1440"";
sendMuteCommand(view);
Logger.debug(""NotificationFragment loadMuteOptions muteView OnClick: "" + selectedSilenceTime);
}
});
muteListView.addView(row_day);


//comment
final View row_block = inflater.inflate(R.layout.row_mute, muteListView, false);
muteView = row_block.findViewById(R.id.row_mute_value);
muteView.setText(R.string.block_app);
if (enableInvertedTheme)
muteView.setTextColor(getResources().getColor(R.color.dark_red));
else
muteView.setTextColor(getResources().getColor(R.color.red_a200));
muteView.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View view) {
selectedSilenceTime = Constants.BLOCK_APP;
sendMuteCommand(view);
Logger.debug(""NotificationFragment loadMuteOptions muteView OnClick: "" + selectedSilenceTime);
}
});
muteListView.addView(row_block);
}","private void loadMuteOptions() {

List<Integer> silenceList = new ArrayList<>();
silenceList.add(5);
silenceList.add(15);
silenceList.add(30);
silenceList.add(60);

LayoutInflater inflater = LayoutInflater.from(NotificationFragment.this.mContext);

//comment
<start>for (final Integer silence : silenceList) {
final View row = inflater.inflate(R.layout.row_mute, muteListView, false);
EmojiTextView muteView = row.findViewById(R.id.row_mute_value);
muteView.setText(String.format(""%s "" + getString(R.string.minutes), silence.toString()));
if (enableInvertedTheme) {
muteView.setTextColor(getResources().getColor(R.color.black));
}
muteView.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View view) {
selectedSilenceTime = silence.toString();
sendMuteCommand(view);
Logger.debug(""NotificationFragment loadMuteOptions muteView OnClick: "" + selectedSilenceTime);
}
});
//comment
muteListView.addView(row);
}<end>

//comment
final View row_day = inflater.inflate(R.layout.row_mute, muteListView, false);
EmojiTextView muteView = row_day.findViewById(R.id.row_mute_value);
muteView.setText(getString(R.string.one_day));
if (enableInvertedTheme) {
muteView.setTextColor(getResources().getColor(R.color.black));
}
muteView.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View view) {
selectedSilenceTime = ""1440"";
sendMuteCommand(view);
Logger.debug(""NotificationFragment loadMuteOptions muteView OnClick: "" + selectedSilenceTime);
}
});
muteListView.addView(row_day);


//comment
final View row_block = inflater.inflate(R.layout.row_mute, muteListView, false);
muteView = row_block.findViewById(R.id.row_mute_value);
muteView.setText(R.string.block_app);
if (enableInvertedTheme)
muteView.setTextColor(getResources().getColor(R.color.dark_red));
else
muteView.setTextColor(getResources().getColor(R.color.red_a200));
muteView.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View view) {
selectedSilenceTime = Constants.BLOCK_APP;
sendMuteCommand(view);
Logger.debug(""NotificationFragment loadMuteOptions muteView OnClick: "" + selectedSilenceTime);
}
});
muteListView.addView(row_block);
}"
6858,"private void loadMuteOptions() {

List<Integer> silenceList = new ArrayList<>();
silenceList.add(5);
silenceList.add(15);
silenceList.add(30);
silenceList.add(60);

LayoutInflater inflater = LayoutInflater.from(NotificationFragment.this.mContext);

//comment
for (final Integer silence : silenceList) {
final View row = inflater.inflate(R.layout.row_mute, muteListView, false);
EmojiTextView muteView = row.findViewById(R.id.row_mute_value);
muteView.setText(String.format(""%s "" + getString(R.string.minutes), silence.toString()));
if (enableInvertedTheme) {
muteView.setTextColor(getResources().getColor(R.color.black));
}
muteView.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View view) {
selectedSilenceTime = silence.toString();
sendMuteCommand(view);
Logger.debug(""NotificationFragment loadMuteOptions muteView OnClick: "" + selectedSilenceTime);
}
});
//comment
<start>muteListView.addView(row);<end>
}

//comment
final View row_day = inflater.inflate(R.layout.row_mute, muteListView, false);
EmojiTextView muteView = row_day.findViewById(R.id.row_mute_value);
muteView.setText(getString(R.string.one_day));
if (enableInvertedTheme) {
muteView.setTextColor(getResources().getColor(R.color.black));
}
muteView.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View view) {
selectedSilenceTime = ""1440"";
sendMuteCommand(view);
Logger.debug(""NotificationFragment loadMuteOptions muteView OnClick: "" + selectedSilenceTime);
}
});
muteListView.addView(row_day);


//comment
final View row_block = inflater.inflate(R.layout.row_mute, muteListView, false);
muteView = row_block.findViewById(R.id.row_mute_value);
muteView.setText(R.string.block_app);
if (enableInvertedTheme)
muteView.setTextColor(getResources().getColor(R.color.dark_red));
else
muteView.setTextColor(getResources().getColor(R.color.red_a200));
muteView.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View view) {
selectedSilenceTime = Constants.BLOCK_APP;
sendMuteCommand(view);
Logger.debug(""NotificationFragment loadMuteOptions muteView OnClick: "" + selectedSilenceTime);
}
});
muteListView.addView(row_block);
}","private void loadMuteOptions() {

List<Integer> silenceList = new ArrayList<>();
silenceList.add(5);
silenceList.add(15);
silenceList.add(30);
silenceList.add(60);

LayoutInflater inflater = LayoutInflater.from(NotificationFragment.this.mContext);

//comment
for (final Integer silence : silenceList) {
final View row = inflater.inflate(R.layout.row_mute, muteListView, false);
EmojiTextView muteView = row.findViewById(R.id.row_mute_value);
muteView.setText(String.format(""%s "" + getString(R.string.minutes), silence.toString()));
if (enableInvertedTheme) {
muteView.setTextColor(getResources().getColor(R.color.black));
}
muteView.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View view) {
selectedSilenceTime = silence.toString();
sendMuteCommand(view);
Logger.debug(""NotificationFragment loadMuteOptions muteView OnClick: "" + selectedSilenceTime);
}
});
//comment
<start>muteListView.addView(row);<end>
}

//comment
final View row_day = inflater.inflate(R.layout.row_mute, muteListView, false);
EmojiTextView muteView = row_day.findViewById(R.id.row_mute_value);
muteView.setText(getString(R.string.one_day));
if (enableInvertedTheme) {
muteView.setTextColor(getResources().getColor(R.color.black));
}
muteView.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View view) {
selectedSilenceTime = ""1440"";
sendMuteCommand(view);
Logger.debug(""NotificationFragment loadMuteOptions muteView OnClick: "" + selectedSilenceTime);
}
});
muteListView.addView(row_day);


//comment
final View row_block = inflater.inflate(R.layout.row_mute, muteListView, false);
muteView = row_block.findViewById(R.id.row_mute_value);
muteView.setText(R.string.block_app);
if (enableInvertedTheme)
muteView.setTextColor(getResources().getColor(R.color.dark_red));
else
muteView.setTextColor(getResources().getColor(R.color.red_a200));
muteView.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View view) {
selectedSilenceTime = Constants.BLOCK_APP;
sendMuteCommand(view);
Logger.debug(""NotificationFragment loadMuteOptions muteView OnClick: "" + selectedSilenceTime);
}
});
muteListView.addView(row_block);
}"
6859,"private void loadMuteOptions() {

List<Integer> silenceList = new ArrayList<>();
silenceList.add(5);
silenceList.add(15);
silenceList.add(30);
silenceList.add(60);

LayoutInflater inflater = LayoutInflater.from(NotificationFragment.this.mContext);

//comment
for (final Integer silence : silenceList) {
final View row = inflater.inflate(R.layout.row_mute, muteListView, false);
EmojiTextView muteView = row.findViewById(R.id.row_mute_value);
muteView.setText(String.format(""%s "" + getString(R.string.minutes), silence.toString()));
if (enableInvertedTheme) {
muteView.setTextColor(getResources().getColor(R.color.black));
}
muteView.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View view) {
selectedSilenceTime = silence.toString();
sendMuteCommand(view);
Logger.debug(""NotificationFragment loadMuteOptions muteView OnClick: "" + selectedSilenceTime);
}
});
//comment
muteListView.addView(row);
}

//comment
<start>final View row_day = inflater.inflate(R.layout.row_mute, muteListView, false);
EmojiTextView muteView = row_day.findViewById(R.id.row_mute_value);<end>
muteView.setText(getString(R.string.one_day));
if (enableInvertedTheme) {
muteView.setTextColor(getResources().getColor(R.color.black));
}
muteView.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View view) {
selectedSilenceTime = ""1440"";
sendMuteCommand(view);
Logger.debug(""NotificationFragment loadMuteOptions muteView OnClick: "" + selectedSilenceTime);
}
});
muteListView.addView(row_day);


//comment
final View row_block = inflater.inflate(R.layout.row_mute, muteListView, false);
muteView = row_block.findViewById(R.id.row_mute_value);
muteView.setText(R.string.block_app);
if (enableInvertedTheme)
muteView.setTextColor(getResources().getColor(R.color.dark_red));
else
muteView.setTextColor(getResources().getColor(R.color.red_a200));
muteView.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View view) {
selectedSilenceTime = Constants.BLOCK_APP;
sendMuteCommand(view);
Logger.debug(""NotificationFragment loadMuteOptions muteView OnClick: "" + selectedSilenceTime);
}
});
muteListView.addView(row_block);
}","private void loadMuteOptions() {

List<Integer> silenceList = new ArrayList<>();
silenceList.add(5);
silenceList.add(15);
silenceList.add(30);
silenceList.add(60);

LayoutInflater inflater = LayoutInflater.from(NotificationFragment.this.mContext);

//comment
for (final Integer silence : silenceList) {
final View row = inflater.inflate(R.layout.row_mute, muteListView, false);
EmojiTextView muteView = row.findViewById(R.id.row_mute_value);
muteView.setText(String.format(""%s "" + getString(R.string.minutes), silence.toString()));
if (enableInvertedTheme) {
muteView.setTextColor(getResources().getColor(R.color.black));
}
muteView.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View view) {
selectedSilenceTime = silence.toString();
sendMuteCommand(view);
Logger.debug(""NotificationFragment loadMuteOptions muteView OnClick: "" + selectedSilenceTime);
}
});
//comment
muteListView.addView(row);
}

//comment
<start>final View row_day = inflater.inflate(R.layout.row_mute, muteListView, false);
EmojiTextView muteView = row_day.findViewById(R.id.row_mute_value);
muteView.setText(getString(R.string.one_day));
if (enableInvertedTheme) {
muteView.setTextColor(getResources().getColor(R.color.black));
}
muteView.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View view) {
selectedSilenceTime = ""1440"";
sendMuteCommand(view);
Logger.debug(""NotificationFragment loadMuteOptions muteView OnClick: "" + selectedSilenceTime);
}
});
muteListView.addView(row_day);<end>


//comment
final View row_block = inflater.inflate(R.layout.row_mute, muteListView, false);
muteView = row_block.findViewById(R.id.row_mute_value);
muteView.setText(R.string.block_app);
if (enableInvertedTheme)
muteView.setTextColor(getResources().getColor(R.color.dark_red));
else
muteView.setTextColor(getResources().getColor(R.color.red_a200));
muteView.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View view) {
selectedSilenceTime = Constants.BLOCK_APP;
sendMuteCommand(view);
Logger.debug(""NotificationFragment loadMuteOptions muteView OnClick: "" + selectedSilenceTime);
}
});
muteListView.addView(row_block);
}"
6860,"private void loadMuteOptions() {

List<Integer> silenceList = new ArrayList<>();
silenceList.add(5);
silenceList.add(15);
silenceList.add(30);
silenceList.add(60);

LayoutInflater inflater = LayoutInflater.from(NotificationFragment.this.mContext);

//comment
for (final Integer silence : silenceList) {
final View row = inflater.inflate(R.layout.row_mute, muteListView, false);
EmojiTextView muteView = row.findViewById(R.id.row_mute_value);
muteView.setText(String.format(""%s "" + getString(R.string.minutes), silence.toString()));
if (enableInvertedTheme) {
muteView.setTextColor(getResources().getColor(R.color.black));
}
muteView.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View view) {
selectedSilenceTime = silence.toString();
sendMuteCommand(view);
Logger.debug(""NotificationFragment loadMuteOptions muteView OnClick: "" + selectedSilenceTime);
}
});
//comment
muteListView.addView(row);
}

//comment
final View row_day = inflater.inflate(R.layout.row_mute, muteListView, false);
EmojiTextView muteView = row_day.findViewById(R.id.row_mute_value);
muteView.setText(getString(R.string.one_day));
if (enableInvertedTheme) {
muteView.setTextColor(getResources().getColor(R.color.black));
}
muteView.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View view) {
selectedSilenceTime = ""1440"";
sendMuteCommand(view);
Logger.debug(""NotificationFragment loadMuteOptions muteView OnClick: "" + selectedSilenceTime);
}
});
muteListView.addView(row_day);


//comment
<start>final View row_block = inflater.inflate(R.layout.row_mute, muteListView, false);<end>
muteView = row_block.findViewById(R.id.row_mute_value);
muteView.setText(R.string.block_app);
if (enableInvertedTheme)
muteView.setTextColor(getResources().getColor(R.color.dark_red));
else
muteView.setTextColor(getResources().getColor(R.color.red_a200));
muteView.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View view) {
selectedSilenceTime = Constants.BLOCK_APP;
sendMuteCommand(view);
Logger.debug(""NotificationFragment loadMuteOptions muteView OnClick: "" + selectedSilenceTime);
}
});
muteListView.addView(row_block);
}","private void loadMuteOptions() {

List<Integer> silenceList = new ArrayList<>();
silenceList.add(5);
silenceList.add(15);
silenceList.add(30);
silenceList.add(60);

LayoutInflater inflater = LayoutInflater.from(NotificationFragment.this.mContext);

//comment
for (final Integer silence : silenceList) {
final View row = inflater.inflate(R.layout.row_mute, muteListView, false);
EmojiTextView muteView = row.findViewById(R.id.row_mute_value);
muteView.setText(String.format(""%s "" + getString(R.string.minutes), silence.toString()));
if (enableInvertedTheme) {
muteView.setTextColor(getResources().getColor(R.color.black));
}
muteView.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View view) {
selectedSilenceTime = silence.toString();
sendMuteCommand(view);
Logger.debug(""NotificationFragment loadMuteOptions muteView OnClick: "" + selectedSilenceTime);
}
});
//comment
muteListView.addView(row);
}

//comment
final View row_day = inflater.inflate(R.layout.row_mute, muteListView, false);
EmojiTextView muteView = row_day.findViewById(R.id.row_mute_value);
muteView.setText(getString(R.string.one_day));
if (enableInvertedTheme) {
muteView.setTextColor(getResources().getColor(R.color.black));
}
muteView.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View view) {
selectedSilenceTime = ""1440"";
sendMuteCommand(view);
Logger.debug(""NotificationFragment loadMuteOptions muteView OnClick: "" + selectedSilenceTime);
}
});
muteListView.addView(row_day);


//comment
<start>final View row_block = inflater.inflate(R.layout.row_mute, muteListView, false);
muteView = row_block.findViewById(R.id.row_mute_value);
muteView.setText(R.string.block_app);
if (enableInvertedTheme)
muteView.setTextColor(getResources().getColor(R.color.dark_red));
else
muteView.setTextColor(getResources().getColor(R.color.red_a200));
muteView.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View view) {
selectedSilenceTime = Constants.BLOCK_APP;
sendMuteCommand(view);
Logger.debug(""NotificationFragment loadMuteOptions muteView OnClick: "" + selectedSilenceTime);
}
});
muteListView.addView(row_block);<end>
}"
6861,"    @Override
public void onTimerSelected(View v) {
action = """";
v.setPressed(true);
delayedConfirmationView.reset();
//comment
<start>((DelayedConfirmationView) v).setListener(null);
((NotificationWearActivity) getActivity()).startTimerFinish();<end>
hideDelayed();
Logger.info(""NotificationFragment onTimerSelected isPressed: "" + v.isPressed());
}","    @Override
public void onTimerSelected(View v) {
action = """";
v.setPressed(true);
delayedConfirmationView.reset();
//comment
<start>((DelayedConfirmationView) v).setListener(null);
((NotificationWearActivity) getActivity()).startTimerFinish();
hideDelayed();<end>
Logger.info(""NotificationFragment onTimerSelected isPressed: "" + v.isPressed());
}"
2979,"@Override
public ResponseEntity<CohortReview> createCohortReview(
String workspaceNamespace,
String workspaceId,
Long cohortId,
Long cdrVersionId,
CreateReviewRequest request) {
if (request.getSize() <= 0 || request.getSize() > MAX_REVIEW_SIZE) {
throw new BadRequestException(
String.format(
""Bad Request: Cohort Review size must be between %s and %s"", 0, MAX_REVIEW_SIZE));
}

//comment
<start>DbWorkspace dbWorkspace =
workspaceAuthService.getWorkspaceEnforceAccessLevelAndSetCdrVersion(
workspaceNamespace, workspaceId, WorkspaceAccessLevel.WRITER);<end>

CohortReview cohortReview;
DbCohort cohort = cohortReviewService.findCohort(dbWorkspace.getWorkspaceId(), cohortId);
try {
cohortReview =
cohortReviewService.findCohortReview(
cohort.getCohortId(), dbWorkspace.getCdrVersion().getCdrVersionId());
} catch (NotFoundException nfe) {
cohortReview = cohortReviewService.initializeCohortReview(cdrVersionId, cohort);
cohortReview = cohortReviewService.saveCohortReview(cohortReview, userProvider.get());
}
if (cohortReview.getReviewSize() > 0) {
throw new BadRequestException(
String.format(
""Bad Request: Cohort Review already created for cohortId: %s, cdrVersionId: %s"",
cohortId, cdrVersionId));
}

List<DbParticipantCohortStatus> participantCohortStatuses =
cohortReviewService.createDbParticipantCohortStatusesList(
cohort, request.getSize(), cohortReview.getCohortReviewId());

cohortReview
.reviewSize((long) participantCohortStatuses.size())
.reviewStatus(ReviewStatus.CREATED);

//comment
cohortReviewService.saveFullCohortReview(cohortReview, participantCohortStatuses);

PageRequest pageRequest =
new PageRequest()
.page(PAGE)
.pageSize(PAGE_SIZE)
.sortOrder(SortOrder.ASC)
.sortColumn(FilterColumns.PARTICIPANTID.toString());

List<ParticipantCohortStatus> paginatedPCS =
cohortReviewService.findAll(cohortReview.getCohortReviewId(), pageRequest);

return ResponseEntity.ok(cohortReview.participantCohortStatuses(paginatedPCS));
}","@Override
public ResponseEntity<CohortReview> createCohortReview(
String workspaceNamespace,
String workspaceId,
Long cohortId,
Long cdrVersionId,
CreateReviewRequest request) {
if (request.getSize() <= 0 || request.getSize() > MAX_REVIEW_SIZE) {
throw new BadRequestException(
String.format(
""Bad Request: Cohort Review size must be between %s and %s"", 0, MAX_REVIEW_SIZE));
}

//comment
<start>DbWorkspace dbWorkspace =
workspaceAuthService.getWorkspaceEnforceAccessLevelAndSetCdrVersion(
workspaceNamespace, workspaceId, WorkspaceAccessLevel.WRITER);<end>

CohortReview cohortReview;
DbCohort cohort = cohortReviewService.findCohort(dbWorkspace.getWorkspaceId(), cohortId);
try {
cohortReview =
cohortReviewService.findCohortReview(
cohort.getCohortId(), dbWorkspace.getCdrVersion().getCdrVersionId());
} catch (NotFoundException nfe) {
cohortReview = cohortReviewService.initializeCohortReview(cdrVersionId, cohort);
cohortReview = cohortReviewService.saveCohortReview(cohortReview, userProvider.get());
}
if (cohortReview.getReviewSize() > 0) {
throw new BadRequestException(
String.format(
""Bad Request: Cohort Review already created for cohortId: %s, cdrVersionId: %s"",
cohortId, cdrVersionId));
}

List<DbParticipantCohortStatus> participantCohortStatuses =
cohortReviewService.createDbParticipantCohortStatusesList(
cohort, request.getSize(), cohortReview.getCohortReviewId());

cohortReview
.reviewSize((long) participantCohortStatuses.size())
.reviewStatus(ReviewStatus.CREATED);

//comment
cohortReviewService.saveFullCohortReview(cohortReview, participantCohortStatuses);

PageRequest pageRequest =
new PageRequest()
.page(PAGE)
.pageSize(PAGE_SIZE)
.sortOrder(SortOrder.ASC)
.sortColumn(FilterColumns.PARTICIPANTID.toString());

List<ParticipantCohortStatus> paginatedPCS =
cohortReviewService.findAll(cohortReview.getCohortReviewId(), pageRequest);

return ResponseEntity.ok(cohortReview.participantCohortStatuses(paginatedPCS));
}"
6938,"private TableNameAndAlias getTableNameAndAlias(
List<String> columnParts, QueryState queryState, boolean beforeLimitRequired) {
String tableName = queryState.mainTableName;
JoinedTableInfo joinedTableInfo = null;
String tableAlias = tableName;
int i;
<start>Map<String, ColumnConfig> tableColumns = queryState.mainTableColumns;<end>
//comment
for (i = columnParts.size() - 1; i > 0; i--) {
<start>String alias = toTableAlias(columnParts, i);<end>
joinedTableInfo = queryState.aliasToJoinedTableInfo.get(alias);
if (joinedTableInfo != null) {
if (beforeLimitRequired && !joinedTableInfo.beforeLimitRequired) {
joinedTableInfo.beforeLimitRequired = true;
//comment
for (int j = i - 1; j > 0; j--) {
String beforeAlias = toTableAlias(columnParts, j);
JoinedTableInfo beforeInfo = queryState.aliasToJoinedTableInfo.get(beforeAlias);
beforeInfo.beforeLimitRequired = true;
}
}
tableName = joinedTableInfo.joinedTableName;
tableAlias = alias;
tableColumns = getColumnConfigs(queryState, tableName, false);
break;
}
}
//comment
for (int j = i; j < columnParts.size() - 1; j++) {
String columnPart = columnParts.get(j);
String foreignKeyColumn = getForeignKeyColumn(columnPart);
ColumnConfig foreignKeyColumnConfig = tableColumns.get(foreignKeyColumn);
if (foreignKeyColumnConfig == null) {
throw new BadRequestException(""No foreign key column found: "" + foreignKeyColumn);
}
String foreignKeyTable = foreignKeyColumnConfig.foreignKey;
if (foreignKeyTable == null) {
throw new BadRequestException(""Column is not a foreign key: "" + foreignKeyColumn);
}
tableColumns = getColumnConfigs(queryState, foreignKeyTable, false);
ColumnConfig foreignKeyTablePrimaryKey = findPrimaryKey(tableColumns.values());

String foreignKeyAlias = toTableAlias(columnParts, j + 1);
joinedTableInfo = new JoinedTableInfo();
joinedTableInfo.joinedTableName = foreignKeyTable;
joinedTableInfo.joinedTablePrimaryKey = foreignKeyTablePrimaryKey;
joinedTableInfo.startTableAlias = tableAlias;
joinedTableInfo.startTableJoinColumn = foreignKeyColumn;
joinedTableInfo.beforeLimitRequired = beforeLimitRequired;
queryState.aliasToJoinedTableInfo.put(foreignKeyAlias, joinedTableInfo);
tableAlias = foreignKeyAlias;
tableName = foreignKeyTable;
}
return new TableNameAndAlias(tableName, tableAlias);
}","private TableNameAndAlias getTableNameAndAlias(
List<String> columnParts, QueryState queryState, boolean beforeLimitRequired) {
String tableName = queryState.mainTableName;
JoinedTableInfo joinedTableInfo = null;
String tableAlias = tableName;
int i;
Map<String, ColumnConfig> tableColumns = queryState.mainTableColumns;
//comment
<start>for (i = columnParts.size() - 1; i > 0; i--) {
String alias = toTableAlias(columnParts, i);
joinedTableInfo = queryState.aliasToJoinedTableInfo.get(alias);
if (joinedTableInfo != null) {
if (beforeLimitRequired && !joinedTableInfo.beforeLimitRequired) {
joinedTableInfo.beforeLimitRequired = true;
//comment
for (int j = i - 1; j > 0; j--) {
String beforeAlias = toTableAlias(columnParts, j);
JoinedTableInfo beforeInfo = queryState.aliasToJoinedTableInfo.get(beforeAlias);
beforeInfo.beforeLimitRequired = true;
}
}
tableName = joinedTableInfo.joinedTableName;
tableAlias = alias;
tableColumns = getColumnConfigs(queryState, tableName, false);
break;
}
}<end>
//comment
for (int j = i; j < columnParts.size() - 1; j++) {
String columnPart = columnParts.get(j);
String foreignKeyColumn = getForeignKeyColumn(columnPart);
ColumnConfig foreignKeyColumnConfig = tableColumns.get(foreignKeyColumn);
if (foreignKeyColumnConfig == null) {
throw new BadRequestException(""No foreign key column found: "" + foreignKeyColumn);
}
String foreignKeyTable = foreignKeyColumnConfig.foreignKey;
if (foreignKeyTable == null) {
throw new BadRequestException(""Column is not a foreign key: "" + foreignKeyColumn);
}
tableColumns = getColumnConfigs(queryState, foreignKeyTable, false);
ColumnConfig foreignKeyTablePrimaryKey = findPrimaryKey(tableColumns.values());

String foreignKeyAlias = toTableAlias(columnParts, j + 1);
joinedTableInfo = new JoinedTableInfo();
joinedTableInfo.joinedTableName = foreignKeyTable;
joinedTableInfo.joinedTablePrimaryKey = foreignKeyTablePrimaryKey;
joinedTableInfo.startTableAlias = tableAlias;
joinedTableInfo.startTableJoinColumn = foreignKeyColumn;
joinedTableInfo.beforeLimitRequired = beforeLimitRequired;
queryState.aliasToJoinedTableInfo.put(foreignKeyAlias, joinedTableInfo);
tableAlias = foreignKeyAlias;
tableName = foreignKeyTable;
}
return new TableNameAndAlias(tableName, tableAlias);
}"
6939,"private TableNameAndAlias getTableNameAndAlias(
List<String> columnParts, QueryState queryState, boolean beforeLimitRequired) {
String tableName = queryState.mainTableName;
JoinedTableInfo joinedTableInfo = null;
String tableAlias = tableName;
int i;
Map<String, ColumnConfig> tableColumns = queryState.mainTableColumns;
//comment
for (i = columnParts.size() - 1; i > 0; i--) {
String alias = toTableAlias(columnParts, i);
joinedTableInfo = queryState.aliasToJoinedTableInfo.get(alias);
if (joinedTableInfo != null) {
if (beforeLimitRequired && !joinedTableInfo.beforeLimitRequired) {
<start>joinedTableInfo.beforeLimitRequired = true;<end>
//comment
for (int j = i - 1; j > 0; j--) {
String beforeAlias = toTableAlias(columnParts, j);
JoinedTableInfo beforeInfo = queryState.aliasToJoinedTableInfo.get(beforeAlias);
<start>beforeInfo.beforeLimitRequired = true;<end>
}
}
<start>tableName = joinedTableInfo.joinedTableName;<end>
tableAlias = alias;
tableColumns = getColumnConfigs(queryState, tableName, false);
break;
}
}
//comment
for (int j = i; j < columnParts.size() - 1; j++) {
String columnPart = columnParts.get(j);
String foreignKeyColumn = getForeignKeyColumn(columnPart);
ColumnConfig foreignKeyColumnConfig = tableColumns.get(foreignKeyColumn);
if (foreignKeyColumnConfig == null) {
throw new BadRequestException(""No foreign key column found: "" + foreignKeyColumn);
}
String foreignKeyTable = foreignKeyColumnConfig.foreignKey;
if (foreignKeyTable == null) {
throw new BadRequestException(""Column is not a foreign key: "" + foreignKeyColumn);
}
tableColumns = getColumnConfigs(queryState, foreignKeyTable, false);
ColumnConfig foreignKeyTablePrimaryKey = findPrimaryKey(tableColumns.values());

String foreignKeyAlias = toTableAlias(columnParts, j + 1);
joinedTableInfo = new JoinedTableInfo();
joinedTableInfo.joinedTableName = foreignKeyTable;
joinedTableInfo.joinedTablePrimaryKey = foreignKeyTablePrimaryKey;
joinedTableInfo.startTableAlias = tableAlias;
joinedTableInfo.startTableJoinColumn = foreignKeyColumn;
joinedTableInfo.beforeLimitRequired = beforeLimitRequired;
queryState.aliasToJoinedTableInfo.put(foreignKeyAlias, joinedTableInfo);
tableAlias = foreignKeyAlias;
tableName = foreignKeyTable;
}
return new TableNameAndAlias(tableName, tableAlias);
}","private TableNameAndAlias getTableNameAndAlias(
List<String> columnParts, QueryState queryState, boolean beforeLimitRequired) {
String tableName = queryState.mainTableName;
JoinedTableInfo joinedTableInfo = null;
String tableAlias = tableName;
int i;
Map<String, ColumnConfig> tableColumns = queryState.mainTableColumns;
//comment
for (i = columnParts.size() - 1; i > 0; i--) {
String alias = toTableAlias(columnParts, i);
joinedTableInfo = queryState.aliasToJoinedTableInfo.get(alias);
if (joinedTableInfo != null) {
if (beforeLimitRequired && !joinedTableInfo.beforeLimitRequired) {
joinedTableInfo.beforeLimitRequired = true;
//comment
<start>for (int j = i - 1; j > 0; j--) {
String beforeAlias = toTableAlias(columnParts, j);
JoinedTableInfo beforeInfo = queryState.aliasToJoinedTableInfo.get(beforeAlias);
beforeInfo.beforeLimitRequired = true;
}<end>
}
tableName = joinedTableInfo.joinedTableName;
tableAlias = alias;
tableColumns = getColumnConfigs(queryState, tableName, false);
break;
}
}
//comment
for (int j = i; j < columnParts.size() - 1; j++) {
String columnPart = columnParts.get(j);
String foreignKeyColumn = getForeignKeyColumn(columnPart);
ColumnConfig foreignKeyColumnConfig = tableColumns.get(foreignKeyColumn);
if (foreignKeyColumnConfig == null) {
throw new BadRequestException(""No foreign key column found: "" + foreignKeyColumn);
}
String foreignKeyTable = foreignKeyColumnConfig.foreignKey;
if (foreignKeyTable == null) {
throw new BadRequestException(""Column is not a foreign key: "" + foreignKeyColumn);
}
tableColumns = getColumnConfigs(queryState, foreignKeyTable, false);
ColumnConfig foreignKeyTablePrimaryKey = findPrimaryKey(tableColumns.values());

String foreignKeyAlias = toTableAlias(columnParts, j + 1);
joinedTableInfo = new JoinedTableInfo();
joinedTableInfo.joinedTableName = foreignKeyTable;
joinedTableInfo.joinedTablePrimaryKey = foreignKeyTablePrimaryKey;
joinedTableInfo.startTableAlias = tableAlias;
joinedTableInfo.startTableJoinColumn = foreignKeyColumn;
joinedTableInfo.beforeLimitRequired = beforeLimitRequired;
queryState.aliasToJoinedTableInfo.put(foreignKeyAlias, joinedTableInfo);
tableAlias = foreignKeyAlias;
tableName = foreignKeyTable;
}
return new TableNameAndAlias(tableName, tableAlias);
}"
6940,"private TableNameAndAlias getTableNameAndAlias(
List<String> columnParts, QueryState queryState, boolean beforeLimitRequired) {
String tableName = queryState.mainTableName;
JoinedTableInfo joinedTableInfo = null;
String tableAlias = tableName;
int i;
Map<String, ColumnConfig> tableColumns = queryState.mainTableColumns;
//comment
for (i = columnParts.size() - 1; i > 0; i--) {
String alias = toTableAlias(columnParts, i);
joinedTableInfo = queryState.aliasToJoinedTableInfo.get(alias);
if (joinedTableInfo != null) {
if (beforeLimitRequired && !joinedTableInfo.beforeLimitRequired) {
joinedTableInfo.beforeLimitRequired = true;
//comment
for (int j = i - 1; j > 0; j--) {
String beforeAlias = toTableAlias(columnParts, j);
JoinedTableInfo beforeInfo = queryState.aliasToJoinedTableInfo.get(beforeAlias);
beforeInfo.beforeLimitRequired = true;
}
}
tableName = joinedTableInfo.joinedTableName;
tableAlias = alias;
tableColumns = getColumnConfigs(queryState, tableName, false);
break;
}
}
//comment
for (int j = i; j < columnParts.size() - 1; j++) {
String columnPart = columnParts.get(j);
<start>String foreignKeyColumn = getForeignKeyColumn(columnPart);<end>
ColumnConfig foreignKeyColumnConfig = tableColumns.get(foreignKeyColumn);
if (foreignKeyColumnConfig == null) {
throw new BadRequestException(""No foreign key column found: "" + foreignKeyColumn);
}
String foreignKeyTable = foreignKeyColumnConfig.foreignKey;
if (foreignKeyTable == null) {
throw new BadRequestException(""Column is not a foreign key: "" + foreignKeyColumn);
}
tableColumns = getColumnConfigs(queryState, foreignKeyTable, false);
ColumnConfig foreignKeyTablePrimaryKey = findPrimaryKey(tableColumns.values());

String foreignKeyAlias = toTableAlias(columnParts, j + 1);
joinedTableInfo = new JoinedTableInfo();
joinedTableInfo.joinedTableName = foreignKeyTable;
joinedTableInfo.joinedTablePrimaryKey = foreignKeyTablePrimaryKey;
joinedTableInfo.startTableAlias = tableAlias;
joinedTableInfo.startTableJoinColumn = foreignKeyColumn;
joinedTableInfo.beforeLimitRequired = beforeLimitRequired;
queryState.aliasToJoinedTableInfo.put(foreignKeyAlias, joinedTableInfo);
tableAlias = foreignKeyAlias;
tableName = foreignKeyTable;
}
return new TableNameAndAlias(tableName, tableAlias);
}","private TableNameAndAlias getTableNameAndAlias(
List<String> columnParts, QueryState queryState, boolean beforeLimitRequired) {
String tableName = queryState.mainTableName;
JoinedTableInfo joinedTableInfo = null;
String tableAlias = tableName;
int i;
Map<String, ColumnConfig> tableColumns = queryState.mainTableColumns;
//comment
for (i = columnParts.size() - 1; i > 0; i--) {
String alias = toTableAlias(columnParts, i);
joinedTableInfo = queryState.aliasToJoinedTableInfo.get(alias);
if (joinedTableInfo != null) {
if (beforeLimitRequired && !joinedTableInfo.beforeLimitRequired) {
joinedTableInfo.beforeLimitRequired = true;
//comment
for (int j = i - 1; j > 0; j--) {
String beforeAlias = toTableAlias(columnParts, j);
JoinedTableInfo beforeInfo = queryState.aliasToJoinedTableInfo.get(beforeAlias);
beforeInfo.beforeLimitRequired = true;
}
}
tableName = joinedTableInfo.joinedTableName;
tableAlias = alias;
tableColumns = getColumnConfigs(queryState, tableName, false);
break;
}
}
//comment
<start>for (int j = i; j < columnParts.size() - 1; j++) {
String columnPart = columnParts.get(j);
String foreignKeyColumn = getForeignKeyColumn(columnPart);
ColumnConfig foreignKeyColumnConfig = tableColumns.get(foreignKeyColumn);
if (foreignKeyColumnConfig == null) {
throw new BadRequestException(""No foreign key column found: "" + foreignKeyColumn);
}
String foreignKeyTable = foreignKeyColumnConfig.foreignKey;
if (foreignKeyTable == null) {
throw new BadRequestException(""Column is not a foreign key: "" + foreignKeyColumn);
}
tableColumns = getColumnConfigs(queryState, foreignKeyTable, false);
ColumnConfig foreignKeyTablePrimaryKey = findPrimaryKey(tableColumns.values());

String foreignKeyAlias = toTableAlias(columnParts, j + 1);
joinedTableInfo = new JoinedTableInfo();
joinedTableInfo.joinedTableName = foreignKeyTable;
joinedTableInfo.joinedTablePrimaryKey = foreignKeyTablePrimaryKey;
joinedTableInfo.startTableAlias = tableAlias;
joinedTableInfo.startTableJoinColumn = foreignKeyColumn;
joinedTableInfo.beforeLimitRequired = beforeLimitRequired;
queryState.aliasToJoinedTableInfo.put(foreignKeyAlias, joinedTableInfo);
tableAlias = foreignKeyAlias;
tableName = foreignKeyTable;
}<end>
return new TableNameAndAlias(tableName, tableAlias);
}"
1453,"  private void updateUserAccessTiers(DbUser dbUser, Agent agent) {
final List<DbAccessTier> previousAccessTiers = accessTierService.getAccessTiersForUser(dbUser);

final List<DbAccessTier> newAccessTiers = getUserAccessTiersList(dbUser);
if (!newAccessTiers.equals(previousAccessTiers)) {
userServiceAuditor.fireUpdateAccessTiersAction(
dbUser, previousAccessTiers, newAccessTiers, agent);
}

//comment
<start>newAccessTiers.forEach(tier -> accessTierService.addUserToTier(dbUser, tier));<end>

//comment
final List<DbAccessTier> tiersForRemoval =
Lists.difference(accessTierService.getAllTiers(), newAccessTiers);
<start>tiersForRemoval.forEach(tier -> accessTierService.removeUserFromTier(dbUser, tier));<end>
}","  private void updateUserAccessTiers(DbUser dbUser, Agent agent) {
final List<DbAccessTier> previousAccessTiers = accessTierService.getAccessTiersForUser(dbUser);

final List<DbAccessTier> newAccessTiers = getUserAccessTiersList(dbUser);
if (!newAccessTiers.equals(previousAccessTiers)) {
userServiceAuditor.fireUpdateAccessTiersAction(
dbUser, previousAccessTiers, newAccessTiers, agent);
}

//comment
<start>newAccessTiers.forEach(tier -> accessTierService.addUserToTier(dbUser, tier));<end>

//comment
final List<DbAccessTier> tiersForRemoval =
Lists.difference(accessTierService.getAllTiers(), newAccessTiers);
tiersForRemoval.forEach(tier -> accessTierService.removeUserFromTier(dbUser, tier));
}"
1454,"  private void updateUserAccessTiers(DbUser dbUser, Agent agent) {
final List<DbAccessTier> previousAccessTiers = accessTierService.getAccessTiersForUser(dbUser);

final List<DbAccessTier> newAccessTiers = getUserAccessTiersList(dbUser);
if (!newAccessTiers.equals(previousAccessTiers)) {
userServiceAuditor.fireUpdateAccessTiersAction(
dbUser, previousAccessTiers, newAccessTiers, agent);
}

//comment
newAccessTiers.forEach(tier -> accessTierService.addUserToTier(dbUser, tier));

//comment
<start>final List<DbAccessTier> tiersForRemoval =
Lists.difference(accessTierService.getAllTiers(), newAccessTiers);<end>
tiersForRemoval.forEach(tier -> accessTierService.removeUserFromTier(dbUser, tier));
}","  private void updateUserAccessTiers(DbUser dbUser, Agent agent) {
final List<DbAccessTier> previousAccessTiers = accessTierService.getAccessTiersForUser(dbUser);

final List<DbAccessTier> newAccessTiers = getUserAccessTiersList(dbUser);
if (!newAccessTiers.equals(previousAccessTiers)) {
userServiceAuditor.fireUpdateAccessTiersAction(
dbUser, previousAccessTiers, newAccessTiers, agent);
}

//comment
newAccessTiers.forEach(tier -> accessTierService.addUserToTier(dbUser, tier));

//comment
<start>final List<DbAccessTier> tiersForRemoval =
Lists.difference(accessTierService.getAllTiers(), newAccessTiers);
tiersForRemoval.forEach(tier -> accessTierService.removeUserFromTier(dbUser, tier));<end>
}"
1455,"<start>  private List<DbAccessTier> getUserAccessTiersList(DbUser dbUser) {
//comment
if (!shouldGrantUserTierAccess(
dbUser, requiredModulesForRegisteredTier, REGISTERED_TIER_SHORT_NAME)) {
return Collections.emptyList();
}<end>

//comment
List<DbAccessTier> userAccessTiers =
com.google.common.collect.Lists.newArrayList(accessTierService.getRegisteredTierOrThrow());

//comment
accessTierService
.getAccessTierByName(CONTROLLED_TIER_SHORT_NAME)
.ifPresent(
tier -> {
if (shouldGrantUserTierAccess(
dbUser, requiredModulesForControlledTier, CONTROLLED_TIER_SHORT_NAME)) {
userAccessTiers.add(tier);
}
});

return userAccessTiers;
}","  private List<DbAccessTier> getUserAccessTiersList(DbUser dbUser) {
//comment
<start>if (!shouldGrantUserTierAccess(
dbUser, requiredModulesForRegisteredTier, REGISTERED_TIER_SHORT_NAME)) {<end>
return Collections.emptyList();
}

//comment
List<DbAccessTier> userAccessTiers =
com.google.common.collect.Lists.newArrayList(accessTierService.getRegisteredTierOrThrow());

//comment
accessTierService
.getAccessTierByName(CONTROLLED_TIER_SHORT_NAME)
.ifPresent(
tier -> {
if (shouldGrantUserTierAccess(
dbUser, requiredModulesForControlledTier, CONTROLLED_TIER_SHORT_NAME)) {
userAccessTiers.add(tier);
}
});

return userAccessTiers;
}"
1456,"  private List<DbAccessTier> getUserAccessTiersList(DbUser dbUser) {
//comment
if (!shouldGrantUserTierAccess(
dbUser, requiredModulesForRegisteredTier, REGISTERED_TIER_SHORT_NAME)) {
return Collections.emptyList();
}

//comment
<start>List<DbAccessTier> userAccessTiers =
com.google.common.collect.Lists.newArrayList(accessTierService.getRegisteredTierOrThrow());<end>

//comment
accessTierService
.getAccessTierByName(CONTROLLED_TIER_SHORT_NAME)
.ifPresent(
tier -> {
if (shouldGrantUserTierAccess(
dbUser, requiredModulesForControlledTier, CONTROLLED_TIER_SHORT_NAME)) {
userAccessTiers.add(tier);
}
});

return userAccessTiers;
}","  private List<DbAccessTier> getUserAccessTiersList(DbUser dbUser) {
//comment
if (!shouldGrantUserTierAccess(
dbUser, requiredModulesForRegisteredTier, REGISTERED_TIER_SHORT_NAME)) {
return Collections.emptyList();
}

//comment
<start>List<DbAccessTier> userAccessTiers =
com.google.common.collect.Lists.newArrayList(accessTierService.getRegisteredTierOrThrow());<end>

//comment
accessTierService
.getAccessTierByName(CONTROLLED_TIER_SHORT_NAME)
.ifPresent(
tier -> {
if (shouldGrantUserTierAccess(
dbUser, requiredModulesForControlledTier, CONTROLLED_TIER_SHORT_NAME)) {
userAccessTiers.add(tier);
}
});

return userAccessTiers;
}"
1457,"  private List<DbAccessTier> getUserAccessTiersList(DbUser dbUser) {
//comment
if (!shouldGrantUserTierAccess(
dbUser, requiredModulesForRegisteredTier, REGISTERED_TIER_SHORT_NAME)) {
return Collections.emptyList();
}

//comment
List<DbAccessTier> userAccessTiers =
com.google.common.collect.Lists.newArrayList(accessTierService.getRegisteredTierOrThrow());

//comment
<start>accessTierService
.getAccessTierByName(CONTROLLED_TIER_SHORT_NAME)<end>
.ifPresent(
tier -> {
if (shouldGrantUserTierAccess(
dbUser, requiredModulesForControlledTier, CONTROLLED_TIER_SHORT_NAME)) {
userAccessTiers.add(tier);
}
});

return userAccessTiers;
}","  private List<DbAccessTier> getUserAccessTiersList(DbUser dbUser) {
//comment
if (!shouldGrantUserTierAccess(
dbUser, requiredModulesForRegisteredTier, REGISTERED_TIER_SHORT_NAME)) {
return Collections.emptyList();
}

//comment
List<DbAccessTier> userAccessTiers =
com.google.common.collect.Lists.newArrayList(accessTierService.getRegisteredTierOrThrow());

//comment
<start>accessTierService
.getAccessTierByName(CONTROLLED_TIER_SHORT_NAME)
.ifPresent(
tier -> {
if (shouldGrantUserTierAccess(
dbUser, requiredModulesForControlledTier, CONTROLLED_TIER_SHORT_NAME)) {
userAccessTiers.add(tier);
}
});<end>

return userAccessTiers;
}"
1458,"  private boolean shouldGrantUserTierAccess(
DbUser user, List<AccessModuleName> requiredModules, String tierShortName) {
boolean allStandardRequiredModulesCompliant =
requiredModules.stream()
.allMatch(moduleName -> accessModuleService.isModuleCompliant(user, moduleName));
boolean eraCompliant =
accessModuleService.isModuleCompliant(user, AccessModuleName.ERA_COMMONS);

boolean eRARequiredForTier = true;
boolean institutionalEmailValidForTier = false;
Optional<Institution> institution = institutionService.getByUser(user);
if (institution.isPresent()) {
//comment
//comment
<start>eRARequiredForTier =
!configProvider.get().access.enableRasLoginGovLinking
|| institutionService.eRaRequiredForTier(institution.get(), tierShortName);<end>
institutionalEmailValidForTier =
institutionService.validateInstitutionalEmail(
institution.get(), user.getContactEmail(), tierShortName);
} else {
log.warning(String.format(""Institution not found for user %s"", user.getUsername()));
}
return !user.getDisabled()
&& (!eRARequiredForTier || eraCompliant)
&& institutionalEmailValidForTier
&& allStandardRequiredModulesCompliant;
}","  private boolean shouldGrantUserTierAccess(
DbUser user, List<AccessModuleName> requiredModules, String tierShortName) {
boolean allStandardRequiredModulesCompliant =
requiredModules.stream()
.allMatch(moduleName -> accessModuleService.isModuleCompliant(user, moduleName));
boolean eraCompliant =
accessModuleService.isModuleCompliant(user, AccessModuleName.ERA_COMMONS);

boolean eRARequiredForTier = true;
boolean institutionalEmailValidForTier = false;
Optional<Institution> institution = institutionService.getByUser(user);
if (institution.isPresent()) {
//comment
//comment
<start>eRARequiredForTier =
!configProvider.get().access.enableRasLoginGovLinking
|| institutionService.eRaRequiredForTier(institution.get(), tierShortName);
institutionalEmailValidForTier =
institutionService.validateInstitutionalEmail(
institution.get(), user.getContactEmail(), tierShortName);<end>
} else {
log.warning(String.format(""Institution not found for user %s"", user.getUsername()));
}
return !user.getDisabled()
&& (!eRARequiredForTier || eraCompliant)
&& institutionalEmailValidForTier
&& allStandardRequiredModulesCompliant;
}"
1459,"  @Override
public DbUser createUser(
String givenName,
String familyName,
String username,
String contactEmail,
String areaOfResearch,
String professionalUrl,
List<Degree> degrees,
DbAddress dbAddress,
DbDemographicSurvey dbDemographicSurvey,
DbVerifiedInstitutionalAffiliation dbVerifiedAffiliation) {
DbUser dbUser = new DbUser();
Timestamp now = new Timestamp(clock.instant().toEpochMilli());
dbUser.setCreationNonce(Math.abs(random.nextLong()));
dbUser.setUsername(username);
dbUser.setContactEmail(contactEmail);
dbUser.setAreaOfResearch(areaOfResearch);
dbUser.setFamilyName(familyName);
dbUser.setGivenName(givenName);
dbUser.setProfessionalUrl(professionalUrl);
dbUser.setDisabled(false);
dbUser.setAddress(dbAddress);
if (degrees != null) {
dbUser.setDegreesEnum(degrees);
}
dbUser.setDemographicSurvey(dbDemographicSurvey);

//comment
<start>if (dbAddress != null) {
dbAddress.setUser(dbUser);
}<end>
if (dbDemographicSurvey != null) {
dbDemographicSurvey.setUser(dbUser);
}

try {
dbUser = userDao.save(dbUser);
dbVerifiedAffiliation.setUser(dbUser);
verifiedInstitutionalAffiliationDao.save(dbVerifiedAffiliation);
accessModuleService.updateCompletionTime(
dbUser, AccessModuleName.PUBLICATION_CONFIRMATION, now);
accessModuleService.updateCompletionTime(dbUser, AccessModuleName.PROFILE_CONFIRMATION, now);
} catch (DataIntegrityViolationException e) {
dbUser = userDao.findUserByUsername(username);
if (dbUser == null) {
throw e;
}
//comment
//comment
}
return dbUser;
}","  @Override
public DbUser createUser(
String givenName,
String familyName,
String username,
String contactEmail,
String areaOfResearch,
String professionalUrl,
List<Degree> degrees,
DbAddress dbAddress,
DbDemographicSurvey dbDemographicSurvey,
DbVerifiedInstitutionalAffiliation dbVerifiedAffiliation) {
DbUser dbUser = new DbUser();
Timestamp now = new Timestamp(clock.instant().toEpochMilli());
dbUser.setCreationNonce(Math.abs(random.nextLong()));
dbUser.setUsername(username);
dbUser.setContactEmail(contactEmail);
dbUser.setAreaOfResearch(areaOfResearch);
dbUser.setFamilyName(familyName);
dbUser.setGivenName(givenName);
dbUser.setProfessionalUrl(professionalUrl);
dbUser.setDisabled(false);
dbUser.setAddress(dbAddress);
if (degrees != null) {
dbUser.setDegreesEnum(degrees);
}
dbUser.setDemographicSurvey(dbDemographicSurvey);

//comment
<start>if (dbAddress != null) {
dbAddress.setUser(dbUser);
}<end>
if (dbDemographicSurvey != null) {
dbDemographicSurvey.setUser(dbUser);
}

try {
dbUser = userDao.save(dbUser);
dbVerifiedAffiliation.setUser(dbUser);
verifiedInstitutionalAffiliationDao.save(dbVerifiedAffiliation);
accessModuleService.updateCompletionTime(
dbUser, AccessModuleName.PUBLICATION_CONFIRMATION, now);
accessModuleService.updateCompletionTime(dbUser, AccessModuleName.PROFILE_CONFIRMATION, now);
} catch (DataIntegrityViolationException e) {
dbUser = userDao.findUserByUsername(username);
if (dbUser == null) {
throw e;
}
//comment
//comment
}
return dbUser;
}"
1460,"<start>  @Override
@Transactional
public void submitTermsOfService(DbUser dbUser, @Nonnull Integer tosVersion) {<end>

//comment
<start>if (tosVersion == null) {
throw new BadRequestException(""Terms of Service version is NULL"");
}<end>
if (tosVersion != CURRENT_TERMS_OF_SERVICE_VERSION) {
throw new BadRequestException(""Terms of Service version is not up to date"");
}

DbUserTermsOfService userTermsOfService = new DbUserTermsOfService();
userTermsOfService.setTosVersion(tosVersion);
userTermsOfService.setUserId(dbUser.getUserId());
userTermsOfServiceDao.save(userTermsOfService);
userServiceAuditor.fireAcknowledgeTermsOfService(dbUser, tosVersion);
}","  @Override
@Transactional
public void submitTermsOfService(DbUser dbUser, @Nonnull Integer tosVersion) {

//comment
<start>if (tosVersion == null) {
throw new BadRequestException(""Terms of Service version is NULL"");
}
if (tosVersion != CURRENT_TERMS_OF_SERVICE_VERSION) {
throw new BadRequestException(""Terms of Service version is not up to date"");
}<end>

DbUserTermsOfService userTermsOfService = new DbUserTermsOfService();
userTermsOfService.setTosVersion(tosVersion);
userTermsOfService.setUserId(dbUser.getUserId());
userTermsOfServiceDao.save(userTermsOfService);
userServiceAuditor.fireAcknowledgeTermsOfService(dbUser, tosVersion);
}"
1461,"@Override
public DbUser syncComplianceTrainingStatusV2(DbUser dbUser, Agent agent)
throws org.pmiops.workbench.moodle.ApiException, NotFoundException {
//comment
<start>if (isServiceAccount(dbUser)) {
return dbUser;
}<end>

try {
Timestamp now = new Timestamp(clock.instant().toEpochMilli());
Map<BadgeName, BadgeDetailsV2> userBadgesByName =
complianceService.getUserBadgesByBadgeName(dbUser.getUsername());

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
Function<AccessModuleName, Optional<Timestamp>> determineCompletionTime =
(moduleName) -> {
BadgeName badgeName = BADGE_BY_COMPLIANCE_MODULE.get(moduleName);
Optional<BadgeDetailsV2> badge =
Optional.ofNullable(userBadgesByName.get(badgeName))
.filter(BadgeDetailsV2::getValid);

if (!badge.isPresent()) {
return Optional.empty();
}

if (badge.get().getLastissued() == null) {
log.warning(
String.format(
""badge %s is indicated as valid by Moodle, but is missing the lastissued ""
+ ""time, this is unexpected - treating this as an incomplete training"",
badgeName));
return Optional.empty();
}
Instant badgeTime = Instant.ofEpochSecond(badge.get().getLastissued());
Instant dbCompletionTime =
accessModuleService
.getAccessModuleStatus(dbUser, moduleName)
.map(AccessModuleStatus::getCompletionEpochMillis)
.map(Instant::ofEpochMilli)
.orElse(Instant.EPOCH);

if (badgeTime.isAfter(dbCompletionTime)) {
//comment
//comment
//comment
return Optional.of(now);
}

//comment
return Optional.of(Timestamp.from(dbCompletionTime));
};

Map<AccessModuleName, Optional<Timestamp>> completionTimes =
BADGE_BY_COMPLIANCE_MODULE.keySet().stream()
.collect(Collectors.toMap(Function.identity(), determineCompletionTime));

return updateUserWithRetries(
u -> {
completionTimes.forEach(
(accessModuleName, timestamp) ->
accessModuleService.updateCompletionTime(
u, accessModuleName, timestamp.orElse(null)));
return u;
},
dbUser,
agent);
} catch (NumberFormatException e) {
log.severe(""Incorrect date expire format from Moodle"");
throw e;
} catch (org.pmiops.workbench.moodle.ApiException ex) {
if (ex.getCode() == HttpStatus.NOT_FOUND.value()) {
log.severe(
String.format(
""Error while querying Moodle for badges for %s: %s "",
dbUser.getUsername(), ex.getMessage()));
throw new NotFoundException(ex.getMessage());
} else {
log.severe(String.format(""Error while syncing compliance training: %s"", ex.getMessage()));
}
throw ex;
}
}","@Override
public DbUser syncComplianceTrainingStatusV2(DbUser dbUser, Agent agent)
throws org.pmiops.workbench.moodle.ApiException, NotFoundException {
//comment
<start>if (isServiceAccount(dbUser)) {
return dbUser;
}<end>

try {
Timestamp now = new Timestamp(clock.instant().toEpochMilli());
Map<BadgeName, BadgeDetailsV2> userBadgesByName =
complianceService.getUserBadgesByBadgeName(dbUser.getUsername());

//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
//comment
Function<AccessModuleName, Optional<Timestamp>> determineCompletionTime =
(moduleName) -> {
BadgeName badgeName = BADGE_BY_COMPLIANCE_MODULE.get(moduleName);
Optional<BadgeDetailsV2> badge =
Optional.ofNullable(userBadgesByName.get(badgeName))
.filter(BadgeDetailsV2::getValid);

if (!badge.isPresent()) {
return Optional.empty();
}

if (badge.get().getLastissued() == null) {
log.warning(
String.format(
""badge %s is indicated as valid by Moodle, but is missing the lastissued ""
+ ""time, this is unexpected - treating this as an incomplete training"",
badgeName));
return Optional.empty();
}
Instant badgeTime = Instant.ofEpochSecond(badge.get().getLastissued());
Instant dbCompletionTime =
accessModuleService
.getAccessModuleStatus(dbUser, moduleName)
.map(AccessModuleStatus::getCompletionEpochMillis)
.map(Instant::ofEpochMilli)
.orElse(Instant.EPOCH);

if (badgeTime.isAfter(dbCompletionTime)) {
//comment
//comment
//comment
return Optional.of(now);
}

//comment
return Optional.of(Timestamp.from(dbCompletionTime));
};

Map<AccessModuleName, Optional<Timestamp>> completionTimes =
BADGE_BY_COMPLIANCE_MODULE.keySet().stream()
.collect(Collectors.toMap(Function.identity(), determineCompletionTime));

return updateUserWithRetries(
u -> {
completionTimes.forEach(
(accessModuleName, timestamp) ->
accessModuleService.updateCompletionTime(
u, accessModuleName, timestamp.orElse(null)));
return u;
},
dbUser,
agent);
} catch (NumberFormatException e) {
log.severe(""Incorrect date expire format from Moodle"");
throw e;
} catch (org.pmiops.workbench.moodle.ApiException ex) {
if (ex.getCode() == HttpStatus.NOT_FOUND.value()) {
log.severe(
String.format(
""Error while querying Moodle for badges for %s: %s "",
dbUser.getUsername(), ex.getMessage()));
throw new NotFoundException(ex.getMessage());
} else {
log.severe(String.format(""Error while syncing compliance training: %s"", ex.getMessage()));
}
throw ex;
}
}"
2046,"  public void remediateEgressEvent(long egressEventId) {
DbEgressEvent event =
egressEventDao
.findById(egressEventId)
.orElseThrow(
() ->
new NotFoundException(
String.format(""egress event %d does not exist"", egressEventId)));
if (!DbEgressEventStatus.PENDING.equals(event.getStatus())) {
log.warning(
String.format(""ignoring non-PENDING egress event %d, nothing to do"", egressEventId));
return;
}

DbUser user = event.getUser();
if (user == null) {
throw new FailedPreconditionException(
String.format(
""egress event %d has no associated user, please investigate"", egressEventId));
}

//comment
<start>int egressIncidentCount = getEgressIncidentCountForUser(user);<end>

//comment
EgressAlertRemediationPolicy egressPolicy =
workbenchConfigProvider.get().egressAlertRemediationPolicy;
Optional<Escalation> escalation = matchEscalation(egressPolicy, egressIncidentCount);

//comment
escalation.ifPresent(
e -> {
EgressRemediationAction action;
if (e.disableUser != null) {
disableUser(user);
action = EgressRemediationAction.DISABLE_USER;
} else if (e.suspendCompute != null) {
suspendUserCompute(user, Duration.ofMinutes(e.suspendCompute.durationMinutes));
action = EgressRemediationAction.SUSPEND_COMPUTE;
} else {
throw new ServerErrorException(""egress alert policy is invalid: "" + e);
}

if (egressPolicy != null && egressPolicy.enableJiraTicketing) {
try {
logEventToJira(event, action);
} catch (ApiException ex) {
throw new ServerErrorException(""failed to log event to Jira"", ex);
}
}

if (shouldNotifyForEvent(event)) {
try {
mailService.sendEgressRemediationEmail(user, action);
} catch (MessagingException ex) {
throw new ServerErrorException(""failed to send egress remediation email"", ex);
}
}
});

egressEventDao.save(event.setStatus(DbEgressEventStatus.REMEDIATED));

egressEventAuditor.fireRemediateEgressEvent(event, escalation.orElse(null));
}","  public void remediateEgressEvent(long egressEventId) {
DbEgressEvent event =
egressEventDao
.findById(egressEventId)
.orElseThrow(
() ->
new NotFoundException(
String.format(""egress event %d does not exist"", egressEventId)));
if (!DbEgressEventStatus.PENDING.equals(event.getStatus())) {
log.warning(
String.format(""ignoring non-PENDING egress event %d, nothing to do"", egressEventId));
return;
}

DbUser user = event.getUser();
if (user == null) {
throw new FailedPreconditionException(
String.format(
""egress event %d has no associated user, please investigate"", egressEventId));
}

//comment
<start>int egressIncidentCount = getEgressIncidentCountForUser(user);<end>

//comment
EgressAlertRemediationPolicy egressPolicy =
workbenchConfigProvider.get().egressAlertRemediationPolicy;
Optional<Escalation> escalation = matchEscalation(egressPolicy, egressIncidentCount);

//comment
escalation.ifPresent(
e -> {
EgressRemediationAction action;
if (e.disableUser != null) {
disableUser(user);
action = EgressRemediationAction.DISABLE_USER;
} else if (e.suspendCompute != null) {
suspendUserCompute(user, Duration.ofMinutes(e.suspendCompute.durationMinutes));
action = EgressRemediationAction.SUSPEND_COMPUTE;
} else {
throw new ServerErrorException(""egress alert policy is invalid: "" + e);
}

if (egressPolicy != null && egressPolicy.enableJiraTicketing) {
try {
logEventToJira(event, action);
} catch (ApiException ex) {
throw new ServerErrorException(""failed to log event to Jira"", ex);
}
}

if (shouldNotifyForEvent(event)) {
try {
mailService.sendEgressRemediationEmail(user, action);
} catch (MessagingException ex) {
throw new ServerErrorException(""failed to send egress remediation email"", ex);
}
}
});

egressEventDao.save(event.setStatus(DbEgressEventStatus.REMEDIATED));

egressEventAuditor.fireRemediateEgressEvent(event, escalation.orElse(null));
}"
2047,"  public void remediateEgressEvent(long egressEventId) {
DbEgressEvent event =
egressEventDao
.findById(egressEventId)
.orElseThrow(
() ->
new NotFoundException(
String.format(""egress event %d does not exist"", egressEventId)));
if (!DbEgressEventStatus.PENDING.equals(event.getStatus())) {
log.warning(
String.format(""ignoring non-PENDING egress event %d, nothing to do"", egressEventId));
return;
}

DbUser user = event.getUser();
if (user == null) {
throw new FailedPreconditionException(
String.format(
""egress event %d has no associated user, please investigate"", egressEventId));
}

//comment
int egressIncidentCount = getEgressIncidentCountForUser(user);

//comment
EgressAlertRemediationPolicy egressPolicy =
workbenchConfigProvider.get().egressAlertRemediationPolicy;
Optional<Escalation> escalation = matchEscalation(egressPolicy, egressIncidentCount);

//comment
escalation.ifPresent(
e -> {
EgressRemediationAction action;
if (e.disableUser != null) {
disableUser(user);
action = EgressRemediationAction.DISABLE_USER;
} else if (e.suspendCompute != null) {
suspendUserCompute(user, Duration.ofMinutes(e.suspendCompute.durationMinutes));
action = EgressRemediationAction.SUSPEND_COMPUTE;
} else {
throw new ServerErrorException(""egress alert policy is invalid: "" + e);
}

if (egressPolicy != null && egressPolicy.enableJiraTicketing) {
try {
logEventToJira(event, action);
} catch (ApiException ex) {
throw new ServerErrorException(""failed to log event to Jira"", ex);
}
}

if (shouldNotifyForEvent(event)) {
try {
mailService.sendEgressRemediationEmail(user, action);
} catch (MessagingException ex) {
throw new ServerErrorException(""failed to send egress remediation email"", ex);
}
}
});

egressEventDao.save(event.setStatus(DbEgressEventStatus.REMEDIATED));

egressEventAuditor.fireRemediateEgressEvent(event, escalation.orElse(null));
}","  public void remediateEgressEvent(long egressEventId) {
DbEgressEvent event =
egressEventDao
.findById(egressEventId)
.orElseThrow(
() ->
new NotFoundException(
String.format(""egress event %d does not exist"", egressEventId)));
if (!DbEgressEventStatus.PENDING.equals(event.getStatus())) {
log.warning(
String.format(""ignoring non-PENDING egress event %d, nothing to do"", egressEventId));
return;
}

DbUser user = event.getUser();
if (user == null) {
throw new FailedPreconditionException(
String.format(
""egress event %d has no associated user, please investigate"", egressEventId));
}

//comment
int egressIncidentCount = getEgressIncidentCountForUser(user);

//comment
<start>EgressAlertRemediationPolicy egressPolicy =
workbenchConfigProvider.get().egressAlertRemediationPolicy;
Optional<Escalation> escalation = matchEscalation(egressPolicy, egressIncidentCount);<end>

//comment
escalation.ifPresent(
e -> {
EgressRemediationAction action;
if (e.disableUser != null) {
disableUser(user);
action = EgressRemediationAction.DISABLE_USER;
} else if (e.suspendCompute != null) {
suspendUserCompute(user, Duration.ofMinutes(e.suspendCompute.durationMinutes));
action = EgressRemediationAction.SUSPEND_COMPUTE;
} else {
throw new ServerErrorException(""egress alert policy is invalid: "" + e);
}

if (egressPolicy != null && egressPolicy.enableJiraTicketing) {
try {
logEventToJira(event, action);
} catch (ApiException ex) {
throw new ServerErrorException(""failed to log event to Jira"", ex);
}
}

if (shouldNotifyForEvent(event)) {
try {
mailService.sendEgressRemediationEmail(user, action);
} catch (MessagingException ex) {
throw new ServerErrorException(""failed to send egress remediation email"", ex);
}
}
});

egressEventDao.save(event.setStatus(DbEgressEventStatus.REMEDIATED));

egressEventAuditor.fireRemediateEgressEvent(event, escalation.orElse(null));
}"
2048,"  public void remediateEgressEvent(long egressEventId) {
DbEgressEvent event =
egressEventDao
.findById(egressEventId)
.orElseThrow(
() ->
new NotFoundException(
String.format(""egress event %d does not exist"", egressEventId)));
if (!DbEgressEventStatus.PENDING.equals(event.getStatus())) {
log.warning(
String.format(""ignoring non-PENDING egress event %d, nothing to do"", egressEventId));
return;
}

DbUser user = event.getUser();
if (user == null) {
throw new FailedPreconditionException(
String.format(
""egress event %d has no associated user, please investigate"", egressEventId));
}

//comment
int egressIncidentCount = getEgressIncidentCountForUser(user);

//comment
EgressAlertRemediationPolicy egressPolicy =
workbenchConfigProvider.get().egressAlertRemediationPolicy;
Optional<Escalation> escalation = matchEscalation(egressPolicy, egressIncidentCount);

//comment
<start>escalation.ifPresent(
e -> {
EgressRemediationAction action;<end>
if (e.disableUser != null) {
disableUser(user);
action = EgressRemediationAction.DISABLE_USER;
} else if (e.suspendCompute != null) {
suspendUserCompute(user, Duration.ofMinutes(e.suspendCompute.durationMinutes));
action = EgressRemediationAction.SUSPEND_COMPUTE;
} else {
throw new ServerErrorException(""egress alert policy is invalid: "" + e);
}

if (egressPolicy != null && egressPolicy.enableJiraTicketing) {
try {
logEventToJira(event, action);
} catch (ApiException ex) {
throw new ServerErrorException(""failed to log event to Jira"", ex);
}
}

if (shouldNotifyForEvent(event)) {
try {
mailService.sendEgressRemediationEmail(user, action);
} catch (MessagingException ex) {
throw new ServerErrorException(""failed to send egress remediation email"", ex);
}
}
});

egressEventDao.save(event.setStatus(DbEgressEventStatus.REMEDIATED));

egressEventAuditor.fireRemediateEgressEvent(event, escalation.orElse(null));
}","  public void remediateEgressEvent(long egressEventId) {
DbEgressEvent event =
egressEventDao
.findById(egressEventId)
.orElseThrow(
() ->
new NotFoundException(
String.format(""egress event %d does not exist"", egressEventId)));
if (!DbEgressEventStatus.PENDING.equals(event.getStatus())) {
log.warning(
String.format(""ignoring non-PENDING egress event %d, nothing to do"", egressEventId));
return;
}

DbUser user = event.getUser();
if (user == null) {
throw new FailedPreconditionException(
String.format(
""egress event %d has no associated user, please investigate"", egressEventId));
}

//comment
int egressIncidentCount = getEgressIncidentCountForUser(user);

//comment
EgressAlertRemediationPolicy egressPolicy =
workbenchConfigProvider.get().egressAlertRemediationPolicy;
Optional<Escalation> escalation = matchEscalation(egressPolicy, egressIncidentCount);

//comment
<start>escalation.ifPresent(
e -> {
EgressRemediationAction action;
if (e.disableUser != null) {
disableUser(user);
action = EgressRemediationAction.DISABLE_USER;
} else if (e.suspendCompute != null) {
suspendUserCompute(user, Duration.ofMinutes(e.suspendCompute.durationMinutes));
action = EgressRemediationAction.SUSPEND_COMPUTE;
} else {
throw new ServerErrorException(""egress alert policy is invalid: "" + e);
}

if (egressPolicy != null && egressPolicy.enableJiraTicketing) {
try {
logEventToJira(event, action);
} catch (ApiException ex) {
throw new ServerErrorException(""failed to log event to Jira"", ex);
}
}

if (shouldNotifyForEvent(event)) {
try {
mailService.sendEgressRemediationEmail(user, action);
} catch (MessagingException ex) {
throw new ServerErrorException(""failed to send egress remediation email"", ex);
}
}
});<end>

egressEventDao.save(event.setStatus(DbEgressEventStatus.REMEDIATED));

egressEventAuditor.fireRemediateEgressEvent(event, escalation.orElse(null));
}"
2049,"private int getEgressIncidentCountForUser(DbUser user) {
List<DbEgressEvent> events =
egressEventDao.findAllByUserAndStatusNot(user, DbEgressEventStatus.VERIFIED_FALSE_POSITIVE);

//comment
//comment
<start>int incidentCount = (int) events.stream().filter(e -> e.getWorkspace() == null).count();<end>

//comment
Collection<List<DbEgressEvent>> eventsByWorkspace =
events.stream()
.filter(e -> e.getWorkspace() != null)
.collect(Collectors.groupingBy(e -> e.getWorkspace().getWorkspaceId()))
.values();

for (List<DbEgressEvent> partition : eventsByWorkspace) {
List<Instant> sortedEventCreationTimes =
partition.stream()
.map(e -> e.getCreationTime().toInstant())
.sorted()
.collect(Collectors.toList());

//comment
Instant lastGroupStart = sortedEventCreationTimes.get(0);
incidentCount++;

for (Instant eventCreationTime : sortedEventCreationTimes) {
//comment
//comment
if (eventCreationTime.isAfter(lastGroupStart.plus(EGRESS_INCIDENT_MERGE_WINDOW))) {
incidentCount++;
lastGroupStart = eventCreationTime;
}
}
}

return incidentCount;
}","private int getEgressIncidentCountForUser(DbUser user) {
List<DbEgressEvent> events =
egressEventDao.findAllByUserAndStatusNot(user, DbEgressEventStatus.VERIFIED_FALSE_POSITIVE);

//comment
//comment
<start>int incidentCount = (int) events.stream().filter(e -> e.getWorkspace() == null).count();<end>

//comment
Collection<List<DbEgressEvent>> eventsByWorkspace =
events.stream()
.filter(e -> e.getWorkspace() != null)
.collect(Collectors.groupingBy(e -> e.getWorkspace().getWorkspaceId()))
.values();

for (List<DbEgressEvent> partition : eventsByWorkspace) {
List<Instant> sortedEventCreationTimes =
partition.stream()
.map(e -> e.getCreationTime().toInstant())
.sorted()
.collect(Collectors.toList());

//comment
Instant lastGroupStart = sortedEventCreationTimes.get(0);
incidentCount++;

for (Instant eventCreationTime : sortedEventCreationTimes) {
//comment
//comment
if (eventCreationTime.isAfter(lastGroupStart.plus(EGRESS_INCIDENT_MERGE_WINDOW))) {
incidentCount++;
lastGroupStart = eventCreationTime;
}
}
}

return incidentCount;
}"
2050,"private int getEgressIncidentCountForUser(DbUser user) {
List<DbEgressEvent> events =
egressEventDao.findAllByUserAndStatusNot(user, DbEgressEventStatus.VERIFIED_FALSE_POSITIVE);

//comment
//comment
int incidentCount = (int) events.stream().filter(e -> e.getWorkspace() == null).count();

//comment
<start>Collection<List<DbEgressEvent>> eventsByWorkspace =
events.stream()
.filter(e -> e.getWorkspace() != null)
.collect(Collectors.groupingBy(e -> e.getWorkspace().getWorkspaceId()))
.values();<end>

for (List<DbEgressEvent> partition : eventsByWorkspace) {
List<Instant> sortedEventCreationTimes =
partition.stream()
.map(e -> e.getCreationTime().toInstant())
.sorted()
.collect(Collectors.toList());

//comment
Instant lastGroupStart = sortedEventCreationTimes.get(0);
incidentCount++;

for (Instant eventCreationTime : sortedEventCreationTimes) {
//comment
//comment
if (eventCreationTime.isAfter(lastGroupStart.plus(EGRESS_INCIDENT_MERGE_WINDOW))) {
incidentCount++;
lastGroupStart = eventCreationTime;
}
}
}

return incidentCount;
}","private int getEgressIncidentCountForUser(DbUser user) {
List<DbEgressEvent> events =
egressEventDao.findAllByUserAndStatusNot(user, DbEgressEventStatus.VERIFIED_FALSE_POSITIVE);

//comment
//comment
int incidentCount = (int) events.stream().filter(e -> e.getWorkspace() == null).count();

//comment
<start>Collection<List<DbEgressEvent>> eventsByWorkspace =
events.stream()
.filter(e -> e.getWorkspace() != null)
.collect(Collectors.groupingBy(e -> e.getWorkspace().getWorkspaceId()))
.values();<end>

for (List<DbEgressEvent> partition : eventsByWorkspace) {
List<Instant> sortedEventCreationTimes =
partition.stream()
.map(e -> e.getCreationTime().toInstant())
.sorted()
.collect(Collectors.toList());

//comment
Instant lastGroupStart = sortedEventCreationTimes.get(0);
incidentCount++;

for (Instant eventCreationTime : sortedEventCreationTimes) {
//comment
//comment
if (eventCreationTime.isAfter(lastGroupStart.plus(EGRESS_INCIDENT_MERGE_WINDOW))) {
incidentCount++;
lastGroupStart = eventCreationTime;
}
}
}

return incidentCount;
}"
2051,"  private static Optional<Escalation> matchEscalation(
@Nullable EgressAlertRemediationPolicy policy, int incidentCount) {
if (policy == null) {
return Optional.empty();
}
List<Escalation> descendingEscalations =
policy.escalations.stream()
.sorted(Comparator.comparingInt((Escalation e) -> e.afterIncidentCount).reversed())
.collect(Collectors.toList());
for (Escalation e : descendingEscalations) {
//comment
//comment
//comment
<start>if (e.afterIncidentCount <= incidentCount) {
return Optional.of(e);
}<end>
}
return Optional.empty();
}","  private static Optional<Escalation> matchEscalation(
@Nullable EgressAlertRemediationPolicy policy, int incidentCount) {
if (policy == null) {
return Optional.empty();
}
List<Escalation> descendingEscalations =
policy.escalations.stream()
.sorted(Comparator.comparingInt((Escalation e) -> e.afterIncidentCount).reversed())
.collect(Collectors.toList());
for (Escalation e : descendingEscalations) {
//comment
//comment
//comment
<start>if (e.afterIncidentCount <= incidentCount) {
return Optional.of(e);
}<end>
}
return Optional.empty();
}"
2052,"<start>  private void suspendUserCompute(DbUser user, Duration duration) {<end>
Timestamp suspendUntil = Timestamp.from(clock.instant().plus(duration));
userService.updateUserWithRetries(
u -> {
//comment
<start>u.setComputeSecuritySuspendedUntil(suspendUntil);<end>
return u;
},
user,
Agent.asSystem());

stopUserRuntimes(user.getUsername());
}","  private void suspendUserCompute(DbUser user, Duration duration) {
Timestamp suspendUntil = Timestamp.from(clock.instant().plus(duration));
userService.updateUserWithRetries(
u -> {
//comment
<start>u.setComputeSecuritySuspendedUntil(suspendUntil);<end>
return u;
},
user,
Agent.asSystem());

stopUserRuntimes(user.getUsername());
}"
2053,"  private void disableUser(DbUser user) {
userService.updateUserWithRetries(
u -> {
u.setDisabled(true);
return u;
},
user,
Agent.asSystem());

//comment
<start>stopUserRuntimes(user.getUsername());<end>
}","  private void disableUser(DbUser user) {
userService.updateUserWithRetries(
u -> {
u.setDisabled(true);
return u;
},
user,
Agent.asSystem());

//comment
<start>stopUserRuntimes(user.getUsername());<end>
}"
615,"  @Override
public Set<BlobId> getExistingBlobIdsIn(List<BlobId> ids) {
if (ids.isEmpty()) {
return ImmutableSet.of();
}
<start>return storageProvider.get().get(ids).stream()
.filter(Objects::nonNull)
//comment
.map(b -> BlobId.of(b.getBucket(), b.getName()))
.collect(Collectors.toSet());<end>
}","  @Override
public Set<BlobId> getExistingBlobIdsIn(List<BlobId> ids) {
if (ids.isEmpty()) {
return ImmutableSet.of();
}
return storageProvider.get().get(ids).stream()
.filter(Objects::nonNull)
//comment
<start>.map(b -> BlobId.of(b.getBucket(), b.getName()))<end>
.collect(Collectors.toSet());
}"
6943,"private static void describeRuntime(
String apiUrl, String workbenchProjectId, String workbenchServiceAccount, String runtimeId)
throws IOException, ApiException {
String[] parts = runtimeId.split(""/"");
if (parts.length != 2) {
System.err.println(
String.format(
""given runtime ID '%s' is invalid, wanted format 'project/runtimeName'"", runtimeId));
return;
}
<start>String runtimeProject = parts[0];<end>
String runtimeName = parts[1];

//comment
//comment
<start>RuntimesApi client = newApiClient(apiUrl);<end>
com.squareup.okhttp.Call call =
client.getRuntimeCall(
runtimeProject,
runtimeName,
null,
null);
ApiResponse<Object> resp = client.getApiClient().execute(call, Object.class);

//comment
LeonardoGetRuntimeResponse runtime =
PRETTY_GSON.fromJson(PRETTY_GSON.toJson(resp.getData()), LeonardoGetRuntimeResponse.class);

System.out.println(PRETTY_GSON.toJson(resp.getData()));
System.out.printf(""\n\nTo inspect logs in cloud storage, run the following:\n\n"");

System.out.printf(
""    gsutil -i %s ls gs://%s/**\n"",
workbenchServiceAccount, runtime.getAsyncRuntimeFields().getStagingBucket());
System.out.printf(
""    gsutil -i %s cat ... # inspect or copy logs\n\n"", workbenchServiceAccount);
}","private static void describeRuntime(
String apiUrl, String workbenchProjectId, String workbenchServiceAccount, String runtimeId)
throws IOException, ApiException {
String[] parts = runtimeId.split(""/"");
if (parts.length != 2) {
System.err.println(
String.format(
""given runtime ID '%s' is invalid, wanted format 'project/runtimeName'"", runtimeId));
return;
}
String runtimeProject = parts[0];
String runtimeName = parts[1];

//comment
//comment
<start>RuntimesApi client = newApiClient(apiUrl);
com.squareup.okhttp.Call call =
client.getRuntimeCall(
runtimeProject,
runtimeName,
null,
null);<end>
ApiResponse<Object> resp = client.getApiClient().execute(call, Object.class);

//comment
LeonardoGetRuntimeResponse runtime =
PRETTY_GSON.fromJson(PRETTY_GSON.toJson(resp.getData()), LeonardoGetRuntimeResponse.class);

System.out.println(PRETTY_GSON.toJson(resp.getData()));
System.out.printf(""\n\nTo inspect logs in cloud storage, run the following:\n\n"");

System.out.printf(
""    gsutil -i %s ls gs://%s/**\n"",
workbenchServiceAccount, runtime.getAsyncRuntimeFields().getStagingBucket());
System.out.printf(
""    gsutil -i %s cat ... # inspect or copy logs\n\n"", workbenchServiceAccount);
}"
6944,"private static void describeRuntime(
String apiUrl, String workbenchProjectId, String workbenchServiceAccount, String runtimeId)
throws IOException, ApiException {
String[] parts = runtimeId.split(""/"");
if (parts.length != 2) {
System.err.println(
String.format(
""given runtime ID '%s' is invalid, wanted format 'project/runtimeName'"", runtimeId));
return;
}
String runtimeProject = parts[0];
String runtimeName = parts[1];

//comment
//comment
RuntimesApi client = newApiClient(apiUrl);
com.squareup.okhttp.Call call =
client.getRuntimeCall(
runtimeProject,
runtimeName,
null,
null);
ApiResponse<Object> resp = client.getApiClient().execute(call, Object.class);

//comment
<start>LeonardoGetRuntimeResponse runtime =
PRETTY_GSON.fromJson(PRETTY_GSON.toJson(resp.getData()), LeonardoGetRuntimeResponse.class);<end>

System.out.println(PRETTY_GSON.toJson(resp.getData()));
System.out.printf(""\n\nTo inspect logs in cloud storage, run the following:\n\n"");

System.out.printf(
""    gsutil -i %s ls gs://%s/**\n"",
workbenchServiceAccount, runtime.getAsyncRuntimeFields().getStagingBucket());
System.out.printf(
""    gsutil -i %s cat ... # inspect or copy logs\n\n"", workbenchServiceAccount);
}","private static void describeRuntime(
String apiUrl, String workbenchProjectId, String workbenchServiceAccount, String runtimeId)
throws IOException, ApiException {
String[] parts = runtimeId.split(""/"");
if (parts.length != 2) {
System.err.println(
String.format(
""given runtime ID '%s' is invalid, wanted format 'project/runtimeName'"", runtimeId));
return;
}
String runtimeProject = parts[0];
String runtimeName = parts[1];

//comment
//comment
RuntimesApi client = newApiClient(apiUrl);
com.squareup.okhttp.Call call =
client.getRuntimeCall(
runtimeProject,
runtimeName,
null,
null);
ApiResponse<Object> resp = client.getApiClient().execute(call, Object.class);

//comment
<start>LeonardoGetRuntimeResponse runtime =
PRETTY_GSON.fromJson(PRETTY_GSON.toJson(resp.getData()), LeonardoGetRuntimeResponse.class);

System.out.println(PRETTY_GSON.toJson(resp.getData()));
System.out.printf(""\n\nTo inspect logs in cloud storage, run the following:\n\n"");

System.out.printf(
""    gsutil -i %s ls gs://%s/**\n"",
workbenchServiceAccount, runtime.getAsyncRuntimeFields().getStagingBucket());
System.out.printf(
""    gsutil -i %s cat ... # inspect or copy logs\n\n"", workbenchServiceAccount);<end>
}"
6945,"@Override
public ResponseEntity<CohortAnnotationDefinition> createCohortAnnotationDefinition(
String workspaceNamespace,
String workspaceId,
Long cohortId,
CohortAnnotationDefinition cohortAnnotationDefinition) {
//comment
<start>DbWorkspace dbWorkspace =
workspaceAuthService.getWorkspaceEnforceAccessLevelAndSetCdrVersion(
workspaceNamespace, workspaceId, WorkspaceAccessLevel.WRITER);<end>

validateColumnName(cohortAnnotationDefinition.getColumnName());
validateCohortExist(dbWorkspace, cohortId);
validateDefinitionExists(cohortId, cohortAnnotationDefinition.getColumnName());

cohortAnnotationDefinition.setCohortId(cohortId);
cohortAnnotationDefinition.etag(Etags.fromVersion(0));
CohortAnnotationDefinition response = save(cohortAnnotationDefinition);
return ResponseEntity.ok(response);
}","@Override
public ResponseEntity<CohortAnnotationDefinition> createCohortAnnotationDefinition(
String workspaceNamespace,
String workspaceId,
Long cohortId,
CohortAnnotationDefinition cohortAnnotationDefinition) {
//comment
<start>DbWorkspace dbWorkspace =
workspaceAuthService.getWorkspaceEnforceAccessLevelAndSetCdrVersion(
workspaceNamespace, workspaceId, WorkspaceAccessLevel.WRITER);<end>

validateColumnName(cohortAnnotationDefinition.getColumnName());
validateCohortExist(dbWorkspace, cohortId);
validateDefinitionExists(cohortId, cohortAnnotationDefinition.getColumnName());

cohortAnnotationDefinition.setCohortId(cohortId);
cohortAnnotationDefinition.etag(Etags.fromVersion(0));
CohortAnnotationDefinition response = save(cohortAnnotationDefinition);
return ResponseEntity.ok(response);
}"
6946,"  @Override
public ResponseEntity<EmptyResponse> deleteCohortAnnotationDefinition(
String workspaceNamespace, String workspaceId, Long cohortId, Long annotationDefinitionId) {
//comment
<start>DbWorkspace dbWorkspace =
workspaceAuthService.getWorkspaceEnforceAccessLevelAndSetCdrVersion(
workspaceNamespace, workspaceId, WorkspaceAccessLevel.WRITER);<end>

validateCohortExist(dbWorkspace, cohortId);
//comment
findCohortAnnotationDefinition(cohortId, annotationDefinitionId);

cohortAnnotationDefinitionService.delete(annotationDefinitionId);
return ResponseEntity.ok(new EmptyResponse());
}","  @Override
public ResponseEntity<EmptyResponse> deleteCohortAnnotationDefinition(
String workspaceNamespace, String workspaceId, Long cohortId, Long annotationDefinitionId) {
//comment
<start>DbWorkspace dbWorkspace =
workspaceAuthService.getWorkspaceEnforceAccessLevelAndSetCdrVersion(
workspaceNamespace, workspaceId, WorkspaceAccessLevel.WRITER);<end>

validateCohortExist(dbWorkspace, cohortId);
//comment
findCohortAnnotationDefinition(cohortId, annotationDefinitionId);

cohortAnnotationDefinitionService.delete(annotationDefinitionId);
return ResponseEntity.ok(new EmptyResponse());
}"
6947,"  @Override
public ResponseEntity<EmptyResponse> deleteCohortAnnotationDefinition(
String workspaceNamespace, String workspaceId, Long cohortId, Long annotationDefinitionId) {
//comment
DbWorkspace dbWorkspace =
workspaceAuthService.getWorkspaceEnforceAccessLevelAndSetCdrVersion(
workspaceNamespace, workspaceId, WorkspaceAccessLevel.WRITER);

<start>validateCohortExist(dbWorkspace, cohortId);
//comment
findCohortAnnotationDefinition(cohortId, annotationDefinitionId);<end>

cohortAnnotationDefinitionService.delete(annotationDefinitionId);
return ResponseEntity.ok(new EmptyResponse());
}","  @Override
public ResponseEntity<EmptyResponse> deleteCohortAnnotationDefinition(
String workspaceNamespace, String workspaceId, Long cohortId, Long annotationDefinitionId) {
//comment
DbWorkspace dbWorkspace =
workspaceAuthService.getWorkspaceEnforceAccessLevelAndSetCdrVersion(
workspaceNamespace, workspaceId, WorkspaceAccessLevel.WRITER);

<start>validateCohortExist(dbWorkspace, cohortId);<end>
//comment
findCohortAnnotationDefinition(cohortId, annotationDefinitionId);

cohortAnnotationDefinitionService.delete(annotationDefinitionId);
return ResponseEntity.ok(new EmptyResponse());
}"
6948,"  @Override
public ResponseEntity<CohortAnnotationDefinition> getCohortAnnotationDefinition(
String workspaceNamespace, String workspaceId, Long cohortId, Long annotationDefinitionId) {
//comment
<start>DbWorkspace dbWorkspace =
workspaceAuthService.getWorkspaceEnforceAccessLevelAndSetCdrVersion(
workspaceNamespace, workspaceId, WorkspaceAccessLevel.READER);<end>

validateCohortExist(dbWorkspace, cohortId);

return ResponseEntity.ok(findCohortAnnotationDefinition(cohortId, annotationDefinitionId));
}","  @Override
public ResponseEntity<CohortAnnotationDefinition> getCohortAnnotationDefinition(
String workspaceNamespace, String workspaceId, Long cohortId, Long annotationDefinitionId) {
//comment
<start>DbWorkspace dbWorkspace =
workspaceAuthService.getWorkspaceEnforceAccessLevelAndSetCdrVersion(
workspaceNamespace, workspaceId, WorkspaceAccessLevel.READER);<end>

validateCohortExist(dbWorkspace, cohortId);

return ResponseEntity.ok(findCohortAnnotationDefinition(cohortId, annotationDefinitionId));
}"
6949,"  @Override
public ResponseEntity<CohortAnnotationDefinitionListResponse> getCohortAnnotationDefinitions(
String workspaceNamespace, String workspaceId, Long cohortId) {
//comment
<start>DbWorkspace dbWorkspace =
workspaceAuthService.getWorkspaceEnforceAccessLevelAndSetCdrVersion(
workspaceNamespace, workspaceId, WorkspaceAccessLevel.READER);<end>

validateCohortExist(dbWorkspace, cohortId);

List<CohortAnnotationDefinition> defs =
cohortAnnotationDefinitionService.findByCohortId(cohortId);

return ResponseEntity.ok(new CohortAnnotationDefinitionListResponse().items(defs));
}","  @Override
public ResponseEntity<CohortAnnotationDefinitionListResponse> getCohortAnnotationDefinitions(
String workspaceNamespace, String workspaceId, Long cohortId) {
//comment
<start>DbWorkspace dbWorkspace =
workspaceAuthService.getWorkspaceEnforceAccessLevelAndSetCdrVersion(
workspaceNamespace, workspaceId, WorkspaceAccessLevel.READER);<end>

validateCohortExist(dbWorkspace, cohortId);

List<CohortAnnotationDefinition> defs =
cohortAnnotationDefinitionService.findByCohortId(cohortId);

return ResponseEntity.ok(new CohortAnnotationDefinitionListResponse().items(defs));
}"
6950,"  @Override
public ResponseEntity<CohortAnnotationDefinition> updateCohortAnnotationDefinition(
String workspaceNamespace,
String workspaceId,
Long cohortId,
Long annotationDefinitionId,
CohortAnnotationDefinition cohortAnnotationDefinitionRequest) {
String columnName = cohortAnnotationDefinitionRequest.getColumnName();

//comment
<start>DbWorkspace dbWorkspace =
workspaceAuthService.getWorkspaceEnforceAccessLevelAndSetCdrVersion(
workspaceNamespace, workspaceId, WorkspaceAccessLevel.WRITER);<end>

validateColumnName(columnName);
validateCohortExist(dbWorkspace, cohortId);

CohortAnnotationDefinition cohortAnnotationDefinition =
findCohortAnnotationDefinition(cohortId, annotationDefinitionId).columnName(columnName);

validateEtag(cohortAnnotationDefinitionRequest.getEtag(), cohortAnnotationDefinition);
validateDefinitionExists(cohortId, columnName);

return ResponseEntity.ok(save(cohortAnnotationDefinition));
}","  @Override
public ResponseEntity<CohortAnnotationDefinition> updateCohortAnnotationDefinition(
String workspaceNamespace,
String workspaceId,
Long cohortId,
Long annotationDefinitionId,
CohortAnnotationDefinition cohortAnnotationDefinitionRequest) {
String columnName = cohortAnnotationDefinitionRequest.getColumnName();

//comment
<start>DbWorkspace dbWorkspace =
workspaceAuthService.getWorkspaceEnforceAccessLevelAndSetCdrVersion(
workspaceNamespace, workspaceId, WorkspaceAccessLevel.WRITER);<end>

validateColumnName(columnName);
validateCohortExist(dbWorkspace, cohortId);

CohortAnnotationDefinition cohortAnnotationDefinition =
findCohortAnnotationDefinition(cohortId, annotationDefinitionId).columnName(columnName);

validateEtag(cohortAnnotationDefinitionRequest.getEtag(), cohortAnnotationDefinition);
validateDefinitionExists(cohortId, columnName);

return ResponseEntity.ok(save(cohortAnnotationDefinition));
}"
7245,"public ArrayList<Token> get(final String input) {
ArrayList<Token> tokens = new ArrayList<Token>();
if (!mHasChinaCollator || TextUtils.isEmpty(input)) {
//comment
return tokens;
}
final int inputLength = input.length();
final StringBuilder sb = new StringBuilder();
<start>int tokenType = Token.LATIN;<end>
//comment
//comment
//comment
//comment
for (int i = 0; i < inputLength; i++) {
<start>final char character = input.charAt(i);<end>
if (character == ' ') {
if (sb.length() > 0) {
addToken(sb, tokens, tokenType);
}
} else if (character < 256) {
<start>if (tokenType != Token.LATIN && sb.length() > 0) {
addToken(sb, tokens, tokenType);
}<end>
tokenType = Token.LATIN;
sb.append(character);
} else {
Token t = getToken(character);
if (t.type == Token.PINYIN) {
if (sb.length() > 0) {
<start>addToken(sb, tokens, tokenType);<end>
}
tokens.add(t);
tokenType = Token.PINYIN;
} else {
if (tokenType != t.type && sb.length() > 0) {
addToken(sb, tokens, tokenType);
}
tokenType = t.type;
sb.append(character);
}
}
}
if (sb.length() > 0) {
addToken(sb, tokens, tokenType);
}
return tokens;
}","public ArrayList<Token> get(final String input) {
ArrayList<Token> tokens = new ArrayList<Token>();
if (!mHasChinaCollator || TextUtils.isEmpty(input)) {
//comment
return tokens;
}
final int inputLength = input.length();
final StringBuilder sb = new StringBuilder();
int tokenType = Token.LATIN;
//comment
//comment
//comment
//comment
<start>for (int i = 0; i < inputLength; i++) {
final char character = input.charAt(i);<end>
if (character == ' ') {
if (sb.length() > 0) {
addToken(sb, tokens, tokenType);
}
} else if (character < 256) {
if (tokenType != Token.LATIN && sb.length() > 0) {
addToken(sb, tokens, tokenType);
}
tokenType = Token.LATIN;
sb.append(character);
} else {
Token t = getToken(character);
if (t.type == Token.PINYIN) {
if (sb.length() > 0) {
addToken(sb, tokens, tokenType);
}
tokens.add(t);
tokenType = Token.PINYIN;
<start>} else {
if (tokenType != t.type && sb.length() > 0) {
addToken(sb, tokens, tokenType);
}
tokenType = t.type;
sb.append(character);<end>
}
}
}
if (sb.length() > 0) {
addToken(sb, tokens, tokenType);
}
return tokens;
}"
7246,"public ArrayList<Token> get(final String input) {
ArrayList<Token> tokens = new ArrayList<Token>();
if (!mHasChinaCollator || TextUtils.isEmpty(input)) {
//comment
<start>return tokens;<end>
}
final int inputLength = input.length();
final StringBuilder sb = new StringBuilder();
<start>int tokenType = Token.LATIN;<end>
//comment
//comment
//comment
//comment
for (int i = 0; i < inputLength; i++) {
<start>final char character = input.charAt(i);<end>
if (character == ' ') {
if (sb.length() > 0) {
addToken(sb, tokens, tokenType);
}
} else if (character < 256) {
if (tokenType != Token.LATIN && sb.length() > 0) {
addToken(sb, tokens, tokenType);
}
tokenType = Token.LATIN;
sb.append(character);
} else {
Token t = getToken(character);
if (t.type == Token.PINYIN) {
if (sb.length() > 0) {
addToken(sb, tokens, tokenType);
}
tokens.add(t);
tokenType = Token.PINYIN;
} else {
if (tokenType != t.type && sb.length() > 0) {
addToken(sb, tokens, tokenType);
}
tokenType = t.type;
sb.append(character);
}
}
}
if (sb.length() > 0) {
addToken(sb, tokens, tokenType);
}
return tokens;
}","public ArrayList<Token> get(final String input) {
ArrayList<Token> tokens = new ArrayList<Token>();
if (!mHasChinaCollator || TextUtils.isEmpty(input)) {
//comment
return tokens;
}
final int inputLength = input.length();
final StringBuilder sb = new StringBuilder();
int tokenType = Token.LATIN;
//comment
//comment
//comment
//comment
<start>for (int i = 0; i < inputLength; i++) {
final char character = input.charAt(i);<end>
if (character == ' ') {
if (sb.length() > 0) {
addToken(sb, tokens, tokenType);
}
} else if (character < 256) {
if (tokenType != Token.LATIN && sb.length() > 0) {
addToken(sb, tokens, tokenType);
}
tokenType = Token.LATIN;
sb.append(character);
} else {
<start>Token t = getToken(character);
if (t.type == Token.PINYIN) {
if (sb.length() > 0) {
addToken(sb, tokens, tokenType);
}
tokens.add(t);
tokenType = Token.PINYIN;<end>
} else {
if (tokenType != t.type && sb.length() > 0) {
addToken(sb, tokens, tokenType);
}
tokenType = t.type;
sb.append(character);
}
}
}
if (sb.length() > 0) {
addToken(sb, tokens, tokenType);
}
return tokens;
}"
7247,"public ArrayList<Token> get(final String input) {
ArrayList<Token> tokens = new ArrayList<Token>();
if (!mHasChinaCollator || TextUtils.isEmpty(input)) {
//comment
<start>return tokens;<end>
}
final int inputLength = input.length();
final StringBuilder sb = new StringBuilder();
<start>int tokenType = Token.LATIN;<end>
//comment
//comment
//comment
//comment
for (int i = 0; i < inputLength; i++) {
<start>final char character = input.charAt(i);<end>
if (character == ' ') {
<start>if (sb.length() > 0) {
addToken(sb, tokens, tokenType);
}<end>
} else if (character < 256) {
if (tokenType != Token.LATIN && sb.length() > 0) {
addToken(sb, tokens, tokenType);
}
tokenType = Token.LATIN;
sb.append(character);
} else {
Token t = getToken(character);
if (t.type == Token.PINYIN) {
if (sb.length() > 0) {
addToken(sb, tokens, tokenType);
}
tokens.add(t);
tokenType = Token.PINYIN;
} else {
if (tokenType != t.type && sb.length() > 0) {
addToken(sb, tokens, tokenType);
}
tokenType = t.type;
sb.append(character);
}
}
}
if (sb.length() > 0) {
addToken(sb, tokens, tokenType);
}
return tokens;
}","public ArrayList<Token> get(final String input) {
ArrayList<Token> tokens = new ArrayList<Token>();
if (!mHasChinaCollator || TextUtils.isEmpty(input)) {
//comment
return tokens;
}
final int inputLength = input.length();
final StringBuilder sb = new StringBuilder();
int tokenType = Token.LATIN;
//comment
//comment
//comment
//comment
<start>for (int i = 0; i < inputLength; i++) {
final char character = input.charAt(i);<end>
if (character == ' ') {
if (sb.length() > 0) {
addToken(sb, tokens, tokenType);
}
} else if (character < 256) {
if (tokenType != Token.LATIN && sb.length() > 0) {
addToken(sb, tokens, tokenType);
}
tokenType = Token.LATIN;
sb.append(character);
} else {
Token t = getToken(character);
if (t.type == Token.PINYIN) {
if (sb.length() > 0) {
addToken(sb, tokens, tokenType);
}
tokens.add(t);
tokenType = Token.PINYIN;
} else {
if (tokenType != t.type && sb.length() > 0) {
addToken(sb, tokens, tokenType);
}
tokenType = t.type;
sb.append(character);
}
}
}
if (sb.length() > 0) {
addToken(sb, tokens, tokenType);
}
return tokens;
}"
7248,"        @Override
public void onResult(Bundle bundle) {
Intent intent = bundle.getParcelable(KEY_INTENT);
if (intent != null && mActivity != null) {
//comment
//comment
<start>mActivity.startActivity(intent);<end>
//comment
} else if (bundle.getBoolean(""retry"")) {
try {
doWork();
} catch (RemoteException e) {
throw new RuntimeException(e);
}
} else {
set(bundle);
}
}","        @Override
public void onResult(Bundle bundle) {
Intent intent = bundle.getParcelable(KEY_INTENT);
<start>if (intent != null && mActivity != null) {
//comment
//comment
mActivity.startActivity(intent);<end>
//comment
} else if (bundle.getBoolean(""retry"")) {
try {
doWork();
} catch (RemoteException e) {
throw new RuntimeException(e);
}
} else {
set(bundle);
}
}"
7191,"public List<R> queryIntent(Intent intent, String resolvedType, boolean defaultOnly, int userId) {
String scheme = intent.getScheme();

ArrayList<R> finalList = new ArrayList<R>();
F[] firstTypeCut = null;
F[] secondTypeCut = null;
F[] thirdTypeCut = null;
F[] schemeCut = null;

//comment
//comment
if (resolvedType != null) {
<start>int slashpos = resolvedType.indexOf('/');<end>
if (slashpos > 0) {
final String baseType = resolvedType.substring(0, slashpos);
if (!baseType.equals(""*"")) {
if (resolvedType.length() != slashpos + 2 || resolvedType.charAt(slashpos + 1) != '*') {
//comment
//comment
//comment
//comment
firstTypeCut = mTypeToFilter.get(resolvedType);
secondTypeCut = mWildTypeToFilter.get(baseType);
} else {
//comment
firstTypeCut = mBaseTypeToFilter.get(baseType);
secondTypeCut = mWildTypeToFilter.get(baseType);
}
//comment
//comment
thirdTypeCut = mWildTypeToFilter.get(""*"");
} else if (intent.getAction() != null) {
//comment
//comment
//comment
firstTypeCut = mTypedActionToFilter.get(intent.getAction());
}
}
}

//comment
//comment
//comment
//comment
if (scheme != null) {
schemeCut = mSchemeToFilter.get(scheme);
}

//comment
//comment
//comment
if (resolvedType == null && scheme == null && intent.getAction() != null) {
firstTypeCut = mActionToFilter.get(intent.getAction());
}

FastImmutableArraySet<String> categories = getFastIntentCategories(intent);
if (firstTypeCut != null) {
buildResolveList(intent, categories, defaultOnly, resolvedType, scheme, firstTypeCut, finalList, userId);
}
if (secondTypeCut != null) {
buildResolveList(intent, categories, defaultOnly, resolvedType, scheme, secondTypeCut, finalList, userId);
}
if (thirdTypeCut != null) {
buildResolveList(intent, categories, defaultOnly, resolvedType, scheme, thirdTypeCut, finalList, userId);
}
if (schemeCut != null) {
buildResolveList(intent, categories, defaultOnly, resolvedType, scheme, schemeCut, finalList, userId);
}
sortResults(finalList);
return finalList;
}","public List<R> queryIntent(Intent intent, String resolvedType, boolean defaultOnly, int userId) {
String scheme = intent.getScheme();

ArrayList<R> finalList = new ArrayList<R>();
F[] firstTypeCut = null;
F[] secondTypeCut = null;
F[] thirdTypeCut = null;
F[] schemeCut = null;

//comment
//comment
<start>if (resolvedType != null) {
int slashpos = resolvedType.indexOf('/');
if (slashpos > 0) {
final String baseType = resolvedType.substring(0, slashpos);
if (!baseType.equals(""*"")) {
if (resolvedType.length() != slashpos + 2 || resolvedType.charAt(slashpos + 1) != '*') {
//comment
//comment
//comment
//comment
firstTypeCut = mTypeToFilter.get(resolvedType);
secondTypeCut = mWildTypeToFilter.get(baseType);
} else {
//comment
firstTypeCut = mBaseTypeToFilter.get(baseType);
secondTypeCut = mWildTypeToFilter.get(baseType);
}
//comment
//comment
thirdTypeCut = mWildTypeToFilter.get(""*"");
} else if (intent.getAction() != null) {
//comment
//comment
//comment
firstTypeCut = mTypedActionToFilter.get(intent.getAction());
}
}
}<end>

//comment
//comment
//comment
//comment
if (scheme != null) {
schemeCut = mSchemeToFilter.get(scheme);
}

//comment
//comment
//comment
if (resolvedType == null && scheme == null && intent.getAction() != null) {
firstTypeCut = mActionToFilter.get(intent.getAction());
}

FastImmutableArraySet<String> categories = getFastIntentCategories(intent);
if (firstTypeCut != null) {
buildResolveList(intent, categories, defaultOnly, resolvedType, scheme, firstTypeCut, finalList, userId);
}
if (secondTypeCut != null) {
buildResolveList(intent, categories, defaultOnly, resolvedType, scheme, secondTypeCut, finalList, userId);
}
if (thirdTypeCut != null) {
buildResolveList(intent, categories, defaultOnly, resolvedType, scheme, thirdTypeCut, finalList, userId);
}
if (schemeCut != null) {
buildResolveList(intent, categories, defaultOnly, resolvedType, scheme, schemeCut, finalList, userId);
}
sortResults(finalList);
return finalList;
}"
7192,"public List<R> queryIntent(Intent intent, String resolvedType, boolean defaultOnly, int userId) {
String scheme = intent.getScheme();

ArrayList<R> finalList = new ArrayList<R>();
F[] firstTypeCut = null;
F[] secondTypeCut = null;
F[] thirdTypeCut = null;
F[] schemeCut = null;

//comment
//comment
if (resolvedType != null) {
int slashpos = resolvedType.indexOf('/');
if (slashpos > 0) {
final String baseType = resolvedType.substring(0, slashpos);
if (!baseType.equals(""*"")) {
if (resolvedType.length() != slashpos + 2 || resolvedType.charAt(slashpos + 1) != '*') {
//comment
//comment
//comment
//comment
firstTypeCut = mTypeToFilter.get(resolvedType);
secondTypeCut = mWildTypeToFilter.get(baseType);
} else {
//comment
<start>firstTypeCut = mBaseTypeToFilter.get(baseType);
secondTypeCut = mWildTypeToFilter.get(baseType);<end>
}
//comment
//comment
thirdTypeCut = mWildTypeToFilter.get(""*"");
<start>} else if (intent.getAction() != null) {<end>
//comment
//comment
//comment
firstTypeCut = mTypedActionToFilter.get(intent.getAction());
}
}
}

//comment
//comment
//comment
//comment
if (scheme != null) {
schemeCut = mSchemeToFilter.get(scheme);
}

//comment
//comment
//comment
if (resolvedType == null && scheme == null && intent.getAction() != null) {
firstTypeCut = mActionToFilter.get(intent.getAction());
}

FastImmutableArraySet<String> categories = getFastIntentCategories(intent);
if (firstTypeCut != null) {
buildResolveList(intent, categories, defaultOnly, resolvedType, scheme, firstTypeCut, finalList, userId);
}
if (secondTypeCut != null) {
buildResolveList(intent, categories, defaultOnly, resolvedType, scheme, secondTypeCut, finalList, userId);
}
if (thirdTypeCut != null) {
buildResolveList(intent, categories, defaultOnly, resolvedType, scheme, thirdTypeCut, finalList, userId);
}
if (schemeCut != null) {
buildResolveList(intent, categories, defaultOnly, resolvedType, scheme, schemeCut, finalList, userId);
}
sortResults(finalList);
return finalList;
}","public List<R> queryIntent(Intent intent, String resolvedType, boolean defaultOnly, int userId) {
String scheme = intent.getScheme();

ArrayList<R> finalList = new ArrayList<R>();
F[] firstTypeCut = null;
F[] secondTypeCut = null;
F[] thirdTypeCut = null;
F[] schemeCut = null;

//comment
//comment
if (resolvedType != null) {
int slashpos = resolvedType.indexOf('/');
if (slashpos > 0) {
final String baseType = resolvedType.substring(0, slashpos);
if (!baseType.equals(""*"")) {
<start>if (resolvedType.length() != slashpos + 2 || resolvedType.charAt(slashpos + 1) != '*') {<end>
//comment
//comment
//comment
//comment
firstTypeCut = mTypeToFilter.get(resolvedType);
secondTypeCut = mWildTypeToFilter.get(baseType);
<start>} else {
//comment
firstTypeCut = mBaseTypeToFilter.get(baseType);
secondTypeCut = mWildTypeToFilter.get(baseType);
}<end>
//comment
//comment
thirdTypeCut = mWildTypeToFilter.get(""*"");
} else if (intent.getAction() != null) {
//comment
//comment
//comment
firstTypeCut = mTypedActionToFilter.get(intent.getAction());
}
}
}

//comment
//comment
//comment
//comment
if (scheme != null) {
schemeCut = mSchemeToFilter.get(scheme);
}

//comment
//comment
//comment
if (resolvedType == null && scheme == null && intent.getAction() != null) {
firstTypeCut = mActionToFilter.get(intent.getAction());
}

FastImmutableArraySet<String> categories = getFastIntentCategories(intent);
if (firstTypeCut != null) {
buildResolveList(intent, categories, defaultOnly, resolvedType, scheme, firstTypeCut, finalList, userId);
}
if (secondTypeCut != null) {
buildResolveList(intent, categories, defaultOnly, resolvedType, scheme, secondTypeCut, finalList, userId);
}
if (thirdTypeCut != null) {
buildResolveList(intent, categories, defaultOnly, resolvedType, scheme, thirdTypeCut, finalList, userId);
}
if (schemeCut != null) {
buildResolveList(intent, categories, defaultOnly, resolvedType, scheme, schemeCut, finalList, userId);
}
sortResults(finalList);
return finalList;
}"
7193,"private void buildResolveList(Intent intent, FastImmutableArraySet<String> categories,
boolean defaultOnly, String resolvedType, String scheme, F[] src, List<R> dest, int userId) {
final String action = intent.getAction();
final Uri data = intent.getData();
final String packageName = intent.getPackage();

final int N = src != null ? src.length : 0;
boolean hasNonDefaults = false;
int i;
F filter;
for (i = 0; i < N && (filter = src[i]) != null; i++) {
int match;

//comment
//comment
<start>if (packageName != null && !isPackageForFilter(packageName, filter)) {
continue;
}<end>
//comment
if (!allowFilterResult(filter, dest)) {
continue;
}

match = filter.filter.match(action, resolvedType, scheme, data, categories, TAG);
if (match >= 0) {
if (!defaultOnly || filter.filter.hasCategory(Intent.CATEGORY_DEFAULT)) {
final R oneResult = newResult(filter, match, userId);
if (oneResult != null) {
dest.add(oneResult);
}
} else {
hasNonDefaults = true;
}
}
}

if (hasNonDefaults) {
if (dest.size() == 0) {
VLog.w(TAG, ""resolveIntent failed: found match, but none with CATEGORY_DEFAULT"");
} else if (dest.size() > 1) {
VLog.w(TAG, ""resolveIntent: multiple matches, only some with CATEGORY_DEFAULT"");
}
}
}","private void buildResolveList(Intent intent, FastImmutableArraySet<String> categories,
boolean defaultOnly, String resolvedType, String scheme, F[] src, List<R> dest, int userId) {
final String action = intent.getAction();
final Uri data = intent.getData();
final String packageName = intent.getPackage();

final int N = src != null ? src.length : 0;
boolean hasNonDefaults = false;
int i;
F filter;
for (i = 0; i < N && (filter = src[i]) != null; i++) {
int match;

//comment
//comment
<start>if (packageName != null && !isPackageForFilter(packageName, filter)) {<end>
continue;
}
//comment
if (!allowFilterResult(filter, dest)) {
continue;
}

match = filter.filter.match(action, resolvedType, scheme, data, categories, TAG);
if (match >= 0) {
if (!defaultOnly || filter.filter.hasCategory(Intent.CATEGORY_DEFAULT)) {
final R oneResult = newResult(filter, match, userId);
if (oneResult != null) {
dest.add(oneResult);
}
} else {
hasNonDefaults = true;
}
}
}

if (hasNonDefaults) {
if (dest.size() == 0) {
VLog.w(TAG, ""resolveIntent failed: found match, but none with CATEGORY_DEFAULT"");
} else if (dest.size() > 1) {
VLog.w(TAG, ""resolveIntent: multiple matches, only some with CATEGORY_DEFAULT"");
}
}
}"
7249,"    private VUserInfo getUserInfoLocked(int userId) {
<start>VUserInfo ui = mUsers.get(userId);<end>
//comment
if (ui != null && ui.partial && !mRemovingUserIds.contains(userId)) {
VLog.w(LOG_TAG, ""getUserInfo: unknown user #"" + userId);
return null;
}
return ui;
}","    private VUserInfo getUserInfoLocked(int userId) {
VUserInfo ui = mUsers.get(userId);
//comment
<start>if (ui != null && ui.partial && !mRemovingUserIds.contains(userId)) {
VLog.w(LOG_TAG, ""getUserInfo: unknown user #"" + userId);
return null;
}<end>
return ui;
}"
7250,"@Override
public void setGuestEnabled(boolean enable) {
checkManageUsersPermission(""enable guest users"");
synchronized (mPackagesLock) {
if (mGuestEnabled != enable) {
<start>mGuestEnabled = enable;<end>
//comment
for (int i = 0; i < mUsers.size(); i++) {
<start>VUserInfo user = mUsers.valueAt(i);<end>
if (!user.partial && user.isGuest()) {
if (!enable) {
removeUser(user.id);
}
return;
}
}
//comment
if (enable) {
createUser(""Guest"", VUserInfo.FLAG_GUEST);
}
}
}
}","@Override
public void setGuestEnabled(boolean enable) {
checkManageUsersPermission(""enable guest users"");
synchronized (mPackagesLock) {
if (mGuestEnabled != enable) {
mGuestEnabled = enable;
//comment
<start>for (int i = 0; i < mUsers.size(); i++) {
VUserInfo user = mUsers.valueAt(i);
if (!user.partial && user.isGuest()) {
if (!enable) {
removeUser(user.id);
}
return;
}
}<end>
//comment
if (enable) {
createUser(""Guest"", VUserInfo.FLAG_GUEST);
}
}
}
}"
7251,"private void upgradeIfNecessary() {
int userVersion = mUserVersion;
if (userVersion < 1) {
//comment
<start>VUserInfo user = mUsers.get(VUserHandle.USER_OWNER);
if (""Primary"".equals(user.name)) {
user.name = ""Admin"";
writeUserLocked(user);
}<end>
userVersion = 1;
}

if (userVersion < USER_VERSION) {
VLog.w(LOG_TAG, ""User version "" + mUserVersion + "" didn't upgrade as expected to ""
+ USER_VERSION);
} else {
mUserVersion = userVersion;
writeUserListLocked();
}
}","private void upgradeIfNecessary() {
int userVersion = mUserVersion;
if (userVersion < 1) {
//comment
<start>VUserInfo user = mUsers.get(VUserHandle.USER_OWNER);
if (""Primary"".equals(user.name)) {
user.name = ""Admin"";
writeUserLocked(user);
}<end>
userVersion = 1;
}

if (userVersion < USER_VERSION) {
VLog.w(LOG_TAG, ""User version "" + mUserVersion + "" didn't upgrade as expected to ""
+ USER_VERSION);
} else {
mUserVersion = userVersion;
writeUserListLocked();
}
}"
7252,"    void finishRemoveUser(final int userHandle) {
if (DBG) VLog.i(LOG_TAG, ""finishRemoveUser "" + userHandle);
//comment
//comment
<start>long identity = Binder.clearCallingIdentity();<end>
try {
Intent addedIntent = new Intent(Constants.ACTION_USER_REMOVED);
addedIntent.putExtra(Constants.EXTRA_USER_HANDLE, userHandle);
VActivityManagerService.get().sendOrderedBroadcastAsUser(addedIntent, VUserHandle.ALL,
null,
new BroadcastReceiver() {
@Override
public void onReceive(Context context, Intent intent) {
if (DBG) {
VLog.i(LOG_TAG,
""USER_REMOVED broadcast sent, cleaning up user data ""
+ userHandle);
}
new Thread() {
public void run() {
synchronized (mInstallLock) {
synchronized (mPackagesLock) {
removeUserStateLocked(userHandle);
}
}
}
}.start();
}
},
null, Activity.RESULT_OK, null, null);
} finally {
Binder.restoreCallingIdentity(identity);
}
}","    void finishRemoveUser(final int userHandle) {
if (DBG) VLog.i(LOG_TAG, ""finishRemoveUser "" + userHandle);
//comment
//comment
<start>long identity = Binder.clearCallingIdentity();
try {
Intent addedIntent = new Intent(Constants.ACTION_USER_REMOVED);
addedIntent.putExtra(Constants.EXTRA_USER_HANDLE, userHandle);
VActivityManagerService.get().sendOrderedBroadcastAsUser(addedIntent, VUserHandle.ALL,
null,
new BroadcastReceiver() {
@Override
public void onReceive(Context context, Intent intent) {
if (DBG) {
VLog.i(LOG_TAG,
""USER_REMOVED broadcast sent, cleaning up user data ""
+ userHandle);
}
new Thread() {
public void run() {
synchronized (mInstallLock) {
synchronized (mPackagesLock) {
removeUserStateLocked(userHandle);
}
}
}
}.start();
}
},
null, Activity.RESULT_OK, null, null);
} finally {
Binder.restoreCallingIdentity(identity);
}<end>
}"
7253,"<start>    private void removeUserStateLocked(int userHandle) {
//comment
mPm.cleanUpUser(userHandle);<end>

//comment
mUsers.remove(userHandle);
mRemovingUserIds.remove(userHandle);
//comment
AtomicFile userFile = new AtomicFile(new File(mUsersDir, userHandle + "".xml""));
userFile.delete();
//comment
writeUserListLocked();
updateUserIdsLocked();
removeDirectoryRecursive(VEnvironment.getUserSystemDirectory(userHandle));
}","    private void removeUserStateLocked(int userHandle) {
//comment
<start>mPm.cleanUpUser(userHandle);<end>

//comment
mUsers.remove(userHandle);
mRemovingUserIds.remove(userHandle);
//comment
AtomicFile userFile = new AtomicFile(new File(mUsersDir, userHandle + "".xml""));
userFile.delete();
//comment
writeUserListLocked();
updateUserIdsLocked();
removeDirectoryRecursive(VEnvironment.getUserSystemDirectory(userHandle));
}"
7254,"<start>    private void removeUserStateLocked(int userHandle) {<end>
//comment
mPm.cleanUpUser(userHandle);

//comment
<start>mUsers.remove(userHandle);<end>
mRemovingUserIds.remove(userHandle);
//comment
AtomicFile userFile = new AtomicFile(new File(mUsersDir, userHandle + "".xml""));
<start>userFile.delete();<end>
//comment
writeUserListLocked();
updateUserIdsLocked();
removeDirectoryRecursive(VEnvironment.getUserSystemDirectory(userHandle));
}","    private void removeUserStateLocked(int userHandle) {
//comment
mPm.cleanUpUser(userHandle);

//comment
<start>mUsers.remove(userHandle);
mRemovingUserIds.remove(userHandle);<end>
//comment
AtomicFile userFile = new AtomicFile(new File(mUsersDir, userHandle + "".xml""));
userFile.delete();
//comment
writeUserListLocked();
updateUserIdsLocked();
removeDirectoryRecursive(VEnvironment.getUserSystemDirectory(userHandle));
}"
7255,"    private void removeUserStateLocked(int userHandle) {
//comment
mPm.cleanUpUser(userHandle);

//comment
mUsers.remove(userHandle);
<start>mRemovingUserIds.remove(userHandle);
//comment
AtomicFile userFile = new AtomicFile(new File(mUsersDir, userHandle + "".xml""));
userFile.delete();<end>
//comment
writeUserListLocked();
updateUserIdsLocked();
removeDirectoryRecursive(VEnvironment.getUserSystemDirectory(userHandle));
}","    private void removeUserStateLocked(int userHandle) {
//comment
mPm.cleanUpUser(userHandle);

//comment
mUsers.remove(userHandle);
mRemovingUserIds.remove(userHandle);
//comment
<start>AtomicFile userFile = new AtomicFile(new File(mUsersDir, userHandle + "".xml""));
userFile.delete();<end>
//comment
writeUserListLocked();
updateUserIdsLocked();
removeDirectoryRecursive(VEnvironment.getUserSystemDirectory(userHandle));
}"
7256,"    private void removeUserStateLocked(int userHandle) {
//comment
mPm.cleanUpUser(userHandle);

//comment
mUsers.remove(userHandle);
mRemovingUserIds.remove(userHandle);
//comment
AtomicFile userFile = new AtomicFile(new File(mUsersDir, userHandle + "".xml""));
userFile.delete();
//comment
<start>writeUserListLocked();<end>
updateUserIdsLocked();
removeDirectoryRecursive(VEnvironment.getUserSystemDirectory(userHandle));
}","    private void removeUserStateLocked(int userHandle) {
//comment
mPm.cleanUpUser(userHandle);

//comment
mUsers.remove(userHandle);
mRemovingUserIds.remove(userHandle);
//comment
AtomicFile userFile = new AtomicFile(new File(mUsersDir, userHandle + "".xml""));
userFile.delete();
//comment
<start>writeUserListLocked();
updateUserIdsLocked();
removeDirectoryRecursive(VEnvironment.getUserSystemDirectory(userHandle));<end>
}"
7197,"public static void addApp(AppInfoLite info, UpdateListener refreshListener) {
class AddResult {
private PackageAppData appData;
private int userId;
private boolean justEnableHidden;
}
AddResult addResult = new AddResult();
VUiKit.defer().when(() -> {
InstalledAppInfo installedAppInfo = VirtualCore.get().getInstalledAppInfo(info.packageName, 0);
addResult.justEnableHidden = installedAppInfo != null;

if (info.disableMultiVersion) {
addResult.justEnableHidden = false;
}
if (addResult.justEnableHidden) {
int[] userIds = installedAppInfo.getInstalledUsers();
int nextUserId = userIds.length;
//comment
//comment
//comment
//comment
for (int i = 0; i < userIds.length; i++) {
if (userIds[i] != i) {
nextUserId = i;
break;
}
}
addResult.userId = nextUserId;

if (VUserManager.get().getUserInfo(nextUserId) == null) {
//comment
String nextUserName = ""Space "" + (nextUserId + 1);
<start>VUserInfo newUserInfo = VUserManager.get().createUser(nextUserName, VUserInfo.FLAG_ADMIN);<end>
if (newUserInfo == null) {
throw new IllegalStateException();
}
}
boolean success = VirtualCore.get().installPackageAsUser(nextUserId, info.packageName);
if (!success) {
throw new IllegalStateException();
}
} else {
PackageInfo pkgInfo = null;
try {
pkgInfo = XApp.getApp().getPackageManager().getPackageArchiveInfo(info.path, 0);
pkgInfo.applicationInfo.sourceDir = info.path;
pkgInfo.applicationInfo.publicSourceDir = info.path;
} catch (Exception e) {
}
if(pkgInfo != null) {
PackageAppData data = PackageAppDataStorage.get().acquire(pkgInfo.applicationInfo);
addResult.appData = data;
data.isInstalling = true;
data.isFirstOpen = false;
if (refreshListener != null) {
refreshListener.update(data);
}
}

InstallResult res = addVirtualApp(info);
if (!res.isSuccess) {
if (addResult.appData != null) {
//comment
}
throw new IllegalStateException(res.error);
}
}
}).then((res) -> {
if (addResult.appData == null) {
addResult.appData = PackageAppDataStorage.get().acquire(info.packageName);
}
}).done(res -> {
boolean multipleVersion = addResult.justEnableHidden && addResult.userId != 0;
if (!multipleVersion) {
PackageAppData data = addResult.appData;
data.isInstalling = false;
data.isLoading = true;

if (refreshListener != null) {
refreshListener.update(data);
}
handleOptApp(data, info.packageName, true, refreshListener);
} else {
MultiplePackageAppData data = new MultiplePackageAppData(addResult.appData, addResult.userId);
data.isInstalling = false;
data.isLoading = true;

if (refreshListener != null) {
refreshListener.update(data);
}
handleOptApp(data, info.packageName, false, refreshListener);
}
}).fail(result -> {
if (refreshListener != null) {
refreshListener.fail(result.getMessage());

}
});
}","public static void addApp(AppInfoLite info, UpdateListener refreshListener) {
class AddResult {
private PackageAppData appData;
private int userId;
private boolean justEnableHidden;
}
AddResult addResult = new AddResult();
VUiKit.defer().when(() -> {
InstalledAppInfo installedAppInfo = VirtualCore.get().getInstalledAppInfo(info.packageName, 0);
addResult.justEnableHidden = installedAppInfo != null;

if (info.disableMultiVersion) {
addResult.justEnableHidden = false;
}
if (addResult.justEnableHidden) {
int[] userIds = installedAppInfo.getInstalledUsers();
int nextUserId = userIds.length;
//comment
//comment
//comment
//comment
for (int i = 0; i < userIds.length; i++) {
if (userIds[i] != i) {
nextUserId = i;
break;
}
}
addResult.userId = nextUserId;

if (VUserManager.get().getUserInfo(nextUserId) == null) {
//comment
<start>String nextUserName = ""Space "" + (nextUserId + 1);
VUserInfo newUserInfo = VUserManager.get().createUser(nextUserName, VUserInfo.FLAG_ADMIN);<end>
if (newUserInfo == null) {
throw new IllegalStateException();
}
}
boolean success = VirtualCore.get().installPackageAsUser(nextUserId, info.packageName);
if (!success) {
throw new IllegalStateException();
}
} else {
PackageInfo pkgInfo = null;
try {
pkgInfo = XApp.getApp().getPackageManager().getPackageArchiveInfo(info.path, 0);
pkgInfo.applicationInfo.sourceDir = info.path;
pkgInfo.applicationInfo.publicSourceDir = info.path;
} catch (Exception e) {
}
if(pkgInfo != null) {
PackageAppData data = PackageAppDataStorage.get().acquire(pkgInfo.applicationInfo);
addResult.appData = data;
data.isInstalling = true;
data.isFirstOpen = false;
if (refreshListener != null) {
refreshListener.update(data);
}
}

InstallResult res = addVirtualApp(info);
if (!res.isSuccess) {
if (addResult.appData != null) {
//comment
}
throw new IllegalStateException(res.error);
}
}
}).then((res) -> {
if (addResult.appData == null) {
addResult.appData = PackageAppDataStorage.get().acquire(info.packageName);
}
}).done(res -> {
boolean multipleVersion = addResult.justEnableHidden && addResult.userId != 0;
if (!multipleVersion) {
PackageAppData data = addResult.appData;
data.isInstalling = false;
data.isLoading = true;

if (refreshListener != null) {
refreshListener.update(data);
}
handleOptApp(data, info.packageName, true, refreshListener);
} else {
MultiplePackageAppData data = new MultiplePackageAppData(addResult.appData, addResult.userId);
data.isInstalling = false;
data.isLoading = true;

if (refreshListener != null) {
refreshListener.update(data);
}
handleOptApp(data, info.packageName, false, refreshListener);
}
}).fail(result -> {
if (refreshListener != null) {
refreshListener.fail(result.getMessage());

}
});
}"
1770,"@Override
public Object call(Object who, Method method, Object... args) throws Throwable {
ActivityManager.TaskDescription td = (ActivityManager.TaskDescription) args[1];
<start>String label = td.getLabel();<end>
Bitmap icon = td.getIcon();

//comment
//comment
if (label == null || icon == null) {
Application app = VClientImpl.get().getCurrentApplication();
if (app != null) {
try {
if (label == null) {
label = app.getApplicationInfo().loadLabel(app.getPackageManager()).toString();
}
if (icon == null) {
Drawable drawable = app.getApplicationInfo().loadIcon(app.getPackageManager());
if (drawable != null) {
icon = DrawableUtils.drawableToBitMap(drawable);
}
}
td = new ActivityManager.TaskDescription(label, icon, td.getPrimaryColor());
} catch (Throwable e) {
e.printStackTrace();
}
}
}

TaskDescriptionDelegate descriptionDelegate = VirtualCore.get().getTaskDescriptionDelegate();
if (descriptionDelegate != null) {
td = descriptionDelegate.getTaskDescription(td);
}

args[1] = td;
return method.invoke(who, args);
}","@Override
public Object call(Object who, Method method, Object... args) throws Throwable {
ActivityManager.TaskDescription td = (ActivityManager.TaskDescription) args[1];
String label = td.getLabel();
Bitmap icon = td.getIcon();

//comment
//comment
<start>if (label == null || icon == null) {
Application app = VClientImpl.get().getCurrentApplication();
if (app != null) {
try {
if (label == null) {
label = app.getApplicationInfo().loadLabel(app.getPackageManager()).toString();
}
if (icon == null) {
Drawable drawable = app.getApplicationInfo().loadIcon(app.getPackageManager());
if (drawable != null) {
icon = DrawableUtils.drawableToBitMap(drawable);
}
}
td = new ActivityManager.TaskDescription(label, icon, td.getPrimaryColor());
} catch (Throwable e) {
e.printStackTrace();
}
}
}<end>

TaskDescriptionDelegate descriptionDelegate = VirtualCore.get().getTaskDescriptionDelegate();
if (descriptionDelegate != null) {
td = descriptionDelegate.getTaskDescription(td);
}

args[1] = td;
return method.invoke(who, args);
}"
1771,"        private Intent handleIntent(final Intent intent) {
final String action = intent.getAction();
if (""android.intent.action.CREATE_SHORTCUT"".equals(action)
|| ""com.android.launcher.action.INSTALL_SHORTCUT"".equals(action)) {

return VASettings.ENABLE_INNER_SHORTCUT ? handleInstallShortcutIntent(intent) : null;

} else if (""com.android.launcher.action.UNINSTALL_SHORTCUT"".equals(action)) {

handleUninstallShortcutIntent(intent);

} else if (BadgerManager.handleBadger(intent)) {
return null;
} else if (Intent.ACTION_MEDIA_SCANNER_SCAN_FILE.equals(action)) {
//comment
<start>return handleMediaScannerIntent(intent);<end>
} else {
return ComponentUtils.redirectBroadcastIntent(intent, VUserHandle.myUserId());
}
return intent;
}","        private Intent handleIntent(final Intent intent) {
final String action = intent.getAction();
if (""android.intent.action.CREATE_SHORTCUT"".equals(action)
|| ""com.android.launcher.action.INSTALL_SHORTCUT"".equals(action)) {

return VASettings.ENABLE_INNER_SHORTCUT ? handleInstallShortcutIntent(intent) : null;

} else if (""com.android.launcher.action.UNINSTALL_SHORTCUT"".equals(action)) {

handleUninstallShortcutIntent(intent);

} else if (BadgerManager.handleBadger(intent)) {
return null;
<start>} else if (Intent.ACTION_MEDIA_SCANNER_SCAN_FILE.equals(action)) {
//comment
return handleMediaScannerIntent(intent);<end>
} else {
return ComponentUtils.redirectBroadcastIntent(intent, VUserHandle.myUserId());
}
return intent;
}"
665,"    public synchronized StoredContractDetails getSnapshot(InternalVmType vm, byte[] key, byte[] storageRoot) {
Optional<byte[]> rawDetails = detailsSrc.get(key);

if (rawDetails.isPresent()) {
//comment
<start>RLPContractDetails rlpDetails = fromEncoding(rawDetails.get());
ByteArrayKeyValueStore storage = createStorageSource(rlpDetails.address);<end>
if (vm == InternalVmType.AVM) {
ByteArrayKeyValueStore graph = createGraphSource(rlpDetails.address);
return AvmContractDetails.decodeAtRoot(rlpDetails, storage, graph, storageRoot);
} else if (vm == InternalVmType.FVM) {
return FvmContractDetails.decodeAtRoot(rlpDetails, storage, storageRoot);
} else {
//comment
//comment
return null;
}
} else {
return null;
}
}","    public synchronized StoredContractDetails getSnapshot(InternalVmType vm, byte[] key, byte[] storageRoot) {
Optional<byte[]> rawDetails = detailsSrc.get(key);

if (rawDetails.isPresent()) {
//comment
<start>RLPContractDetails rlpDetails = fromEncoding(rawDetails.get());
ByteArrayKeyValueStore storage = createStorageSource(rlpDetails.address);
if (vm == InternalVmType.AVM) {
ByteArrayKeyValueStore graph = createGraphSource(rlpDetails.address);
return AvmContractDetails.decodeAtRoot(rlpDetails, storage, graph, storageRoot);
} else if (vm == InternalVmType.FVM) {
return FvmContractDetails.decodeAtRoot(rlpDetails, storage, storageRoot);
} else {
//comment
//comment
return null;
}<end>
} else {
return null;
}
}"
666,"<start>public synchronized void update(AionAddress key, StoredContractDetails contractDetails) {
//comment
byte[] rawDetails = contractDetails.getEncoded();<end>
detailsSrc.put(key.toByteArray(), rawDetails);
<start>detailsSrc.commit();
contractDetails.syncStorage();<end>
}","public synchronized void update(AionAddress key, StoredContractDetails contractDetails) {
//comment
<start>byte[] rawDetails = contractDetails.getEncoded();
detailsSrc.put(key.toByteArray(), rawDetails);
detailsSrc.commit();
contractDetails.syncStorage();<end>
}"
7650,"public synchronized TxResponse addTransactionFromApiServer(AionTransaction tx) {

TxResponse response = validateTx(tx);
if (response.isFail()) {
LOGGER_TX.warn(""tx is not valid - status: {} tx: {}"", response.name(), tx);
return response;
}

//comment
<start>if (isSeedMode || !closeToNetworkBest) {
transactionBroadcastCallback.broadcastTransactions(Collections.singletonList(tx));
return TxResponse.SUCCESS;
}<end>

return addPendingTransactions(Collections.singletonList(tx)).get(0);
}","public synchronized TxResponse addTransactionFromApiServer(AionTransaction tx) {

TxResponse response = validateTx(tx);
if (response.isFail()) {
LOGGER_TX.warn(""tx is not valid - status: {} tx: {}"", response.name(), tx);
return response;
}

//comment
<start>if (isSeedMode || !closeToNetworkBest) {
transactionBroadcastCallback.broadcastTransactions(Collections.singletonList(tx));
return TxResponse.SUCCESS;
}<end>

return addPendingTransactions(Collections.singletonList(tx)).get(0);
}"
7651,"    public synchronized void addTransactionsFromNetwork(List<AionTransaction> transactions) {
List<AionTransaction> validTransactions = new ArrayList<>();

for (AionTransaction tx : transactions) {
if (!TXValidator.isInCache(ByteArrayWrapper.wrap(tx.getTransactionHash())) && !validateTx(tx).isFail()) {
validTransactions.add(tx);
}
}

//comment
if (isSeedMode || !closeToNetworkBest) {
<start>transactionBroadcastCallback.broadcastTransactions(validTransactions);<end>
} else {
addPendingTransactions(validTransactions);
}
}","    public synchronized void addTransactionsFromNetwork(List<AionTransaction> transactions) {
List<AionTransaction> validTransactions = new ArrayList<>();

for (AionTransaction tx : transactions) {
if (!TXValidator.isInCache(ByteArrayWrapper.wrap(tx.getTransactionHash())) && !validateTx(tx).isFail()) {
validTransactions.add(tx);
}
}

//comment
<start>if (isSeedMode || !closeToNetworkBest) {
transactionBroadcastCallback.broadcastTransactions(validTransactions);
} else {
addPendingTransactions(validTransactions);
}<end>
}"
7652,"private TxResponse addPendingTransactionInner(final AionTransaction tx) {

if (txPool.isContained(tx.getSenderAddress(), tx.getNonceBI())) {
//comment
<start>PooledTransaction poolTx = txPool.getPoolTx(tx.getSenderAddress(), tx.getNonceBI());
//comment
BigInteger repayValidPrice = BigInteger.valueOf(poolTx.tx.getEnergyPrice()).multiply(BigInteger.TWO);<end>
if (BigInteger.valueOf(tx.getEnergyPrice()).compareTo(repayValidPrice) >= 0) {
if (repayTransaction.size() < (txPool.maxPoolSize / 4)) {
<start>repayTransaction.add(tx);<end>
return TxResponse.REPAID;
} else {
fireDroppedTx(tx, TxResponse.REPAYTX_BUFFER_FULL.getMessage());
return TxResponse.DROPPED;
}
} else {
fireDroppedTx(tx, TxResponse.REPAYTX_LOWPRICE.getMessage());
return TxResponse.REPAYTX_LOWPRICE;
}
} else {
AionTxExecSummary txSum = executeTx(tx);
if (txSum.isRejected()) {
LOGGER_TX.debug(
""addPendingTransactionImpl tx: {} is rejected due to: {}"",
Hex.toHexString(tx.getTransactionHash()),
txSum.getReceipt().getError());

fireTxUpdate(txSum.getReceipt(), PendingTransactionState.DROPPED, currentBestBlock.get());
return TxResponse.DROPPED;
} else {
PooledTransaction pendingTx = new PooledTransaction(tx, txSum.getReceipt().getEnergyUsed());
LOGGER_TX.debug(""addPendingTransactionImpl validTx: {}"", tx);

PooledTransaction rtn = this.txPool.add(pendingTx);
if (rtn == null|| rtn != pendingTx) {
//comment
throw new IllegalStateException(""The pool data has broken, missing the tx: "" + pendingTx);
} else {
fireTxUpdate(txSum.getReceipt(), PendingTransactionState.NEW_PENDING, currentBestBlock.get());
return TxResponse.SUCCESS;
}
}
}
}","private TxResponse addPendingTransactionInner(final AionTransaction tx) {

if (txPool.isContained(tx.getSenderAddress(), tx.getNonceBI())) {
//comment
PooledTransaction poolTx = txPool.getPoolTx(tx.getSenderAddress(), tx.getNonceBI());
//comment
BigInteger repayValidPrice = BigInteger.valueOf(poolTx.tx.getEnergyPrice()).multiply(BigInteger.TWO);
<start>if (BigInteger.valueOf(tx.getEnergyPrice()).compareTo(repayValidPrice) >= 0) {<end>
if (repayTransaction.size() < (txPool.maxPoolSize / 4)) {
repayTransaction.add(tx);
return TxResponse.REPAID;
} else {
fireDroppedTx(tx, TxResponse.REPAYTX_BUFFER_FULL.getMessage());
return TxResponse.DROPPED;
}
} else {
fireDroppedTx(tx, TxResponse.REPAYTX_LOWPRICE.getMessage());
return TxResponse.REPAYTX_LOWPRICE;
}
} else {
AionTxExecSummary txSum = executeTx(tx);
if (txSum.isRejected()) {
LOGGER_TX.debug(
""addPendingTransactionImpl tx: {} is rejected due to: {}"",
Hex.toHexString(tx.getTransactionHash()),
txSum.getReceipt().getError());

fireTxUpdate(txSum.getReceipt(), PendingTransactionState.DROPPED, currentBestBlock.get());
return TxResponse.DROPPED;
} else {
PooledTransaction pendingTx = new PooledTransaction(tx, txSum.getReceipt().getEnergyUsed());
LOGGER_TX.debug(""addPendingTransactionImpl validTx: {}"", tx);

PooledTransaction rtn = this.txPool.add(pendingTx);
if (rtn == null|| rtn != pendingTx) {
//comment
throw new IllegalStateException(""The pool data has broken, missing the tx: "" + pendingTx);
} else {
fireTxUpdate(txSum.getReceipt(), PendingTransactionState.NEW_PENDING, currentBestBlock.get());
return TxResponse.SUCCESS;
}
}
}
}"
7653,"    @Override
public synchronized void applyBlockUpdate(Block newBlock, List<AionTxReceipt> receipts) {

<start>if (isSeedMode) {
//comment
return;
}<end>

if (currentBestBlock.get().isParentOf(newBlock)) {
LOGGER_TX.info(""PendingStateImpl.processBest: {}"", newBlock.getShortDescr());
processBestInternal(newBlock, receipts);
} else {
//comment
Block commonAncestor = findCommonAncestor(currentBestBlock.get(), newBlock);

LOGGER_TX.info(
""New best block from another fork: {}, old best: {}, ancestor: {}"",
newBlock.getShortDescr(),
currentBestBlock.get().getShortDescr(),
commonAncestor.getShortDescr());

processRollbackTransactions(commonAncestor);

processMainChainBlocks(commonAncestor, newBlock);
}

currentBestBlock.set(newBlock);
txPool.updateBlkNrgLimit(currentBestBlock.get().getNrgLimit());

checkNetworkFullSynced();
checkCloseToNetworkBest();

//comment
pendingState = blockchain.getRepository().startTracking();
rerunTxsInPool(currentBestBlock.get());

flushCachedTx();
backupPendingTx();

//comment
dumpPool();
}","    @Override
public synchronized void applyBlockUpdate(Block newBlock, List<AionTxReceipt> receipts) {

<start>if (isSeedMode) {
//comment
return;
}<end>

if (currentBestBlock.get().isParentOf(newBlock)) {
LOGGER_TX.info(""PendingStateImpl.processBest: {}"", newBlock.getShortDescr());
processBestInternal(newBlock, receipts);
} else {
//comment
Block commonAncestor = findCommonAncestor(currentBestBlock.get(), newBlock);

LOGGER_TX.info(
""New best block from another fork: {}, old best: {}, ancestor: {}"",
newBlock.getShortDescr(),
currentBestBlock.get().getShortDescr(),
commonAncestor.getShortDescr());

processRollbackTransactions(commonAncestor);

processMainChainBlocks(commonAncestor, newBlock);
}

currentBestBlock.set(newBlock);
txPool.updateBlkNrgLimit(currentBestBlock.get().getNrgLimit());

checkNetworkFullSynced();
checkCloseToNetworkBest();

//comment
pendingState = blockchain.getRepository().startTracking();
rerunTxsInPool(currentBestBlock.get());

flushCachedTx();
backupPendingTx();

//comment
dumpPool();
}"
7654,"    @Override
public synchronized void applyBlockUpdate(Block newBlock, List<AionTxReceipt> receipts) {

if (isSeedMode) {
//comment
return;
}

if (currentBestBlock.get().isParentOf(newBlock)) {
LOGGER_TX.info(""PendingStateImpl.processBest: {}"", newBlock.getShortDescr());
processBestInternal(newBlock, receipts);
} else {
//comment
Block commonAncestor = findCommonAncestor(currentBestBlock.get(), newBlock);

LOGGER_TX.info(
""New best block from another fork: {}, old best: {}, ancestor: {}"",
newBlock.getShortDescr(),
currentBestBlock.get().getShortDescr(),
commonAncestor.getShortDescr());

processRollbackTransactions(commonAncestor);

processMainChainBlocks(commonAncestor, newBlock);
}

currentBestBlock.set(newBlock);
txPool.updateBlkNrgLimit(currentBestBlock.get().getNrgLimit());

checkNetworkFullSynced();
checkCloseToNetworkBest();

//comment
<start>pendingState = blockchain.getRepository().startTracking();<end>
rerunTxsInPool(currentBestBlock.get());

flushCachedTx();
backupPendingTx();

//comment
dumpPool();
}","    @Override
public synchronized void applyBlockUpdate(Block newBlock, List<AionTxReceipt> receipts) {

if (isSeedMode) {
//comment
return;
}

if (currentBestBlock.get().isParentOf(newBlock)) {
LOGGER_TX.info(""PendingStateImpl.processBest: {}"", newBlock.getShortDescr());
processBestInternal(newBlock, receipts);
} else {
//comment
Block commonAncestor = findCommonAncestor(currentBestBlock.get(), newBlock);

LOGGER_TX.info(
""New best block from another fork: {}, old best: {}, ancestor: {}"",
newBlock.getShortDescr(),
currentBestBlock.get().getShortDescr(),
commonAncestor.getShortDescr());

processRollbackTransactions(commonAncestor);

processMainChainBlocks(commonAncestor, newBlock);
}

currentBestBlock.set(newBlock);
txPool.updateBlkNrgLimit(currentBestBlock.get().getNrgLimit());

checkNetworkFullSynced();
checkCloseToNetworkBest();

//comment
<start>pendingState = blockchain.getRepository().startTracking();
rerunTxsInPool(currentBestBlock.get());<end>

flushCachedTx();
backupPendingTx();

//comment
dumpPool();
}"
7655,"    private void processMainChainBlocks(Block commonAncestor, Block mainChainBest) {
Block mainChainBlock = mainChainBest;
Stack<Block> stack = new Stack<>();
<start>while (!mainChainBlock.isEqual(commonAncestor)) {
LOGGER_TX.debug(""mainChain: {}"", mainChainBlock.getShortDescr());
stack.push(mainChainBlock);
mainChainBlock = blockchain.getBlockByHash(mainChainBlock.getParentHash());
}<end>

//comment
<start>while (!stack.isEmpty()) {
processBestInternal(stack.pop(), null);
}<end>
}","    private void processMainChainBlocks(Block commonAncestor, Block mainChainBest) {
Block mainChainBlock = mainChainBest;
Stack<Block> stack = new Stack<>();
while (!mainChainBlock.isEqual(commonAncestor)) {
LOGGER_TX.debug(""mainChain: {}"", mainChainBlock.getShortDescr());
stack.push(mainChainBlock);
mainChainBlock = blockchain.getBlockByHash(mainChainBlock.getParentHash());
}

//comment
<start>while (!stack.isEmpty()) {
processBestInternal(stack.pop(), null);
}<end>
}"
7656,"<start>    private void processRollbackTransactions(Block commonAncestor) {<end>

//comment
<start>Block rollback = currentBestBlock.get();<end>
Stack<List<AionTransaction>> stack = new Stack<>();
while (!rollback.isEqual(commonAncestor)) {
LOGGER_TX.debug(""Rollback: {}"", rollback.getShortDescr());
stack.push(rollback.getTransactionsList());
rollback = blockchain.getBlockByHash(rollback.getParentHash());
}

while (!stack.isEmpty()) {
List<AionTransaction> transactions = stack.pop();
for (AionTransaction tx : transactions) {
//comment
//comment
txPool.add(new PooledTransaction(tx, tx.getEnergyLimit()));
}
}
}","    private void processRollbackTransactions(Block commonAncestor) {

//comment
Block rollback = currentBestBlock.get();
<start>Stack<List<AionTransaction>> stack = new Stack<>();
while (!rollback.isEqual(commonAncestor)) {
LOGGER_TX.debug(""Rollback: {}"", rollback.getShortDescr());
stack.push(rollback.getTransactionsList());
rollback = blockchain.getBlockByHash(rollback.getParentHash());
}<end>

while (!stack.isEmpty()) {
List<AionTransaction> transactions = stack.pop();
for (AionTransaction tx : transactions) {
//comment
//comment
txPool.add(new PooledTransaction(tx, tx.getEnergyLimit()));
}
}
}"
7657,"private AionTxExecSummary executeTx(AionTransaction tx) {

Block bestBlk = currentBestBlock.get();
LOGGER_TX.debug(""executeTx: {}"", Hex.toHexString(tx.getTransactionHash()));

try {
//comment
boolean isLocalCall = false;
boolean incrementSenderNonce = true;
boolean checkBlockEnergyLimit = false;

//comment
byte[] difficulty = bestBlk.getDifficulty();
//comment
long currentBlockNumber = bestBlk.getNumber() + 1;
//comment
long timestamp = bestBlk.getTimestamp() + 1;
//comment
<start>long blockNrgLimit = Long.MAX_VALUE;<end>
//comment
AionAddress miner = bestBlk.getCoinbase();

return BulkExecutor.executeTransactionWithNoPostExecutionWork(
difficulty,
currentBlockNumber,
timestamp,
blockNrgLimit,
miner,
tx,
pendingState,
isLocalCall,
incrementSenderNonce,
blockchain.forkUtility.is040ForkActive(currentBlockNumber),
checkBlockEnergyLimit,
LOGGER_VM,
BlockCachingContext.PENDING,
bestBlk.getNumber(),
blockchain.forkUtility.isUnityForkActive(currentBlockNumber),
blockchain.forkUtility.isSignatureSwapForkActive(currentBlockNumber));
} catch (VmFatalException e) {
LOGGER_VM.error(""Shutdown due to a VM fatal error."", e);
System.exit(SystemExitCodes.FATAL_VM_ERROR);
return null;
}
}","private AionTxExecSummary executeTx(AionTransaction tx) {

Block bestBlk = currentBestBlock.get();
LOGGER_TX.debug(""executeTx: {}"", Hex.toHexString(tx.getTransactionHash()));

try {
//comment
boolean isLocalCall = false;
boolean incrementSenderNonce = true;
boolean checkBlockEnergyLimit = false;

//comment
byte[] difficulty = bestBlk.getDifficulty();
//comment
long currentBlockNumber = bestBlk.getNumber() + 1;
//comment
long timestamp = bestBlk.getTimestamp() + 1;
//comment
<start>long blockNrgLimit = Long.MAX_VALUE;<end>
//comment
AionAddress miner = bestBlk.getCoinbase();

return BulkExecutor.executeTransactionWithNoPostExecutionWork(
difficulty,
currentBlockNumber,
timestamp,
blockNrgLimit,
miner,
tx,
pendingState,
isLocalCall,
incrementSenderNonce,
blockchain.forkUtility.is040ForkActive(currentBlockNumber),
checkBlockEnergyLimit,
LOGGER_VM,
BlockCachingContext.PENDING,
bestBlk.getNumber(),
blockchain.forkUtility.isUnityForkActive(currentBlockNumber),
blockchain.forkUtility.isSignatureSwapForkActive(currentBlockNumber));
} catch (VmFatalException e) {
LOGGER_VM.error(""Shutdown due to a VM fatal error."", e);
System.exit(SystemExitCodes.FATAL_VM_ERROR);
return null;
}
}"
7644,"@Override
public void run() {
while (go) {
IEvent e = ees.take();
if (e.getEventType() == IHandler.TYPE.BLOCK0.getValue()
&& e.getCallbackType() == EventBlock.CALLBACK.ONBEST0.getValue()) {
//comment
//comment
<start>createNewBlockTemplate();
} else if (e.getEventType() == IHandler.TYPE.CONSENSUS.getValue()<end>
&& e.getCallbackType() == EventConsensus.CALLBACK.ON_SOLUTION.getValue()) {
<start>processSolution((AionPowSolution) e.getFuncArgs().get(0));<end>
} else if (e.getEventType() == IHandler.TYPE.POISONPILL.getValue()) {
<start>go = false;<end>
}
}
}","@Override
public void run() {
while (go) {
IEvent e = ees.take();
if (e.getEventType() == IHandler.TYPE.BLOCK0.getValue()
&& e.getCallbackType() == EventBlock.CALLBACK.ONBEST0.getValue()) {
//comment
//comment
<start>createNewBlockTemplate();<end>
} else if (e.getEventType() == IHandler.TYPE.CONSENSUS.getValue()
&& e.getCallbackType() == EventConsensus.CALLBACK.ON_SOLUTION.getValue()) {
processSolution((AionPowSolution) e.getFuncArgs().get(0));
} else if (e.getEventType() == IHandler.TYPE.POISONPILL.getValue()) {
go = false;
}
}
}"
7645,"public void init(IAionBlockchain blockchain, IPendingState pendingState, IEventMgr eventMgr, SyncMgr syncMgr) {
if (initialized.compareAndSet(false, true)) {
this.blockchain = blockchain;
this.pendingState = pendingState;
this.pendingState.setNewPendingReceiveForMining(newPendingTxReceived.get());

this.eventMgr = eventMgr;
this.syncMgr = syncMgr;

//comment
//comment
<start>if (!config.getConsensus().getMining()) return;<end>

setupHandler();
ees = new EventExecuteService(100_000, ""EpPow"", Thread.NORM_PRIORITY, LOG);
ees.setFilter(setEvtFilter());

registerCallback();
ees.start(new EpPOW());

new Thread(
() -> {
while (!shutDown.get()) {
try {
Thread.sleep(100);

long now = System.currentTimeMillis();
if ((now - lastUpdate.get() > 3000 && newPendingTxReceived.compareAndSet(true, false))
|| now - lastUpdate.get() > 10000) {
createNewBlockTemplate();
} else {
if (TimeUnit.MILLISECONDS.toSeconds(now) == latestBlockTemplate.getTimestamp() + 1) {
createNewBlockTemplate();
}
}
} catch (InterruptedException e) {
break;
}
}
},
""pow"")
.start();
}
}","public void init(IAionBlockchain blockchain, IPendingState pendingState, IEventMgr eventMgr, SyncMgr syncMgr) {
if (initialized.compareAndSet(false, true)) {
this.blockchain = blockchain;
this.pendingState = pendingState;
this.pendingState.setNewPendingReceiveForMining(newPendingTxReceived.get());

this.eventMgr = eventMgr;
this.syncMgr = syncMgr;

//comment
//comment
<start>if (!config.getConsensus().getMining()) return;<end>

setupHandler();
ees = new EventExecuteService(100_000, ""EpPow"", Thread.NORM_PRIORITY, LOG);
ees.setFilter(setEvtFilter());

registerCallback();
ees.start(new EpPOW());

new Thread(
() -> {
while (!shutDown.get()) {
try {
Thread.sleep(100);

long now = System.currentTimeMillis();
if ((now - lastUpdate.get() > 3000 && newPendingTxReceived.compareAndSet(true, false))
|| now - lastUpdate.get() > 10000) {
createNewBlockTemplate();
} else {
if (TimeUnit.MILLISECONDS.toSeconds(now) == latestBlockTemplate.getTimestamp() + 1) {
createNewBlockTemplate();
}
}
} catch (InterruptedException e) {
break;
}
}
},
""pow"")
.start();
}
}"
7646,"private synchronized void processSolution(AionPowSolution solution) {
if (!shutDown.get()) {
if (LOG.isDebugEnabled()) {
LOG.debug(""Best block num [{}]"", blockchain.getBestBlock().getNumber());
LOG.debug(
""Best block hash [{}]"",
Hex.toHexString(blockchain.getBestBlock().getHash()));
}

MiningBlock block = solution.getBlock();
<start>if (!Arrays.equals(block.getHeader().getNonce(), new byte[32])
&& !(block.getHeader().getNonce().length == 0)) {
//comment
return;
}<end>

//comment
try {
block.seal(solution.getNonce(), solution.getSolution());
} catch (Exception e) {
LOG.error(""seal block failed!"", e);
return;
}

//comment
ImportResult importResult = AionImpl.inst().addNewBlock(block);

//comment
if (importResult.isSuccessful()) {
if (importResult == IMPORTED_BEST) {
LOG.info(
""block sealed <num={}, hash={}, diff={}, tx={}>"",
block.getNumber(),
block.getShortHash(),
block.getHeader().getDifficultyBI().toString(),
block.getTransactionsList().size());
} else {
LOG.debug(
""block sealed <num={}, hash={}, diff={}, td={}, tx={}, result={}>"",
block.getNumber(),
block.getShortHash(),
block.getHeader().getDifficultyBI().toString(),
blockchain.getTotalDifficulty(),
block.getTransactionsList().size(),
importResult);
}
//comment
} else {
LOG.info(
""Unable to import a new mined block; restarting mining.\n""
+ ""Mined block import result is ""
+ importResult
+ "" : ""
+ block.getShortHash());
}
}
}","private synchronized void processSolution(AionPowSolution solution) {
if (!shutDown.get()) {
if (LOG.isDebugEnabled()) {
LOG.debug(""Best block num [{}]"", blockchain.getBestBlock().getNumber());
LOG.debug(
""Best block hash [{}]"",
Hex.toHexString(blockchain.getBestBlock().getHash()));
}

MiningBlock block = solution.getBlock();
if (!Arrays.equals(block.getHeader().getNonce(), new byte[32])
&& !(block.getHeader().getNonce().length == 0)) {
//comment
return;
}

//comment
try {
<start>block.seal(solution.getNonce(), solution.getSolution());<end>
} catch (Exception e) {
LOG.error(""seal block failed!"", e);
return;
}

//comment
ImportResult importResult = AionImpl.inst().addNewBlock(block);

//comment
if (importResult.isSuccessful()) {
if (importResult == IMPORTED_BEST) {
LOG.info(
""block sealed <num={}, hash={}, diff={}, tx={}>"",
block.getNumber(),
block.getShortHash(),
block.getHeader().getDifficultyBI().toString(),
block.getTransactionsList().size());
} else {
LOG.debug(
""block sealed <num={}, hash={}, diff={}, td={}, tx={}, result={}>"",
block.getNumber(),
block.getShortHash(),
block.getHeader().getDifficultyBI().toString(),
blockchain.getTotalDifficulty(),
block.getTransactionsList().size(),
importResult);
}
//comment
} else {
LOG.info(
""Unable to import a new mined block; restarting mining.\n""
+ ""Mined block import result is ""
+ importResult
+ "" : ""
+ block.getShortHash());
}
}
}"
7647,"private synchronized void processSolution(AionPowSolution solution) {
if (!shutDown.get()) {
if (LOG.isDebugEnabled()) {
LOG.debug(""Best block num [{}]"", blockchain.getBestBlock().getNumber());
LOG.debug(
""Best block hash [{}]"",
Hex.toHexString(blockchain.getBestBlock().getHash()));
}

MiningBlock block = solution.getBlock();
if (!Arrays.equals(block.getHeader().getNonce(), new byte[32])
&& !(block.getHeader().getNonce().length == 0)) {
//comment
return;
}

//comment
try {
block.seal(solution.getNonce(), solution.getSolution());
} catch (Exception e) {
LOG.error(""seal block failed!"", e);
return;
}

//comment
ImportResult importResult = AionImpl.inst().addNewBlock(block);

//comment
if (importResult.isSuccessful()) {
if (importResult == IMPORTED_BEST) {
LOG.info(
""block sealed <num={}, hash={}, diff={}, tx={}>"",
block.getNumber(),
block.getShortHash(),
block.getHeader().getDifficultyBI().toString(),
block.getTransactionsList().size());
} else {
LOG.debug(
""block sealed <num={}, hash={}, diff={}, td={}, tx={}, result={}>"",
block.getNumber(),
block.getShortHash(),
block.getHeader().getDifficultyBI().toString(),
blockchain.getTotalDifficulty(),
block.getTransactionsList().size(),
importResult);
}
//comment
} else {
LOG.info(
""Unable to import a new mined block; restarting mining.\n""
+ ""Mined block import result is ""
+ importResult
+ "" : ""
+ block.getShortHash());
}
}
}","private synchronized void processSolution(AionPowSolution solution) {
if (!shutDown.get()) {
if (LOG.isDebugEnabled()) {
LOG.debug(""Best block num [{}]"", blockchain.getBestBlock().getNumber());
LOG.debug(
""Best block hash [{}]"",
Hex.toHexString(blockchain.getBestBlock().getHash()));
}

MiningBlock block = solution.getBlock();
if (!Arrays.equals(block.getHeader().getNonce(), new byte[32])
&& !(block.getHeader().getNonce().length == 0)) {
//comment
return;
}

//comment
try {
block.seal(solution.getNonce(), solution.getSolution());
} catch (Exception e) {
LOG.error(""seal block failed!"", e);
return;
}

//comment
ImportResult importResult = AionImpl.inst().addNewBlock(block);

//comment
<start>if (importResult.isSuccessful()) {<end>
if (importResult == IMPORTED_BEST) {
LOG.info(
""block sealed <num={}, hash={}, diff={}, tx={}>"",
block.getNumber(),
block.getShortHash(),
block.getHeader().getDifficultyBI().toString(),
block.getTransactionsList().size());
} else {
LOG.debug(
""block sealed <num={}, hash={}, diff={}, td={}, tx={}, result={}>"",
block.getNumber(),
block.getShortHash(),
block.getHeader().getDifficultyBI().toString(),
blockchain.getTotalDifficulty(),
block.getTransactionsList().size(),
importResult);
}
//comment
} else {
LOG.info(
""Unable to import a new mined block; restarting mining.\n""
+ ""Mined block import result is ""
+ importResult
+ "" : ""
+ block.getShortHash());
}
}
}"
3034,"private void sendHeadersRequestsInternal(long currentBestBlock, BigInteger currentTotalDifficulty, IP2pMgr p2pManager, SyncStats syncStatistics) {
//comment
long startTime = System.nanoTime();

int count = 0;

//comment
<start>Map<Integer, INode> currentNodes =
p2pManager.getActiveNodes().values().stream()
.filter(node -> isAdequateTotalDifficulty(node, currentTotalDifficulty))
.collect(Collectors.toMap(node -> node.getIdHash(), node -> node));<end>

//comment
updateActiveNodes(currentNodes);

//comment
List<RequestState> statesForRequest;
if (requestHeight > localHeight + MAX_BLOCK_DIFF) {
syncLog.debug(""<get-headers near top of chain>"");
statesForRequest = updateStatesForRequests(false, currentBestBlock);
} else {
statesForRequest = updateStatesForRequests(true, currentBestBlock);
}

for (RequestState requestState : statesForRequest) {
String peerAlias = requestState.alias;
long from = requestState.from;
int take = requestState.size;

if (from <= requestState.lastBestBlock || requestState.lastBestBlock == 0) {
//comment
p2pManager.send(requestState.id, peerAlias, new ReqBlocksHeaders(from, take));
//comment
requestHeight = Math.max(requestHeight, from + take);

//comment
requestState.saveRequestTime(System.nanoTime());
availablePeerStates.remove(requestState.id);
bookedPeerStates.put(requestState.id, requestState);

syncLog.debug(
""<get-headers mode={} from-num={} size={} node={}>"",
requestState.mode,
from,
take,
peerAlias);

//comment
syncStatistics.updateTotalRequestsToPeer(peerAlias, RequestType.STATUS);
syncStatistics.updateRequestTime(peerAlias, System.nanoTime(), RequestType.HEADERS);
count++;
} else {
//comment
//comment
//comment
requestState.from = 0;
}
}

long duration = System.nanoTime() - startTime;
surveyLog.debug(
""Request Stage 2: made {} header request{}, duration = {} ns."",
count,
(count == 1 ? """" : ""s""),
duration);
}","private void sendHeadersRequestsInternal(long currentBestBlock, BigInteger currentTotalDifficulty, IP2pMgr p2pManager, SyncStats syncStatistics) {
//comment
long startTime = System.nanoTime();

int count = 0;

//comment
<start>Map<Integer, INode> currentNodes =
p2pManager.getActiveNodes().values().stream()
.filter(node -> isAdequateTotalDifficulty(node, currentTotalDifficulty))
.collect(Collectors.toMap(node -> node.getIdHash(), node -> node));<end>

//comment
updateActiveNodes(currentNodes);

//comment
List<RequestState> statesForRequest;
if (requestHeight > localHeight + MAX_BLOCK_DIFF) {
syncLog.debug(""<get-headers near top of chain>"");
statesForRequest = updateStatesForRequests(false, currentBestBlock);
} else {
statesForRequest = updateStatesForRequests(true, currentBestBlock);
}

for (RequestState requestState : statesForRequest) {
String peerAlias = requestState.alias;
long from = requestState.from;
int take = requestState.size;

if (from <= requestState.lastBestBlock || requestState.lastBestBlock == 0) {
//comment
p2pManager.send(requestState.id, peerAlias, new ReqBlocksHeaders(from, take));
//comment
requestHeight = Math.max(requestHeight, from + take);

//comment
requestState.saveRequestTime(System.nanoTime());
availablePeerStates.remove(requestState.id);
bookedPeerStates.put(requestState.id, requestState);

syncLog.debug(
""<get-headers mode={} from-num={} size={} node={}>"",
requestState.mode,
from,
take,
peerAlias);

//comment
syncStatistics.updateTotalRequestsToPeer(peerAlias, RequestType.STATUS);
syncStatistics.updateRequestTime(peerAlias, System.nanoTime(), RequestType.HEADERS);
count++;
} else {
//comment
//comment
//comment
requestState.from = 0;
}
}

long duration = System.nanoTime() - startTime;
surveyLog.debug(
""Request Stage 2: made {} header request{}, duration = {} ns."",
count,
(count == 1 ? """" : ""s""),
duration);
}"
3035,"private void sendHeadersRequestsInternal(long currentBestBlock, BigInteger currentTotalDifficulty, IP2pMgr p2pManager, SyncStats syncStatistics) {
//comment
long startTime = System.nanoTime();

int count = 0;

//comment
Map<Integer, INode> currentNodes =
p2pManager.getActiveNodes().values().stream()
.filter(node -> isAdequateTotalDifficulty(node, currentTotalDifficulty))
.collect(Collectors.toMap(node -> node.getIdHash(), node -> node));

//comment
<start>updateActiveNodes(currentNodes);<end>

//comment
List<RequestState> statesForRequest;
if (requestHeight > localHeight + MAX_BLOCK_DIFF) {
syncLog.debug(""<get-headers near top of chain>"");
statesForRequest = updateStatesForRequests(false, currentBestBlock);
} else {
statesForRequest = updateStatesForRequests(true, currentBestBlock);
}

for (RequestState requestState : statesForRequest) {
String peerAlias = requestState.alias;
long from = requestState.from;
int take = requestState.size;

if (from <= requestState.lastBestBlock || requestState.lastBestBlock == 0) {
//comment
p2pManager.send(requestState.id, peerAlias, new ReqBlocksHeaders(from, take));
//comment
requestHeight = Math.max(requestHeight, from + take);

//comment
requestState.saveRequestTime(System.nanoTime());
availablePeerStates.remove(requestState.id);
bookedPeerStates.put(requestState.id, requestState);

syncLog.debug(
""<get-headers mode={} from-num={} size={} node={}>"",
requestState.mode,
from,
take,
peerAlias);

//comment
syncStatistics.updateTotalRequestsToPeer(peerAlias, RequestType.STATUS);
syncStatistics.updateRequestTime(peerAlias, System.nanoTime(), RequestType.HEADERS);
count++;
} else {
//comment
//comment
//comment
requestState.from = 0;
}
}

long duration = System.nanoTime() - startTime;
surveyLog.debug(
""Request Stage 2: made {} header request{}, duration = {} ns."",
count,
(count == 1 ? """" : ""s""),
duration);
}","private void sendHeadersRequestsInternal(long currentBestBlock, BigInteger currentTotalDifficulty, IP2pMgr p2pManager, SyncStats syncStatistics) {
//comment
long startTime = System.nanoTime();

int count = 0;

//comment
Map<Integer, INode> currentNodes =
p2pManager.getActiveNodes().values().stream()
.filter(node -> isAdequateTotalDifficulty(node, currentTotalDifficulty))
.collect(Collectors.toMap(node -> node.getIdHash(), node -> node));

//comment
<start>updateActiveNodes(currentNodes);<end>

//comment
List<RequestState> statesForRequest;
if (requestHeight > localHeight + MAX_BLOCK_DIFF) {
syncLog.debug(""<get-headers near top of chain>"");
statesForRequest = updateStatesForRequests(false, currentBestBlock);
} else {
statesForRequest = updateStatesForRequests(true, currentBestBlock);
}

for (RequestState requestState : statesForRequest) {
String peerAlias = requestState.alias;
long from = requestState.from;
int take = requestState.size;

if (from <= requestState.lastBestBlock || requestState.lastBestBlock == 0) {
//comment
p2pManager.send(requestState.id, peerAlias, new ReqBlocksHeaders(from, take));
//comment
requestHeight = Math.max(requestHeight, from + take);

//comment
requestState.saveRequestTime(System.nanoTime());
availablePeerStates.remove(requestState.id);
bookedPeerStates.put(requestState.id, requestState);

syncLog.debug(
""<get-headers mode={} from-num={} size={} node={}>"",
requestState.mode,
from,
take,
peerAlias);

//comment
syncStatistics.updateTotalRequestsToPeer(peerAlias, RequestType.STATUS);
syncStatistics.updateRequestTime(peerAlias, System.nanoTime(), RequestType.HEADERS);
count++;
} else {
//comment
//comment
//comment
requestState.from = 0;
}
}

long duration = System.nanoTime() - startTime;
surveyLog.debug(
""Request Stage 2: made {} header request{}, duration = {} ns."",
count,
(count == 1 ? """" : ""s""),
duration);
}"
3036,"private void sendHeadersRequestsInternal(long currentBestBlock, BigInteger currentTotalDifficulty, IP2pMgr p2pManager, SyncStats syncStatistics) {
//comment
long startTime = System.nanoTime();

int count = 0;

//comment
Map<Integer, INode> currentNodes =
p2pManager.getActiveNodes().values().stream()
.filter(node -> isAdequateTotalDifficulty(node, currentTotalDifficulty))
.collect(Collectors.toMap(node -> node.getIdHash(), node -> node));

//comment
updateActiveNodes(currentNodes);

//comment
<start>List<RequestState> statesForRequest;<end>
if (requestHeight > localHeight + MAX_BLOCK_DIFF) {
syncLog.debug(""<get-headers near top of chain>"");
<start>statesForRequest = updateStatesForRequests(false, currentBestBlock);
} else {<end>
statesForRequest = updateStatesForRequests(true, currentBestBlock);
}

for (RequestState requestState : statesForRequest) {
String peerAlias = requestState.alias;
long from = requestState.from;
int take = requestState.size;

if (from <= requestState.lastBestBlock || requestState.lastBestBlock == 0) {
//comment
p2pManager.send(requestState.id, peerAlias, new ReqBlocksHeaders(from, take));
//comment
requestHeight = Math.max(requestHeight, from + take);

//comment
requestState.saveRequestTime(System.nanoTime());
availablePeerStates.remove(requestState.id);
bookedPeerStates.put(requestState.id, requestState);

syncLog.debug(
""<get-headers mode={} from-num={} size={} node={}>"",
requestState.mode,
from,
take,
peerAlias);

//comment
syncStatistics.updateTotalRequestsToPeer(peerAlias, RequestType.STATUS);
syncStatistics.updateRequestTime(peerAlias, System.nanoTime(), RequestType.HEADERS);
count++;
} else {
//comment
//comment
//comment
requestState.from = 0;
}
}

long duration = System.nanoTime() - startTime;
surveyLog.debug(
""Request Stage 2: made {} header request{}, duration = {} ns."",
count,
(count == 1 ? """" : ""s""),
duration);
}","private void sendHeadersRequestsInternal(long currentBestBlock, BigInteger currentTotalDifficulty, IP2pMgr p2pManager, SyncStats syncStatistics) {
//comment
long startTime = System.nanoTime();

int count = 0;

//comment
Map<Integer, INode> currentNodes =
p2pManager.getActiveNodes().values().stream()
.filter(node -> isAdequateTotalDifficulty(node, currentTotalDifficulty))
.collect(Collectors.toMap(node -> node.getIdHash(), node -> node));

//comment
updateActiveNodes(currentNodes);

//comment
<start>List<RequestState> statesForRequest;
if (requestHeight > localHeight + MAX_BLOCK_DIFF) {
syncLog.debug(""<get-headers near top of chain>"");
statesForRequest = updateStatesForRequests(false, currentBestBlock);
} else {
statesForRequest = updateStatesForRequests(true, currentBestBlock);
}<end>

for (RequestState requestState : statesForRequest) {
String peerAlias = requestState.alias;
long from = requestState.from;
int take = requestState.size;

if (from <= requestState.lastBestBlock || requestState.lastBestBlock == 0) {
//comment
p2pManager.send(requestState.id, peerAlias, new ReqBlocksHeaders(from, take));
//comment
requestHeight = Math.max(requestHeight, from + take);

//comment
requestState.saveRequestTime(System.nanoTime());
availablePeerStates.remove(requestState.id);
bookedPeerStates.put(requestState.id, requestState);

syncLog.debug(
""<get-headers mode={} from-num={} size={} node={}>"",
requestState.mode,
from,
take,
peerAlias);

//comment
syncStatistics.updateTotalRequestsToPeer(peerAlias, RequestType.STATUS);
syncStatistics.updateRequestTime(peerAlias, System.nanoTime(), RequestType.HEADERS);
count++;
} else {
//comment
//comment
//comment
requestState.from = 0;
}
}

long duration = System.nanoTime() - startTime;
surveyLog.debug(
""Request Stage 2: made {} header request{}, duration = {} ns."",
count,
(count == 1 ? """" : ""s""),
duration);
}"
3037,"private void sendHeadersRequestsInternal(long currentBestBlock, BigInteger currentTotalDifficulty, IP2pMgr p2pManager, SyncStats syncStatistics) {
//comment
long startTime = System.nanoTime();

int count = 0;

//comment
Map<Integer, INode> currentNodes =
p2pManager.getActiveNodes().values().stream()
.filter(node -> isAdequateTotalDifficulty(node, currentTotalDifficulty))
.collect(Collectors.toMap(node -> node.getIdHash(), node -> node));

//comment
updateActiveNodes(currentNodes);

//comment
List<RequestState> statesForRequest;
if (requestHeight > localHeight + MAX_BLOCK_DIFF) {
syncLog.debug(""<get-headers near top of chain>"");
statesForRequest = updateStatesForRequests(false, currentBestBlock);
} else {
statesForRequest = updateStatesForRequests(true, currentBestBlock);
}

for (RequestState requestState : statesForRequest) {
String peerAlias = requestState.alias;
long from = requestState.from;
int take = requestState.size;

if (from <= requestState.lastBestBlock || requestState.lastBestBlock == 0) {
//comment
<start>p2pManager.send(requestState.id, peerAlias, new ReqBlocksHeaders(from, take));
//comment
requestHeight = Math.max(requestHeight, from + take);<end>

//comment
requestState.saveRequestTime(System.nanoTime());
availablePeerStates.remove(requestState.id);
bookedPeerStates.put(requestState.id, requestState);

syncLog.debug(
""<get-headers mode={} from-num={} size={} node={}>"",
requestState.mode,
from,
take,
peerAlias);

//comment
syncStatistics.updateTotalRequestsToPeer(peerAlias, RequestType.STATUS);
syncStatistics.updateRequestTime(peerAlias, System.nanoTime(), RequestType.HEADERS);
count++;
} else {
//comment
//comment
//comment
requestState.from = 0;
}
}

long duration = System.nanoTime() - startTime;
surveyLog.debug(
""Request Stage 2: made {} header request{}, duration = {} ns."",
count,
(count == 1 ? """" : ""s""),
duration);
}","private void sendHeadersRequestsInternal(long currentBestBlock, BigInteger currentTotalDifficulty, IP2pMgr p2pManager, SyncStats syncStatistics) {
//comment
long startTime = System.nanoTime();

int count = 0;

//comment
Map<Integer, INode> currentNodes =
p2pManager.getActiveNodes().values().stream()
.filter(node -> isAdequateTotalDifficulty(node, currentTotalDifficulty))
.collect(Collectors.toMap(node -> node.getIdHash(), node -> node));

//comment
updateActiveNodes(currentNodes);

//comment
List<RequestState> statesForRequest;
if (requestHeight > localHeight + MAX_BLOCK_DIFF) {
syncLog.debug(""<get-headers near top of chain>"");
statesForRequest = updateStatesForRequests(false, currentBestBlock);
} else {
statesForRequest = updateStatesForRequests(true, currentBestBlock);
}

for (RequestState requestState : statesForRequest) {
String peerAlias = requestState.alias;
long from = requestState.from;
int take = requestState.size;

if (from <= requestState.lastBestBlock || requestState.lastBestBlock == 0) {
//comment
<start>p2pManager.send(requestState.id, peerAlias, new ReqBlocksHeaders(from, take));<end>
//comment
requestHeight = Math.max(requestHeight, from + take);

//comment
requestState.saveRequestTime(System.nanoTime());
availablePeerStates.remove(requestState.id);
bookedPeerStates.put(requestState.id, requestState);

syncLog.debug(
""<get-headers mode={} from-num={} size={} node={}>"",
requestState.mode,
from,
take,
peerAlias);

//comment
syncStatistics.updateTotalRequestsToPeer(peerAlias, RequestType.STATUS);
syncStatistics.updateRequestTime(peerAlias, System.nanoTime(), RequestType.HEADERS);
count++;
} else {
//comment
//comment
//comment
requestState.from = 0;
}
}

long duration = System.nanoTime() - startTime;
surveyLog.debug(
""Request Stage 2: made {} header request{}, duration = {} ns."",
count,
(count == 1 ? """" : ""s""),
duration);
}"
3038,"private void sendHeadersRequestsInternal(long currentBestBlock, BigInteger currentTotalDifficulty, IP2pMgr p2pManager, SyncStats syncStatistics) {
//comment
long startTime = System.nanoTime();

int count = 0;

//comment
Map<Integer, INode> currentNodes =
p2pManager.getActiveNodes().values().stream()
.filter(node -> isAdequateTotalDifficulty(node, currentTotalDifficulty))
.collect(Collectors.toMap(node -> node.getIdHash(), node -> node));

//comment
updateActiveNodes(currentNodes);

//comment
List<RequestState> statesForRequest;
if (requestHeight > localHeight + MAX_BLOCK_DIFF) {
syncLog.debug(""<get-headers near top of chain>"");
statesForRequest = updateStatesForRequests(false, currentBestBlock);
} else {
statesForRequest = updateStatesForRequests(true, currentBestBlock);
}

for (RequestState requestState : statesForRequest) {
String peerAlias = requestState.alias;
long from = requestState.from;
int take = requestState.size;

if (from <= requestState.lastBestBlock || requestState.lastBestBlock == 0) {
//comment
p2pManager.send(requestState.id, peerAlias, new ReqBlocksHeaders(from, take));
//comment
<start>requestHeight = Math.max(requestHeight, from + take);<end>

//comment
requestState.saveRequestTime(System.nanoTime());
availablePeerStates.remove(requestState.id);
bookedPeerStates.put(requestState.id, requestState);

syncLog.debug(
""<get-headers mode={} from-num={} size={} node={}>"",
requestState.mode,
from,
take,
peerAlias);

//comment
syncStatistics.updateTotalRequestsToPeer(peerAlias, RequestType.STATUS);
syncStatistics.updateRequestTime(peerAlias, System.nanoTime(), RequestType.HEADERS);
count++;
} else {
//comment
//comment
//comment
requestState.from = 0;
}
}

long duration = System.nanoTime() - startTime;
surveyLog.debug(
""Request Stage 2: made {} header request{}, duration = {} ns."",
count,
(count == 1 ? """" : ""s""),
duration);
}","private void sendHeadersRequestsInternal(long currentBestBlock, BigInteger currentTotalDifficulty, IP2pMgr p2pManager, SyncStats syncStatistics) {
//comment
long startTime = System.nanoTime();

int count = 0;

//comment
Map<Integer, INode> currentNodes =
p2pManager.getActiveNodes().values().stream()
.filter(node -> isAdequateTotalDifficulty(node, currentTotalDifficulty))
.collect(Collectors.toMap(node -> node.getIdHash(), node -> node));

//comment
updateActiveNodes(currentNodes);

//comment
List<RequestState> statesForRequest;
if (requestHeight > localHeight + MAX_BLOCK_DIFF) {
syncLog.debug(""<get-headers near top of chain>"");
statesForRequest = updateStatesForRequests(false, currentBestBlock);
} else {
statesForRequest = updateStatesForRequests(true, currentBestBlock);
}

for (RequestState requestState : statesForRequest) {
String peerAlias = requestState.alias;
long from = requestState.from;
int take = requestState.size;

if (from <= requestState.lastBestBlock || requestState.lastBestBlock == 0) {
//comment
p2pManager.send(requestState.id, peerAlias, new ReqBlocksHeaders(from, take));
//comment
<start>requestHeight = Math.max(requestHeight, from + take);<end>

//comment
requestState.saveRequestTime(System.nanoTime());
availablePeerStates.remove(requestState.id);
bookedPeerStates.put(requestState.id, requestState);

syncLog.debug(
""<get-headers mode={} from-num={} size={} node={}>"",
requestState.mode,
from,
take,
peerAlias);

//comment
syncStatistics.updateTotalRequestsToPeer(peerAlias, RequestType.STATUS);
syncStatistics.updateRequestTime(peerAlias, System.nanoTime(), RequestType.HEADERS);
count++;
} else {
//comment
//comment
//comment
requestState.from = 0;
}
}

long duration = System.nanoTime() - startTime;
surveyLog.debug(
""Request Stage 2: made {} header request{}, duration = {} ns."",
count,
(count == 1 ? """" : ""s""),
duration);
}"
3039,"private void sendHeadersRequestsInternal(long currentBestBlock, BigInteger currentTotalDifficulty, IP2pMgr p2pManager, SyncStats syncStatistics) {
//comment
long startTime = System.nanoTime();

int count = 0;

//comment
Map<Integer, INode> currentNodes =
p2pManager.getActiveNodes().values().stream()
.filter(node -> isAdequateTotalDifficulty(node, currentTotalDifficulty))
.collect(Collectors.toMap(node -> node.getIdHash(), node -> node));

//comment
updateActiveNodes(currentNodes);

//comment
List<RequestState> statesForRequest;
if (requestHeight > localHeight + MAX_BLOCK_DIFF) {
syncLog.debug(""<get-headers near top of chain>"");
statesForRequest = updateStatesForRequests(false, currentBestBlock);
} else {
statesForRequest = updateStatesForRequests(true, currentBestBlock);
}

for (RequestState requestState : statesForRequest) {
String peerAlias = requestState.alias;
long from = requestState.from;
int take = requestState.size;

if (from <= requestState.lastBestBlock || requestState.lastBestBlock == 0) {
//comment
p2pManager.send(requestState.id, peerAlias, new ReqBlocksHeaders(from, take));
//comment
requestHeight = Math.max(requestHeight, from + take);

//comment
<start>requestState.saveRequestTime(System.nanoTime());
availablePeerStates.remove(requestState.id);<end>
bookedPeerStates.put(requestState.id, requestState);

syncLog.debug(
""<get-headers mode={} from-num={} size={} node={}>"",
requestState.mode,
from,
take,
peerAlias);

//comment
syncStatistics.updateTotalRequestsToPeer(peerAlias, RequestType.STATUS);
syncStatistics.updateRequestTime(peerAlias, System.nanoTime(), RequestType.HEADERS);
count++;
} else {
//comment
//comment
//comment
requestState.from = 0;
}
}

long duration = System.nanoTime() - startTime;
surveyLog.debug(
""Request Stage 2: made {} header request{}, duration = {} ns."",
count,
(count == 1 ? """" : ""s""),
duration);
}","private void sendHeadersRequestsInternal(long currentBestBlock, BigInteger currentTotalDifficulty, IP2pMgr p2pManager, SyncStats syncStatistics) {
//comment
long startTime = System.nanoTime();

int count = 0;

//comment
Map<Integer, INode> currentNodes =
p2pManager.getActiveNodes().values().stream()
.filter(node -> isAdequateTotalDifficulty(node, currentTotalDifficulty))
.collect(Collectors.toMap(node -> node.getIdHash(), node -> node));

//comment
updateActiveNodes(currentNodes);

//comment
List<RequestState> statesForRequest;
if (requestHeight > localHeight + MAX_BLOCK_DIFF) {
syncLog.debug(""<get-headers near top of chain>"");
statesForRequest = updateStatesForRequests(false, currentBestBlock);
} else {
statesForRequest = updateStatesForRequests(true, currentBestBlock);
}

for (RequestState requestState : statesForRequest) {
String peerAlias = requestState.alias;
long from = requestState.from;
int take = requestState.size;

if (from <= requestState.lastBestBlock || requestState.lastBestBlock == 0) {
//comment
p2pManager.send(requestState.id, peerAlias, new ReqBlocksHeaders(from, take));
//comment
requestHeight = Math.max(requestHeight, from + take);

//comment
<start>requestState.saveRequestTime(System.nanoTime());
availablePeerStates.remove(requestState.id);
bookedPeerStates.put(requestState.id, requestState);<end>

syncLog.debug(
""<get-headers mode={} from-num={} size={} node={}>"",
requestState.mode,
from,
take,
peerAlias);

//comment
syncStatistics.updateTotalRequestsToPeer(peerAlias, RequestType.STATUS);
syncStatistics.updateRequestTime(peerAlias, System.nanoTime(), RequestType.HEADERS);
count++;
} else {
//comment
//comment
//comment
requestState.from = 0;
}
}

long duration = System.nanoTime() - startTime;
surveyLog.debug(
""Request Stage 2: made {} header request{}, duration = {} ns."",
count,
(count == 1 ? """" : ""s""),
duration);
}"
3040,"private void sendHeadersRequestsInternal(long currentBestBlock, BigInteger currentTotalDifficulty, IP2pMgr p2pManager, SyncStats syncStatistics) {
//comment
long startTime = System.nanoTime();

int count = 0;

//comment
Map<Integer, INode> currentNodes =
p2pManager.getActiveNodes().values().stream()
.filter(node -> isAdequateTotalDifficulty(node, currentTotalDifficulty))
.collect(Collectors.toMap(node -> node.getIdHash(), node -> node));

//comment
updateActiveNodes(currentNodes);

//comment
List<RequestState> statesForRequest;
if (requestHeight > localHeight + MAX_BLOCK_DIFF) {
syncLog.debug(""<get-headers near top of chain>"");
statesForRequest = updateStatesForRequests(false, currentBestBlock);
} else {
statesForRequest = updateStatesForRequests(true, currentBestBlock);
}

for (RequestState requestState : statesForRequest) {
String peerAlias = requestState.alias;
long from = requestState.from;
int take = requestState.size;

if (from <= requestState.lastBestBlock || requestState.lastBestBlock == 0) {
//comment
p2pManager.send(requestState.id, peerAlias, new ReqBlocksHeaders(from, take));
//comment
requestHeight = Math.max(requestHeight, from + take);

//comment
requestState.saveRequestTime(System.nanoTime());
availablePeerStates.remove(requestState.id);
bookedPeerStates.put(requestState.id, requestState);

syncLog.debug(
""<get-headers mode={} from-num={} size={} node={}>"",
requestState.mode,
from,
take,
peerAlias);

//comment
syncStatistics.updateTotalRequestsToPeer(peerAlias, RequestType.STATUS);
<start>syncStatistics.updateRequestTime(peerAlias, System.nanoTime(), RequestType.HEADERS);<end>
count++;
} else {
//comment
//comment
//comment
requestState.from = 0;
}
}

long duration = System.nanoTime() - startTime;
surveyLog.debug(
""Request Stage 2: made {} header request{}, duration = {} ns."",
count,
(count == 1 ? """" : ""s""),
duration);
}","private void sendHeadersRequestsInternal(long currentBestBlock, BigInteger currentTotalDifficulty, IP2pMgr p2pManager, SyncStats syncStatistics) {
//comment
long startTime = System.nanoTime();

int count = 0;

//comment
Map<Integer, INode> currentNodes =
p2pManager.getActiveNodes().values().stream()
.filter(node -> isAdequateTotalDifficulty(node, currentTotalDifficulty))
.collect(Collectors.toMap(node -> node.getIdHash(), node -> node));

//comment
updateActiveNodes(currentNodes);

//comment
List<RequestState> statesForRequest;
if (requestHeight > localHeight + MAX_BLOCK_DIFF) {
syncLog.debug(""<get-headers near top of chain>"");
statesForRequest = updateStatesForRequests(false, currentBestBlock);
} else {
statesForRequest = updateStatesForRequests(true, currentBestBlock);
}

for (RequestState requestState : statesForRequest) {
String peerAlias = requestState.alias;
long from = requestState.from;
int take = requestState.size;

if (from <= requestState.lastBestBlock || requestState.lastBestBlock == 0) {
//comment
p2pManager.send(requestState.id, peerAlias, new ReqBlocksHeaders(from, take));
//comment
requestHeight = Math.max(requestHeight, from + take);

//comment
requestState.saveRequestTime(System.nanoTime());
availablePeerStates.remove(requestState.id);
bookedPeerStates.put(requestState.id, requestState);

syncLog.debug(
""<get-headers mode={} from-num={} size={} node={}>"",
requestState.mode,
from,
take,
peerAlias);

//comment
<start>syncStatistics.updateTotalRequestsToPeer(peerAlias, RequestType.STATUS);
syncStatistics.updateRequestTime(peerAlias, System.nanoTime(), RequestType.HEADERS);<end>
count++;
} else {
//comment
//comment
//comment
requestState.from = 0;
}
}

long duration = System.nanoTime() - startTime;
surveyLog.debug(
""Request Stage 2: made {} header request{}, duration = {} ns."",
count,
(count == 1 ? """" : ""s""),
duration);
}"
3041,"<start>    private void updateActiveNodes(Map<Integer, INode> current) {
//comment
Set<Integer> dropped =
knownActiveNodes.stream()
.filter(node -> !current.containsKey(node))
.collect(Collectors.toSet());<end>

//comment
for (Integer id : dropped) {
storedHeaders.remove(id);
bookedPeerStates.remove(id);
availablePeerStates.remove(id);
}

//comment
for (INode node : current.values()) {
Integer id = node.getIdHash();
if (bookedPeerStates.containsKey(id)) {
bookedPeerStates.get(id).lastBestBlock = node.getBestBlockNumber();
} else if (availablePeerStates.containsKey(id)) {
availablePeerStates.get(id).lastBestBlock = node.getBestBlockNumber();
} else {
availablePeerStates.put(
id, new RequestState(id, node.getIdShort(), node.getBestBlockNumber()));
}

//comment
networkHeight = Math.max(networkHeight, node.getBestBlockNumber());
}

//comment
knownActiveNodes.clear();
knownActiveNodes.addAll(current.keySet());

//comment
if (!bookedPeerStates.isEmpty()) {
//comment
Iterator<RequestState> states = bookedPeerStates.values().iterator();
while (states.hasNext()) {
RequestState currentState = states.next();
if (currentState.tryMakeAvailable()) {
availablePeerStates.put(currentState.id, currentState);
states.remove();
}
}
}
}","    private void updateActiveNodes(Map<Integer, INode> current) {
//comment
<start>Set<Integer> dropped =
knownActiveNodes.stream()
.filter(node -> !current.containsKey(node))
.collect(Collectors.toSet());<end>

//comment
for (Integer id : dropped) {
storedHeaders.remove(id);
bookedPeerStates.remove(id);
availablePeerStates.remove(id);
}

//comment
for (INode node : current.values()) {
Integer id = node.getIdHash();
if (bookedPeerStates.containsKey(id)) {
bookedPeerStates.get(id).lastBestBlock = node.getBestBlockNumber();
} else if (availablePeerStates.containsKey(id)) {
availablePeerStates.get(id).lastBestBlock = node.getBestBlockNumber();
} else {
availablePeerStates.put(
id, new RequestState(id, node.getIdShort(), node.getBestBlockNumber()));
}

//comment
networkHeight = Math.max(networkHeight, node.getBestBlockNumber());
}

//comment
knownActiveNodes.clear();
knownActiveNodes.addAll(current.keySet());

//comment
if (!bookedPeerStates.isEmpty()) {
//comment
Iterator<RequestState> states = bookedPeerStates.values().iterator();
while (states.hasNext()) {
RequestState currentState = states.next();
if (currentState.tryMakeAvailable()) {
availablePeerStates.put(currentState.id, currentState);
states.remove();
}
}
}
}"
3042,"    private void updateActiveNodes(Map<Integer, INode> current) {
//comment
Set<Integer> dropped =
knownActiveNodes.stream()
.filter(node -> !current.containsKey(node))
.collect(Collectors.toSet());

//comment
for (Integer id : dropped) {
<start>storedHeaders.remove(id);
bookedPeerStates.remove(id);
availablePeerStates.remove(id);<end>
}

//comment
for (INode node : current.values()) {
Integer id = node.getIdHash();
if (bookedPeerStates.containsKey(id)) {
bookedPeerStates.get(id).lastBestBlock = node.getBestBlockNumber();
} else if (availablePeerStates.containsKey(id)) {
availablePeerStates.get(id).lastBestBlock = node.getBestBlockNumber();
} else {
availablePeerStates.put(
id, new RequestState(id, node.getIdShort(), node.getBestBlockNumber()));
}

//comment
networkHeight = Math.max(networkHeight, node.getBestBlockNumber());
}

//comment
knownActiveNodes.clear();
knownActiveNodes.addAll(current.keySet());

//comment
if (!bookedPeerStates.isEmpty()) {
//comment
Iterator<RequestState> states = bookedPeerStates.values().iterator();
while (states.hasNext()) {
RequestState currentState = states.next();
if (currentState.tryMakeAvailable()) {
availablePeerStates.put(currentState.id, currentState);
states.remove();
}
}
}
}","    private void updateActiveNodes(Map<Integer, INode> current) {
//comment
Set<Integer> dropped =
knownActiveNodes.stream()
.filter(node -> !current.containsKey(node))
.collect(Collectors.toSet());

//comment
<start>for (Integer id : dropped) {
storedHeaders.remove(id);
bookedPeerStates.remove(id);
availablePeerStates.remove(id);
}<end>

//comment
for (INode node : current.values()) {
Integer id = node.getIdHash();
if (bookedPeerStates.containsKey(id)) {
bookedPeerStates.get(id).lastBestBlock = node.getBestBlockNumber();
} else if (availablePeerStates.containsKey(id)) {
availablePeerStates.get(id).lastBestBlock = node.getBestBlockNumber();
} else {
availablePeerStates.put(
id, new RequestState(id, node.getIdShort(), node.getBestBlockNumber()));
}

//comment
networkHeight = Math.max(networkHeight, node.getBestBlockNumber());
}

//comment
knownActiveNodes.clear();
knownActiveNodes.addAll(current.keySet());

//comment
if (!bookedPeerStates.isEmpty()) {
//comment
Iterator<RequestState> states = bookedPeerStates.values().iterator();
while (states.hasNext()) {
RequestState currentState = states.next();
if (currentState.tryMakeAvailable()) {
availablePeerStates.put(currentState.id, currentState);
states.remove();
}
}
}
}"
3043,"    private void updateActiveNodes(Map<Integer, INode> current) {
//comment
Set<Integer> dropped =
knownActiveNodes.stream()
.filter(node -> !current.containsKey(node))
.collect(Collectors.toSet());

//comment
for (Integer id : dropped) {
storedHeaders.remove(id);
bookedPeerStates.remove(id);
availablePeerStates.remove(id);
}

//comment
for (INode node : current.values()) {
Integer id = node.getIdHash();
if (bookedPeerStates.containsKey(id)) {
bookedPeerStates.get(id).lastBestBlock = node.getBestBlockNumber();
} else if (availablePeerStates.containsKey(id)) {
<start>availablePeerStates.get(id).lastBestBlock = node.getBestBlockNumber();<end>
} else {
availablePeerStates.put(
id, new RequestState(id, node.getIdShort(), node.getBestBlockNumber()));
}

//comment
networkHeight = Math.max(networkHeight, node.getBestBlockNumber());
}

//comment
knownActiveNodes.clear();
knownActiveNodes.addAll(current.keySet());

//comment
if (!bookedPeerStates.isEmpty()) {
//comment
Iterator<RequestState> states = bookedPeerStates.values().iterator();
while (states.hasNext()) {
RequestState currentState = states.next();
if (currentState.tryMakeAvailable()) {
availablePeerStates.put(currentState.id, currentState);
states.remove();
}
}
}
}","    private void updateActiveNodes(Map<Integer, INode> current) {
//comment
Set<Integer> dropped =
knownActiveNodes.stream()
.filter(node -> !current.containsKey(node))
.collect(Collectors.toSet());

//comment
for (Integer id : dropped) {
storedHeaders.remove(id);
bookedPeerStates.remove(id);
availablePeerStates.remove(id);
}

//comment
<start>for (INode node : current.values()) {
Integer id = node.getIdHash();
if (bookedPeerStates.containsKey(id)) {
bookedPeerStates.get(id).lastBestBlock = node.getBestBlockNumber();
} else if (availablePeerStates.containsKey(id)) {
availablePeerStates.get(id).lastBestBlock = node.getBestBlockNumber();
} else {
availablePeerStates.put(
id, new RequestState(id, node.getIdShort(), node.getBestBlockNumber()));
}

//comment
networkHeight = Math.max(networkHeight, node.getBestBlockNumber());
}<end>

//comment
knownActiveNodes.clear();
knownActiveNodes.addAll(current.keySet());

//comment
if (!bookedPeerStates.isEmpty()) {
//comment
Iterator<RequestState> states = bookedPeerStates.values().iterator();
while (states.hasNext()) {
RequestState currentState = states.next();
if (currentState.tryMakeAvailable()) {
availablePeerStates.put(currentState.id, currentState);
states.remove();
}
}
}
}"
3044,"    private void updateActiveNodes(Map<Integer, INode> current) {
//comment
Set<Integer> dropped =
knownActiveNodes.stream()
.filter(node -> !current.containsKey(node))
.collect(Collectors.toSet());

//comment
for (Integer id : dropped) {
storedHeaders.remove(id);
bookedPeerStates.remove(id);
availablePeerStates.remove(id);
}

//comment
for (INode node : current.values()) {
Integer id = node.getIdHash();
if (bookedPeerStates.containsKey(id)) {
bookedPeerStates.get(id).lastBestBlock = node.getBestBlockNumber();
} else if (availablePeerStates.containsKey(id)) {
availablePeerStates.get(id).lastBestBlock = node.getBestBlockNumber();
} else {
availablePeerStates.put(
id, new RequestState(id, node.getIdShort(), node.getBestBlockNumber()));
}

//comment
networkHeight = Math.max(networkHeight, node.getBestBlockNumber());
}

//comment
knownActiveNodes.clear();
knownActiveNodes.addAll(current.keySet());

//comment
if (!bookedPeerStates.isEmpty()) {
//comment
Iterator<RequestState> states = bookedPeerStates.values().iterator();
while (states.hasNext()) {
RequestState currentState = states.next();
if (currentState.tryMakeAvailable()) {
availablePeerStates.put(currentState.id, currentState);
states.remove();
}
}
}
}","    private void updateActiveNodes(Map<Integer, INode> current) {
//comment
Set<Integer> dropped =
knownActiveNodes.stream()
.filter(node -> !current.containsKey(node))
.collect(Collectors.toSet());

//comment
for (Integer id : dropped) {
storedHeaders.remove(id);
bookedPeerStates.remove(id);
availablePeerStates.remove(id);
}

//comment
for (INode node : current.values()) {
Integer id = node.getIdHash();
if (bookedPeerStates.containsKey(id)) {
bookedPeerStates.get(id).lastBestBlock = node.getBestBlockNumber();
} else if (availablePeerStates.containsKey(id)) {
availablePeerStates.get(id).lastBestBlock = node.getBestBlockNumber();
} else {
<start>availablePeerStates.put(
id, new RequestState(id, node.getIdShort(), node.getBestBlockNumber()));<end>
}

//comment
networkHeight = Math.max(networkHeight, node.getBestBlockNumber());
}

//comment
knownActiveNodes.clear();
knownActiveNodes.addAll(current.keySet());

//comment
if (!bookedPeerStates.isEmpty()) {
//comment
Iterator<RequestState> states = bookedPeerStates.values().iterator();
while (states.hasNext()) {
RequestState currentState = states.next();
if (currentState.tryMakeAvailable()) {
availablePeerStates.put(currentState.id, currentState);
states.remove();
}
}
}
}"
3045,"    private void updateActiveNodes(Map<Integer, INode> current) {
//comment
Set<Integer> dropped =
knownActiveNodes.stream()
.filter(node -> !current.containsKey(node))
.collect(Collectors.toSet());

//comment
for (Integer id : dropped) {
storedHeaders.remove(id);
bookedPeerStates.remove(id);
availablePeerStates.remove(id);
}

//comment
for (INode node : current.values()) {
Integer id = node.getIdHash();
if (bookedPeerStates.containsKey(id)) {
bookedPeerStates.get(id).lastBestBlock = node.getBestBlockNumber();
} else if (availablePeerStates.containsKey(id)) {
availablePeerStates.get(id).lastBestBlock = node.getBestBlockNumber();
} else {
availablePeerStates.put(
id, new RequestState(id, node.getIdShort(), node.getBestBlockNumber()));
}

//comment
<start>networkHeight = Math.max(networkHeight, node.getBestBlockNumber());<end>
}

//comment
knownActiveNodes.clear();
knownActiveNodes.addAll(current.keySet());

//comment
if (!bookedPeerStates.isEmpty()) {
//comment
Iterator<RequestState> states = bookedPeerStates.values().iterator();
while (states.hasNext()) {
RequestState currentState = states.next();
if (currentState.tryMakeAvailable()) {
availablePeerStates.put(currentState.id, currentState);
states.remove();
}
}
}
}","    private void updateActiveNodes(Map<Integer, INode> current) {
//comment
Set<Integer> dropped =
knownActiveNodes.stream()
.filter(node -> !current.containsKey(node))
.collect(Collectors.toSet());

//comment
for (Integer id : dropped) {
storedHeaders.remove(id);
bookedPeerStates.remove(id);
availablePeerStates.remove(id);
}

//comment
for (INode node : current.values()) {
Integer id = node.getIdHash();
if (bookedPeerStates.containsKey(id)) {
bookedPeerStates.get(id).lastBestBlock = node.getBestBlockNumber();
} else if (availablePeerStates.containsKey(id)) {
availablePeerStates.get(id).lastBestBlock = node.getBestBlockNumber();
} else {
availablePeerStates.put(
id, new RequestState(id, node.getIdShort(), node.getBestBlockNumber()));
}

//comment
<start>networkHeight = Math.max(networkHeight, node.getBestBlockNumber());<end>
}

//comment
knownActiveNodes.clear();
knownActiveNodes.addAll(current.keySet());

//comment
if (!bookedPeerStates.isEmpty()) {
//comment
Iterator<RequestState> states = bookedPeerStates.values().iterator();
while (states.hasNext()) {
RequestState currentState = states.next();
if (currentState.tryMakeAvailable()) {
availablePeerStates.put(currentState.id, currentState);
states.remove();
}
}
}
}"
3046,"    private void updateActiveNodes(Map<Integer, INode> current) {
//comment
Set<Integer> dropped =
knownActiveNodes.stream()
.filter(node -> !current.containsKey(node))
.collect(Collectors.toSet());

//comment
for (Integer id : dropped) {
storedHeaders.remove(id);
bookedPeerStates.remove(id);
availablePeerStates.remove(id);
}

//comment
for (INode node : current.values()) {
Integer id = node.getIdHash();
if (bookedPeerStates.containsKey(id)) {
bookedPeerStates.get(id).lastBestBlock = node.getBestBlockNumber();
} else if (availablePeerStates.containsKey(id)) {
availablePeerStates.get(id).lastBestBlock = node.getBestBlockNumber();
} else {
availablePeerStates.put(
id, new RequestState(id, node.getIdShort(), node.getBestBlockNumber()));
}

//comment
networkHeight = Math.max(networkHeight, node.getBestBlockNumber());
}

//comment
<start>knownActiveNodes.clear();<end>
knownActiveNodes.addAll(current.keySet());

//comment
if (!bookedPeerStates.isEmpty()) {
//comment
Iterator<RequestState> states = bookedPeerStates.values().iterator();
while (states.hasNext()) {
RequestState currentState = states.next();
if (currentState.tryMakeAvailable()) {
availablePeerStates.put(currentState.id, currentState);
states.remove();
}
}
}
}","    private void updateActiveNodes(Map<Integer, INode> current) {
//comment
Set<Integer> dropped =
knownActiveNodes.stream()
.filter(node -> !current.containsKey(node))
.collect(Collectors.toSet());

//comment
for (Integer id : dropped) {
storedHeaders.remove(id);
bookedPeerStates.remove(id);
availablePeerStates.remove(id);
}

//comment
for (INode node : current.values()) {
Integer id = node.getIdHash();
if (bookedPeerStates.containsKey(id)) {
bookedPeerStates.get(id).lastBestBlock = node.getBestBlockNumber();
} else if (availablePeerStates.containsKey(id)) {
availablePeerStates.get(id).lastBestBlock = node.getBestBlockNumber();
} else {
availablePeerStates.put(
id, new RequestState(id, node.getIdShort(), node.getBestBlockNumber()));
}

//comment
networkHeight = Math.max(networkHeight, node.getBestBlockNumber());
}

//comment
<start>knownActiveNodes.clear();
knownActiveNodes.addAll(current.keySet());<end>

//comment
if (!bookedPeerStates.isEmpty()) {
//comment
Iterator<RequestState> states = bookedPeerStates.values().iterator();
while (states.hasNext()) {
RequestState currentState = states.next();
if (currentState.tryMakeAvailable()) {
availablePeerStates.put(currentState.id, currentState);
states.remove();
}
}
}
}"
3047,"    private void updateActiveNodes(Map<Integer, INode> current) {
//comment
Set<Integer> dropped =
knownActiveNodes.stream()
.filter(node -> !current.containsKey(node))
.collect(Collectors.toSet());

//comment
for (Integer id : dropped) {
storedHeaders.remove(id);
bookedPeerStates.remove(id);
availablePeerStates.remove(id);
}

//comment
for (INode node : current.values()) {
Integer id = node.getIdHash();
if (bookedPeerStates.containsKey(id)) {
bookedPeerStates.get(id).lastBestBlock = node.getBestBlockNumber();
} else if (availablePeerStates.containsKey(id)) {
availablePeerStates.get(id).lastBestBlock = node.getBestBlockNumber();
} else {
availablePeerStates.put(
id, new RequestState(id, node.getIdShort(), node.getBestBlockNumber()));
}

//comment
networkHeight = Math.max(networkHeight, node.getBestBlockNumber());
}

//comment
knownActiveNodes.clear();
knownActiveNodes.addAll(current.keySet());

//comment
if (!bookedPeerStates.isEmpty()) {
//comment
<start>Iterator<RequestState> states = bookedPeerStates.values().iterator();<end>
while (states.hasNext()) {
RequestState currentState = states.next();
if (currentState.tryMakeAvailable()) {
availablePeerStates.put(currentState.id, currentState);
states.remove();
}
}
}
}","    private void updateActiveNodes(Map<Integer, INode> current) {
//comment
Set<Integer> dropped =
knownActiveNodes.stream()
.filter(node -> !current.containsKey(node))
.collect(Collectors.toSet());

//comment
for (Integer id : dropped) {
storedHeaders.remove(id);
bookedPeerStates.remove(id);
availablePeerStates.remove(id);
}

//comment
for (INode node : current.values()) {
Integer id = node.getIdHash();
if (bookedPeerStates.containsKey(id)) {
bookedPeerStates.get(id).lastBestBlock = node.getBestBlockNumber();
} else if (availablePeerStates.containsKey(id)) {
availablePeerStates.get(id).lastBestBlock = node.getBestBlockNumber();
} else {
availablePeerStates.put(
id, new RequestState(id, node.getIdShort(), node.getBestBlockNumber()));
}

//comment
networkHeight = Math.max(networkHeight, node.getBestBlockNumber());
}

//comment
knownActiveNodes.clear();
knownActiveNodes.addAll(current.keySet());

//comment
<start>if (!bookedPeerStates.isEmpty()) {
//comment
Iterator<RequestState> states = bookedPeerStates.values().iterator();
while (states.hasNext()) {
RequestState currentState = states.next();
if (currentState.tryMakeAvailable()) {
availablePeerStates.put(currentState.id, currentState);
states.remove();
}
}
}<end>
}"
3048,"    private void updateActiveNodes(Map<Integer, INode> current) {
//comment
Set<Integer> dropped =
knownActiveNodes.stream()
.filter(node -> !current.containsKey(node))
.collect(Collectors.toSet());

//comment
for (Integer id : dropped) {
storedHeaders.remove(id);
bookedPeerStates.remove(id);
availablePeerStates.remove(id);
}

//comment
for (INode node : current.values()) {
Integer id = node.getIdHash();
if (bookedPeerStates.containsKey(id)) {
bookedPeerStates.get(id).lastBestBlock = node.getBestBlockNumber();
} else if (availablePeerStates.containsKey(id)) {
availablePeerStates.get(id).lastBestBlock = node.getBestBlockNumber();
} else {
availablePeerStates.put(
id, new RequestState(id, node.getIdShort(), node.getBestBlockNumber()));
}

//comment
networkHeight = Math.max(networkHeight, node.getBestBlockNumber());
}

//comment
knownActiveNodes.clear();
knownActiveNodes.addAll(current.keySet());

//comment
if (!bookedPeerStates.isEmpty()) {
//comment
<start>Iterator<RequestState> states = bookedPeerStates.values().iterator();<end>
while (states.hasNext()) {
RequestState currentState = states.next();
if (currentState.tryMakeAvailable()) {
availablePeerStates.put(currentState.id, currentState);
states.remove();
}
}
}
}","    private void updateActiveNodes(Map<Integer, INode> current) {
//comment
Set<Integer> dropped =
knownActiveNodes.stream()
.filter(node -> !current.containsKey(node))
.collect(Collectors.toSet());

//comment
for (Integer id : dropped) {
storedHeaders.remove(id);
bookedPeerStates.remove(id);
availablePeerStates.remove(id);
}

//comment
for (INode node : current.values()) {
Integer id = node.getIdHash();
if (bookedPeerStates.containsKey(id)) {
bookedPeerStates.get(id).lastBestBlock = node.getBestBlockNumber();
} else if (availablePeerStates.containsKey(id)) {
availablePeerStates.get(id).lastBestBlock = node.getBestBlockNumber();
} else {
availablePeerStates.put(
id, new RequestState(id, node.getIdShort(), node.getBestBlockNumber()));
}

//comment
networkHeight = Math.max(networkHeight, node.getBestBlockNumber());
}

//comment
knownActiveNodes.clear();
knownActiveNodes.addAll(current.keySet());

//comment
if (!bookedPeerStates.isEmpty()) {
//comment
<start>Iterator<RequestState> states = bookedPeerStates.values().iterator();
while (states.hasNext()) {
RequestState currentState = states.next();
if (currentState.tryMakeAvailable()) {
availablePeerStates.put(currentState.id, currentState);
states.remove();
}
}<end>
}
}"
3049,"private List<RequestState> updateStatesForRequests(boolean distantFuture, long currentBestBlock) {
//comment
<start>localHeight = Math.max(localHeight, currentBestBlock);<end>

long nextFrom;
SyncMode nextMode;

//comment
if (networkHeight >= currentBestBlock + SWITCH_OVERLAPPING_BLOCKS_RANGE) {
nextFrom = Math.max(1, currentBestBlock - FAR_OVERLAPPING_BLOCKS);
} else {
nextFrom = Math.max(1, currentBestBlock - CLOSE_OVERLAPPING_BLOCKS);
}
nextMode = SyncMode.NORMAL;

List<RequestState> availableSet = new ArrayList<>(availablePeerStates.values());
if (availableSet.isEmpty()){
return Collections.emptyList();
}

if (!distantFuture) {
//comment
RequestState singleRequest = availableSet.get(random.nextInt(availableSet.size()));
availableSet.clear();
availableSet.add(singleRequest);
}

List<RequestState> requestStates = new ArrayList<>();
for (RequestState state : availableSet) {
//comment
//comment
//comment
//comment
int nextSize = state.size - 2;
if (nextSize < MIN_REQUEST_SIZE) {
nextSize = MAX_REQUEST_SIZE;
}

if (state.mode == BACKWARD) {
state.from = Math.max(1, state.from - BACKWARD_SYNC_STEP);
state.size = nextSize;
} else if (state.mode == FORWARD) {
state.from = state.from + state.size;
state.size = nextSize;
} else {
//comment
if (state.from == nextFrom) {
nextFrom = nextFrom + state.size;
}

//comment
state.from = nextFrom;
state.mode = nextMode;
state.size = nextSize;

//comment
//comment
nextFrom = Math.max(requestHeight, nextFrom + nextSize);
}

requestStates.add(state);
}

return requestStates;
}","private List<RequestState> updateStatesForRequests(boolean distantFuture, long currentBestBlock) {
//comment
<start>localHeight = Math.max(localHeight, currentBestBlock);<end>

long nextFrom;
SyncMode nextMode;

//comment
if (networkHeight >= currentBestBlock + SWITCH_OVERLAPPING_BLOCKS_RANGE) {
nextFrom = Math.max(1, currentBestBlock - FAR_OVERLAPPING_BLOCKS);
} else {
nextFrom = Math.max(1, currentBestBlock - CLOSE_OVERLAPPING_BLOCKS);
}
nextMode = SyncMode.NORMAL;

List<RequestState> availableSet = new ArrayList<>(availablePeerStates.values());
if (availableSet.isEmpty()){
return Collections.emptyList();
}

if (!distantFuture) {
//comment
RequestState singleRequest = availableSet.get(random.nextInt(availableSet.size()));
availableSet.clear();
availableSet.add(singleRequest);
}

List<RequestState> requestStates = new ArrayList<>();
for (RequestState state : availableSet) {
//comment
//comment
//comment
//comment
int nextSize = state.size - 2;
if (nextSize < MIN_REQUEST_SIZE) {
nextSize = MAX_REQUEST_SIZE;
}

if (state.mode == BACKWARD) {
state.from = Math.max(1, state.from - BACKWARD_SYNC_STEP);
state.size = nextSize;
} else if (state.mode == FORWARD) {
state.from = state.from + state.size;
state.size = nextSize;
} else {
//comment
if (state.from == nextFrom) {
nextFrom = nextFrom + state.size;
}

//comment
state.from = nextFrom;
state.mode = nextMode;
state.size = nextSize;

//comment
//comment
nextFrom = Math.max(requestHeight, nextFrom + nextSize);
}

requestStates.add(state);
}

return requestStates;
}"
3050,"private List<RequestState> updateStatesForRequests(boolean distantFuture, long currentBestBlock) {
//comment
localHeight = Math.max(localHeight, currentBestBlock);

long nextFrom;
SyncMode nextMode;

//comment
<start>if (networkHeight >= currentBestBlock + SWITCH_OVERLAPPING_BLOCKS_RANGE) {
nextFrom = Math.max(1, currentBestBlock - FAR_OVERLAPPING_BLOCKS);
} else {
nextFrom = Math.max(1, currentBestBlock - CLOSE_OVERLAPPING_BLOCKS);
}<end>
nextMode = SyncMode.NORMAL;

List<RequestState> availableSet = new ArrayList<>(availablePeerStates.values());
if (availableSet.isEmpty()){
return Collections.emptyList();
}

if (!distantFuture) {
//comment
RequestState singleRequest = availableSet.get(random.nextInt(availableSet.size()));
availableSet.clear();
availableSet.add(singleRequest);
}

List<RequestState> requestStates = new ArrayList<>();
for (RequestState state : availableSet) {
//comment
//comment
//comment
//comment
int nextSize = state.size - 2;
if (nextSize < MIN_REQUEST_SIZE) {
nextSize = MAX_REQUEST_SIZE;
}

if (state.mode == BACKWARD) {
state.from = Math.max(1, state.from - BACKWARD_SYNC_STEP);
state.size = nextSize;
} else if (state.mode == FORWARD) {
state.from = state.from + state.size;
state.size = nextSize;
} else {
//comment
if (state.from == nextFrom) {
nextFrom = nextFrom + state.size;
}

//comment
state.from = nextFrom;
state.mode = nextMode;
state.size = nextSize;

//comment
//comment
nextFrom = Math.max(requestHeight, nextFrom + nextSize);
}

requestStates.add(state);
}

return requestStates;
}","private List<RequestState> updateStatesForRequests(boolean distantFuture, long currentBestBlock) {
//comment
localHeight = Math.max(localHeight, currentBestBlock);

long nextFrom;
SyncMode nextMode;

//comment
<start>if (networkHeight >= currentBestBlock + SWITCH_OVERLAPPING_BLOCKS_RANGE) {
nextFrom = Math.max(1, currentBestBlock - FAR_OVERLAPPING_BLOCKS);
} else {
nextFrom = Math.max(1, currentBestBlock - CLOSE_OVERLAPPING_BLOCKS);
}<end>
nextMode = SyncMode.NORMAL;

List<RequestState> availableSet = new ArrayList<>(availablePeerStates.values());
if (availableSet.isEmpty()){
return Collections.emptyList();
}

if (!distantFuture) {
//comment
RequestState singleRequest = availableSet.get(random.nextInt(availableSet.size()));
availableSet.clear();
availableSet.add(singleRequest);
}

List<RequestState> requestStates = new ArrayList<>();
for (RequestState state : availableSet) {
//comment
//comment
//comment
//comment
int nextSize = state.size - 2;
if (nextSize < MIN_REQUEST_SIZE) {
nextSize = MAX_REQUEST_SIZE;
}

if (state.mode == BACKWARD) {
state.from = Math.max(1, state.from - BACKWARD_SYNC_STEP);
state.size = nextSize;
} else if (state.mode == FORWARD) {
state.from = state.from + state.size;
state.size = nextSize;
} else {
//comment
if (state.from == nextFrom) {
nextFrom = nextFrom + state.size;
}

//comment
state.from = nextFrom;
state.mode = nextMode;
state.size = nextSize;

//comment
//comment
nextFrom = Math.max(requestHeight, nextFrom + nextSize);
}

requestStates.add(state);
}

return requestStates;
}"
3051,"private List<RequestState> updateStatesForRequests(boolean distantFuture, long currentBestBlock) {
//comment
localHeight = Math.max(localHeight, currentBestBlock);

long nextFrom;
SyncMode nextMode;

//comment
if (networkHeight >= currentBestBlock + SWITCH_OVERLAPPING_BLOCKS_RANGE) {
nextFrom = Math.max(1, currentBestBlock - FAR_OVERLAPPING_BLOCKS);
} else {
nextFrom = Math.max(1, currentBestBlock - CLOSE_OVERLAPPING_BLOCKS);
}
nextMode = SyncMode.NORMAL;

List<RequestState> availableSet = new ArrayList<>(availablePeerStates.values());
if (availableSet.isEmpty()){
return Collections.emptyList();
}

if (!distantFuture) {
//comment
<start>RequestState singleRequest = availableSet.get(random.nextInt(availableSet.size()));<end>
availableSet.clear();
availableSet.add(singleRequest);
}

List<RequestState> requestStates = new ArrayList<>();
for (RequestState state : availableSet) {
//comment
//comment
//comment
//comment
int nextSize = state.size - 2;
if (nextSize < MIN_REQUEST_SIZE) {
nextSize = MAX_REQUEST_SIZE;
}

if (state.mode == BACKWARD) {
state.from = Math.max(1, state.from - BACKWARD_SYNC_STEP);
state.size = nextSize;
} else if (state.mode == FORWARD) {
state.from = state.from + state.size;
state.size = nextSize;
} else {
//comment
if (state.from == nextFrom) {
nextFrom = nextFrom + state.size;
}

//comment
state.from = nextFrom;
state.mode = nextMode;
state.size = nextSize;

//comment
//comment
nextFrom = Math.max(requestHeight, nextFrom + nextSize);
}

requestStates.add(state);
}

return requestStates;
}","private List<RequestState> updateStatesForRequests(boolean distantFuture, long currentBestBlock) {
//comment
localHeight = Math.max(localHeight, currentBestBlock);

long nextFrom;
SyncMode nextMode;

//comment
if (networkHeight >= currentBestBlock + SWITCH_OVERLAPPING_BLOCKS_RANGE) {
nextFrom = Math.max(1, currentBestBlock - FAR_OVERLAPPING_BLOCKS);
} else {
nextFrom = Math.max(1, currentBestBlock - CLOSE_OVERLAPPING_BLOCKS);
}
nextMode = SyncMode.NORMAL;

List<RequestState> availableSet = new ArrayList<>(availablePeerStates.values());
if (availableSet.isEmpty()){
return Collections.emptyList();
}

<start>if (!distantFuture) {
//comment
RequestState singleRequest = availableSet.get(random.nextInt(availableSet.size()));
availableSet.clear();
availableSet.add(singleRequest);
}<end>

List<RequestState> requestStates = new ArrayList<>();
for (RequestState state : availableSet) {
//comment
//comment
//comment
//comment
int nextSize = state.size - 2;
if (nextSize < MIN_REQUEST_SIZE) {
nextSize = MAX_REQUEST_SIZE;
}

if (state.mode == BACKWARD) {
state.from = Math.max(1, state.from - BACKWARD_SYNC_STEP);
state.size = nextSize;
} else if (state.mode == FORWARD) {
state.from = state.from + state.size;
state.size = nextSize;
} else {
//comment
if (state.from == nextFrom) {
nextFrom = nextFrom + state.size;
}

//comment
state.from = nextFrom;
state.mode = nextMode;
state.size = nextSize;

//comment
//comment
nextFrom = Math.max(requestHeight, nextFrom + nextSize);
}

requestStates.add(state);
}

return requestStates;
}"
3052,"private List<RequestState> updateStatesForRequests(boolean distantFuture, long currentBestBlock) {
//comment
localHeight = Math.max(localHeight, currentBestBlock);

long nextFrom;
SyncMode nextMode;

//comment
if (networkHeight >= currentBestBlock + SWITCH_OVERLAPPING_BLOCKS_RANGE) {
nextFrom = Math.max(1, currentBestBlock - FAR_OVERLAPPING_BLOCKS);
} else {
nextFrom = Math.max(1, currentBestBlock - CLOSE_OVERLAPPING_BLOCKS);
}
nextMode = SyncMode.NORMAL;

List<RequestState> availableSet = new ArrayList<>(availablePeerStates.values());
if (availableSet.isEmpty()){
return Collections.emptyList();
}

if (!distantFuture) {
//comment
RequestState singleRequest = availableSet.get(random.nextInt(availableSet.size()));
availableSet.clear();
availableSet.add(singleRequest);
}

List<RequestState> requestStates = new ArrayList<>();
for (RequestState state : availableSet) {
//comment
//comment
//comment
//comment
<start>int nextSize = state.size - 2;
if (nextSize < MIN_REQUEST_SIZE) {
nextSize = MAX_REQUEST_SIZE;
}<end>

if (state.mode == BACKWARD) {
state.from = Math.max(1, state.from - BACKWARD_SYNC_STEP);
state.size = nextSize;
} else if (state.mode == FORWARD) {
state.from = state.from + state.size;
state.size = nextSize;
} else {
//comment
if (state.from == nextFrom) {
nextFrom = nextFrom + state.size;
}

//comment
state.from = nextFrom;
state.mode = nextMode;
state.size = nextSize;

//comment
//comment
nextFrom = Math.max(requestHeight, nextFrom + nextSize);
}

requestStates.add(state);
}

return requestStates;
}","private List<RequestState> updateStatesForRequests(boolean distantFuture, long currentBestBlock) {
//comment
localHeight = Math.max(localHeight, currentBestBlock);

long nextFrom;
SyncMode nextMode;

//comment
if (networkHeight >= currentBestBlock + SWITCH_OVERLAPPING_BLOCKS_RANGE) {
nextFrom = Math.max(1, currentBestBlock - FAR_OVERLAPPING_BLOCKS);
} else {
nextFrom = Math.max(1, currentBestBlock - CLOSE_OVERLAPPING_BLOCKS);
}
nextMode = SyncMode.NORMAL;

List<RequestState> availableSet = new ArrayList<>(availablePeerStates.values());
if (availableSet.isEmpty()){
return Collections.emptyList();
}

if (!distantFuture) {
//comment
RequestState singleRequest = availableSet.get(random.nextInt(availableSet.size()));
availableSet.clear();
availableSet.add(singleRequest);
}

List<RequestState> requestStates = new ArrayList<>();
for (RequestState state : availableSet) {
//comment
//comment
//comment
//comment
<start>int nextSize = state.size - 2;
if (nextSize < MIN_REQUEST_SIZE) {
nextSize = MAX_REQUEST_SIZE;
}

if (state.mode == BACKWARD) {
state.from = Math.max(1, state.from - BACKWARD_SYNC_STEP);
state.size = nextSize;
} else if (state.mode == FORWARD) {
state.from = state.from + state.size;
state.size = nextSize;
} else {
//comment
if (state.from == nextFrom) {
nextFrom = nextFrom + state.size;
}

//comment
state.from = nextFrom;
state.mode = nextMode;
state.size = nextSize;

//comment
//comment
nextFrom = Math.max(requestHeight, nextFrom + nextSize);
}

requestStates.add(state);<end>
}

return requestStates;
}"
3053,"private List<RequestState> updateStatesForRequests(boolean distantFuture, long currentBestBlock) {
//comment
localHeight = Math.max(localHeight, currentBestBlock);

long nextFrom;
SyncMode nextMode;

//comment
if (networkHeight >= currentBestBlock + SWITCH_OVERLAPPING_BLOCKS_RANGE) {
nextFrom = Math.max(1, currentBestBlock - FAR_OVERLAPPING_BLOCKS);
} else {
nextFrom = Math.max(1, currentBestBlock - CLOSE_OVERLAPPING_BLOCKS);
}
nextMode = SyncMode.NORMAL;

List<RequestState> availableSet = new ArrayList<>(availablePeerStates.values());
if (availableSet.isEmpty()){
return Collections.emptyList();
}

if (!distantFuture) {
//comment
RequestState singleRequest = availableSet.get(random.nextInt(availableSet.size()));
availableSet.clear();
availableSet.add(singleRequest);
}

List<RequestState> requestStates = new ArrayList<>();
for (RequestState state : availableSet) {
//comment
//comment
//comment
//comment
int nextSize = state.size - 2;
if (nextSize < MIN_REQUEST_SIZE) {
nextSize = MAX_REQUEST_SIZE;
}

if (state.mode == BACKWARD) {
state.from = Math.max(1, state.from - BACKWARD_SYNC_STEP);
state.size = nextSize;
} else if (state.mode == FORWARD) {
state.from = state.from + state.size;
state.size = nextSize;
} else {
//comment
if (state.from == nextFrom) {
nextFrom = nextFrom + state.size;
}

//comment
state.from = nextFrom;
state.mode = nextMode;
state.size = nextSize;

//comment
//comment
nextFrom = Math.max(requestHeight, nextFrom + nextSize);
}

requestStates.add(state);
}

return requestStates;
}","private List<RequestState> updateStatesForRequests(boolean distantFuture, long currentBestBlock) {
//comment
localHeight = Math.max(localHeight, currentBestBlock);

long nextFrom;
SyncMode nextMode;

//comment
if (networkHeight >= currentBestBlock + SWITCH_OVERLAPPING_BLOCKS_RANGE) {
nextFrom = Math.max(1, currentBestBlock - FAR_OVERLAPPING_BLOCKS);
} else {
nextFrom = Math.max(1, currentBestBlock - CLOSE_OVERLAPPING_BLOCKS);
}
nextMode = SyncMode.NORMAL;

List<RequestState> availableSet = new ArrayList<>(availablePeerStates.values());
if (availableSet.isEmpty()){
return Collections.emptyList();
}

if (!distantFuture) {
//comment
RequestState singleRequest = availableSet.get(random.nextInt(availableSet.size()));
availableSet.clear();
availableSet.add(singleRequest);
}

List<RequestState> requestStates = new ArrayList<>();
for (RequestState state : availableSet) {
//comment
//comment
//comment
//comment
int nextSize = state.size - 2;
if (nextSize < MIN_REQUEST_SIZE) {
nextSize = MAX_REQUEST_SIZE;
}

if (state.mode == BACKWARD) {
state.from = Math.max(1, state.from - BACKWARD_SYNC_STEP);
state.size = nextSize;
} else if (state.mode == FORWARD) {
state.from = state.from + state.size;
state.size = nextSize;
} else {
//comment
<start>if (state.from == nextFrom) {
nextFrom = nextFrom + state.size;
}<end>

//comment
state.from = nextFrom;
state.mode = nextMode;
state.size = nextSize;

//comment
//comment
nextFrom = Math.max(requestHeight, nextFrom + nextSize);
}

requestStates.add(state);
}

return requestStates;
}"
3054,"private List<RequestState> updateStatesForRequests(boolean distantFuture, long currentBestBlock) {
//comment
localHeight = Math.max(localHeight, currentBestBlock);

long nextFrom;
SyncMode nextMode;

//comment
if (networkHeight >= currentBestBlock + SWITCH_OVERLAPPING_BLOCKS_RANGE) {
nextFrom = Math.max(1, currentBestBlock - FAR_OVERLAPPING_BLOCKS);
} else {
nextFrom = Math.max(1, currentBestBlock - CLOSE_OVERLAPPING_BLOCKS);
}
nextMode = SyncMode.NORMAL;

List<RequestState> availableSet = new ArrayList<>(availablePeerStates.values());
if (availableSet.isEmpty()){
return Collections.emptyList();
}

if (!distantFuture) {
//comment
RequestState singleRequest = availableSet.get(random.nextInt(availableSet.size()));
availableSet.clear();
availableSet.add(singleRequest);
}

List<RequestState> requestStates = new ArrayList<>();
for (RequestState state : availableSet) {
//comment
//comment
//comment
//comment
int nextSize = state.size - 2;
if (nextSize < MIN_REQUEST_SIZE) {
nextSize = MAX_REQUEST_SIZE;
}

if (state.mode == BACKWARD) {
state.from = Math.max(1, state.from - BACKWARD_SYNC_STEP);
state.size = nextSize;
} else if (state.mode == FORWARD) {
state.from = state.from + state.size;
state.size = nextSize;
} else {
//comment
if (state.from == nextFrom) {
nextFrom = nextFrom + state.size;
}

//comment
state.from = nextFrom;
<start>state.mode = nextMode;<end>
state.size = nextSize;

//comment
//comment
<start>nextFrom = Math.max(requestHeight, nextFrom + nextSize);<end>
}

requestStates.add(state);
}

return requestStates;
}","private List<RequestState> updateStatesForRequests(boolean distantFuture, long currentBestBlock) {
//comment
localHeight = Math.max(localHeight, currentBestBlock);

long nextFrom;
SyncMode nextMode;

//comment
if (networkHeight >= currentBestBlock + SWITCH_OVERLAPPING_BLOCKS_RANGE) {
nextFrom = Math.max(1, currentBestBlock - FAR_OVERLAPPING_BLOCKS);
} else {
nextFrom = Math.max(1, currentBestBlock - CLOSE_OVERLAPPING_BLOCKS);
}
nextMode = SyncMode.NORMAL;

List<RequestState> availableSet = new ArrayList<>(availablePeerStates.values());
if (availableSet.isEmpty()){
return Collections.emptyList();
}

if (!distantFuture) {
//comment
RequestState singleRequest = availableSet.get(random.nextInt(availableSet.size()));
availableSet.clear();
availableSet.add(singleRequest);
}

List<RequestState> requestStates = new ArrayList<>();
for (RequestState state : availableSet) {
//comment
//comment
//comment
//comment
int nextSize = state.size - 2;
if (nextSize < MIN_REQUEST_SIZE) {
nextSize = MAX_REQUEST_SIZE;
}

if (state.mode == BACKWARD) {
state.from = Math.max(1, state.from - BACKWARD_SYNC_STEP);
state.size = nextSize;
} else if (state.mode == FORWARD) {
state.from = state.from + state.size;
state.size = nextSize;
} else {
//comment
if (state.from == nextFrom) {
nextFrom = nextFrom + state.size;
}

//comment
state.from = nextFrom;
state.mode = nextMode;
state.size = nextSize;

//comment
//comment
<start>nextFrom = Math.max(requestHeight, nextFrom + nextSize);<end>
}

requestStates.add(state);
}

return requestStates;
}"
3055,"    private void storeHeadersInternal(int peerId, List<BlockHeader> headers) {
Objects.requireNonNull(headers);

//comment
<start>int size = headers.size();<end>
if (storedHeaders.containsKey(peerId)) {
Map<Integer, LinkedList<List<BlockHeader>>> peerList = storedHeaders.get(peerId);
if (peerList.containsKey(size)) {
peerList.get(size).addLast(headers);
} else {
LinkedList<List<BlockHeader>> headersList = new LinkedList<>();
headersList.addLast(headers);
peerList.put(size, headersList);
}
} else {
Map<Integer, LinkedList<List<BlockHeader>>> peerHeaders = new HashMap<>();
LinkedList<List<BlockHeader>> headersList = new LinkedList<>();
headersList.addLast(headers);
peerHeaders.put(size, headersList);
storedHeaders.put(peerId, peerHeaders);
}

//comment
if (bookedPeerStates.containsKey(peerId)
&& bookedPeerStates.get(peerId).tryMakeAvailable()) {
availablePeerStates.put(peerId, bookedPeerStates.remove(peerId));
}

syncLog.debug(""<save-headers nodeId={} size={} object={}>"", peerId, headers.size(), printHeaders(headers));
}","    private void storeHeadersInternal(int peerId, List<BlockHeader> headers) {
Objects.requireNonNull(headers);

//comment
<start>int size = headers.size();
if (storedHeaders.containsKey(peerId)) {
Map<Integer, LinkedList<List<BlockHeader>>> peerList = storedHeaders.get(peerId);
if (peerList.containsKey(size)) {
peerList.get(size).addLast(headers);
} else {
LinkedList<List<BlockHeader>> headersList = new LinkedList<>();
headersList.addLast(headers);
peerList.put(size, headersList);
}
} else {
Map<Integer, LinkedList<List<BlockHeader>>> peerHeaders = new HashMap<>();
LinkedList<List<BlockHeader>> headersList = new LinkedList<>();
headersList.addLast(headers);
peerHeaders.put(size, headersList);
storedHeaders.put(peerId, peerHeaders);
}<end>

//comment
if (bookedPeerStates.containsKey(peerId)
&& bookedPeerStates.get(peerId).tryMakeAvailable()) {
availablePeerStates.put(peerId, bookedPeerStates.remove(peerId));
}

syncLog.debug(""<save-headers nodeId={} size={} object={}>"", peerId, headers.size(), printHeaders(headers));
}"
3056,"    private void storeHeadersInternal(int peerId, List<BlockHeader> headers) {
Objects.requireNonNull(headers);

//comment
int size = headers.size();
if (storedHeaders.containsKey(peerId)) {
Map<Integer, LinkedList<List<BlockHeader>>> peerList = storedHeaders.get(peerId);
if (peerList.containsKey(size)) {
peerList.get(size).addLast(headers);
} else {
LinkedList<List<BlockHeader>> headersList = new LinkedList<>();
headersList.addLast(headers);
peerList.put(size, headersList);
}
} else {
Map<Integer, LinkedList<List<BlockHeader>>> peerHeaders = new HashMap<>();
LinkedList<List<BlockHeader>> headersList = new LinkedList<>();
headersList.addLast(headers);
peerHeaders.put(size, headersList);
storedHeaders.put(peerId, peerHeaders);
}

//comment
<start>if (bookedPeerStates.containsKey(peerId)
&& bookedPeerStates.get(peerId).tryMakeAvailable()) {
availablePeerStates.put(peerId, bookedPeerStates.remove(peerId));
}<end>

syncLog.debug(""<save-headers nodeId={} size={} object={}>"", peerId, headers.size(), printHeaders(headers));
}","    private void storeHeadersInternal(int peerId, List<BlockHeader> headers) {
Objects.requireNonNull(headers);

//comment
int size = headers.size();
if (storedHeaders.containsKey(peerId)) {
Map<Integer, LinkedList<List<BlockHeader>>> peerList = storedHeaders.get(peerId);
if (peerList.containsKey(size)) {
peerList.get(size).addLast(headers);
} else {
LinkedList<List<BlockHeader>> headersList = new LinkedList<>();
headersList.addLast(headers);
peerList.put(size, headersList);
}
} else {
Map<Integer, LinkedList<List<BlockHeader>>> peerHeaders = new HashMap<>();
LinkedList<List<BlockHeader>> headersList = new LinkedList<>();
headersList.addLast(headers);
peerHeaders.put(size, headersList);
storedHeaders.put(peerId, peerHeaders);
}

//comment
<start>if (bookedPeerStates.containsKey(peerId)
&& bookedPeerStates.get(peerId).tryMakeAvailable()) {
availablePeerStates.put(peerId, bookedPeerStates.remove(peerId));
}<end>

syncLog.debug(""<save-headers nodeId={} size={} object={}>"", peerId, headers.size(), printHeaders(headers));
}"
3057,"    private void runInModeInternal(int peerId, SyncMode mode) {
//comment
<start>RequestState state = bookedPeerStates.get(peerId);<end>
if (state == null) {
state = availablePeerStates.get(peerId);
}

//comment
if (state != null) {
syncLog.debug(
""<mode-update: node={}, nodeId={}, from_mode={}, to_mode={}>"",
state.alias,
peerId,
state.mode,
mode);
state.mode = mode;
}
}","    private void runInModeInternal(int peerId, SyncMode mode) {
//comment
<start>RequestState state = bookedPeerStates.get(peerId);
if (state == null) {
state = availablePeerStates.get(peerId);
}<end>

//comment
if (state != null) {
syncLog.debug(
""<mode-update: node={}, nodeId={}, from_mode={}, to_mode={}>"",
state.alias,
peerId,
state.mode,
mode);
state.mode = mode;
}
}"
3058,"    private void runInModeInternal(int peerId, SyncMode mode) {
//comment
RequestState state = bookedPeerStates.get(peerId);
if (state == null) {
state = availablePeerStates.get(peerId);
}

//comment
if (state != null) {
syncLog.debug(
""<mode-update: node={}, nodeId={}, from_mode={}, to_mode={}>"",
state.alias,
peerId,
state.mode,
mode);
state.mode = mode;
}
}","    private void runInModeInternal(int peerId, SyncMode mode) {
//comment
RequestState state = bookedPeerStates.get(peerId);
if (state == null) {
state = availablePeerStates.get(peerId);
}

//comment
<start>if (state != null) {<end>
syncLog.debug(
""<mode-update: node={}, nodeId={}, from_mode={}, to_mode={}>"",
state.alias,
peerId,
state.mode,
mode);
<start>state.mode = mode;
}<end>
}"
3059,"public boolean tryMakeAvailable() {
if (headerRequests.size() < MAX_REQUESTS_PER_SECOND) {
//comment
return true;
} else {
long now = System.nanoTime();
long first = headerRequests.first();

if ((now - first) <= ONE_SECOND) {
//comment
return false;
} else {
//comment
//comment
<start>headerRequests.remove(first);<end>
return true;
}
}
}","public boolean tryMakeAvailable() {
if (headerRequests.size() < MAX_REQUESTS_PER_SECOND) {
//comment
return true;
} else {
long now = System.nanoTime();
long first = headerRequests.first();

<start>if ((now - first) <= ONE_SECOND) {<end>
//comment
return false;
<start>} else {
//comment
//comment
headerRequests.remove(first);
return true;
}<end>
}
}"
983,"private void broadcastTx() {

List<AionTransaction> transactions;
broadcastLock.lock();
try {

//comment
<start>if (transactionQueue.isEmpty()) return;<end>

//comment
transactions = new ArrayList<>(transactionQueue.size());
transactionQueue.drainTo(transactions);

//comment
for (AionTransaction a : transactions) {
queueSizeBytes.addAndGet(a.getEncoded().length * -1);
}
} finally {
broadcastLock.unlock();
}

//comment
this.lastBroadcast.set(System.currentTimeMillis());

if (!transactions.isEmpty()) {
if (LOG.isTraceEnabled()) {
LOG.trace(""TxCollector.broadcastTransactions Tx#{}"", transactions.size());
}

txBroadcaster.submitTransaction(
new A0TxTask(transactions, this.p2p, new BroadcastTx(transactions)));
}
}","private void broadcastTx() {

List<AionTransaction> transactions;
broadcastLock.lock();
try {

//comment
<start>if (transactionQueue.isEmpty()) return;<end>

//comment
transactions = new ArrayList<>(transactionQueue.size());
transactionQueue.drainTo(transactions);

//comment
for (AionTransaction a : transactions) {
queueSizeBytes.addAndGet(a.getEncoded().length * -1);
}
} finally {
broadcastLock.unlock();
}

//comment
this.lastBroadcast.set(System.currentTimeMillis());

if (!transactions.isEmpty()) {
if (LOG.isTraceEnabled()) {
LOG.trace(""TxCollector.broadcastTransactions Tx#{}"", transactions.size());
}

txBroadcaster.submitTransaction(
new A0TxTask(transactions, this.p2p, new BroadcastTx(transactions)));
}
}"
984,"private void broadcastTx() {

List<AionTransaction> transactions;
broadcastLock.lock();
try {

//comment
if (transactionQueue.isEmpty()) return;

//comment
<start>transactions = new ArrayList<>(transactionQueue.size());<end>
transactionQueue.drainTo(transactions);

//comment
for (AionTransaction a : transactions) {
queueSizeBytes.addAndGet(a.getEncoded().length * -1);
}
} finally {
broadcastLock.unlock();
}

//comment
this.lastBroadcast.set(System.currentTimeMillis());

if (!transactions.isEmpty()) {
if (LOG.isTraceEnabled()) {
LOG.trace(""TxCollector.broadcastTransactions Tx#{}"", transactions.size());
}

txBroadcaster.submitTransaction(
new A0TxTask(transactions, this.p2p, new BroadcastTx(transactions)));
}
}","private void broadcastTx() {

List<AionTransaction> transactions;
broadcastLock.lock();
try {

//comment
if (transactionQueue.isEmpty()) return;

//comment
<start>transactions = new ArrayList<>(transactionQueue.size());
transactionQueue.drainTo(transactions);<end>

//comment
for (AionTransaction a : transactions) {
queueSizeBytes.addAndGet(a.getEncoded().length * -1);
}
} finally {
broadcastLock.unlock();
}

//comment
this.lastBroadcast.set(System.currentTimeMillis());

if (!transactions.isEmpty()) {
if (LOG.isTraceEnabled()) {
LOG.trace(""TxCollector.broadcastTransactions Tx#{}"", transactions.size());
}

txBroadcaster.submitTransaction(
new A0TxTask(transactions, this.p2p, new BroadcastTx(transactions)));
}
}"
985,"private void broadcastTx() {

List<AionTransaction> transactions;
broadcastLock.lock();
try {

//comment
if (transactionQueue.isEmpty()) return;

//comment
transactions = new ArrayList<>(transactionQueue.size());
<start>transactionQueue.drainTo(transactions);<end>

//comment
for (AionTransaction a : transactions) {
queueSizeBytes.addAndGet(a.getEncoded().length * -1);
}
} finally {
broadcastLock.unlock();
}

//comment
this.lastBroadcast.set(System.currentTimeMillis());

if (!transactions.isEmpty()) {
if (LOG.isTraceEnabled()) {
LOG.trace(""TxCollector.broadcastTransactions Tx#{}"", transactions.size());
}

txBroadcaster.submitTransaction(
new A0TxTask(transactions, this.p2p, new BroadcastTx(transactions)));
}
}","private void broadcastTx() {

List<AionTransaction> transactions;
broadcastLock.lock();
try {

//comment
if (transactionQueue.isEmpty()) return;

//comment
transactions = new ArrayList<>(transactionQueue.size());
transactionQueue.drainTo(transactions);

//comment
<start>for (AionTransaction a : transactions) {
queueSizeBytes.addAndGet(a.getEncoded().length * -1);
}<end>
} finally {
broadcastLock.unlock();
}

//comment
this.lastBroadcast.set(System.currentTimeMillis());

if (!transactions.isEmpty()) {
if (LOG.isTraceEnabled()) {
LOG.trace(""TxCollector.broadcastTransactions Tx#{}"", transactions.size());
}

txBroadcaster.submitTransaction(
new A0TxTask(transactions, this.p2p, new BroadcastTx(transactions)));
}
}"
986,"private void broadcastTx() {

List<AionTransaction> transactions;
broadcastLock.lock();
try {

//comment
if (transactionQueue.isEmpty()) return;

//comment
transactions = new ArrayList<>(transactionQueue.size());
transactionQueue.drainTo(transactions);

//comment
for (AionTransaction a : transactions) {
queueSizeBytes.addAndGet(a.getEncoded().length * -1);
}
} finally {
broadcastLock.unlock();
}

//comment
<start>this.lastBroadcast.set(System.currentTimeMillis());<end>

if (!transactions.isEmpty()) {
if (LOG.isTraceEnabled()) {
LOG.trace(""TxCollector.broadcastTransactions Tx#{}"", transactions.size());
}

txBroadcaster.submitTransaction(
new A0TxTask(transactions, this.p2p, new BroadcastTx(transactions)));
}
}","private void broadcastTx() {

List<AionTransaction> transactions;
broadcastLock.lock();
try {

//comment
if (transactionQueue.isEmpty()) return;

//comment
transactions = new ArrayList<>(transactionQueue.size());
transactionQueue.drainTo(transactions);

//comment
for (AionTransaction a : transactions) {
queueSizeBytes.addAndGet(a.getEncoded().length * -1);
}
} finally {
broadcastLock.unlock();
}

//comment
<start>this.lastBroadcast.set(System.currentTimeMillis());<end>

if (!transactions.isEmpty()) {
if (LOG.isTraceEnabled()) {
LOG.trace(""TxCollector.broadcastTransactions Tx#{}"", transactions.size());
}

txBroadcaster.submitTransaction(
new A0TxTask(transactions, this.p2p, new BroadcastTx(transactions)));
}
}"
7648,"@Override
public void addStorageValue(AionAddress address, IPrecompiledDataWord key, IPrecompiledDataWord value) {
//comment
//comment
//comment
<start>byte[] valueBytes = (value instanceof PrecompiledDataWord) ? dropLeadingZeroes(value.copyOfData()) : value.copyOfData();
this.repository.addStorageRow(address, ByteArrayWrapper.wrap(key.copyOfData()), ByteArrayWrapper.wrap(valueBytes));<end>
}","@Override
public void addStorageValue(AionAddress address, IPrecompiledDataWord key, IPrecompiledDataWord value) {
//comment
//comment
//comment
<start>byte[] valueBytes = (value instanceof PrecompiledDataWord) ? dropLeadingZeroes(value.copyOfData()) : value.copyOfData();<end>
this.repository.addStorageRow(address, ByteArrayWrapper.wrap(key.copyOfData()), ByteArrayWrapper.wrap(valueBytes));
}"
1752,"public static void handleArguments(String[] args) {
CommandLine cl = getArgs(args);
if (cl.hasOption('h')) {
HelpFormatter hf = new HelpFormatter();
hf.printHelp(""java -jar ripme.jar [OPTIONS]"", getOptions());
System.exit(0);
}
if (cl.hasOption('w')) {
Utils.setConfigBoolean(""file.overwrite"", true);
}
if (cl.hasOption('t')) {
Utils.setConfigInteger(""threads.size"", Integer.parseInt(cl.getOptionValue('t')));
}
if (cl.hasOption('4')) {
Utils.setConfigBoolean(""errors.skip404"", true);
}
if (cl.hasOption('r')) {
//comment
List<String> history = Utils.getConfigList(""download.history"");
for (String urlString : history) {
try {
URL url = new URL(urlString.trim());
rip(url);
} catch (Exception e) {
logger.error(""[!] Failed to rip URL "" + urlString, e);
continue;
}
try {
Thread.sleep(500);
} catch (InterruptedException e) {
logger.warn(""[!] Interrupted while re-ripping history"");
System.exit(-1);
}
}
//comment
<start>System.exit(0);<end>
}
if (cl.hasOption('R')) {
loadHistory();
if (HISTORY.toList().size() == 0) {
System.err.println(""There are no history entries to re-rip. Rip some albums first"");
System.exit(-1);
}
int added = 0;
for (HistoryEntry entry : HISTORY.toList()) {
if (entry.selected) {
added++;
try {
URL url = new URL(entry.url);
rip(url);
} catch (Exception e) {
logger.error(""[!] Failed to rip URL "" + entry.url, e);
continue;
}
try {
Thread.sleep(500);
} catch (InterruptedException e) {
logger.warn(""[!] Interrupted while re-ripping history"");
System.exit(-1);
}
}
}
if (added == 0) {
System.err.println(""No history entries have been 'Checked'\n"" +
""Check an entry by clicking the checkbox to the right of the URL or Right-click a URL to check/uncheck all items"");
System.exit(-1);
}
}
if (cl.hasOption('d')) {
Utils.setConfigBoolean(""download.save_order"", true);
}
if (cl.hasOption('D')) {
Utils.setConfigBoolean(""download.save_order"", false);
}
if ((cl.hasOption('d'))&&(cl.hasOption('D'))) {
System.err.println(""\nCannot specify '-d' and '-D' simultaneously"");
System.exit(-1);
}
if (cl.hasOption('l')) {
//comment
Utils.setConfigString(""rips.directory"", cl.getOptionValue('l'));
}
if (cl.hasOption('f')) {
String filename = cl.getOptionValue('f');
try {
String url;
BufferedReader br = new BufferedReader(new FileReader(filename));
while ((url = br.readLine()) != null) {
//comment
ripURL(url.trim(), cl.hasOption(""n""));
}
} catch (FileNotFoundException fne) {
logger.error(""[!] File containing list of URLs not found. Cannot continue."");
} catch (IOException ioe) {
logger.error(""[!] Failed reading file containing list of URLs. Cannot continue."");
}
}
if (cl.hasOption('u')) {
String url = cl.getOptionValue('u').trim();
ripURL(url, cl.hasOption(""n""));
}
}","public static void handleArguments(String[] args) {
CommandLine cl = getArgs(args);
if (cl.hasOption('h')) {
HelpFormatter hf = new HelpFormatter();
hf.printHelp(""java -jar ripme.jar [OPTIONS]"", getOptions());
System.exit(0);
}
if (cl.hasOption('w')) {
Utils.setConfigBoolean(""file.overwrite"", true);
}
if (cl.hasOption('t')) {
Utils.setConfigInteger(""threads.size"", Integer.parseInt(cl.getOptionValue('t')));
}
if (cl.hasOption('4')) {
Utils.setConfigBoolean(""errors.skip404"", true);
}
if (cl.hasOption('r')) {
//comment
List<String> history = Utils.getConfigList(""download.history"");
for (String urlString : history) {
try {
URL url = new URL(urlString.trim());
rip(url);
} catch (Exception e) {
logger.error(""[!] Failed to rip URL "" + urlString, e);
continue;
}
try {
Thread.sleep(500);
} catch (InterruptedException e) {
logger.warn(""[!] Interrupted while re-ripping history"");
System.exit(-1);
}
}
//comment
<start>System.exit(0);<end>
}
if (cl.hasOption('R')) {
loadHistory();
if (HISTORY.toList().size() == 0) {
System.err.println(""There are no history entries to re-rip. Rip some albums first"");
System.exit(-1);
}
int added = 0;
for (HistoryEntry entry : HISTORY.toList()) {
if (entry.selected) {
added++;
try {
URL url = new URL(entry.url);
rip(url);
} catch (Exception e) {
logger.error(""[!] Failed to rip URL "" + entry.url, e);
continue;
}
try {
Thread.sleep(500);
} catch (InterruptedException e) {
logger.warn(""[!] Interrupted while re-ripping history"");
System.exit(-1);
}
}
}
if (added == 0) {
System.err.println(""No history entries have been 'Checked'\n"" +
""Check an entry by clicking the checkbox to the right of the URL or Right-click a URL to check/uncheck all items"");
System.exit(-1);
}
}
if (cl.hasOption('d')) {
Utils.setConfigBoolean(""download.save_order"", true);
}
if (cl.hasOption('D')) {
Utils.setConfigBoolean(""download.save_order"", false);
}
if ((cl.hasOption('d'))&&(cl.hasOption('D'))) {
System.err.println(""\nCannot specify '-d' and '-D' simultaneously"");
System.exit(-1);
}
if (cl.hasOption('l')) {
//comment
Utils.setConfigString(""rips.directory"", cl.getOptionValue('l'));
}
if (cl.hasOption('f')) {
String filename = cl.getOptionValue('f');
try {
String url;
BufferedReader br = new BufferedReader(new FileReader(filename));
while ((url = br.readLine()) != null) {
//comment
ripURL(url.trim(), cl.hasOption(""n""));
}
} catch (FileNotFoundException fne) {
logger.error(""[!] File containing list of URLs not found. Cannot continue."");
} catch (IOException ioe) {
logger.error(""[!] Failed reading file containing list of URLs. Cannot continue."");
}
}
if (cl.hasOption('u')) {
String url = cl.getOptionValue('u').trim();
ripURL(url, cl.hasOption(""n""));
}
}"
1753,"public static void handleArguments(String[] args) {
CommandLine cl = getArgs(args);
if (cl.hasOption('h')) {
HelpFormatter hf = new HelpFormatter();
hf.printHelp(""java -jar ripme.jar [OPTIONS]"", getOptions());
System.exit(0);
}
if (cl.hasOption('w')) {
Utils.setConfigBoolean(""file.overwrite"", true);
}
if (cl.hasOption('t')) {
Utils.setConfigInteger(""threads.size"", Integer.parseInt(cl.getOptionValue('t')));
}
if (cl.hasOption('4')) {
Utils.setConfigBoolean(""errors.skip404"", true);
}
if (cl.hasOption('r')) {
//comment
List<String> history = Utils.getConfigList(""download.history"");
for (String urlString : history) {
try {
URL url = new URL(urlString.trim());
rip(url);
} catch (Exception e) {
logger.error(""[!] Failed to rip URL "" + urlString, e);
continue;
}
try {
Thread.sleep(500);
} catch (InterruptedException e) {
logger.warn(""[!] Interrupted while re-ripping history"");
System.exit(-1);
}
}
//comment
System.exit(0);
}
if (cl.hasOption('R')) {
loadHistory();
if (HISTORY.toList().size() == 0) {
System.err.println(""There are no history entries to re-rip. Rip some albums first"");
System.exit(-1);
}
int added = 0;
for (HistoryEntry entry : HISTORY.toList()) {
if (entry.selected) {
added++;
try {
URL url = new URL(entry.url);
rip(url);
} catch (Exception e) {
logger.error(""[!] Failed to rip URL "" + entry.url, e);
continue;
}
try {
Thread.sleep(500);
} catch (InterruptedException e) {
logger.warn(""[!] Interrupted while re-ripping history"");
System.exit(-1);
}
}
}
if (added == 0) {
System.err.println(""No history entries have been 'Checked'\n"" +
""Check an entry by clicking the checkbox to the right of the URL or Right-click a URL to check/uncheck all items"");
System.exit(-1);
}
}
if (cl.hasOption('d')) {
Utils.setConfigBoolean(""download.save_order"", true);
}
if (cl.hasOption('D')) {
Utils.setConfigBoolean(""download.save_order"", false);
}
if ((cl.hasOption('d'))&&(cl.hasOption('D'))) {
System.err.println(""\nCannot specify '-d' and '-D' simultaneously"");
<start>System.exit(-1);<end>
}
if (cl.hasOption('l')) {
//comment
Utils.setConfigString(""rips.directory"", cl.getOptionValue('l'));
}
if (cl.hasOption('f')) {
String filename = cl.getOptionValue('f');
try {
String url;
BufferedReader br = new BufferedReader(new FileReader(filename));
while ((url = br.readLine()) != null) {
//comment
ripURL(url.trim(), cl.hasOption(""n""));
}
} catch (FileNotFoundException fne) {
logger.error(""[!] File containing list of URLs not found. Cannot continue."");
} catch (IOException ioe) {
logger.error(""[!] Failed reading file containing list of URLs. Cannot continue."");
}
}
if (cl.hasOption('u')) {
String url = cl.getOptionValue('u').trim();
ripURL(url, cl.hasOption(""n""));
}
}","public static void handleArguments(String[] args) {
CommandLine cl = getArgs(args);
if (cl.hasOption('h')) {
HelpFormatter hf = new HelpFormatter();
hf.printHelp(""java -jar ripme.jar [OPTIONS]"", getOptions());
System.exit(0);
}
if (cl.hasOption('w')) {
Utils.setConfigBoolean(""file.overwrite"", true);
}
if (cl.hasOption('t')) {
Utils.setConfigInteger(""threads.size"", Integer.parseInt(cl.getOptionValue('t')));
}
if (cl.hasOption('4')) {
Utils.setConfigBoolean(""errors.skip404"", true);
}
if (cl.hasOption('r')) {
//comment
List<String> history = Utils.getConfigList(""download.history"");
for (String urlString : history) {
try {
URL url = new URL(urlString.trim());
rip(url);
} catch (Exception e) {
logger.error(""[!] Failed to rip URL "" + urlString, e);
continue;
}
try {
Thread.sleep(500);
} catch (InterruptedException e) {
logger.warn(""[!] Interrupted while re-ripping history"");
System.exit(-1);
}
}
//comment
System.exit(0);
}
if (cl.hasOption('R')) {
loadHistory();
if (HISTORY.toList().size() == 0) {
System.err.println(""There are no history entries to re-rip. Rip some albums first"");
System.exit(-1);
}
int added = 0;
for (HistoryEntry entry : HISTORY.toList()) {
if (entry.selected) {
added++;
try {
URL url = new URL(entry.url);
rip(url);
} catch (Exception e) {
logger.error(""[!] Failed to rip URL "" + entry.url, e);
continue;
}
try {
Thread.sleep(500);
} catch (InterruptedException e) {
logger.warn(""[!] Interrupted while re-ripping history"");
System.exit(-1);
}
}
}
if (added == 0) {
System.err.println(""No history entries have been 'Checked'\n"" +
""Check an entry by clicking the checkbox to the right of the URL or Right-click a URL to check/uncheck all items"");
System.exit(-1);
}
}
if (cl.hasOption('d')) {
Utils.setConfigBoolean(""download.save_order"", true);
}
if (cl.hasOption('D')) {
Utils.setConfigBoolean(""download.save_order"", false);
}
if ((cl.hasOption('d'))&&(cl.hasOption('D'))) {
System.err.println(""\nCannot specify '-d' and '-D' simultaneously"");
System.exit(-1);
}
if (cl.hasOption('l')) {
//comment
<start>Utils.setConfigString(""rips.directory"", cl.getOptionValue('l'));<end>
}
if (cl.hasOption('f')) {
String filename = cl.getOptionValue('f');
try {
String url;
BufferedReader br = new BufferedReader(new FileReader(filename));
while ((url = br.readLine()) != null) {
//comment
ripURL(url.trim(), cl.hasOption(""n""));
}
} catch (FileNotFoundException fne) {
logger.error(""[!] File containing list of URLs not found. Cannot continue."");
} catch (IOException ioe) {
logger.error(""[!] Failed reading file containing list of URLs. Cannot continue."");
}
}
if (cl.hasOption('u')) {
String url = cl.getOptionValue('u').trim();
ripURL(url, cl.hasOption(""n""));
}
}"
1754,"public static void handleArguments(String[] args) {
CommandLine cl = getArgs(args);
if (cl.hasOption('h')) {
HelpFormatter hf = new HelpFormatter();
hf.printHelp(""java -jar ripme.jar [OPTIONS]"", getOptions());
System.exit(0);
}
if (cl.hasOption('w')) {
Utils.setConfigBoolean(""file.overwrite"", true);
}
if (cl.hasOption('t')) {
Utils.setConfigInteger(""threads.size"", Integer.parseInt(cl.getOptionValue('t')));
}
if (cl.hasOption('4')) {
Utils.setConfigBoolean(""errors.skip404"", true);
}
if (cl.hasOption('r')) {
//comment
List<String> history = Utils.getConfigList(""download.history"");
for (String urlString : history) {
try {
URL url = new URL(urlString.trim());
rip(url);
} catch (Exception e) {
logger.error(""[!] Failed to rip URL "" + urlString, e);
continue;
}
try {
Thread.sleep(500);
} catch (InterruptedException e) {
logger.warn(""[!] Interrupted while re-ripping history"");
System.exit(-1);
}
}
//comment
System.exit(0);
}
if (cl.hasOption('R')) {
loadHistory();
if (HISTORY.toList().size() == 0) {
System.err.println(""There are no history entries to re-rip. Rip some albums first"");
System.exit(-1);
}
int added = 0;
for (HistoryEntry entry : HISTORY.toList()) {
if (entry.selected) {
added++;
try {
URL url = new URL(entry.url);
rip(url);
} catch (Exception e) {
logger.error(""[!] Failed to rip URL "" + entry.url, e);
continue;
}
try {
Thread.sleep(500);
} catch (InterruptedException e) {
logger.warn(""[!] Interrupted while re-ripping history"");
System.exit(-1);
}
}
}
if (added == 0) {
System.err.println(""No history entries have been 'Checked'\n"" +
""Check an entry by clicking the checkbox to the right of the URL or Right-click a URL to check/uncheck all items"");
System.exit(-1);
}
}
if (cl.hasOption('d')) {
Utils.setConfigBoolean(""download.save_order"", true);
}
if (cl.hasOption('D')) {
Utils.setConfigBoolean(""download.save_order"", false);
}
if ((cl.hasOption('d'))&&(cl.hasOption('D'))) {
System.err.println(""\nCannot specify '-d' and '-D' simultaneously"");
System.exit(-1);
}
if (cl.hasOption('l')) {
//comment
Utils.setConfigString(""rips.directory"", cl.getOptionValue('l'));
}
if (cl.hasOption('f')) {
String filename = cl.getOptionValue('f');
try {
String url;
BufferedReader br = new BufferedReader(new FileReader(filename));
<start>while ((url = br.readLine()) != null) {
//comment
ripURL(url.trim(), cl.hasOption(""n""));
}<end>
} catch (FileNotFoundException fne) {
logger.error(""[!] File containing list of URLs not found. Cannot continue."");
} catch (IOException ioe) {
logger.error(""[!] Failed reading file containing list of URLs. Cannot continue."");
}
}
if (cl.hasOption('u')) {
String url = cl.getOptionValue('u').trim();
ripURL(url, cl.hasOption(""n""));
}
}","public static void handleArguments(String[] args) {
CommandLine cl = getArgs(args);
if (cl.hasOption('h')) {
HelpFormatter hf = new HelpFormatter();
hf.printHelp(""java -jar ripme.jar [OPTIONS]"", getOptions());
System.exit(0);
}
if (cl.hasOption('w')) {
Utils.setConfigBoolean(""file.overwrite"", true);
}
if (cl.hasOption('t')) {
Utils.setConfigInteger(""threads.size"", Integer.parseInt(cl.getOptionValue('t')));
}
if (cl.hasOption('4')) {
Utils.setConfigBoolean(""errors.skip404"", true);
}
if (cl.hasOption('r')) {
//comment
List<String> history = Utils.getConfigList(""download.history"");
for (String urlString : history) {
try {
URL url = new URL(urlString.trim());
rip(url);
} catch (Exception e) {
logger.error(""[!] Failed to rip URL "" + urlString, e);
continue;
}
try {
Thread.sleep(500);
} catch (InterruptedException e) {
logger.warn(""[!] Interrupted while re-ripping history"");
System.exit(-1);
}
}
//comment
System.exit(0);
}
if (cl.hasOption('R')) {
loadHistory();
if (HISTORY.toList().size() == 0) {
System.err.println(""There are no history entries to re-rip. Rip some albums first"");
System.exit(-1);
}
int added = 0;
for (HistoryEntry entry : HISTORY.toList()) {
if (entry.selected) {
added++;
try {
URL url = new URL(entry.url);
rip(url);
} catch (Exception e) {
logger.error(""[!] Failed to rip URL "" + entry.url, e);
continue;
}
try {
Thread.sleep(500);
} catch (InterruptedException e) {
logger.warn(""[!] Interrupted while re-ripping history"");
System.exit(-1);
}
}
}
if (added == 0) {
System.err.println(""No history entries have been 'Checked'\n"" +
""Check an entry by clicking the checkbox to the right of the URL or Right-click a URL to check/uncheck all items"");
System.exit(-1);
}
}
if (cl.hasOption('d')) {
Utils.setConfigBoolean(""download.save_order"", true);
}
if (cl.hasOption('D')) {
Utils.setConfigBoolean(""download.save_order"", false);
}
if ((cl.hasOption('d'))&&(cl.hasOption('D'))) {
System.err.println(""\nCannot specify '-d' and '-D' simultaneously"");
System.exit(-1);
}
if (cl.hasOption('l')) {
//comment
Utils.setConfigString(""rips.directory"", cl.getOptionValue('l'));
}
if (cl.hasOption('f')) {
String filename = cl.getOptionValue('f');
try {
String url;
BufferedReader br = new BufferedReader(new FileReader(filename));
<start>while ((url = br.readLine()) != null) {
//comment
ripURL(url.trim(), cl.hasOption(""n""));
}<end>
} catch (FileNotFoundException fne) {
logger.error(""[!] File containing list of URLs not found. Cannot continue."");
} catch (IOException ioe) {
logger.error(""[!] Failed reading file containing list of URLs. Cannot continue."");
}
}
if (cl.hasOption('u')) {
String url = cl.getOptionValue('u').trim();
ripURL(url, cl.hasOption(""n""));
}
}"
1755,"private static void loadHistory() {
File historyFile = new File(""history.json"");
HISTORY.clear();
if (historyFile.exists()) {
try {
logger.info(""Loading history from history.json"");
HISTORY.fromFile(""history.json"");
} catch (IOException e) {
logger.error(""Failed to load history from file "" + historyFile, e);
System.out.println(
""RipMe failed to load the history file at "" + historyFile.getAbsolutePath() + ""\n\n"" +
""Error: "" + e.getMessage() + ""\n\n"" +
""Closing RipMe will automatically overwrite the contents of this file,\n"" +
""so you may want to back the file up before closing RipMe!"");
}
} else {
logger.info(""Loading history from configuration"");
HISTORY.fromList(Utils.getConfigList(""download.history""));
if (HISTORY.toList().size() == 0) {
//comment
//comment
String[] dirs = Utils.getWorkingDirectory().list(new FilenameFilter() {
@Override
public boolean accept(File dir, String file) {
return new File(dir.getAbsolutePath() + File.separator + file).isDirectory();
}
});
for (String dir : dirs) {
String url = RipUtils.urlFromDirectoryName(dir);
if (url != null) {
//comment
HistoryEntry entry = new HistoryEntry();
entry.url = url;
HISTORY.add(entry);
}
}
}
}
}","private static void loadHistory() {
File historyFile = new File(""history.json"");
HISTORY.clear();
if (historyFile.exists()) {
try {
logger.info(""Loading history from history.json"");
HISTORY.fromFile(""history.json"");
} catch (IOException e) {
logger.error(""Failed to load history from file "" + historyFile, e);
System.out.println(
""RipMe failed to load the history file at "" + historyFile.getAbsolutePath() + ""\n\n"" +
""Error: "" + e.getMessage() + ""\n\n"" +
""Closing RipMe will automatically overwrite the contents of this file,\n"" +
""so you may want to back the file up before closing RipMe!"");
}
} else {
logger.info(""Loading history from configuration"");
<start>HISTORY.fromList(Utils.getConfigList(""download.history""));
if (HISTORY.toList().size() == 0) {<end>
//comment
//comment
String[] dirs = Utils.getWorkingDirectory().list(new FilenameFilter() {
@Override
public boolean accept(File dir, String file) {
return new File(dir.getAbsolutePath() + File.separator + file).isDirectory();
}
});
for (String dir : dirs) {
String url = RipUtils.urlFromDirectoryName(dir);
if (url != null) {
//comment
HistoryEntry entry = new HistoryEntry();
entry.url = url;
HISTORY.add(entry);
}
}
}
}
}"
1756,"private static void loadHistory() {
File historyFile = new File(""history.json"");
HISTORY.clear();
if (historyFile.exists()) {
try {
logger.info(""Loading history from history.json"");
HISTORY.fromFile(""history.json"");
} catch (IOException e) {
logger.error(""Failed to load history from file "" + historyFile, e);
System.out.println(
""RipMe failed to load the history file at "" + historyFile.getAbsolutePath() + ""\n\n"" +
""Error: "" + e.getMessage() + ""\n\n"" +
""Closing RipMe will automatically overwrite the contents of this file,\n"" +
""so you may want to back the file up before closing RipMe!"");
}
} else {
logger.info(""Loading history from configuration"");
HISTORY.fromList(Utils.getConfigList(""download.history""));
if (HISTORY.toList().size() == 0) {
//comment
//comment
String[] dirs = Utils.getWorkingDirectory().list(new FilenameFilter() {
@Override
public boolean accept(File dir, String file) {
return new File(dir.getAbsolutePath() + File.separator + file).isDirectory();
}
});
for (String dir : dirs) {
String url = RipUtils.urlFromDirectoryName(dir);
if (url != null) {
//comment
HistoryEntry entry = new HistoryEntry();
entry.url = url;
HISTORY.add(entry);
}
}
}
}
}","private static void loadHistory() {
File historyFile = new File(""history.json"");
HISTORY.clear();
if (historyFile.exists()) {
try {
logger.info(""Loading history from history.json"");
HISTORY.fromFile(""history.json"");
} catch (IOException e) {
logger.error(""Failed to load history from file "" + historyFile, e);
System.out.println(
""RipMe failed to load the history file at "" + historyFile.getAbsolutePath() + ""\n\n"" +
""Error: "" + e.getMessage() + ""\n\n"" +
""Closing RipMe will automatically overwrite the contents of this file,\n"" +
""so you may want to back the file up before closing RipMe!"");
}
} else {
logger.info(""Loading history from configuration"");
HISTORY.fromList(Utils.getConfigList(""download.history""));
if (HISTORY.toList().size() == 0) {
//comment
//comment
<start>String[] dirs = Utils.getWorkingDirectory().list(new FilenameFilter() {
@Override
public boolean accept(File dir, String file) {
return new File(dir.getAbsolutePath() + File.separator + file).isDirectory();
}
});
for (String dir : dirs) {
String url = RipUtils.urlFromDirectoryName(dir);
if (url != null) {
//comment
HistoryEntry entry = new HistoryEntry();
entry.url = url;
HISTORY.add(entry);
}
}<end>
}
}
}"
1757,"private static void loadHistory() {
File historyFile = new File(""history.json"");
HISTORY.clear();
if (historyFile.exists()) {
try {
logger.info(""Loading history from history.json"");
HISTORY.fromFile(""history.json"");
} catch (IOException e) {
logger.error(""Failed to load history from file "" + historyFile, e);
System.out.println(
""RipMe failed to load the history file at "" + historyFile.getAbsolutePath() + ""\n\n"" +
""Error: "" + e.getMessage() + ""\n\n"" +
""Closing RipMe will automatically overwrite the contents of this file,\n"" +
""so you may want to back the file up before closing RipMe!"");
}
} else {
logger.info(""Loading history from configuration"");
HISTORY.fromList(Utils.getConfigList(""download.history""));
if (HISTORY.toList().size() == 0) {
//comment
//comment
String[] dirs = Utils.getWorkingDirectory().list(new FilenameFilter() {
@Override
public boolean accept(File dir, String file) {
return new File(dir.getAbsolutePath() + File.separator + file).isDirectory();
}
});
for (String dir : dirs) {
String url = RipUtils.urlFromDirectoryName(dir);
if (url != null) {
//comment
HistoryEntry entry = new HistoryEntry();
entry.url = url;
<start>HISTORY.add(entry);<end>
}
}
}
}
}","private static void loadHistory() {
File historyFile = new File(""history.json"");
HISTORY.clear();
if (historyFile.exists()) {
try {
logger.info(""Loading history from history.json"");
HISTORY.fromFile(""history.json"");
} catch (IOException e) {
logger.error(""Failed to load history from file "" + historyFile, e);
System.out.println(
""RipMe failed to load the history file at "" + historyFile.getAbsolutePath() + ""\n\n"" +
""Error: "" + e.getMessage() + ""\n\n"" +
""Closing RipMe will automatically overwrite the contents of this file,\n"" +
""so you may want to back the file up before closing RipMe!"");
}
} else {
logger.info(""Loading history from configuration"");
HISTORY.fromList(Utils.getConfigList(""download.history""));
if (HISTORY.toList().size() == 0) {
//comment
//comment
String[] dirs = Utils.getWorkingDirectory().list(new FilenameFilter() {
@Override
public boolean accept(File dir, String file) {
return new File(dir.getAbsolutePath() + File.separator + file).isDirectory();
}
});
for (String dir : dirs) {
String url = RipUtils.urlFromDirectoryName(dir);
<start>if (url != null) {
//comment
HistoryEntry entry = new HistoryEntry();
entry.url = url;
HISTORY.add(entry);
}<end>
}
}
}
}"
22,"public void cleanup() {
if (this.workingDir.list().length == 0) {
//comment
<start>logger.info(""Deleting empty directory "" + this.workingDir);
boolean deleteResult = this.workingDir.delete();<end>
if (!deleteResult) {
<start>logger.error(""Unable to delete empty directory "" +  this.workingDir);<end>
}
}
}","public void cleanup() {
if (this.workingDir.list().length == 0) {
//comment
<start>logger.info(""Deleting empty directory "" + this.workingDir);
boolean deleteResult = this.workingDir.delete();<end>
if (!deleteResult) {
logger.error(""Unable to delete empty directory "" +  this.workingDir);
}
}
}"
7680,"    @Override
public void downloadURL(URL url, int index) {
//comment
addURLToDownload(url, getPrefix(index), """", this.url.toExternalForm(), null);
}","    @Override
public void downloadURL(URL url, int index) {
//comment
<start>addURLToDownload(url, getPrefix(index), """", this.url.toExternalForm(), null);<end>
}"
7681,"@Override
public String getAlbumTitle(URL url) throws MalformedURLException {
try {
//comment
<start>String title = getFirstPage().title();
Pattern p = Pattern.compile(""^Porn pics of (.*) \\(Page 1\\)$"");<end>
Matcher m = p.matcher(title);
if (m.matches()) {
<start>return getHost() + ""_"" + m.group(1);<end>
}
} catch (IOException e) {
//comment
}
return super.getAlbumTitle(url);
}","@Override
public String getAlbumTitle(URL url) throws MalformedURLException {
try {
//comment
<start>String title = getFirstPage().title();
Pattern p = Pattern.compile(""^Porn pics of (.*) \\(Page 1\\)$"");
Matcher m = p.matcher(title);
if (m.matches()) {
return getHost() + ""_"" + m.group(1);
}<end>
} catch (IOException e) {
//comment
}
return super.getAlbumTitle(url);
}"
2920,"@Override
public String getAlbumTitle(URL url) throws MalformedURLException {
try {
//comment
<start>if (albumDoc == null) {
albumDoc = Http.url(url).get();
}<end>
String title = albumDoc.select(""h2"").first().text().trim();
return ""nfsfw_"" + Utils.filesystemSafe(title);
} catch (Exception e) {
//comment
}
return super.getAlbumTitle(url);
}","@Override
public String getAlbumTitle(URL url) throws MalformedURLException {
try {
//comment
<start>if (albumDoc == null) {
albumDoc = Http.url(url).get();
}<end>
String title = albumDoc.select(""h2"").first().text().trim();
return ""nfsfw_"" + Utils.filesystemSafe(title);
} catch (Exception e) {
//comment
}
return super.getAlbumTitle(url);
}"
2921,"@Override
public void rip() throws IOException {
List<Pair> subAlbums = new ArrayList<Pair>();
int index = 0;
subAlbums.add(new Pair(this.url.toExternalForm(), """"));
while (subAlbums.size() > 0) {
if (isStopped()) {
break;
}
Pair nextAlbum = subAlbums.remove(0);
String nextURL = nextAlbum.first;
String nextSubalbum = nextAlbum.second;
sendUpdate(STATUS.LOADING_RESOURCE, nextURL);
logger.info(""    Retrieving "" + nextURL);
if (albumDoc == null) {
albumDoc = Http.url(nextURL).get();
}
//comment
for (Element suba : albumDoc.select(""td.IMG > a"")) {
if (isStopped() || isThisATest()) {
break;
}
String subURL = ""http://nfsfw.com"" + suba.attr(""href"");
String subdir = subURL;
while (subdir.endsWith(""/"")) {
subdir = subdir.substring(0, subdir.length() - 1);
}
subdir = subdir.substring(subdir.lastIndexOf(""/"") + 1);
subAlbums.add(new Pair(subURL, subdir));
}
//comment
for (Element thumb : albumDoc.select(""td.giItemCell > div > a"")) {
if (isStopped()) {
break;
}
String imagePage = ""http://nfsfw.com"" + thumb.attr(""href"");
try {
NfsfwImageThread t = new NfsfwImageThread(new URL(imagePage), nextSubalbum, ++index);
nfsfwThreadPool.addThread(t);
if (isThisATest()) {
break;
}
} catch (MalformedURLException mue) {
logger.warn(""Invalid URL: "" + imagePage);
}
}
if (isThisATest()) {
break;
}
//comment
for (Element a : albumDoc.select(""a.next"")) {
subAlbums.add(0, new Pair(""http://nfsfw.com"" + a.attr(""href""), """"));
<start>break;<end>
}
//comment
albumDoc = null;
//comment
try {
Thread.sleep(1000);
} catch (InterruptedException e) {
logger.error(""Interrupted while waiting to load next page"", e);
throw new IOException(e);
}
}
nfsfwThreadPool.waitForThreads();
<start>waitForThreads();<end>
}","@Override
public void rip() throws IOException {
List<Pair> subAlbums = new ArrayList<Pair>();
int index = 0;
subAlbums.add(new Pair(this.url.toExternalForm(), """"));
while (subAlbums.size() > 0) {
if (isStopped()) {
break;
}
Pair nextAlbum = subAlbums.remove(0);
String nextURL = nextAlbum.first;
String nextSubalbum = nextAlbum.second;
sendUpdate(STATUS.LOADING_RESOURCE, nextURL);
logger.info(""    Retrieving "" + nextURL);
if (albumDoc == null) {
albumDoc = Http.url(nextURL).get();
}
//comment
for (Element suba : albumDoc.select(""td.IMG > a"")) {
if (isStopped() || isThisATest()) {
break;
}
String subURL = ""http://nfsfw.com"" + suba.attr(""href"");
String subdir = subURL;
while (subdir.endsWith(""/"")) {
subdir = subdir.substring(0, subdir.length() - 1);
}
subdir = subdir.substring(subdir.lastIndexOf(""/"") + 1);
subAlbums.add(new Pair(subURL, subdir));
}
//comment
for (Element thumb : albumDoc.select(""td.giItemCell > div > a"")) {
if (isStopped()) {
break;
}
String imagePage = ""http://nfsfw.com"" + thumb.attr(""href"");
try {
NfsfwImageThread t = new NfsfwImageThread(new URL(imagePage), nextSubalbum, ++index);
nfsfwThreadPool.addThread(t);
if (isThisATest()) {
break;
}
} catch (MalformedURLException mue) {
logger.warn(""Invalid URL: "" + imagePage);
}
}
if (isThisATest()) {
break;
}
//comment
<start>for (Element a : albumDoc.select(""a.next"")) {
subAlbums.add(0, new Pair(""http://nfsfw.com"" + a.attr(""href""), """"));
break;
}<end>
//comment
albumDoc = null;
//comment
try {
Thread.sleep(1000);
} catch (InterruptedException e) {
logger.error(""Interrupted while waiting to load next page"", e);
throw new IOException(e);
}
}
nfsfwThreadPool.waitForThreads();
waitForThreads();
}"
7682,"private void loadHistory() {
File historyFile = new File(""history.json"");
HISTORY.clear();
if (historyFile.exists()) {
try {
logger.info(""Loading history from history.json"");
HISTORY.fromFile(""history.json"");
} catch (IOException e) {
logger.error(""Failed to load history from file "" + historyFile, e);
JOptionPane.showMessageDialog(null,
""RipMe failed to load the history file at "" + historyFile.getAbsolutePath() + ""\n\n"" +
""Error: "" + e.getMessage() + ""\n\n"" +
""Closing RipMe will automatically overwrite the contents of this file,\n"" +
""so you may want to back the file up before closing RipMe!"",
""RipMe - history load failure"",
JOptionPane.ERROR_MESSAGE);
}
}
else {
logger.info(""Loading history from configuration"");
HISTORY.fromList(Utils.getConfigList(""download.history""));
if (HISTORY.toList().size() == 0) {
//comment
//comment
String[] dirs = Utils.getWorkingDirectory().list(new FilenameFilter() {
@Override
public boolean accept(File dir, String file) {
return new File(dir.getAbsolutePath() + File.separator + file).isDirectory();
}
});
for (String dir : dirs) {
String url = RipUtils.urlFromDirectoryName(dir);
if (url != null) {
//comment
HistoryEntry entry = new HistoryEntry();
entry.url = url;
HISTORY.add(entry);
}
}
}
}
}","private void loadHistory() {
File historyFile = new File(""history.json"");
HISTORY.clear();
if (historyFile.exists()) {
try {
logger.info(""Loading history from history.json"");
HISTORY.fromFile(""history.json"");
} catch (IOException e) {
logger.error(""Failed to load history from file "" + historyFile, e);
JOptionPane.showMessageDialog(null,
""RipMe failed to load the history file at "" + historyFile.getAbsolutePath() + ""\n\n"" +
""Error: "" + e.getMessage() + ""\n\n"" +
""Closing RipMe will automatically overwrite the contents of this file,\n"" +
""so you may want to back the file up before closing RipMe!"",
""RipMe - history load failure"",
JOptionPane.ERROR_MESSAGE);
}
}
else {
logger.info(""Loading history from configuration"");
HISTORY.fromList(Utils.getConfigList(""download.history""));
if (HISTORY.toList().size() == 0) {
//comment
//comment
<start>String[] dirs = Utils.getWorkingDirectory().list(new FilenameFilter() {
@Override
public boolean accept(File dir, String file) {
return new File(dir.getAbsolutePath() + File.separator + file).isDirectory();
}
});
for (String dir : dirs) {
String url = RipUtils.urlFromDirectoryName(dir);
if (url != null) {
//comment
HistoryEntry entry = new HistoryEntry();
entry.url = url;
HISTORY.add(entry);
}
}<end>
}
}
}"
7683,"private void loadHistory() {
File historyFile = new File(""history.json"");
HISTORY.clear();
if (historyFile.exists()) {
try {
logger.info(""Loading history from history.json"");
HISTORY.fromFile(""history.json"");
} catch (IOException e) {
logger.error(""Failed to load history from file "" + historyFile, e);
JOptionPane.showMessageDialog(null,
""RipMe failed to load the history file at "" + historyFile.getAbsolutePath() + ""\n\n"" +
""Error: "" + e.getMessage() + ""\n\n"" +
""Closing RipMe will automatically overwrite the contents of this file,\n"" +
""so you may want to back the file up before closing RipMe!"",
""RipMe - history load failure"",
JOptionPane.ERROR_MESSAGE);
}
}
else {
logger.info(""Loading history from configuration"");
HISTORY.fromList(Utils.getConfigList(""download.history""));
if (HISTORY.toList().size() == 0) {
//comment
//comment
String[] dirs = Utils.getWorkingDirectory().list(new FilenameFilter() {
@Override
public boolean accept(File dir, String file) {
return new File(dir.getAbsolutePath() + File.separator + file).isDirectory();
}
});
for (String dir : dirs) {
String url = RipUtils.urlFromDirectoryName(dir);
if (url != null) {
//comment
HistoryEntry entry = new HistoryEntry();
entry.url = url;
<start>HISTORY.add(entry);<end>
}
}
}
}
}","private void loadHistory() {
File historyFile = new File(""history.json"");
HISTORY.clear();
if (historyFile.exists()) {
try {
logger.info(""Loading history from history.json"");
HISTORY.fromFile(""history.json"");
} catch (IOException e) {
logger.error(""Failed to load history from file "" + historyFile, e);
JOptionPane.showMessageDialog(null,
""RipMe failed to load the history file at "" + historyFile.getAbsolutePath() + ""\n\n"" +
""Error: "" + e.getMessage() + ""\n\n"" +
""Closing RipMe will automatically overwrite the contents of this file,\n"" +
""so you may want to back the file up before closing RipMe!"",
""RipMe - history load failure"",
JOptionPane.ERROR_MESSAGE);
}
}
else {
logger.info(""Loading history from configuration"");
HISTORY.fromList(Utils.getConfigList(""download.history""));
if (HISTORY.toList().size() == 0) {
//comment
//comment
String[] dirs = Utils.getWorkingDirectory().list(new FilenameFilter() {
@Override
public boolean accept(File dir, String file) {
return new File(dir.getAbsolutePath() + File.separator + file).isDirectory();
}
});
for (String dir : dirs) {
String url = RipUtils.urlFromDirectoryName(dir);
<start>if (url != null) {
//comment
HistoryEntry entry = new HistoryEntry();
entry.url = url;
HISTORY.add(entry);
}<end>
}
}
}
}"
7684,"@SuppressWarnings(""unchecked"")
private void ripNextAlbum() {
isRipping = true;
//comment
<start>Utils.setConfigList(""queue"", (Enumeration<Object>) queueListModel.elements());<end>

if (queueListModel.isEmpty()) {
//comment
isRipping = false;
return;
}
String nextAlbum = (String) queueListModel.remove(0);
if (queueListModel.isEmpty()) {
optionQueue.setText(""Queue"");
}
else {
optionQueue.setText(""Queue ("" + queueListModel.size() + "")"");
}
Thread t = ripAlbum(nextAlbum);
if (t == null) {
try {
Thread.sleep(500);
} catch (InterruptedException ie) {
logger.error(""Interrupted while waiting to rip next album"", ie);
}
ripNextAlbum();
}
else {
t.start();
}
}","@SuppressWarnings(""unchecked"")
private void ripNextAlbum() {
isRipping = true;
//comment
<start>Utils.setConfigList(""queue"", (Enumeration<Object>) queueListModel.elements());<end>

if (queueListModel.isEmpty()) {
//comment
isRipping = false;
return;
}
String nextAlbum = (String) queueListModel.remove(0);
if (queueListModel.isEmpty()) {
optionQueue.setText(""Queue"");
}
else {
optionQueue.setText(""Queue ("" + queueListModel.size() + "")"");
}
Thread t = ripAlbum(nextAlbum);
if (t == null) {
try {
Thread.sleep(500);
} catch (InterruptedException ie) {
logger.error(""Interrupted while waiting to rip next album"", ie);
}
ripNextAlbum();
}
else {
t.start();
}
}"
516,"@Override
public void rip() throws IOException {
int index = 0;
int textindex = 0;
logger.info(""Retrieving "" + this.url);
sendUpdate(STATUS.LOADING_RESOURCE, this.url.toExternalForm());
Document doc = getFirstPage();

while (doc != null) {
<start>List<String> imageURLs = getURLsFromPage(doc);<end>
//comment
if (isThisATest()) {
<start>while (imageURLs.size() > 1) {
imageURLs.remove(1);
}<end>
}

if (imageURLs.size() == 0) {
throw new IOException(""No images found at "" + doc.location());
}

for (String imageURL : imageURLs) {
index += 1;
logger.debug(""Found image url #"" + index + "": "" + imageURL);
downloadURL(new URL(imageURL), index);
if (isStopped()) {
break;
}
}
if (hasDescriptionSupport() && Utils.getConfigBoolean(""descriptions.save"", false)) {
logger.debug(""Fetching description(s) from "" + doc.location());
List<String> textURLs = getDescriptionsFromPage(doc);
if (textURLs.size() > 0) {
logger.debug(""Found description link(s) from "" + doc.location());
for (String textURL : textURLs) {
if (isStopped()) {
break;
}
textindex += 1;
logger.debug(""Getting description from "" + textURL);
String[] tempDesc = getDescription(textURL,doc);
if (tempDesc != null) {
if (Utils.getConfigBoolean(""file.overwrite"", false) || !(new File(
workingDir.getCanonicalPath()
+ """"
+ File.separator
+ getPrefix(index)
+ (tempDesc.length > 1 ? tempDesc[1] : fileNameFromURL(new URL(textURL)))
+ "".txt"").exists())) {
logger.debug(""Got description from "" + textURL);
saveText(new URL(textURL), """", tempDesc[0], textindex, (tempDesc.length > 1 ? tempDesc[1] : fileNameFromURL(new URL(textURL))));
sleep(descSleepTime());
} else {
logger.debug(""Description from "" + textURL + "" already exists."");
}
}

}
}
}

if (isStopped() || isThisATest()) {
break;
}

try {
sendUpdate(STATUS.LOADING_RESOURCE, ""next page"");
doc = getNextPage(doc);
} catch (IOException e) {
logger.info(""Can't get next page: "" + e.getMessage());
break;
}
}

//comment
if (getThreadPool() != null) {
logger.debug(""Waiting for threadpool "" + getThreadPool().getClass().getName());
getThreadPool().waitForThreads();
}
waitForThreads();
}","@Override
public void rip() throws IOException {
int index = 0;
int textindex = 0;
logger.info(""Retrieving "" + this.url);
sendUpdate(STATUS.LOADING_RESOURCE, this.url.toExternalForm());
Document doc = getFirstPage();

while (doc != null) {
List<String> imageURLs = getURLsFromPage(doc);
//comment
if (isThisATest()) {
<start>while (imageURLs.size() > 1) {
imageURLs.remove(1);
}<end>
}

if (imageURLs.size() == 0) {
throw new IOException(""No images found at "" + doc.location());
}

for (String imageURL : imageURLs) {
index += 1;
logger.debug(""Found image url #"" + index + "": "" + imageURL);
downloadURL(new URL(imageURL), index);
if (isStopped()) {
break;
}
}
if (hasDescriptionSupport() && Utils.getConfigBoolean(""descriptions.save"", false)) {
logger.debug(""Fetching description(s) from "" + doc.location());
List<String> textURLs = getDescriptionsFromPage(doc);
if (textURLs.size() > 0) {
logger.debug(""Found description link(s) from "" + doc.location());
for (String textURL : textURLs) {
if (isStopped()) {
break;
}
textindex += 1;
logger.debug(""Getting description from "" + textURL);
String[] tempDesc = getDescription(textURL,doc);
if (tempDesc != null) {
if (Utils.getConfigBoolean(""file.overwrite"", false) || !(new File(
workingDir.getCanonicalPath()
+ """"
+ File.separator
+ getPrefix(index)
+ (tempDesc.length > 1 ? tempDesc[1] : fileNameFromURL(new URL(textURL)))
+ "".txt"").exists())) {
logger.debug(""Got description from "" + textURL);
saveText(new URL(textURL), """", tempDesc[0], textindex, (tempDesc.length > 1 ? tempDesc[1] : fileNameFromURL(new URL(textURL))));
sleep(descSleepTime());
} else {
logger.debug(""Description from "" + textURL + "" already exists."");
}
}

}
}
}

if (isStopped() || isThisATest()) {
break;
}

try {
sendUpdate(STATUS.LOADING_RESOURCE, ""next page"");
doc = getNextPage(doc);
} catch (IOException e) {
logger.info(""Can't get next page: "" + e.getMessage());
break;
}
}

//comment
if (getThreadPool() != null) {
logger.debug(""Waiting for threadpool "" + getThreadPool().getClass().getName());
getThreadPool().waitForThreads();
}
waitForThreads();
}"
517,"@Override
public void rip() throws IOException {
int index = 0;
int textindex = 0;
logger.info(""Retrieving "" + this.url);
sendUpdate(STATUS.LOADING_RESOURCE, this.url.toExternalForm());
Document doc = getFirstPage();

while (doc != null) {
List<String> imageURLs = getURLsFromPage(doc);
//comment
if (isThisATest()) {
while (imageURLs.size() > 1) {
imageURLs.remove(1);
}
}

if (imageURLs.size() == 0) {
throw new IOException(""No images found at "" + doc.location());
}

for (String imageURL : imageURLs) {
index += 1;
logger.debug(""Found image url #"" + index + "": "" + imageURL);
downloadURL(new URL(imageURL), index);
if (isStopped()) {
break;
}
}
if (hasDescriptionSupport() && Utils.getConfigBoolean(""descriptions.save"", false)) {
logger.debug(""Fetching description(s) from "" + doc.location());
List<String> textURLs = getDescriptionsFromPage(doc);
if (textURLs.size() > 0) {
logger.debug(""Found description link(s) from "" + doc.location());
for (String textURL : textURLs) {
if (isStopped()) {
break;
}
textindex += 1;
logger.debug(""Getting description from "" + textURL);
String[] tempDesc = getDescription(textURL,doc);
if (tempDesc != null) {
if (Utils.getConfigBoolean(""file.overwrite"", false) || !(new File(
workingDir.getCanonicalPath()
+ """"
+ File.separator
+ getPrefix(index)
+ (tempDesc.length > 1 ? tempDesc[1] : fileNameFromURL(new URL(textURL)))
+ "".txt"").exists())) {
logger.debug(""Got description from "" + textURL);
saveText(new URL(textURL), """", tempDesc[0], textindex, (tempDesc.length > 1 ? tempDesc[1] : fileNameFromURL(new URL(textURL))));
sleep(descSleepTime());
} else {
logger.debug(""Description from "" + textURL + "" already exists."");
}
}

}
}
}

if (isStopped() || isThisATest()) {
break;
}

try {
sendUpdate(STATUS.LOADING_RESOURCE, ""next page"");
doc = getNextPage(doc);
} catch (IOException e) {
logger.info(""Can't get next page: "" + e.getMessage());
break;
}
}

//comment
if (getThreadPool() != null) {
<start>logger.debug(""Waiting for threadpool "" + getThreadPool().getClass().getName());<end>
getThreadPool().waitForThreads();
}
<start>waitForThreads();<end>
}","@Override
public void rip() throws IOException {
int index = 0;
int textindex = 0;
logger.info(""Retrieving "" + this.url);
sendUpdate(STATUS.LOADING_RESOURCE, this.url.toExternalForm());
Document doc = getFirstPage();

while (doc != null) {
List<String> imageURLs = getURLsFromPage(doc);
//comment
if (isThisATest()) {
while (imageURLs.size() > 1) {
imageURLs.remove(1);
}
}

if (imageURLs.size() == 0) {
throw new IOException(""No images found at "" + doc.location());
}

for (String imageURL : imageURLs) {
index += 1;
logger.debug(""Found image url #"" + index + "": "" + imageURL);
downloadURL(new URL(imageURL), index);
if (isStopped()) {
break;
}
}
if (hasDescriptionSupport() && Utils.getConfigBoolean(""descriptions.save"", false)) {
logger.debug(""Fetching description(s) from "" + doc.location());
List<String> textURLs = getDescriptionsFromPage(doc);
if (textURLs.size() > 0) {
logger.debug(""Found description link(s) from "" + doc.location());
for (String textURL : textURLs) {
if (isStopped()) {
break;
}
textindex += 1;
logger.debug(""Getting description from "" + textURL);
String[] tempDesc = getDescription(textURL,doc);
if (tempDesc != null) {
if (Utils.getConfigBoolean(""file.overwrite"", false) || !(new File(
workingDir.getCanonicalPath()
+ """"
+ File.separator
+ getPrefix(index)
+ (tempDesc.length > 1 ? tempDesc[1] : fileNameFromURL(new URL(textURL)))
+ "".txt"").exists())) {
logger.debug(""Got description from "" + textURL);
saveText(new URL(textURL), """", tempDesc[0], textindex, (tempDesc.length > 1 ? tempDesc[1] : fileNameFromURL(new URL(textURL))));
sleep(descSleepTime());
} else {
logger.debug(""Description from "" + textURL + "" already exists."");
}
}

}
}
}

if (isStopped() || isThisATest()) {
break;
}

try {
sendUpdate(STATUS.LOADING_RESOURCE, ""next page"");
doc = getNextPage(doc);
} catch (IOException e) {
logger.info(""Can't get next page: "" + e.getMessage());
break;
}
}

//comment
<start>if (getThreadPool() != null) {<end>
logger.debug(""Waiting for threadpool "" + getThreadPool().getClass().getName());
<start>getThreadPool().waitForThreads();<end>
}
waitForThreads();
}"
518,"    public boolean saveText(URL url, String subdirectory, String text, int index, String fileName) {
//comment
try {
stopCheck();
} catch (IOException e) {
return false;
}
File saveFileAs;
try {
if (!subdirectory.equals("""")) {
subdirectory = File.separator + subdirectory;
}
//comment
saveFileAs = new File(
workingDir.getCanonicalPath()
+ subdirectory
+ File.separator
+ getPrefix(index)
+ fileName
+ "".txt"");
//comment
<start>FileOutputStream out = (new FileOutputStream(saveFileAs));<end>
out.write(text.getBytes());
out.close();
} catch (IOException e) {
logger.error(""[!] Error creating save file path for description '"" + url + ""':"", e);
return false;
}
<start>logger.debug(""Downloading "" + url + ""'s description to "" + saveFileAs);<end>
if (!saveFileAs.getParentFile().exists()) {
logger.info(""[+] Creating directory: "" + Utils.removeCWD(saveFileAs.getParent()));
saveFileAs.getParentFile().mkdirs();
}
return true;
}","    public boolean saveText(URL url, String subdirectory, String text, int index, String fileName) {
//comment
try {
stopCheck();
} catch (IOException e) {
return false;
}
File saveFileAs;
try {
if (!subdirectory.equals("""")) {
subdirectory = File.separator + subdirectory;
}
//comment
saveFileAs = new File(
workingDir.getCanonicalPath()
+ subdirectory
+ File.separator
+ getPrefix(index)
+ fileName
+ "".txt"");
//comment
<start>FileOutputStream out = (new FileOutputStream(saveFileAs));
out.write(text.getBytes());
out.close();<end>
} catch (IOException e) {
logger.error(""[!] Error creating save file path for description '"" + url + ""':"", e);
return false;
}
logger.debug(""Downloading "" + url + ""'s description to "" + saveFileAs);
if (!saveFileAs.getParentFile().exists()) {
logger.info(""[+] Creating directory: "" + Utils.removeCWD(saveFileAs.getParent()));
saveFileAs.getParentFile().mkdirs();
}
return true;
}"
457,"    public String getAlbumTitle(URL url) throws MalformedURLException {
try {
//comment
Document doc = getFirstPage();
<start>Elements elems = doc.select("".albumName"");<end>
return getHost() + ""_"" + elems.first().text();
} catch (Exception e) {
//comment
logger.warn(""Failed to get album title from "" + url, e);
}
return super.getAlbumTitle(url);
}","    public String getAlbumTitle(URL url) throws MalformedURLException {
<start>try {
//comment
Document doc = getFirstPage();
Elements elems = doc.select("".albumName"");
return getHost() + ""_"" + elems.first().text();
} catch (Exception e) {
//comment
logger.warn(""Failed to get album title from "" + url, e);
}<end>
return super.getAlbumTitle(url);
}"
458,"    @Override
public void downloadURL(URL url, int index) {
//comment
addURLToDownload(url, getPrefix(index), """", this.url.toExternalForm(), null);
}","    @Override
public void downloadURL(URL url, int index) {
//comment
<start>addURLToDownload(url, getPrefix(index), """", this.url.toExternalForm(), null);<end>
}"
1143,"public String getOperationResult(Token token, int precision)
{
//comment
if (hasInput())
{
decodeTransactionInput(token.getWallet());
String value = transactionInput.getOperationValue(token, this);
boolean isSendOrReceive = !from.equalsIgnoreCase(to) && transactionInput.isSendOrReceive(this);
String prefix = (value.length() == 0 || (value.startsWith(""#"") || !isSendOrReceive)) ? """" :
(token.getIsSent(this) ? ""- "" : ""+ "");
return prefix + value;
}
else
{
return token.getTransactionValue(this, precision);
}
}","public String getOperationResult(Token token, int precision)
{
//comment
if (hasInput())
{
decodeTransactionInput(token.getWallet());
<start>String value = transactionInput.getOperationValue(token, this);
boolean isSendOrReceive = !from.equalsIgnoreCase(to) && transactionInput.isSendOrReceive(this);
String prefix = (value.length() == 0 || (value.startsWith(""#"") || !isSendOrReceive)) ? """" :
(token.getIsSent(this) ? ""- "" : ""+ "");
return prefix + value;<end>
}
else
{
return token.getTransactionValue(this, precision);
}
}"
1466,"private String sanitiseString(String str)
{
StringBuilder sb = new StringBuilder();
for (char ch : str.toCharArray())
{
if (Character.isAlphabetic(ch) || Character.isDigit(ch) || Character.isIdeographic(ch) || ch < 65530)
{
sb.append(ch);
}
else
{
sb.append(""*"");
}
}

str = sb.toString();

//comment
if (str.toLowerCase().contains(""<a href=""))
{
<start>return str;<end>
}
else
{
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N)
{
return Html.fromHtml(str, FROM_HTML_MODE_COMPACT).toString();
}
else
{
//comment
return Html.fromHtml(str).toString();
}
}
}","private String sanitiseString(String str)
{
StringBuilder sb = new StringBuilder();
for (char ch : str.toCharArray())
{
if (Character.isAlphabetic(ch) || Character.isDigit(ch) || Character.isIdeographic(ch) || ch < 65530)
{
sb.append(ch);
}
else
{
sb.append(""*"");
}
}

str = sb.toString();

//comment
<start>if (str.toLowerCase().contains(""<a href=""))
{
return str;
}<end>
else
{
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N)
{
return Html.fromHtml(str, FROM_HTML_MODE_COMPACT).toString();
}
else
{
//comment
return Html.fromHtml(str).toString();
}
}
}"
1467,"public int getContractType()
{
switch (contractType)
{
case ERC20:
return R.string.erc20;
case ETHEREUM:
return 0;
default:
return 0;
}
}","public int getContractType()
{
<start>switch (contractType)
{<end>
case ERC20:
return R.string.erc20;
<start>case ETHEREUM:
return 0;<end>
default:
return 0;
<start>}<end>
}"
1468,"    public boolean checkRealmBalanceChange(RealmToken realmToken)
{
if (contractType == null || contractType.ordinal() != realmToken.getInterfaceSpec()) return true;
String currentState = realmToken.getBalance();
if (currentState == null) return true;
if (tokenInfo.name != null && realmToken.getName() == null) return true;
if (tokenInfo.name == null && realmToken.getName() != null) return true;
<start>if (tokenInfo.symbol == null && realmToken.getSymbol() != null) return true;<end>
if (tokenInfo.name != null && realmToken.getName() != null) return true;
if (tokenInfo.symbol != null && realmToken.getSymbol() == null) return true;
if (tokenInfo.name != null && (!tokenInfo.name.equals(realmToken.getName()) || !tokenInfo.symbol.equals(realmToken.getSymbol()))) return true;
String currentBalance = getFullBalance();
return !currentState.equals(currentBalance);
}","    public boolean checkRealmBalanceChange(RealmToken realmToken)
{
if (contractType == null || contractType.ordinal() != realmToken.getInterfaceSpec()) return true;
String currentState = realmToken.getBalance();
if (currentState == null) return true;
<start>if (tokenInfo.name != null && realmToken.getName() == null) return true;<end>
if (tokenInfo.name == null && realmToken.getName() != null) return true;
if (tokenInfo.symbol == null && realmToken.getSymbol() != null) return true;
if (tokenInfo.name != null && realmToken.getName() != null) return true;
if (tokenInfo.symbol != null && realmToken.getSymbol() == null) return true;
if (tokenInfo.name != null && (!tokenInfo.name.equals(realmToken.getName()) || !tokenInfo.symbol.equals(realmToken.getSymbol()))) return true;
String currentBalance = getFullBalance();
return !currentState.equals(currentBalance);
}"
1469,"    public String getTokenName(AssetDefinitionService assetService, int count)
{
//comment
if (assetService.hasDefinition(tokenInfo.chainId, tokenInfo.address))
{
if (tokenInfo.name != null) return tokenInfo.name;
else return assetService.getAssetDefinition(tokenInfo.chainId, getAddress()).getTokenName(count);
}
else
{
return tokenInfo.name;
}
}","    public String getTokenName(AssetDefinitionService assetService, int count)
{
//comment
<start>if (assetService.hasDefinition(tokenInfo.chainId, tokenInfo.address))
{
if (tokenInfo.name != null) return tokenInfo.name;
else return assetService.getAssetDefinition(tokenInfo.chainId, getAddress()).getTokenName(count);
}
else
{
return tokenInfo.name;
}<end>
}"
1470,"<start>public NFTAsset fetchTokenMetadata(BigInteger tokenId)<end>
{
//comment
<start>String responseValue = callSmartContractFunction(tokenInfo.chainId, getTokenURI(tokenId), getAddress(), getWallet());
if (responseValue == null) responseValue = callSmartContractFunction(tokenInfo.chainId, getTokenURI2(tokenId), getAddress(), getWallet());<end>
String metaData = loadMetaData(responseValue);
if (!TextUtils.isEmpty(metaData))
{
return new NFTAsset(metaData);
}
else
{
return new NFTAsset();
}
}","public NFTAsset fetchTokenMetadata(BigInteger tokenId)
{
//comment
<start>String responseValue = callSmartContractFunction(tokenInfo.chainId, getTokenURI(tokenId), getAddress(), getWallet());<end>
if (responseValue == null) responseValue = callSmartContractFunction(tokenInfo.chainId, getTokenURI2(tokenId), getAddress(), getWallet());
String metaData = loadMetaData(responseValue);
if (!TextUtils.isEmpty(metaData))
{
return new NFTAsset(metaData);
}
else
{
return new NFTAsset();
}
}"
7708,"@Override
public Single<Token[]> checkInterface(Token[] tokens, Wallet wallet)
{
return Single.fromCallable(() -> {
//comment
for (int i = 0; i < tokens.length; i++)
{
Token t = tokens[i];
if (t.getInterfaceSpec() == ContractType.ERC721_UNDETERMINED || t.getInterfaceSpec() == ContractType.MAYBE_ERC20 || !t.checkBalanceType())
{
ContractType type = determineCommonType(t.tokenInfo).blockingGet();
TokenInfo tInfo = t.tokenInfo;
//comment
switch (type)
{
case OTHER:
if (t.getInterfaceSpec() == ContractType.MAYBE_ERC20)
{
type = ContractType.ERC20;
break;
}
//comment
continue;
case ERC20:
if (t.getInterfaceSpec() != ContractType.MAYBE_ERC20)
{
type = ContractType.ERC721;
}
break;
case ERC1155:
break;
case ERC721:
case ERC721_LEGACY:
Map<BigInteger, NFTAsset> NFTBalance = t.getTokenAssets();
t.balance = checkUint256Balance(wallet, tInfo.chainId, tInfo.address);
if (TextUtils.isEmpty(tInfo.name + tInfo.symbol)) tInfo = new TokenInfo(tInfo.address, "" "", "" "", tInfo.decimals, tInfo.isEnabled, tInfo.chainId);
t = new ERC721Token(tInfo, NFTBalance, t.balance, System.currentTimeMillis(), t.getNetworkName(), type);
t.lastTxTime = tokens[i].lastTxTime;
tokens[i] = t;
break;
case ERC721_TICKET:
List<BigInteger> balanceFromOpenSea = t.getArrayBalance();
t = new ERC721Ticket(t.tokenInfo, balanceFromOpenSea, System.currentTimeMillis(), t.getNetworkName(), ContractType.ERC721_TICKET);
tokens[i] = t;
break;
default:
type = ContractType.ERC721;
}

//comment
updateTokenType(t, wallet, type);
TokensService.setInterfaceSpec(t.tokenInfo.chainId, t.tokenInfo.address, type);
}
}

return tokens;
}).flatMap(this::checkTokenData);
}","@Override
public Single<Token[]> checkInterface(Token[] tokens, Wallet wallet)
{
return Single.fromCallable(() -> {
//comment
for (int i = 0; i < tokens.length; i++)
{
Token t = tokens[i];
if (t.getInterfaceSpec() == ContractType.ERC721_UNDETERMINED || t.getInterfaceSpec() == ContractType.MAYBE_ERC20 || !t.checkBalanceType())
{
ContractType type = determineCommonType(t.tokenInfo).blockingGet();
TokenInfo tInfo = t.tokenInfo;
//comment
switch (type)
{
case OTHER:
if (t.getInterfaceSpec() == ContractType.MAYBE_ERC20)
{
type = ContractType.ERC20;
break;
}
//comment
continue;
case ERC20:
if (t.getInterfaceSpec() != ContractType.MAYBE_ERC20)
{
type = ContractType.ERC721;
}
break;
case ERC1155:
break;
case ERC721:
case ERC721_LEGACY:
Map<BigInteger, NFTAsset> NFTBalance = t.getTokenAssets();
t.balance = checkUint256Balance(wallet, tInfo.chainId, tInfo.address);
if (TextUtils.isEmpty(tInfo.name + tInfo.symbol)) tInfo = new TokenInfo(tInfo.address, "" "", "" "", tInfo.decimals, tInfo.isEnabled, tInfo.chainId);
t = new ERC721Token(tInfo, NFTBalance, t.balance, System.currentTimeMillis(), t.getNetworkName(), type);
t.lastTxTime = tokens[i].lastTxTime;
tokens[i] = t;
break;
case ERC721_TICKET:
List<BigInteger> balanceFromOpenSea = t.getArrayBalance();
t = new ERC721Ticket(t.tokenInfo, balanceFromOpenSea, System.currentTimeMillis(), t.getNetworkName(), ContractType.ERC721_TICKET);
tokens[i] = t;
break;
default:
type = ContractType.ERC721;
}

//comment
<start>updateTokenType(t, wallet, type);
TokensService.setInterfaceSpec(t.tokenInfo.chainId, t.tokenInfo.address, type);<end>
}
}

return tokens;
}).flatMap(this::checkTokenData);
}"
7709,"@Override
public Single<Token[]> checkInterface(Token[] tokens, Wallet wallet)
{
return Single.fromCallable(() -> {
//comment
for (int i = 0; i < tokens.length; i++)
{
Token t = tokens[i];
if (t.getInterfaceSpec() == ContractType.ERC721_UNDETERMINED || t.getInterfaceSpec() == ContractType.MAYBE_ERC20 || !t.checkBalanceType())
{
ContractType type = determineCommonType(t.tokenInfo).blockingGet();
TokenInfo tInfo = t.tokenInfo;
//comment
switch (type)
{
case OTHER:
if (t.getInterfaceSpec() == ContractType.MAYBE_ERC20)
{
type = ContractType.ERC20;
break;
}
//comment
continue;
case ERC20:
if (t.getInterfaceSpec() != ContractType.MAYBE_ERC20)
{
type = ContractType.ERC721;
}
break;
case ERC1155:
break;
case ERC721:
case ERC721_LEGACY:
<start>Map<BigInteger, NFTAsset> NFTBalance = t.getTokenAssets();<end>
t.balance = checkUint256Balance(wallet, tInfo.chainId, tInfo.address);
if (TextUtils.isEmpty(tInfo.name + tInfo.symbol)) tInfo = new TokenInfo(tInfo.address, "" "", "" "", tInfo.decimals, tInfo.isEnabled, tInfo.chainId);
t = new ERC721Token(tInfo, NFTBalance, t.balance, System.currentTimeMillis(), t.getNetworkName(), type);
t.lastTxTime = tokens[i].lastTxTime;
tokens[i] = t;
break;
case ERC721_TICKET:
List<BigInteger> balanceFromOpenSea = t.getArrayBalance();
t = new ERC721Ticket(t.tokenInfo, balanceFromOpenSea, System.currentTimeMillis(), t.getNetworkName(), ContractType.ERC721_TICKET);
tokens[i] = t;
break;
default:
type = ContractType.ERC721;
}

//comment
updateTokenType(t, wallet, type);
TokensService.setInterfaceSpec(t.tokenInfo.chainId, t.tokenInfo.address, type);
}
}

return tokens;
}).flatMap(this::checkTokenData);
}","@Override
public Single<Token[]> checkInterface(Token[] tokens, Wallet wallet)
{
return Single.fromCallable(() -> {
//comment
for (int i = 0; i < tokens.length; i++)
{
Token t = tokens[i];
if (t.getInterfaceSpec() == ContractType.ERC721_UNDETERMINED || t.getInterfaceSpec() == ContractType.MAYBE_ERC20 || !t.checkBalanceType())
{
ContractType type = determineCommonType(t.tokenInfo).blockingGet();
TokenInfo tInfo = t.tokenInfo;
//comment
switch (type)
{
case OTHER:
if (t.getInterfaceSpec() == ContractType.MAYBE_ERC20)
{
type = ContractType.ERC20;
break;
}
//comment
continue;
case ERC20:
if (t.getInterfaceSpec() != ContractType.MAYBE_ERC20)
{
type = ContractType.ERC721;
}
break;
case ERC1155:
break;
case ERC721:
case ERC721_LEGACY:
<start>Map<BigInteger, NFTAsset> NFTBalance = t.getTokenAssets();<end>
t.balance = checkUint256Balance(wallet, tInfo.chainId, tInfo.address);
if (TextUtils.isEmpty(tInfo.name + tInfo.symbol)) tInfo = new TokenInfo(tInfo.address, "" "", "" "", tInfo.decimals, tInfo.isEnabled, tInfo.chainId);
t = new ERC721Token(tInfo, NFTBalance, t.balance, System.currentTimeMillis(), t.getNetworkName(), type);
t.lastTxTime = tokens[i].lastTxTime;
tokens[i] = t;
break;
case ERC721_TICKET:
List<BigInteger> balanceFromOpenSea = t.getArrayBalance();
t = new ERC721Ticket(t.tokenInfo, balanceFromOpenSea, System.currentTimeMillis(), t.getNetworkName(), ContractType.ERC721_TICKET);
tokens[i] = t;
break;
default:
type = ContractType.ERC721;
}

//comment
updateTokenType(t, wallet, type);
TokensService.setInterfaceSpec(t.tokenInfo.chainId, t.tokenInfo.address, type);
}
}

return tokens;
}).flatMap(this::checkTokenData);
}"
7710,"@Override
public Single<Token[]> checkInterface(Token[] tokens, Wallet wallet)
{
return Single.fromCallable(() -> {
//comment
for (int i = 0; i < tokens.length; i++)
{
Token t = tokens[i];
if (t.getInterfaceSpec() == ContractType.ERC721_UNDETERMINED || t.getInterfaceSpec() == ContractType.MAYBE_ERC20 || !t.checkBalanceType())
{
ContractType type = determineCommonType(t.tokenInfo).blockingGet();
TokenInfo tInfo = t.tokenInfo;
//comment
switch (type)
{
case OTHER:
if (t.getInterfaceSpec() == ContractType.MAYBE_ERC20)
{
type = ContractType.ERC20;
break;
}
//comment
continue;
case ERC20:
if (t.getInterfaceSpec() != ContractType.MAYBE_ERC20)
{
type = ContractType.ERC721;
}
break;
case ERC1155:
break;
case ERC721:
case ERC721_LEGACY:
<start>Map<BigInteger, NFTAsset> NFTBalance = t.getTokenAssets();<end>
t.balance = checkUint256Balance(wallet, tInfo.chainId, tInfo.address);
<start>if (TextUtils.isEmpty(tInfo.name + tInfo.symbol)) tInfo = new TokenInfo(tInfo.address, "" "", "" "", tInfo.decimals, tInfo.isEnabled, tInfo.chainId);<end>
t = new ERC721Token(tInfo, NFTBalance, t.balance, System.currentTimeMillis(), t.getNetworkName(), type);
t.lastTxTime = tokens[i].lastTxTime;
tokens[i] = t;
break;
case ERC721_TICKET:
List<BigInteger> balanceFromOpenSea = t.getArrayBalance();
t = new ERC721Ticket(t.tokenInfo, balanceFromOpenSea, System.currentTimeMillis(), t.getNetworkName(), ContractType.ERC721_TICKET);
tokens[i] = t;
break;
default:
type = ContractType.ERC721;
}

//comment
updateTokenType(t, wallet, type);
TokensService.setInterfaceSpec(t.tokenInfo.chainId, t.tokenInfo.address, type);
}
}

return tokens;
}).flatMap(this::checkTokenData);
}","@Override
public Single<Token[]> checkInterface(Token[] tokens, Wallet wallet)
{
return Single.fromCallable(() -> {
//comment
for (int i = 0; i < tokens.length; i++)
{
Token t = tokens[i];
if (t.getInterfaceSpec() == ContractType.ERC721_UNDETERMINED || t.getInterfaceSpec() == ContractType.MAYBE_ERC20 || !t.checkBalanceType())
{
ContractType type = determineCommonType(t.tokenInfo).blockingGet();
TokenInfo tInfo = t.tokenInfo;
//comment
switch (type)
{
case OTHER:
if (t.getInterfaceSpec() == ContractType.MAYBE_ERC20)
{
type = ContractType.ERC20;
break;
}
//comment
continue;
case ERC20:
if (t.getInterfaceSpec() != ContractType.MAYBE_ERC20)
{
type = ContractType.ERC721;
}
break;
case ERC1155:
break;
case ERC721:
case ERC721_LEGACY:
Map<BigInteger, NFTAsset> NFTBalance = t.getTokenAssets();
<start>t.balance = checkUint256Balance(wallet, tInfo.chainId, tInfo.address);<end>
if (TextUtils.isEmpty(tInfo.name + tInfo.symbol)) tInfo = new TokenInfo(tInfo.address, "" "", "" "", tInfo.decimals, tInfo.isEnabled, tInfo.chainId);
t = new ERC721Token(tInfo, NFTBalance, t.balance, System.currentTimeMillis(), t.getNetworkName(), type);
t.lastTxTime = tokens[i].lastTxTime;
tokens[i] = t;
break;
case ERC721_TICKET:
List<BigInteger> balanceFromOpenSea = t.getArrayBalance();
t = new ERC721Ticket(t.tokenInfo, balanceFromOpenSea, System.currentTimeMillis(), t.getNetworkName(), ContractType.ERC721_TICKET);
tokens[i] = t;
break;
default:
type = ContractType.ERC721;
}

//comment
updateTokenType(t, wallet, type);
TokensService.setInterfaceSpec(t.tokenInfo.chainId, t.tokenInfo.address, type);
}
}

return tokens;
}).flatMap(this::checkTokenData);
}"
7711,"    @Override
public TokenCardMeta[] fetchTokenMetasForUpdate(Wallet wallet, List<Long> networkFilters)
{
<start>if (networkFilters == null) networkFilters = Collections.emptyList();
return localSource.fetchTokenMetasForUpdate(wallet, networkFilters);<end>
}","    @Override
public TokenCardMeta[] fetchTokenMetasForUpdate(Wallet wallet, List<Long> networkFilters)
{
<start>if (networkFilters == null) networkFilters = Collections.emptyList();<end>
return localSource.fetchTokenMetasForUpdate(wallet, networkFilters);
}"
7712,"    @Override
public Single<TokenCardMeta[]> fetchTokenMetas(Wallet wallet, List<Long> networkFilters,
AssetDefinitionService svs)
{
<start>if (networkFilters == null) networkFilters = Collections.emptyList();
return localSource
.fetchTokenMetas(wallet, networkFilters, svs);<end>
}","    @Override
public Single<TokenCardMeta[]> fetchTokenMetas(Wallet wallet, List<Long> networkFilters,
AssetDefinitionService svs)
{
<start>if (networkFilters == null) networkFilters = Collections.emptyList();<end>
return localSource
.fetchTokenMetas(wallet, networkFilters, svs);
}"
7713,"    @Override
public Single<TokenCardMeta[]> fetchAllTokenMetas(Wallet wallet, List<Long> networkFilters, String searchTerm) {
<start>if (networkFilters == null) networkFilters = Collections.emptyList();
return localSource
.fetchAllTokenMetas(wallet, networkFilters, searchTerm);<end>
}","    @Override
public Single<TokenCardMeta[]> fetchAllTokenMetas(Wallet wallet, List<Long> networkFilters, String searchTerm) {
<start>if (networkFilters == null) networkFilters = Collections.emptyList();<end>
return localSource
.fetchAllTokenMetas(wallet, networkFilters, searchTerm);
}"
7714,"    @Override
public Single<Token[]> fetchTokensThatMayNeedUpdating(String walletAddress, List<Long> networkFilters) {
<start>if (networkFilters == null) networkFilters = Collections.emptyList();
return localSource
.fetchAllTokensWithNameIssue(walletAddress, networkFilters);<end>
}","    @Override
public Single<Token[]> fetchTokensThatMayNeedUpdating(String walletAddress, List<Long> networkFilters) {
<start>if (networkFilters == null) networkFilters = Collections.emptyList();<end>
return localSource
.fetchAllTokensWithNameIssue(walletAddress, networkFilters);
}"
7715,"    @Override
public Single<ContractAddress[]> fetchAllTokensWithBlankName(String walletAddress, List<Long> networkFilters) {
<start>if (networkFilters == null) networkFilters = Collections.emptyList();
return localSource
.fetchAllTokensWithBlankName(walletAddress, networkFilters);<end>
}","    @Override
public Single<ContractAddress[]> fetchAllTokensWithBlankName(String walletAddress, List<Long> networkFilters) {
<start>if (networkFilters == null) networkFilters = Collections.emptyList();<end>
return localSource
.fetchAllTokensWithBlankName(walletAddress, networkFilters);
}"
7716,"private Single<BigDecimal> updateBalance(final Wallet wallet, final Token token)
{
return Single.fromCallable(() -> {
BigDecimal balance = BigDecimal.valueOf(-1);
try
{
List<BigInteger> balanceArray = null;

switch (token.getInterfaceSpec())
{
case ETHEREUM:
balance = getEthBalance(wallet, token.tokenInfo.chainId);
break;
case ERC875:
case ERC875_LEGACY:
balanceArray = getBalanceArray875(wallet, token.tokenInfo.chainId, token.getAddress());
balance = BigDecimal.valueOf(balanceArray.size());
break;
case ERC721_LEGACY:
case ERC721:
case ERC20:
case DYNAMIC_CONTRACT:
//comment
balance = checkUint256Balance(wallet, token.tokenInfo.chainId, token.getAddress());
break;
case MAYBE_ERC20:
balance = wrappedCheckUint256Balance(wallet, token.tokenInfo, token);
break;
case ERC1155:
balance = token.updateBalance(getRealmInstance(wallet));
break;
case ERC721_TICKET:
balanceArray = getBalanceArray721Ticket(wallet, token.tokenInfo.chainId, token.getAddress());
balance = BigDecimal.valueOf(balanceArray.size());
break;
case NOT_SET:
case OTHER:
//comment
break;
default:
break;
}

if (!balance.equals(BigDecimal.valueOf(-1)) || balanceArray != null)
{
localSource.updateTokenBalance(wallet, token, balance, balanceArray);
}
else
{
balance = token.balance;
}
}
catch (Exception e)
{
if (LOG_CONTRACT_EXCEPTION_EVENTS) e.printStackTrace();
}

return balance;
});
}","private Single<BigDecimal> updateBalance(final Wallet wallet, final Token token)
{
return Single.fromCallable(() -> {
BigDecimal balance = BigDecimal.valueOf(-1);
try
{
List<BigInteger> balanceArray = null;

switch (token.getInterfaceSpec())
{
case ETHEREUM:
balance = getEthBalance(wallet, token.tokenInfo.chainId);
break;
case ERC875:
case ERC875_LEGACY:
balanceArray = getBalanceArray875(wallet, token.tokenInfo.chainId, token.getAddress());
balance = BigDecimal.valueOf(balanceArray.size());
break;
case ERC721_LEGACY:
case ERC721:
case ERC20:
case DYNAMIC_CONTRACT:
//comment
<start>balance = checkUint256Balance(wallet, token.tokenInfo.chainId, token.getAddress());<end>
break;
case MAYBE_ERC20:
balance = wrappedCheckUint256Balance(wallet, token.tokenInfo, token);
break;
case ERC1155:
balance = token.updateBalance(getRealmInstance(wallet));
break;
case ERC721_TICKET:
balanceArray = getBalanceArray721Ticket(wallet, token.tokenInfo.chainId, token.getAddress());
balance = BigDecimal.valueOf(balanceArray.size());
break;
case NOT_SET:
case OTHER:
//comment
break;
default:
break;
}

if (!balance.equals(BigDecimal.valueOf(-1)) || balanceArray != null)
{
localSource.updateTokenBalance(wallet, token, balance, balanceArray);
}
else
{
balance = token.balance;
}
}
catch (Exception e)
{
if (LOG_CONTRACT_EXCEPTION_EVENTS) e.printStackTrace();
}

return balance;
});
}"
7717,"private Single<Token[]> updateBalances(Wallet wallet, Token[] tokens)
{
return Single.fromCallable(() -> {
for (Token t : tokens)
{
//comment
<start>if (t.isERC721() || t.isERC20()) t.balance = checkUint256Balance(wallet, t.tokenInfo.chainId, t.getAddress());<end>
}
<start>return tokens;<end>
});
}","private Single<Token[]> updateBalances(Wallet wallet, Token[] tokens)
{
return Single.fromCallable(() -> {
for (Token t : tokens)
{
//comment
<start>if (t.isERC721() || t.isERC20()) t.balance = checkUint256Balance(wallet, t.tokenInfo.chainId, t.getAddress());<end>
}
return tokens;
});
}"
7718,"private BigDecimal wrappedCheckUint256Balance(@NonNull Wallet wallet, @NonNull TokenInfo tokenInfo, @Nullable Token token)
{
BigDecimal balance = BigDecimal.ZERO;
try
{
Function function = balanceOf(wallet.address);
NetworkInfo network = ethereumNetworkRepository.getNetworkByChain(tokenInfo.chainId);
String responseValue = callSmartContractFunction(function, tokenInfo.address, network, wallet);

if (token != null && TextUtils.isEmpty(responseValue))
{
balance = token.balance;
}
else
{
List<Type> response = FunctionReturnDecoder.decode(responseValue, function.getOutputParameters());
if (response.size() > 0) balance = new BigDecimal(((Uint256) response.get(0)).getValue());

//comment
if (token != null && tokenInfo.decimals == 18 && balance.compareTo(BigDecimal.ZERO) > 0 && balance.compareTo(BigDecimal.valueOf(10)) < 0)
{
//comment
List<BigInteger> testBalance = getBalanceArray721Ticket(wallet, tokenInfo);
if (testBalance != null && testBalance.size() > 0)
{
//comment
addToken(wallet, tokenInfo, ContractType.ERC721_TICKET)
.subscribe(this::updateInService).isDisposed();
balance = token.balance;
}
}
else if (token != null && balance.equals(BigDecimal.valueOf(32)) && responseValue.length() > 66)
{
//comment
determineCommonType(tokenInfo)
.flatMap(tType -> addToken(wallet, tokenInfo, tType))
.subscribe(this::updateInService).isDisposed();
balance = token.balance;
}
}
}
catch (Exception e)
{
//comment
if (token != null) balance = token.balance;
}

return balance;
}","private BigDecimal wrappedCheckUint256Balance(@NonNull Wallet wallet, @NonNull TokenInfo tokenInfo, @Nullable Token token)
{
BigDecimal balance = BigDecimal.ZERO;
try
{
Function function = balanceOf(wallet.address);
NetworkInfo network = ethereumNetworkRepository.getNetworkByChain(tokenInfo.chainId);
String responseValue = callSmartContractFunction(function, tokenInfo.address, network, wallet);

if (token != null && TextUtils.isEmpty(responseValue))
{
balance = token.balance;
}
else
{
List<Type> response = FunctionReturnDecoder.decode(responseValue, function.getOutputParameters());
if (response.size() > 0) balance = new BigDecimal(((Uint256) response.get(0)).getValue());

//comment
<start>if (token != null && tokenInfo.decimals == 18 && balance.compareTo(BigDecimal.ZERO) > 0 && balance.compareTo(BigDecimal.valueOf(10)) < 0)<end>
{
//comment
List<BigInteger> testBalance = getBalanceArray721Ticket(wallet, tokenInfo);
if (testBalance != null && testBalance.size() > 0)
{
//comment
addToken(wallet, tokenInfo, ContractType.ERC721_TICKET)
.subscribe(this::updateInService).isDisposed();
balance = token.balance;
}
}
else if (token != null && balance.equals(BigDecimal.valueOf(32)) && responseValue.length() > 66)
{
//comment
determineCommonType(tokenInfo)
.flatMap(tType -> addToken(wallet, tokenInfo, tType))
.subscribe(this::updateInService).isDisposed();
balance = token.balance;
}
}
}
catch (Exception e)
{
//comment
if (token != null) balance = token.balance;
}

return balance;
}"
7719,"private BigDecimal wrappedCheckUint256Balance(@NonNull Wallet wallet, @NonNull TokenInfo tokenInfo, @Nullable Token token)
{
BigDecimal balance = BigDecimal.ZERO;
try
{
Function function = balanceOf(wallet.address);
NetworkInfo network = ethereumNetworkRepository.getNetworkByChain(tokenInfo.chainId);
String responseValue = callSmartContractFunction(function, tokenInfo.address, network, wallet);

if (token != null && TextUtils.isEmpty(responseValue))
{
balance = token.balance;
}
else
{
List<Type> response = FunctionReturnDecoder.decode(responseValue, function.getOutputParameters());
if (response.size() > 0) balance = new BigDecimal(((Uint256) response.get(0)).getValue());

//comment
if (token != null && tokenInfo.decimals == 18 && balance.compareTo(BigDecimal.ZERO) > 0 && balance.compareTo(BigDecimal.valueOf(10)) < 0)
{
//comment
List<BigInteger> testBalance = getBalanceArray721Ticket(wallet, tokenInfo);
if (testBalance != null && testBalance.size() > 0)
{
//comment
addToken(wallet, tokenInfo, ContractType.ERC721_TICKET)
.subscribe(this::updateInService).isDisposed();
balance = token.balance;
}
}
else if (token != null && balance.equals(BigDecimal.valueOf(32)) && responseValue.length() > 66)
{
//comment
determineCommonType(tokenInfo)
<start>.flatMap(tType -> addToken(wallet, tokenInfo, tType))
.subscribe(this::updateInService).isDisposed();<end>
balance = token.balance;
}
}
}
catch (Exception e)
{
//comment
if (token != null) balance = token.balance;
}

return balance;
}","private BigDecimal wrappedCheckUint256Balance(@NonNull Wallet wallet, @NonNull TokenInfo tokenInfo, @Nullable Token token)
{
BigDecimal balance = BigDecimal.ZERO;
try
{
Function function = balanceOf(wallet.address);
NetworkInfo network = ethereumNetworkRepository.getNetworkByChain(tokenInfo.chainId);
String responseValue = callSmartContractFunction(function, tokenInfo.address, network, wallet);

if (token != null && TextUtils.isEmpty(responseValue))
{
balance = token.balance;
}
else
{
List<Type> response = FunctionReturnDecoder.decode(responseValue, function.getOutputParameters());
if (response.size() > 0) balance = new BigDecimal(((Uint256) response.get(0)).getValue());

//comment
if (token != null && tokenInfo.decimals == 18 && balance.compareTo(BigDecimal.ZERO) > 0 && balance.compareTo(BigDecimal.valueOf(10)) < 0)
{
//comment
List<BigInteger> testBalance = getBalanceArray721Ticket(wallet, tokenInfo);
if (testBalance != null && testBalance.size() > 0)
{
//comment
addToken(wallet, tokenInfo, ContractType.ERC721_TICKET)
.subscribe(this::updateInService).isDisposed();
balance = token.balance;
}
}
else if (token != null && balance.equals(BigDecimal.valueOf(32)) && responseValue.length() > 66)
{
//comment
<start>determineCommonType(tokenInfo)
.flatMap(tType -> addToken(wallet, tokenInfo, tType))<end>
.subscribe(this::updateInService).isDisposed();
balance = token.balance;
}
}
}
catch (Exception e)
{
//comment
if (token != null) balance = token.balance;
}

return balance;
}"
737,"public Single<Wallet[]> populateWalletData(Wallet[] wallets, KeyService keyService)
{
return Single.fromCallable(() -> {
List<Wallet> walletList;
try (Realm realm = realmManager.getWalletDataRealmInstance())
{
walletList = loadOrCreateKeyRealmDB(wallets);
//comment
for (Wallet wallet : walletList)
{
RealmWalletData data = realm.where(RealmWalletData.class)
.equalTo(""address"", wallet.address, Case.INSENSITIVE)
.findFirst();

composeWallet(wallet, data);
}

List<Wallet> oldWalletList = loadOrCreateKeyRealmDB(wallets);
if (keyService.detectWalletIssues(walletList))
{
//comment
<start>for (Wallet w : walletList) storeKeyData(w);<end>

for (Wallet o : oldWalletList)
{
boolean found = false;
for (Wallet w : walletList)
{
if (w.address.equalsIgnoreCase(o.address))
{
found = true;
break;
}
}

if (!found)
{
//comment
Wallet gone = deleteWallet(o).subscribeOn(Schedulers.io()).blockingGet();
System.out.println(""DELETED WALLET: "" + gone.address);
}
}
}

//comment
realm.executeTransaction(r -> {
RealmResults<RealmWalletData> items = r.where(RealmWalletData.class).findAll();
for (RealmWalletData rwd : items)
{
boolean found = false;
for (Wallet w : walletList)
{
if (rwd.getAddress().equalsIgnoreCase(w.address))
{
found = true;
break;
}
}

if (!found)
{
//comment
rwd.deleteFromRealm();
}
}
});
}

if (BuildConfig.DEBUG) Log.d(""RealmDebug"", ""populate "" + walletList.size());
return walletList.toArray(new Wallet[0]);
});
}","public Single<Wallet[]> populateWalletData(Wallet[] wallets, KeyService keyService)
{
return Single.fromCallable(() -> {
List<Wallet> walletList;
try (Realm realm = realmManager.getWalletDataRealmInstance())
{
walletList = loadOrCreateKeyRealmDB(wallets);
//comment
for (Wallet wallet : walletList)
{
RealmWalletData data = realm.where(RealmWalletData.class)
.equalTo(""address"", wallet.address, Case.INSENSITIVE)
.findFirst();

composeWallet(wallet, data);
}

List<Wallet> oldWalletList = loadOrCreateKeyRealmDB(wallets);
if (keyService.detectWalletIssues(walletList))
{
//comment
<start>for (Wallet w : walletList) storeKeyData(w);<end>

for (Wallet o : oldWalletList)
{
boolean found = false;
for (Wallet w : walletList)
{
if (w.address.equalsIgnoreCase(o.address))
{
found = true;
break;
}
}

if (!found)
{
//comment
Wallet gone = deleteWallet(o).subscribeOn(Schedulers.io()).blockingGet();
System.out.println(""DELETED WALLET: "" + gone.address);
}
}
}

//comment
realm.executeTransaction(r -> {
RealmResults<RealmWalletData> items = r.where(RealmWalletData.class).findAll();
for (RealmWalletData rwd : items)
{
boolean found = false;
for (Wallet w : walletList)
{
if (rwd.getAddress().equalsIgnoreCase(w.address))
{
found = true;
break;
}
}

if (!found)
{
//comment
rwd.deleteFromRealm();
}
}
});
}

if (BuildConfig.DEBUG) Log.d(""RealmDebug"", ""populate "" + walletList.size());
return walletList.toArray(new Wallet[0]);
});
}"
738,"public Single<Wallet[]> populateWalletData(Wallet[] wallets, KeyService keyService)
{
return Single.fromCallable(() -> {
List<Wallet> walletList;
try (Realm realm = realmManager.getWalletDataRealmInstance())
{
walletList = loadOrCreateKeyRealmDB(wallets);
//comment
for (Wallet wallet : walletList)
{
RealmWalletData data = realm.where(RealmWalletData.class)
.equalTo(""address"", wallet.address, Case.INSENSITIVE)
.findFirst();

composeWallet(wallet, data);
}

List<Wallet> oldWalletList = loadOrCreateKeyRealmDB(wallets);
if (keyService.detectWalletIssues(walletList))
{
//comment
for (Wallet w : walletList) storeKeyData(w);

for (Wallet o : oldWalletList)
{
boolean found = false;
for (Wallet w : walletList)
{
if (w.address.equalsIgnoreCase(o.address))
{
found = true;
break;
}
}

if (!found)
{
//comment
<start>Wallet gone = deleteWallet(o).subscribeOn(Schedulers.io()).blockingGet();<end>
System.out.println(""DELETED WALLET: "" + gone.address);
}
}
}

//comment
realm.executeTransaction(r -> {
RealmResults<RealmWalletData> items = r.where(RealmWalletData.class).findAll();
for (RealmWalletData rwd : items)
{
boolean found = false;
for (Wallet w : walletList)
{
if (rwd.getAddress().equalsIgnoreCase(w.address))
{
found = true;
break;
}
}

if (!found)
{
//comment
rwd.deleteFromRealm();
}
}
});
}

if (BuildConfig.DEBUG) Log.d(""RealmDebug"", ""populate "" + walletList.size());
return walletList.toArray(new Wallet[0]);
});
}","public Single<Wallet[]> populateWalletData(Wallet[] wallets, KeyService keyService)
{
return Single.fromCallable(() -> {
List<Wallet> walletList;
try (Realm realm = realmManager.getWalletDataRealmInstance())
{
walletList = loadOrCreateKeyRealmDB(wallets);
//comment
for (Wallet wallet : walletList)
{
RealmWalletData data = realm.where(RealmWalletData.class)
.equalTo(""address"", wallet.address, Case.INSENSITIVE)
.findFirst();

composeWallet(wallet, data);
}

List<Wallet> oldWalletList = loadOrCreateKeyRealmDB(wallets);
if (keyService.detectWalletIssues(walletList))
{
//comment
for (Wallet w : walletList) storeKeyData(w);

for (Wallet o : oldWalletList)
{
boolean found = false;
for (Wallet w : walletList)
{
if (w.address.equalsIgnoreCase(o.address))
{
found = true;
break;
}
}

if (!found)
{
//comment
Wallet gone = deleteWallet(o).subscribeOn(Schedulers.io()).blockingGet();
System.out.println(""DELETED WALLET: "" + gone.address);
}
}
}

//comment
realm.executeTransaction(r -> {
RealmResults<RealmWalletData> items = r.where(RealmWalletData.class).findAll();
for (RealmWalletData rwd : items)
{
boolean found = false;
for (Wallet w : walletList)
{
if (rwd.getAddress().equalsIgnoreCase(w.address))
{
found = true;
break;
}
}

if (!found)
{
//comment
<start>rwd.deleteFromRealm();<end>
}
}
});
}

if (BuildConfig.DEBUG) Log.d(""RealmDebug"", ""populate "" + walletList.size());
return walletList.toArray(new Wallet[0]);
});
}"
739,"private List<Wallet> loadOrCreateKeyRealmDB(Wallet[] wallets)
{
List<Wallet> walletList = new ArrayList<>();
List<String> keyStoreList = walletArrayToAddressList(wallets);

try (Realm realmType = realmManager.getWalletTypeRealmInstance())
{
realmType.refresh();
RealmResults<RealmKeyType> realmKeyTypes = realmType.where(RealmKeyType.class)
.sort(""dateAdded"", Sort.ASCENDING)
.findAll();

if (realmKeyTypes.size() > 0)
{
//comment
for (RealmKeyType walletTypeData : realmKeyTypes)
{
Wallet w = composeKeyType(walletTypeData);
if (w == null || (w.type == WalletType.KEYSTORE || w.type == WalletType.KEYSTORE_LEGACY) &&
!keyStoreList.contains(walletTypeData.getAddress().toLowerCase()))
{
continue;
}

walletList.add(w);
}
}
else
{
realmType.executeTransaction(r -> {
for (Wallet wallet : wallets)
{
RealmKeyType realmKey = r.createObject(RealmKeyType.class, wallet.address);
wallet.authLevel = KeyService.AuthenticationLevel.TEE_NO_AUTHENTICATION;
wallet.type = WalletType.KEYSTORE_LEGACY;
realmKey.setType(wallet.type);
realmKey.setLastBackup(System.currentTimeMillis());
realmKey.setDateAdded(wallet.walletCreationTime);
realmKey.setAuthLevel(wallet.authLevel);
walletList.add(wallet);
}
});
}
}

if (BuildConfig.DEBUG) Log.d(""RealmDebug"", ""loadorcreate "" + walletList.size());
return walletList;
}","private List<Wallet> loadOrCreateKeyRealmDB(Wallet[] wallets)
{
List<Wallet> walletList = new ArrayList<>();
List<String> keyStoreList = walletArrayToAddressList(wallets);

try (Realm realmType = realmManager.getWalletTypeRealmInstance())
{
realmType.refresh();
RealmResults<RealmKeyType> realmKeyTypes = realmType.where(RealmKeyType.class)
.sort(""dateAdded"", Sort.ASCENDING)
.findAll();

if (realmKeyTypes.size() > 0)
{
//comment
<start>for (RealmKeyType walletTypeData : realmKeyTypes)
{
Wallet w = composeKeyType(walletTypeData);
if (w == null || (w.type == WalletType.KEYSTORE || w.type == WalletType.KEYSTORE_LEGACY) &&
!keyStoreList.contains(walletTypeData.getAddress().toLowerCase()))
{
continue;
}

walletList.add(w);
}<end>
}
else
{
realmType.executeTransaction(r -> {
for (Wallet wallet : wallets)
{
RealmKeyType realmKey = r.createObject(RealmKeyType.class, wallet.address);
wallet.authLevel = KeyService.AuthenticationLevel.TEE_NO_AUTHENTICATION;
wallet.type = WalletType.KEYSTORE_LEGACY;
realmKey.setType(wallet.type);
realmKey.setLastBackup(System.currentTimeMillis());
realmKey.setDateAdded(wallet.walletCreationTime);
realmKey.setAuthLevel(wallet.authLevel);
walletList.add(wallet);
}
});
}
}

if (BuildConfig.DEBUG) Log.d(""RealmDebug"", ""loadorcreate "" + walletList.size());
return walletList;
}"
577,"private void finishAndLaunchSend()
{
//comment
if (currentResult.getFunction().length() > 0)
{
//comment
<start>Token token = viewModel.getToken(currentResult.chainId, currentResult.getAddress());<end>
if (token == null)
{
showProgress(true);
//comment
viewModel.fetchToken(currentResult.chainId, currentResult.getAddress());
}
else
{
viewModel.showSend(this, currentResult, token);
finish();
}
}
else
{
//comment
viewModel.showSend(this, currentResult, viewModel.getToken(currentResult.chainId, viewModel.wallet().getValue().address));
finish();
}
}","private void finishAndLaunchSend()
{
//comment
if (currentResult.getFunction().length() > 0)
{
//comment
<start>Token token = viewModel.getToken(currentResult.chainId, currentResult.getAddress());
if (token == null)<end>
{
showProgress(true);
//comment
viewModel.fetchToken(currentResult.chainId, currentResult.getAddress());
}
else
{
viewModel.showSend(this, currentResult, token);
finish();
}
}
else
{
//comment
viewModel.showSend(this, currentResult, viewModel.getToken(currentResult.chainId, viewModel.wallet().getValue().address));
finish();
}
}"
578,"private void finishAndLaunchSend()
{
//comment
if (currentResult.getFunction().length() > 0)
{
//comment
<start>Token token = viewModel.getToken(currentResult.chainId, currentResult.getAddress());<end>
if (token == null)
{
<start>showProgress(true);<end>
//comment
viewModel.fetchToken(currentResult.chainId, currentResult.getAddress());
}
else
{
viewModel.showSend(this, currentResult, token);
finish();
}
}
else
{
//comment
viewModel.showSend(this, currentResult, viewModel.getToken(currentResult.chainId, viewModel.wallet().getValue().address));
finish();
}
}","private void finishAndLaunchSend()
{
//comment
if (currentResult.getFunction().length() > 0)
{
//comment
<start>Token token = viewModel.getToken(currentResult.chainId, currentResult.getAddress());<end>
if (token == null)
{
showProgress(true);
//comment
<start>viewModel.fetchToken(currentResult.chainId, currentResult.getAddress());<end>
}
else
{
viewModel.showSend(this, currentResult, token);
finish();
}
}
else
{
//comment
viewModel.showSend(this, currentResult, viewModel.getToken(currentResult.chainId, viewModel.wallet().getValue().address));
finish();
}
}"
579,"<start>    private void userAddingZeroBalanceToken()<end>
{
//comment
aDialog = new AWalletAlertDialog(this);
<start>aDialog.setTitle(R.string.zero_balance_tokens_off);<end>
aDialog.setIcon(AWalletAlertDialog.WARNING);
<start>aDialog.setMessage(R.string.zero_balance_tokens_are_switched_off);<end>
aDialog.setButtonText(R.string.dialog_switch_zero_balance_tokens_on);
aDialog.setButtonListener(v -> {
<start>aDialog.dismiss();<end>
viewModel.hideZeroBalanceTokens();
inputAddressView.getAddress();
});
aDialog.setSecondaryButtonText(R.string.action_cancel);
aDialog.setSecondaryButtonListener(v -> {
//comment
aDialog.dismiss();
inputAddressView.getAddress();
});
aDialog.show();
}","    private void userAddingZeroBalanceToken()
{
//comment
<start>aDialog = new AWalletAlertDialog(this);
aDialog.setTitle(R.string.zero_balance_tokens_off);
aDialog.setIcon(AWalletAlertDialog.WARNING);
aDialog.setMessage(R.string.zero_balance_tokens_are_switched_off);
aDialog.setButtonText(R.string.dialog_switch_zero_balance_tokens_on);
aDialog.setButtonListener(v -> {
aDialog.dismiss();
viewModel.hideZeroBalanceTokens();
inputAddressView.getAddress();
});<end>
aDialog.setSecondaryButtonText(R.string.action_cancel);
aDialog.setSecondaryButtonListener(v -> {
//comment
aDialog.dismiss();
inputAddressView.getAddress();
});
aDialog.show();
}"
449,"@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
AndroidInjection.inject(this);
super.onCreate(savedInstanceState);

setContentView(R.layout.activity_gas_settings);
toolbar();
setTitle(R.string.set_speed_title);

gasSliderView = findViewById(R.id.gasSliderView);
recyclerView = findViewById(R.id.list);
gasWarning = findViewById(R.id.gas_warning_bubble);
insufficientWarning = findViewById(R.id.insufficient_bubble);
recyclerView.setLayoutManager(new LinearLayoutManager(this));

viewModel = new ViewModelProvider(this, viewModelFactory)
.get(GasSettingsViewModel.class);

minGasPrice = getIntent().getLongExtra(C.EXTRA_MIN_GAS_PRICE, -1);
if (minGasPrice > 0)
{
gasSliderView.setupResendSettings(minGasPrice);
FrameLayout resendNote = findViewById(R.id.layout_resend_note);
resendNote.setVisibility(View.VISIBLE);
}

currentGasSpeedIndex = getIntent().getIntExtra(C.EXTRA_SINGLE_ITEM, -1);
chainId = getIntent().getLongExtra(C.EXTRA_CHAIN_ID, MAINNET_ID);
customGasLimit = new BigDecimal(getIntent().getStringExtra(C.EXTRA_CUSTOM_GAS_LIMIT));
presetGasLimit = new BigDecimal(getIntent().getStringExtra(C.EXTRA_GAS_LIMIT_PRESET));
availableBalance = new BigDecimal(getIntent().getStringExtra(C.EXTRA_TOKEN_BALANCE));
sendAmount = new BigDecimal(getIntent().getStringExtra(C.EXTRA_AMOUNT));
gasSliderView.setNonce(getIntent().getLongExtra(C.EXTRA_NONCE, -1));
gasSliderView.initGasLimit(customGasLimit.toBigInteger());
customGasPriceFromWidget = new BigInteger(getIntent().getStringExtra(C.EXTRA_GAS_PRICE));

gasSliderView.initGasPrice(customGasPriceFromWidget);
adapter = new CustomAdapter(this);
recyclerView.setAdapter(adapter);
recyclerView.addItemDecoration(new ListDivider(this));
gasSliderView.setCallback(this);

//comment
<start>setupGasSpeeds();
startGasListener();<end>
gasWarningShown = false;
}","@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
AndroidInjection.inject(this);
super.onCreate(savedInstanceState);

setContentView(R.layout.activity_gas_settings);
toolbar();
setTitle(R.string.set_speed_title);

gasSliderView = findViewById(R.id.gasSliderView);
recyclerView = findViewById(R.id.list);
gasWarning = findViewById(R.id.gas_warning_bubble);
insufficientWarning = findViewById(R.id.insufficient_bubble);
recyclerView.setLayoutManager(new LinearLayoutManager(this));

viewModel = new ViewModelProvider(this, viewModelFactory)
.get(GasSettingsViewModel.class);

minGasPrice = getIntent().getLongExtra(C.EXTRA_MIN_GAS_PRICE, -1);
if (minGasPrice > 0)
{
gasSliderView.setupResendSettings(minGasPrice);
FrameLayout resendNote = findViewById(R.id.layout_resend_note);
resendNote.setVisibility(View.VISIBLE);
}

currentGasSpeedIndex = getIntent().getIntExtra(C.EXTRA_SINGLE_ITEM, -1);
chainId = getIntent().getLongExtra(C.EXTRA_CHAIN_ID, MAINNET_ID);
customGasLimit = new BigDecimal(getIntent().getStringExtra(C.EXTRA_CUSTOM_GAS_LIMIT));
presetGasLimit = new BigDecimal(getIntent().getStringExtra(C.EXTRA_GAS_LIMIT_PRESET));
availableBalance = new BigDecimal(getIntent().getStringExtra(C.EXTRA_TOKEN_BALANCE));
sendAmount = new BigDecimal(getIntent().getStringExtra(C.EXTRA_AMOUNT));
gasSliderView.setNonce(getIntent().getLongExtra(C.EXTRA_NONCE, -1));
gasSliderView.initGasLimit(customGasLimit.toBigInteger());
customGasPriceFromWidget = new BigInteger(getIntent().getStringExtra(C.EXTRA_GAS_PRICE));

gasSliderView.initGasPrice(customGasPriceFromWidget);
adapter = new CustomAdapter(this);
recyclerView.setAdapter(adapter);
recyclerView.addItemDecoration(new ListDivider(this));
gasSliderView.setCallback(this);

//comment
setupGasSpeeds();
<start>startGasListener();<end>
gasWarningShown = false;
}"
450,"@Override
public void onBindViewHolder(CustomAdapter.CustomViewHolder holder, int p)
{
BigDecimal useGasLimit = presetGasLimit;
int position = holder.getAbsoluteAdapterPosition();
GasSpeed gs = gasSpeeds.get(position);
holder.speedName.setText(gs.speed);

holder.speedName.setVisibility(View.VISIBLE);
holder.warning.setVisibility(View.GONE);

holder.checkbox.setSelected(position == currentGasSpeedIndex);
holder.itemLayout.setOnClickListener(v -> {
if (position == customIndex && currentGasSpeedIndex != customIndex)
{
gasSliderView.initGasLimit(customGasLimit.toBigInteger());
gasSliderView.reportPosition();
}
else if (position != customIndex && currentGasSpeedIndex == customIndex)
{
hideGasWarning();
}
notifyItemChanged(currentGasSpeedIndex);
currentGasSpeedIndex = position;
notifyItemChanged(position);
});

String speedGwei = BalanceUtils.weiToGweiBI(gs.gasPrice).toBigInteger().toString();

if (position == customIndex)
{
if (gs.seconds == 0)
{
blankCustomHolder(holder);
setCustomGasDetails(position);
return;
}
else
{
//comment
<start>gs.seconds = getExpectedTransactionTime(gs.gasPrice);<end>
speedGwei = context.getString(R.string.bracketed, context.getString(R.string.set_your_speed));
<start>useGasLimit = customGasLimit;<end>
}

holder.speedName.setVisibility(View.GONE);
holder.warning.setVisibility(View.VISIBLE);

switch (warningType)
{
case OFF:
holder.warning.setVisibility(View.GONE);
holder.speedName.setVisibility(View.VISIBLE);
break;
case LOW:
holder.warningText.setText(R.string.speed_too_low);
break;
case HIGH:
holder.warningText.setText(R.string.speed_high_gas);
break;
case INSUFFICIENT:
holder.warningText.setText(R.string.insufficient_gas);
break;
}
}

BigDecimal gasFee = new BigDecimal(gs.gasPrice).multiply(useGasLimit);

String gasAmountInBase = BalanceUtils.getScaledValueScientific(gasFee, baseCurrency.tokenInfo.decimals, GAS_PRECISION);
if (gasAmountInBase.equals(""0"")) gasAmountInBase = ""0.00001"";
String displayStr = context.getString(R.string.gas_amount, gasAmountInBase, baseCurrency.getSymbol());
String displayTime = context.getString(R.string.gas_time_suffix,
Utils.shortConvertTimePeriodInSeconds(gs.seconds, context));
String fiatStr = getGasCost(gasAmountInBase);

holder.speedGwei.setText(context.getString(R.string.gas_price_widget, speedGwei));
holder.speedCostEth.setText(context.getString(R.string.gas_fiat_suffix, gasAmountInBase, baseCurrency.getSymbol()));
holder.speedTime.setText(displayTime);

if (fiatStr.length() > 0)
{
holder.speedCostFiat.setVisibility(View.VISIBLE);
holder.speedCostFiat.setText(fiatStr);
}
else
{
holder.speedCostFiat.setVisibility(View.GONE);
}

setCustomGasDetails(position);

//comment
//comment
if(minGasPrice > 0)
{
if(!gs.isCustom && gs.gasPrice.longValue() < minGasPrice)
{
ViewGroup.LayoutParams params = holder.itemLayout.getLayoutParams();
params.height = 0;
holder.itemLayout.setLayoutParams(params);
holder.itemLayout.requestLayout();
}
}

//comment
BigDecimal txCost = gasFee.add(sendAmount);
checkInsufficientGas(txCost);
}","@Override
public void onBindViewHolder(CustomAdapter.CustomViewHolder holder, int p)
{
BigDecimal useGasLimit = presetGasLimit;
int position = holder.getAbsoluteAdapterPosition();
GasSpeed gs = gasSpeeds.get(position);
holder.speedName.setText(gs.speed);

holder.speedName.setVisibility(View.VISIBLE);
holder.warning.setVisibility(View.GONE);

holder.checkbox.setSelected(position == currentGasSpeedIndex);
holder.itemLayout.setOnClickListener(v -> {
if (position == customIndex && currentGasSpeedIndex != customIndex)
{
gasSliderView.initGasLimit(customGasLimit.toBigInteger());
gasSliderView.reportPosition();
}
else if (position != customIndex && currentGasSpeedIndex == customIndex)
{
hideGasWarning();
}
notifyItemChanged(currentGasSpeedIndex);
currentGasSpeedIndex = position;
notifyItemChanged(position);
});

String speedGwei = BalanceUtils.weiToGweiBI(gs.gasPrice).toBigInteger().toString();

if (position == customIndex)
{
if (gs.seconds == 0)
{
blankCustomHolder(holder);
setCustomGasDetails(position);
return;
}
else
{
//comment
<start>gs.seconds = getExpectedTransactionTime(gs.gasPrice);
speedGwei = context.getString(R.string.bracketed, context.getString(R.string.set_your_speed));<end>
useGasLimit = customGasLimit;
}

holder.speedName.setVisibility(View.GONE);
holder.warning.setVisibility(View.VISIBLE);

switch (warningType)
{
case OFF:
holder.warning.setVisibility(View.GONE);
holder.speedName.setVisibility(View.VISIBLE);
break;
case LOW:
holder.warningText.setText(R.string.speed_too_low);
break;
case HIGH:
holder.warningText.setText(R.string.speed_high_gas);
break;
case INSUFFICIENT:
holder.warningText.setText(R.string.insufficient_gas);
break;
}
}

BigDecimal gasFee = new BigDecimal(gs.gasPrice).multiply(useGasLimit);

String gasAmountInBase = BalanceUtils.getScaledValueScientific(gasFee, baseCurrency.tokenInfo.decimals, GAS_PRECISION);
if (gasAmountInBase.equals(""0"")) gasAmountInBase = ""0.00001"";
String displayStr = context.getString(R.string.gas_amount, gasAmountInBase, baseCurrency.getSymbol());
String displayTime = context.getString(R.string.gas_time_suffix,
Utils.shortConvertTimePeriodInSeconds(gs.seconds, context));
String fiatStr = getGasCost(gasAmountInBase);

holder.speedGwei.setText(context.getString(R.string.gas_price_widget, speedGwei));
holder.speedCostEth.setText(context.getString(R.string.gas_fiat_suffix, gasAmountInBase, baseCurrency.getSymbol()));
holder.speedTime.setText(displayTime);

if (fiatStr.length() > 0)
{
holder.speedCostFiat.setVisibility(View.VISIBLE);
holder.speedCostFiat.setText(fiatStr);
}
else
{
holder.speedCostFiat.setVisibility(View.GONE);
}

setCustomGasDetails(position);

//comment
//comment
if(minGasPrice > 0)
{
if(!gs.isCustom && gs.gasPrice.longValue() < minGasPrice)
{
ViewGroup.LayoutParams params = holder.itemLayout.getLayoutParams();
params.height = 0;
holder.itemLayout.setLayoutParams(params);
holder.itemLayout.requestLayout();
}
}

//comment
BigDecimal txCost = gasFee.add(sendAmount);
checkInsufficientGas(txCost);
}"
451,"public long getExpectedTransactionTime(BigInteger customGasPriceBI)
{
long expectedTime = gasSpeeds.get(0).seconds;
if (gasSpeeds.size() > 2)
{
<start>double dGasPrice = customGasPriceBI.doubleValue();<end>
//comment
for (int index = 0; index < gasSpeeds.size() - 2; index++)
{
GasSpeed ug = gasSpeeds.get(index);
GasSpeed lg = gasSpeeds.get(index + 1);
double lowerBound = lg.gasPrice.doubleValue();
double upperBound = ug.gasPrice.doubleValue();
if (lowerBound <= dGasPrice && (upperBound >= dGasPrice))
{
double timeDiff = lg.seconds - ug.seconds;
double extrapolateFactor = (dGasPrice - lowerBound) / (upperBound - lowerBound);
expectedTime = (long) ((double) lg.seconds - extrapolateFactor * timeDiff);
break;
}
else if (lg.speed.equals(getString(R.string.speed_slow))) {
//comment
double dangerAmount = lowerBound / 2.0;
long dangerTime = 12 * DateUtils.HOUR_IN_MILLIS / 1000;

if (dGasPrice < (lowerBound*0.95))
{
showGasWarning(false);
}

if (dGasPrice < dangerAmount) {
expectedTime = -1;
} else {
expectedTime = extrapolateTime(dangerTime, lg.seconds, dGasPrice, dangerAmount, lowerBound);
}

return expectedTime;
}
else if (ug.speed.equals(getString(R.string.speed_rapid)) && dGasPrice >= upperBound)
{
if (dGasPrice > 1.4 * upperBound)
{
showGasWarning(true);
}
else
{
hideGasWarning();
}
return expectedTime;
}
}
hideGasWarning();
}

return expectedTime;
}","public long getExpectedTransactionTime(BigInteger customGasPriceBI)
{
long expectedTime = gasSpeeds.get(0).seconds;
if (gasSpeeds.size() > 2)
{
double dGasPrice = customGasPriceBI.doubleValue();
//comment
<start>for (int index = 0; index < gasSpeeds.size() - 2; index++)
{
GasSpeed ug = gasSpeeds.get(index);
GasSpeed lg = gasSpeeds.get(index + 1);
double lowerBound = lg.gasPrice.doubleValue();
double upperBound = ug.gasPrice.doubleValue();<end>
if (lowerBound <= dGasPrice && (upperBound >= dGasPrice))
{
double timeDiff = lg.seconds - ug.seconds;
double extrapolateFactor = (dGasPrice - lowerBound) / (upperBound - lowerBound);
expectedTime = (long) ((double) lg.seconds - extrapolateFactor * timeDiff);
break;
}
else if (lg.speed.equals(getString(R.string.speed_slow))) {
//comment
double dangerAmount = lowerBound / 2.0;
long dangerTime = 12 * DateUtils.HOUR_IN_MILLIS / 1000;

if (dGasPrice < (lowerBound*0.95))
{
showGasWarning(false);
}

if (dGasPrice < dangerAmount) {
expectedTime = -1;
} else {
expectedTime = extrapolateTime(dangerTime, lg.seconds, dGasPrice, dangerAmount, lowerBound);
}

return expectedTime;
}
else if (ug.speed.equals(getString(R.string.speed_rapid)) && dGasPrice >= upperBound)
{
if (dGasPrice > 1.4 * upperBound)
{
showGasWarning(true);
}
else
{
hideGasWarning();
}
return expectedTime;
}
}
hideGasWarning();
}

return expectedTime;
}"
452,"public long getExpectedTransactionTime(BigInteger customGasPriceBI)
{
long expectedTime = gasSpeeds.get(0).seconds;
if (gasSpeeds.size() > 2)
{
double dGasPrice = customGasPriceBI.doubleValue();
//comment
for (int index = 0; index < gasSpeeds.size() - 2; index++)
{
GasSpeed ug = gasSpeeds.get(index);
GasSpeed lg = gasSpeeds.get(index + 1);
double lowerBound = lg.gasPrice.doubleValue();
double upperBound = ug.gasPrice.doubleValue();
if (lowerBound <= dGasPrice && (upperBound >= dGasPrice))
{
double timeDiff = lg.seconds - ug.seconds;
double extrapolateFactor = (dGasPrice - lowerBound) / (upperBound - lowerBound);
expectedTime = (long) ((double) lg.seconds - extrapolateFactor * timeDiff);
break;
}
else if (lg.speed.equals(getString(R.string.speed_slow))) {
//comment
double dangerAmount = lowerBound / 2.0;
long dangerTime = 12 * DateUtils.HOUR_IN_MILLIS / 1000;

if (dGasPrice < (lowerBound*0.95))
{
<start>showGasWarning(false);<end>
}

if (dGasPrice < dangerAmount) {
expectedTime = -1;
} else {
expectedTime = extrapolateTime(dangerTime, lg.seconds, dGasPrice, dangerAmount, lowerBound);
}

return expectedTime;
}
else if (ug.speed.equals(getString(R.string.speed_rapid)) && dGasPrice >= upperBound)
{
if (dGasPrice > 1.4 * upperBound)
{
showGasWarning(true);
}
else
{
hideGasWarning();
}
return expectedTime;
}
}
hideGasWarning();
}

return expectedTime;
}","public long getExpectedTransactionTime(BigInteger customGasPriceBI)
{
long expectedTime = gasSpeeds.get(0).seconds;
if (gasSpeeds.size() > 2)
{
double dGasPrice = customGasPriceBI.doubleValue();
//comment
for (int index = 0; index < gasSpeeds.size() - 2; index++)
{
GasSpeed ug = gasSpeeds.get(index);
GasSpeed lg = gasSpeeds.get(index + 1);
double lowerBound = lg.gasPrice.doubleValue();
double upperBound = ug.gasPrice.doubleValue();
if (lowerBound <= dGasPrice && (upperBound >= dGasPrice))
{
double timeDiff = lg.seconds - ug.seconds;
double extrapolateFactor = (dGasPrice - lowerBound) / (upperBound - lowerBound);
expectedTime = (long) ((double) lg.seconds - extrapolateFactor * timeDiff);
break;
}
else if (lg.speed.equals(getString(R.string.speed_slow))) {
//comment
double dangerAmount = lowerBound / 2.0;
long dangerTime = 12 * DateUtils.HOUR_IN_MILLIS / 1000;

<start>if (dGasPrice < (lowerBound*0.95))
{
showGasWarning(false);
}<end>

if (dGasPrice < dangerAmount) {
expectedTime = -1;
} else {
expectedTime = extrapolateTime(dangerTime, lg.seconds, dGasPrice, dangerAmount, lowerBound);
}

return expectedTime;
}
else if (ug.speed.equals(getString(R.string.speed_rapid)) && dGasPrice >= upperBound)
{
if (dGasPrice > 1.4 * upperBound)
{
showGasWarning(true);
}
else
{
hideGasWarning();
}
return expectedTime;
}
}
hideGasWarning();
}

return expectedTime;
}"
453,"public long getExpectedTransactionTime(BigInteger customGasPriceBI)
{
long expectedTime = gasSpeeds.get(0).seconds;
if (gasSpeeds.size() > 2)
{
double dGasPrice = customGasPriceBI.doubleValue();
//comment
for (int index = 0; index < gasSpeeds.size() - 2; index++)
{
GasSpeed ug = gasSpeeds.get(index);
GasSpeed lg = gasSpeeds.get(index + 1);
double lowerBound = lg.gasPrice.doubleValue();
double upperBound = ug.gasPrice.doubleValue();
if (lowerBound <= dGasPrice && (upperBound >= dGasPrice))
{
double timeDiff = lg.seconds - ug.seconds;
double extrapolateFactor = (dGasPrice - lowerBound) / (upperBound - lowerBound);
expectedTime = (long) ((double) lg.seconds - extrapolateFactor * timeDiff);
break;
}
else if (lg.speed.equals(getString(R.string.speed_slow))) {
//comment
double dangerAmount = lowerBound / 2.0;
long dangerTime = 12 * DateUtils.HOUR_IN_MILLIS / 1000;

if (dGasPrice < (lowerBound*0.95))
{
showGasWarning(false);
}

if (dGasPrice < dangerAmount) {
expectedTime = -1;
} else {
expectedTime = extrapolateTime(dangerTime, lg.seconds, dGasPrice, dangerAmount, lowerBound);
}

return expectedTime;
}
else if (ug.speed.equals(getString(R.string.speed_rapid)) && dGasPrice >= upperBound)
{
if (dGasPrice > 1.4 * upperBound)
{
<start>showGasWarning(true);<end>
}
else
{
<start>hideGasWarning();<end>
}
return expectedTime;
}
}
hideGasWarning();
}

return expectedTime;
}","public long getExpectedTransactionTime(BigInteger customGasPriceBI)
{
long expectedTime = gasSpeeds.get(0).seconds;
if (gasSpeeds.size() > 2)
{
double dGasPrice = customGasPriceBI.doubleValue();
//comment
for (int index = 0; index < gasSpeeds.size() - 2; index++)
{
GasSpeed ug = gasSpeeds.get(index);
GasSpeed lg = gasSpeeds.get(index + 1);
double lowerBound = lg.gasPrice.doubleValue();
double upperBound = ug.gasPrice.doubleValue();
if (lowerBound <= dGasPrice && (upperBound >= dGasPrice))
{
double timeDiff = lg.seconds - ug.seconds;
double extrapolateFactor = (dGasPrice - lowerBound) / (upperBound - lowerBound);
expectedTime = (long) ((double) lg.seconds - extrapolateFactor * timeDiff);
break;
}
else if (lg.speed.equals(getString(R.string.speed_slow))) {
//comment
double dangerAmount = lowerBound / 2.0;
long dangerTime = 12 * DateUtils.HOUR_IN_MILLIS / 1000;

if (dGasPrice < (lowerBound*0.95))
{
showGasWarning(false);
}

if (dGasPrice < dangerAmount) {
expectedTime = -1;
} else {
expectedTime = extrapolateTime(dangerTime, lg.seconds, dGasPrice, dangerAmount, lowerBound);
}

return expectedTime;
}
else if (ug.speed.equals(getString(R.string.speed_rapid)) && dGasPrice >= upperBound)
{
<start>if (dGasPrice > 1.4 * upperBound)
{
showGasWarning(true);<end>
}
else
{
hideGasWarning();
}
return expectedTime;
}
}
hideGasWarning();
}

return expectedTime;
}"
1655,"    @Override
public boolean areItemsTheSame(SortedItem other)
{
try
{
if (viewType == other.viewType)
{
TransactionMeta oldTx = (TransactionMeta) other.value;
return value.hash.equals(oldTx.hash);
}
<start>else if (other.viewType == EventHolder.VIEW_TYPE || other.viewType == TransferHolder.VIEW_TYPE)<end>
{
<start>return true;<end>
}
else
{
return false;
}
}
catch (Exception e)
{
return false;
}
}","    @Override
public boolean areItemsTheSame(SortedItem other)
{
try
{
if (viewType == other.viewType)
{
TransactionMeta oldTx = (TransactionMeta) other.value;
return value.hash.equals(oldTx.hash);
}
<start>else if (other.viewType == EventHolder.VIEW_TYPE || other.viewType == TransferHolder.VIEW_TYPE)<end>
{
<start>return true;<end>
}
else
{
return false;
}
}
catch (Exception e)
{
return false;
}
}"
1441,"@Override
public void bind(@Nullable TokenCardMeta data, @NonNull Bundle addition)
{
try
{
token = tokensService.getToken(data.getChain(), data.getAddress());
if (token == null)
{
fillEmpty();
return;
}
else if (data.nameWeight < 1000 && !token.isEthereum())
{
//comment
Token backupChain = tokensService.getToken(data.getChain(), ""eth"");
if (backupChain != null) token = backupChain;
}

tokenLayout.setBackgroundResource(R.drawable.background_marketplace_event);
if (EthereumNetworkRepository.isPriorityToken(token)) extendedInfo.setVisibility(View.GONE);
contractSeparator.setVisibility(View.GONE);

//comment
<start>String nameValue = token.getStringBalance() + "" "" + token.getFullName(assetDefinition, token.getTokenCount());<end>
balanceEth.setText(nameValue);

primaryElement = false;

tokenIcon.bindData(token, assetDefinition);
tokenIcon.setOnTokenClickListener(onTokenClickListener);


populateTicker();

setContractType();

setPendingAmount();

} catch (Exception ex) {
fillEmpty();
}
}","@Override
public void bind(@Nullable TokenCardMeta data, @NonNull Bundle addition)
{
try
{
token = tokensService.getToken(data.getChain(), data.getAddress());
if (token == null)
{
fillEmpty();
return;
}
else if (data.nameWeight < 1000 && !token.isEthereum())
{
//comment
Token backupChain = tokensService.getToken(data.getChain(), ""eth"");
if (backupChain != null) token = backupChain;
}

tokenLayout.setBackgroundResource(R.drawable.background_marketplace_event);
if (EthereumNetworkRepository.isPriorityToken(token)) extendedInfo.setVisibility(View.GONE);
contractSeparator.setVisibility(View.GONE);

//comment
<start>String nameValue = token.getStringBalance() + "" "" + token.getFullName(assetDefinition, token.getTokenCount());
balanceEth.setText(nameValue);<end>

primaryElement = false;

tokenIcon.bindData(token, assetDefinition);
tokenIcon.setOnTokenClickListener(onTokenClickListener);


populateTicker();

setContractType();

setPendingAmount();

} catch (Exception ex) {
fillEmpty();
}
}"
1442,"<start>private void setContractType()<end>
{
//comment
<start>int contractStringId = token.getContractType();<end>
if (contractStringId > 0)
{
contractType.setText(contractStringId);
contractType.setVisibility(View.VISIBLE);
if (primaryElement) contractSeparator.setVisibility(View.VISIBLE);
}
else
{
contractType.setVisibility(View.GONE);
}
}","private void setContractType()
{
//comment
<start>int contractStringId = token.getContractType();
if (contractStringId > 0)
{
contractType.setText(contractStringId);
contractType.setVisibility(View.VISIBLE);
if (primaryElement) contractSeparator.setVisibility(View.VISIBLE);
}<end>
else
{
contractType.setVisibility(View.GONE);
}
}"
1443,"private void setTickerInfo(TokenTicker ticker)
{
//comment
BigDecimal correctedBalance = token.getCorrectedBalance(18);
BigDecimal fiatBalance = correctedBalance.multiply(new BigDecimal(ticker.price)).setScale(18, RoundingMode.DOWN);
String converted = TickerService.getCurrencyString(fiatBalance.doubleValue());

String lbl = getString(R.string.token_balance, """", converted);
lbl += "" "" + ticker.priceSymbol;
if (correctedBalance.compareTo(BigDecimal.ZERO) > 0)
{
issuer.setVisibility(View.GONE);
}
else
{
lbl = EMPTY_BALANCE;
}

balanceCurrency.setText(lbl);
balanceCurrency.setTextColor(getContext().getColor(R.color.text_dark_gray));

//comment
try {
<start>double percentage = Double.parseDouble(ticker.percentChange24h);<end>
String formattedPercents = (percentage < 0 ? ""("" : ""(+"") + ticker.percentChange24h + ""%)"";
text24Hours.setText(formattedPercents);
text24Hours.setTextColor(ContextCompat.getColor(getContext(), percentage < 0 ? R.color.red : R.color.green));
} catch (Exception ex)
{  }

//comment
String formattedValue = TickerService.getCurrencyString(new BigDecimal(ticker.price).doubleValue());
//comment

lbl = getString(R.string.token_balance, """", formattedValue);
//comment
textAppreciation.setText(lbl);
textAppreciation.setTextColor(getContext().getColor(R.color.text_dark_gray));

tokensService.addTokenValue(token.tokenInfo.chainId, token.getAddress(), fiatBalance.floatValue());
}","private void setTickerInfo(TokenTicker ticker)
{
//comment
BigDecimal correctedBalance = token.getCorrectedBalance(18);
BigDecimal fiatBalance = correctedBalance.multiply(new BigDecimal(ticker.price)).setScale(18, RoundingMode.DOWN);
String converted = TickerService.getCurrencyString(fiatBalance.doubleValue());

String lbl = getString(R.string.token_balance, """", converted);
lbl += "" "" + ticker.priceSymbol;
if (correctedBalance.compareTo(BigDecimal.ZERO) > 0)
{
issuer.setVisibility(View.GONE);
}
else
{
lbl = EMPTY_BALANCE;
}

balanceCurrency.setText(lbl);
balanceCurrency.setTextColor(getContext().getColor(R.color.text_dark_gray));

//comment
try {
<start>double percentage = Double.parseDouble(ticker.percentChange24h);
String formattedPercents = (percentage < 0 ? ""("" : ""(+"") + ticker.percentChange24h + ""%)"";
text24Hours.setText(formattedPercents);
text24Hours.setTextColor(ContextCompat.getColor(getContext(), percentage < 0 ? R.color.red : R.color.green));<end>
} catch (Exception ex)
{  }

//comment
String formattedValue = TickerService.getCurrencyString(new BigDecimal(ticker.price).doubleValue());
//comment

lbl = getString(R.string.token_balance, """", formattedValue);
//comment
textAppreciation.setText(lbl);
textAppreciation.setTextColor(getContext().getColor(R.color.text_dark_gray));

tokensService.addTokenValue(token.tokenInfo.chainId, token.getAddress(), fiatBalance.floatValue());
}"
1444,"private void setTickerInfo(TokenTicker ticker)
{
//comment
BigDecimal correctedBalance = token.getCorrectedBalance(18);
BigDecimal fiatBalance = correctedBalance.multiply(new BigDecimal(ticker.price)).setScale(18, RoundingMode.DOWN);
String converted = TickerService.getCurrencyString(fiatBalance.doubleValue());

String lbl = getString(R.string.token_balance, """", converted);
lbl += "" "" + ticker.priceSymbol;
if (correctedBalance.compareTo(BigDecimal.ZERO) > 0)
{
issuer.setVisibility(View.GONE);
}
else
{
lbl = EMPTY_BALANCE;
}

balanceCurrency.setText(lbl);
balanceCurrency.setTextColor(getContext().getColor(R.color.text_dark_gray));

//comment
try {
double percentage = Double.parseDouble(ticker.percentChange24h);
String formattedPercents = (percentage < 0 ? ""("" : ""(+"") + ticker.percentChange24h + ""%)"";
text24Hours.setText(formattedPercents);
<start>text24Hours.setTextColor(ContextCompat.getColor(getContext(), percentage < 0 ? R.color.red : R.color.green));<end>
} catch (Exception ex)
{  }

//comment
<start>String formattedValue = TickerService.getCurrencyString(new BigDecimal(ticker.price).doubleValue());<end>
//comment

lbl = getString(R.string.token_balance, """", formattedValue);
//comment
textAppreciation.setText(lbl);
textAppreciation.setTextColor(getContext().getColor(R.color.text_dark_gray));

tokensService.addTokenValue(token.tokenInfo.chainId, token.getAddress(), fiatBalance.floatValue());
}","private void setTickerInfo(TokenTicker ticker)
{
//comment
BigDecimal correctedBalance = token.getCorrectedBalance(18);
BigDecimal fiatBalance = correctedBalance.multiply(new BigDecimal(ticker.price)).setScale(18, RoundingMode.DOWN);
String converted = TickerService.getCurrencyString(fiatBalance.doubleValue());

String lbl = getString(R.string.token_balance, """", converted);
lbl += "" "" + ticker.priceSymbol;
if (correctedBalance.compareTo(BigDecimal.ZERO) > 0)
{
issuer.setVisibility(View.GONE);
}
else
{
lbl = EMPTY_BALANCE;
}

balanceCurrency.setText(lbl);
balanceCurrency.setTextColor(getContext().getColor(R.color.text_dark_gray));

//comment
try {
double percentage = Double.parseDouble(ticker.percentChange24h);
String formattedPercents = (percentage < 0 ? ""("" : ""(+"") + ticker.percentChange24h + ""%)"";
text24Hours.setText(formattedPercents);
text24Hours.setTextColor(ContextCompat.getColor(getContext(), percentage < 0 ? R.color.red : R.color.green));
} catch (Exception ex)
{  }

//comment
<start>String formattedValue = TickerService.getCurrencyString(new BigDecimal(ticker.price).doubleValue());<end>
//comment

lbl = getString(R.string.token_balance, """", formattedValue);
//comment
textAppreciation.setText(lbl);
textAppreciation.setTextColor(getContext().getColor(R.color.text_dark_gray));

tokensService.addTokenValue(token.tokenInfo.chainId, token.getAddress(), fiatBalance.floatValue());
}"
